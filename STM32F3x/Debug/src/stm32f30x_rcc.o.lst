   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"stm32f30x_rcc.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.data
  20              		.align	2
  23              	APBAHBPrescTable:
  24 0000 00       		.byte	0
  25 0001 00       		.byte	0
  26 0002 00       		.byte	0
  27 0003 00       		.byte	0
  28 0004 01       		.byte	1
  29 0005 02       		.byte	2
  30 0006 03       		.byte	3
  31 0007 04       		.byte	4
  32 0008 01       		.byte	1
  33 0009 02       		.byte	2
  34 000a 03       		.byte	3
  35 000b 04       		.byte	4
  36 000c 06       		.byte	6
  37 000d 07       		.byte	7
  38 000e 08       		.byte	8
  39 000f 09       		.byte	9
  40              		.align	2
  43              	ADCPrescTable:
  44 0010 0000     		.short	0
  45 0012 0100     		.short	1
  46 0014 0200     		.short	2
  47 0016 0400     		.short	4
  48 0018 0600     		.short	6
  49 001a 0800     		.short	8
  50 001c 0A00     		.short	10
  51 001e 0C00     		.short	12
  52 0020 1000     		.short	16
  53 0022 2000     		.short	32
  54 0024 4000     		.short	64
  55 0026 8000     		.short	128
  56 0028 0001     		.short	256
  57 002a 0000     		.text
  58              		.align	2
  59              		.global	RCC_DeInit
  60              		.thumb
  61              		.thumb_func
  63              	RCC_DeInit:
  64              	.LFB111:
  65              		.file 1 "../src/stm32f30x_rcc.c"
   1:../src/stm32f30x_rcc.c **** /**
   2:../src/stm32f30x_rcc.c ****   ******************************************************************************
   3:../src/stm32f30x_rcc.c ****   * @file    stm32f30x_rcc.c
   4:../src/stm32f30x_rcc.c ****   * @author  MCD Application Team
   5:../src/stm32f30x_rcc.c ****   * @version V1.0.1
   6:../src/stm32f30x_rcc.c ****   * @date    23-October-2012
   7:../src/stm32f30x_rcc.c ****   * @brief   This file provides firmware functions to manage the following 
   8:../src/stm32f30x_rcc.c ****   *          functionalities of the Reset and clock control (RCC) peripheral:           
   9:../src/stm32f30x_rcc.c ****   *           + Internal/external clocks, PLL, CSS and MCO configuration
  10:../src/stm32f30x_rcc.c ****   *           + System, AHB and APB busses clocks configuration
  11:../src/stm32f30x_rcc.c ****   *           + Peripheral clocks configuration
  12:../src/stm32f30x_rcc.c ****   *           + Interrupts and flags management
  13:../src/stm32f30x_rcc.c ****   *
  14:../src/stm32f30x_rcc.c ****   @verbatim
  15:../src/stm32f30x_rcc.c ****                
  16:../src/stm32f30x_rcc.c ****  ===============================================================================
  17:../src/stm32f30x_rcc.c ****                       ##### RCC specific features #####
  18:../src/stm32f30x_rcc.c ****  ===============================================================================
  19:../src/stm32f30x_rcc.c ****     [..] After reset the device is running from HSI (8 MHz) with Flash 0 WS, 
  20:../src/stm32f30x_rcc.c ****          all peripherals are off except internal SRAM, Flash and SWD.
  21:../src/stm32f30x_rcc.c ****          (+) There is no prescaler on High speed (AHB) and Low speed (APB) busses;
  22:../src/stm32f30x_rcc.c ****              all peripherals mapped on these busses are running at HSI speed.
  23:../src/stm32f30x_rcc.c ****        	 (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
  24:../src/stm32f30x_rcc.c ****          (+) All GPIOs are in input floating state, except the SWD pins which
  25:../src/stm32f30x_rcc.c ****              are assigned to be used for debug purpose.
  26:../src/stm32f30x_rcc.c ****     [..] Once the device starts from reset, the user application has to:        
  27:../src/stm32f30x_rcc.c ****          (+) Configure the clock source to be used to drive the System clock
  28:../src/stm32f30x_rcc.c ****              (if the application needs higher frequency/performance).
  29:../src/stm32f30x_rcc.c ****          (+) Configure the System clock frequency and Flash settings.  
  30:../src/stm32f30x_rcc.c ****          (+) Configure the AHB and APB busses prescalers.
  31:../src/stm32f30x_rcc.c ****          (+) Enable the clock for the peripheral(s) to be used.
  32:../src/stm32f30x_rcc.c ****          (+) Configure the clock source(s) for peripherals which clocks are not
  33:../src/stm32f30x_rcc.c ****              derived from the System clock (ADC, TIM, I2C, USART, RTC and IWDG).      
  34:../src/stm32f30x_rcc.c ****                         
  35:../src/stm32f30x_rcc.c ****   @endverbatim
  36:../src/stm32f30x_rcc.c ****     
  37:../src/stm32f30x_rcc.c ****   ******************************************************************************
  38:../src/stm32f30x_rcc.c ****   * @attention
  39:../src/stm32f30x_rcc.c ****   *
  40:../src/stm32f30x_rcc.c ****   * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
  41:../src/stm32f30x_rcc.c ****   *
  42:../src/stm32f30x_rcc.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  43:../src/stm32f30x_rcc.c ****   * You may not use this file except in compliance with the License.
  44:../src/stm32f30x_rcc.c ****   * You may obtain a copy of the License at:
  45:../src/stm32f30x_rcc.c ****   *
  46:../src/stm32f30x_rcc.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  47:../src/stm32f30x_rcc.c ****   *
  48:../src/stm32f30x_rcc.c ****   * Unless required by applicable law or agreed to in writing, software 
  49:../src/stm32f30x_rcc.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  50:../src/stm32f30x_rcc.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  51:../src/stm32f30x_rcc.c ****   * See the License for the specific language governing permissions and
  52:../src/stm32f30x_rcc.c ****   * limitations under the License.
  53:../src/stm32f30x_rcc.c ****   *
  54:../src/stm32f30x_rcc.c ****   ******************************************************************************
  55:../src/stm32f30x_rcc.c ****   */
  56:../src/stm32f30x_rcc.c **** 
  57:../src/stm32f30x_rcc.c **** /* Includes ------------------------------------------------------------------*/
  58:../src/stm32f30x_rcc.c **** #include "stm32f30x_rcc.h"
  59:../src/stm32f30x_rcc.c **** 
  60:../src/stm32f30x_rcc.c **** /** @addtogroup STM32F30x_StdPeriph_Driver
  61:../src/stm32f30x_rcc.c ****   * @{
  62:../src/stm32f30x_rcc.c ****   */
  63:../src/stm32f30x_rcc.c **** 
  64:../src/stm32f30x_rcc.c **** /** @defgroup RCC 
  65:../src/stm32f30x_rcc.c ****   * @brief RCC driver modules
  66:../src/stm32f30x_rcc.c ****   * @{
  67:../src/stm32f30x_rcc.c ****   */ 
  68:../src/stm32f30x_rcc.c **** 
  69:../src/stm32f30x_rcc.c **** /* Private typedef -----------------------------------------------------------*/
  70:../src/stm32f30x_rcc.c **** /* Private define ------------------------------------------------------------*/
  71:../src/stm32f30x_rcc.c **** /* ------------ RCC registers bit address in the alias region ----------- */
  72:../src/stm32f30x_rcc.c **** #define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
  73:../src/stm32f30x_rcc.c **** 
  74:../src/stm32f30x_rcc.c **** /* --- CR Register ---*/
  75:../src/stm32f30x_rcc.c **** 
  76:../src/stm32f30x_rcc.c **** /* Alias word address of HSION bit */
  77:../src/stm32f30x_rcc.c **** #define CR_OFFSET                 (RCC_OFFSET + 0x00)
  78:../src/stm32f30x_rcc.c **** #define HSION_BitNumber           0x00
  79:../src/stm32f30x_rcc.c **** #define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
  80:../src/stm32f30x_rcc.c **** 
  81:../src/stm32f30x_rcc.c **** /* Alias word address of PLLON bit */
  82:../src/stm32f30x_rcc.c **** #define PLLON_BitNumber           0x18
  83:../src/stm32f30x_rcc.c **** #define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
  84:../src/stm32f30x_rcc.c **** 
  85:../src/stm32f30x_rcc.c **** /* Alias word address of CSSON bit */
  86:../src/stm32f30x_rcc.c **** #define CSSON_BitNumber           0x13
  87:../src/stm32f30x_rcc.c **** #define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
  88:../src/stm32f30x_rcc.c **** 
  89:../src/stm32f30x_rcc.c **** /* --- CFGR Register ---*/
  90:../src/stm32f30x_rcc.c **** /* Alias word address of USBPRE bit */
  91:../src/stm32f30x_rcc.c **** #define CFGR_OFFSET               (RCC_OFFSET + 0x04)
  92:../src/stm32f30x_rcc.c **** #define USBPRE_BitNumber          0x16
  93:../src/stm32f30x_rcc.c **** #define CFGR_USBPRE_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (USBPRE_BitNumber * 4))
  94:../src/stm32f30x_rcc.c **** /* Alias word address of I2SSRC bit */
  95:../src/stm32f30x_rcc.c **** #define I2SSRC_BitNumber          0x17
  96:../src/stm32f30x_rcc.c **** #define CFGR_I2SSRC_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (I2SSRC_BitNumber * 4))
  97:../src/stm32f30x_rcc.c **** 
  98:../src/stm32f30x_rcc.c **** /* --- BDCR Register ---*/
  99:../src/stm32f30x_rcc.c **** 
 100:../src/stm32f30x_rcc.c **** /* Alias word address of RTCEN bit */
 101:../src/stm32f30x_rcc.c **** #define BDCR_OFFSET               (RCC_OFFSET + 0x20)
 102:../src/stm32f30x_rcc.c **** #define RTCEN_BitNumber           0x0F
 103:../src/stm32f30x_rcc.c **** #define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
 104:../src/stm32f30x_rcc.c **** 
 105:../src/stm32f30x_rcc.c **** /* Alias word address of BDRST bit */
 106:../src/stm32f30x_rcc.c **** #define BDRST_BitNumber           0x10
 107:../src/stm32f30x_rcc.c **** #define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
 108:../src/stm32f30x_rcc.c **** 
 109:../src/stm32f30x_rcc.c **** /* --- CSR Register ---*/
 110:../src/stm32f30x_rcc.c **** 
 111:../src/stm32f30x_rcc.c **** /* Alias word address of LSION bit */
 112:../src/stm32f30x_rcc.c **** #define CSR_OFFSET                (RCC_OFFSET + 0x24)
 113:../src/stm32f30x_rcc.c **** #define LSION_BitNumber           0x00
 114:../src/stm32f30x_rcc.c **** #define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
 115:../src/stm32f30x_rcc.c **** 
 116:../src/stm32f30x_rcc.c **** /* ---------------------- RCC registers bit mask ------------------------ */
 117:../src/stm32f30x_rcc.c **** /* RCC Flag Mask */
 118:../src/stm32f30x_rcc.c **** #define FLAG_MASK                 ((uint8_t)0x1F)
 119:../src/stm32f30x_rcc.c **** 
 120:../src/stm32f30x_rcc.c **** /* CFGR register byte 3 (Bits[31:23]) base address */
 121:../src/stm32f30x_rcc.c **** #define CFGR_BYTE3_ADDRESS        ((uint32_t)0x40021007)
 122:../src/stm32f30x_rcc.c **** 
 123:../src/stm32f30x_rcc.c **** /* CIR register byte 2 (Bits[15:8]) base address */
 124:../src/stm32f30x_rcc.c **** #define CIR_BYTE2_ADDRESS         ((uint32_t)0x40021009)
 125:../src/stm32f30x_rcc.c **** 
 126:../src/stm32f30x_rcc.c **** /* CIR register byte 3 (Bits[23:16]) base address */
 127:../src/stm32f30x_rcc.c **** #define CIR_BYTE3_ADDRESS         ((uint32_t)0x4002100A)
 128:../src/stm32f30x_rcc.c **** 
 129:../src/stm32f30x_rcc.c **** /* CR register byte 2 (Bits[23:16]) base address */
 130:../src/stm32f30x_rcc.c **** #define CR_BYTE2_ADDRESS          ((uint32_t)0x40021002)
 131:../src/stm32f30x_rcc.c **** 
 132:../src/stm32f30x_rcc.c **** /* Private macro -------------------------------------------------------------*/
 133:../src/stm32f30x_rcc.c **** /* Private variables ---------------------------------------------------------*/
 134:../src/stm32f30x_rcc.c **** static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
 135:../src/stm32f30x_rcc.c **** static __I uint16_t ADCPrescTable[13] = {0, 1, 2, 4, 6, 8, 10, 12, 16, 32, 64, 128, 256};
 136:../src/stm32f30x_rcc.c **** 
 137:../src/stm32f30x_rcc.c **** /* Private function prototypes -----------------------------------------------*/
 138:../src/stm32f30x_rcc.c **** /* Private functions ---------------------------------------------------------*/
 139:../src/stm32f30x_rcc.c **** 
 140:../src/stm32f30x_rcc.c **** /** @defgroup RCC_Private_Functions
 141:../src/stm32f30x_rcc.c ****   * @{
 142:../src/stm32f30x_rcc.c ****   */
 143:../src/stm32f30x_rcc.c **** 
 144:../src/stm32f30x_rcc.c **** /** @defgroup RCC_Group1 Internal and external clocks, PLL, CSS and MCO configuration functions
 145:../src/stm32f30x_rcc.c ****  *  @brief   Internal and external clocks, PLL, CSS and MCO configuration functions 
 146:../src/stm32f30x_rcc.c ****  *
 147:../src/stm32f30x_rcc.c **** @verbatim   
 148:../src/stm32f30x_rcc.c ****  ===============================================================================
 149:../src/stm32f30x_rcc.c ****  ##### Internal-external clocks, PLL, CSS and MCO configuration functions #####
 150:../src/stm32f30x_rcc.c ****  ===============================================================================  
 151:../src/stm32f30x_rcc.c ****     [..] This section provides functions allowing to configure the internal/external 
 152:../src/stm32f30x_rcc.c ****          clocks, PLL, CSS and MCO.
 153:../src/stm32f30x_rcc.c ****          (#) HSI (high-speed internal), 8 MHz factory-trimmed RC used directly 
 154:../src/stm32f30x_rcc.c ****              or through the PLL as System clock source.
 155:../src/stm32f30x_rcc.c ****              The HSI clock can be used also to clock the USART and I2C peripherals.
 156:../src/stm32f30x_rcc.c ****          (#) LSI (low-speed internal), 40 KHz low consumption RC used as IWDG and/or RTC
 157:../src/stm32f30x_rcc.c ****              clock source.
 158:../src/stm32f30x_rcc.c ****          (#) HSE (high-speed external), 4 to 32 MHz crystal oscillator used directly or
 159:../src/stm32f30x_rcc.c ****              through the PLL as System clock source. Can be used also as RTC clock source.
 160:../src/stm32f30x_rcc.c ****          (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.
 161:../src/stm32f30x_rcc.c ****              LSE can be used also to clock the USART peripherals.
 162:../src/stm32f30x_rcc.c ****          (#) PLL (clocked by HSI or HSE), for System clock.
 163:../src/stm32f30x_rcc.c ****          (#) CSS (Clock security system), once enabled and if a HSE clock failure occurs 
 164:../src/stm32f30x_rcc.c ****              (HSE used directly or through PLL as System clock source), the System clock
 165:../src/stm32f30x_rcc.c ****              is automatically switched to HSI and an interrupt is generated if enabled. 
 166:../src/stm32f30x_rcc.c ****              The interrupt is linked to the Cortex-M4 NMI (Non-Maskable Interrupt) 
 167:../src/stm32f30x_rcc.c ****              exception vector.   
 168:../src/stm32f30x_rcc.c ****          (#) MCO (microcontroller clock output), used to output SYSCLK, HSI, HSE, LSI, LSE,
 169:../src/stm32f30x_rcc.c ****              PLL clock on PA8 pin.
 170:../src/stm32f30x_rcc.c **** 
 171:../src/stm32f30x_rcc.c **** @endverbatim
 172:../src/stm32f30x_rcc.c ****   * @{
 173:../src/stm32f30x_rcc.c ****   */
 174:../src/stm32f30x_rcc.c **** 
 175:../src/stm32f30x_rcc.c **** /**
 176:../src/stm32f30x_rcc.c ****   * @brief  Resets the RCC clock configuration to the default reset state.
 177:../src/stm32f30x_rcc.c ****   * @note   The default reset state of the clock configuration is given below:
 178:../src/stm32f30x_rcc.c ****   * @note     HSI ON and used as system clock source 
 179:../src/stm32f30x_rcc.c ****   * @note     HSE and PLL OFF
 180:../src/stm32f30x_rcc.c ****   * @note     AHB, APB1 and APB2 prescalers set to 1.
 181:../src/stm32f30x_rcc.c ****   * @note     CSS and MCO OFF
 182:../src/stm32f30x_rcc.c ****   * @note     All interrupts disabled
 183:../src/stm32f30x_rcc.c ****   * @note   However, this function doesn't modify the configuration of the
 184:../src/stm32f30x_rcc.c ****   * @note     Peripheral clocks
 185:../src/stm32f30x_rcc.c ****   * @note     LSI, LSE and RTC clocks                  
 186:../src/stm32f30x_rcc.c ****   * @param  None
 187:../src/stm32f30x_rcc.c ****   * @retval None
 188:../src/stm32f30x_rcc.c ****   */
 189:../src/stm32f30x_rcc.c **** void RCC_DeInit(void)
 190:../src/stm32f30x_rcc.c **** {
  66              		.loc 1 190 0
  67              		.cfi_startproc
  68              		@ args = 0, pretend = 0, frame = 0
  69              		@ frame_needed = 1, uses_anonymous_args = 0
  70              		@ link register save eliminated.
  71 0000 80B4     		push	{r7}
  72              	.LCFI0:
  73              		.cfi_def_cfa_offset 4
  74              		.cfi_offset 7, -4
  75 0002 00AF     		add	r7, sp, #0
  76              	.LCFI1:
  77              		.cfi_def_cfa_register 7
 191:../src/stm32f30x_rcc.c ****   /* Set HSION bit */
 192:../src/stm32f30x_rcc.c ****   RCC->CR |= (uint32_t)0x00000001;
  78              		.loc 1 192 0
  79 0004 4FF48053 		mov	r3, #4096
  80 0008 C4F20203 		movt	r3, 16386
  81 000c 4FF48052 		mov	r2, #4096
  82 0010 C4F20202 		movt	r2, 16386
  83 0014 1268     		ldr	r2, [r2, #0]
  84 0016 42F00102 		orr	r2, r2, #1
  85 001a 1A60     		str	r2, [r3, #0]
 193:../src/stm32f30x_rcc.c **** 
 194:../src/stm32f30x_rcc.c ****   /* Reset SW[1:0], HPRE[3:0], PPRE[2:0] and MCOSEL[2:0] bits */
 195:../src/stm32f30x_rcc.c ****   RCC->CFGR &= (uint32_t)0xF8FFC000;
  86              		.loc 1 195 0
  87 001c 4FF48052 		mov	r2, #4096
  88 0020 C4F20202 		movt	r2, 16386
  89 0024 4FF48053 		mov	r3, #4096
  90 0028 C4F20203 		movt	r3, 16386
  91 002c 5968     		ldr	r1, [r3, #4]
  92 002e 4FF44043 		mov	r3, #49152
  93 0032 CFF6FF03 		movt	r3, 63743
  94 0036 0B40     		ands	r3, r3, r1
  95 0038 5360     		str	r3, [r2, #4]
 196:../src/stm32f30x_rcc.c ****   
 197:../src/stm32f30x_rcc.c ****   /* Reset HSEON, CSSON and PLLON bits */
 198:../src/stm32f30x_rcc.c ****   RCC->CR &= (uint32_t)0xFEF6FFFF;
  96              		.loc 1 198 0
  97 003a 4FF48053 		mov	r3, #4096
  98 003e C4F20203 		movt	r3, 16386
  99 0042 4FF48052 		mov	r2, #4096
 100 0046 C4F20202 		movt	r2, 16386
 101 004a 1268     		ldr	r2, [r2, #0]
 102 004c 22F08472 		bic	r2, r2, #17301504
 103 0050 22F48032 		bic	r2, r2, #65536
 104 0054 1A60     		str	r2, [r3, #0]
 199:../src/stm32f30x_rcc.c **** 
 200:../src/stm32f30x_rcc.c ****   /* Reset HSEBYP bit */
 201:../src/stm32f30x_rcc.c ****   RCC->CR &= (uint32_t)0xFFFBFFFF;
 105              		.loc 1 201 0
 106 0056 4FF48053 		mov	r3, #4096
 107 005a C4F20203 		movt	r3, 16386
 108 005e 4FF48052 		mov	r2, #4096
 109 0062 C4F20202 		movt	r2, 16386
 110 0066 1268     		ldr	r2, [r2, #0]
 111 0068 22F48022 		bic	r2, r2, #262144
 112 006c 1A60     		str	r2, [r3, #0]
 202:../src/stm32f30x_rcc.c **** 
 203:../src/stm32f30x_rcc.c ****   /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE bits */
 204:../src/stm32f30x_rcc.c ****   RCC->CFGR &= (uint32_t)0xFF80FFFF;
 113              		.loc 1 204 0
 114 006e 4FF48053 		mov	r3, #4096
 115 0072 C4F20203 		movt	r3, 16386
 116 0076 4FF48052 		mov	r2, #4096
 117 007a C4F20202 		movt	r2, 16386
 118 007e 5268     		ldr	r2, [r2, #4]
 119 0080 22F4FE02 		bic	r2, r2, #8323072
 120 0084 5A60     		str	r2, [r3, #4]
 205:../src/stm32f30x_rcc.c **** 
 206:../src/stm32f30x_rcc.c ****   /* Reset PREDIV1[3:0] and ADCPRE[13:4] bits */
 207:../src/stm32f30x_rcc.c ****   RCC->CFGR2 &= (uint32_t)0xFFFFC000;
 121              		.loc 1 207 0
 122 0086 4FF48053 		mov	r3, #4096
 123 008a C4F20203 		movt	r3, 16386
 124 008e 4FF48052 		mov	r2, #4096
 125 0092 C4F20202 		movt	r2, 16386
 126 0096 D26A     		ldr	r2, [r2, #44]
 127 0098 22F47F52 		bic	r2, r2, #16320
 128 009c 22F03F02 		bic	r2, r2, #63
 129 00a0 DA62     		str	r2, [r3, #44]
 208:../src/stm32f30x_rcc.c **** 
 209:../src/stm32f30x_rcc.c ****   /* Reset USARTSW[1:0], I2CSW and TIMSW bits */
 210:../src/stm32f30x_rcc.c ****   RCC->CFGR3 &= (uint32_t)0xF00FCCC;
 130              		.loc 1 210 0
 131 00a2 4FF48052 		mov	r2, #4096
 132 00a6 C4F20202 		movt	r2, 16386
 133 00aa 4FF48053 		mov	r3, #4096
 134 00ae C4F20203 		movt	r3, 16386
 135 00b2 196B     		ldr	r1, [r3, #48]
 136 00b4 4FF6CC43 		movw	r3, #64716
 137 00b8 C0F60073 		movt	r3, 3840
 138 00bc 0B40     		ands	r3, r3, r1
 139 00be 1363     		str	r3, [r2, #48]
 211:../src/stm32f30x_rcc.c ****   
 212:../src/stm32f30x_rcc.c ****   /* Disable all interrupts */
 213:../src/stm32f30x_rcc.c ****   RCC->CIR = 0x00000000;
 140              		.loc 1 213 0
 141 00c0 4FF48053 		mov	r3, #4096
 142 00c4 C4F20203 		movt	r3, 16386
 143 00c8 4FF00002 		mov	r2, #0
 144 00cc 9A60     		str	r2, [r3, #8]
 214:../src/stm32f30x_rcc.c **** }
 145              		.loc 1 214 0
 146 00ce BD46     		mov	sp, r7
 147 00d0 80BC     		pop	{r7}
 148 00d2 7047     		bx	lr
 149              		.cfi_endproc
 150              	.LFE111:
 152              		.align	2
 153              		.global	RCC_HSEConfig
 154              		.thumb
 155              		.thumb_func
 157              	RCC_HSEConfig:
 158              	.LFB112:
 215:../src/stm32f30x_rcc.c **** 
 216:../src/stm32f30x_rcc.c **** /**
 217:../src/stm32f30x_rcc.c ****   * @brief  Configures the External High Speed oscillator (HSE).
 218:../src/stm32f30x_rcc.c ****   * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
 219:../src/stm32f30x_rcc.c ****   *         software should wait on HSERDY flag to be set indicating that HSE clock
 220:../src/stm32f30x_rcc.c ****   *         is stable and can be used to clock the PLL and/or system clock.
 221:../src/stm32f30x_rcc.c ****   * @note   HSE state can not be changed if it is used directly or through the
 222:../src/stm32f30x_rcc.c ****   *         PLL as system clock. In this case, you have to select another source
 223:../src/stm32f30x_rcc.c ****   *         of the system clock then change the HSE state (ex. disable it).
 224:../src/stm32f30x_rcc.c ****   * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.         
 225:../src/stm32f30x_rcc.c ****   * @note   This function resets the CSSON bit, so if the Clock security system(CSS)
 226:../src/stm32f30x_rcc.c ****   *         was previously enabled you have to enable it again after calling this
 227:../src/stm32f30x_rcc.c ****   *         function.
 228:../src/stm32f30x_rcc.c ****   * @param  RCC_HSE: specifies the new state of the HSE.
 229:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 230:../src/stm32f30x_rcc.c ****   *     @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
 231:../src/stm32f30x_rcc.c ****   *                       6 HSE oscillator clock cycles.
 232:../src/stm32f30x_rcc.c ****   *     @arg RCC_HSE_ON: turn ON the HSE oscillator
 233:../src/stm32f30x_rcc.c ****   *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
 234:../src/stm32f30x_rcc.c ****   * @retval None
 235:../src/stm32f30x_rcc.c ****   */
 236:../src/stm32f30x_rcc.c **** void RCC_HSEConfig(uint8_t RCC_HSE)
 237:../src/stm32f30x_rcc.c **** {
 159              		.loc 1 237 0
 160              		.cfi_startproc
 161              		@ args = 0, pretend = 0, frame = 8
 162              		@ frame_needed = 1, uses_anonymous_args = 0
 163              		@ link register save eliminated.
 164 00d4 80B4     		push	{r7}
 165              	.LCFI2:
 166              		.cfi_def_cfa_offset 4
 167              		.cfi_offset 7, -4
 168 00d6 83B0     		sub	sp, sp, #12
 169              	.LCFI3:
 170              		.cfi_def_cfa_offset 16
 171 00d8 00AF     		add	r7, sp, #0
 172              	.LCFI4:
 173              		.cfi_def_cfa_register 7
 174 00da 0346     		mov	r3, r0
 175 00dc FB71     		strb	r3, [r7, #7]
 238:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 239:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_HSE(RCC_HSE));
 240:../src/stm32f30x_rcc.c **** 
 241:../src/stm32f30x_rcc.c ****   /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
 242:../src/stm32f30x_rcc.c ****   *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE_OFF;
 176              		.loc 1 242 0
 177 00de 41F20203 		movw	r3, #4098
 178 00e2 C4F20203 		movt	r3, 16386
 179 00e6 4FF00002 		mov	r2, #0
 180 00ea 1A70     		strb	r2, [r3, #0]
 243:../src/stm32f30x_rcc.c **** 
 244:../src/stm32f30x_rcc.c ****   /* Set the new HSE configuration -------------------------------------------*/
 245:../src/stm32f30x_rcc.c ****   *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE;
 181              		.loc 1 245 0
 182 00ec 41F20203 		movw	r3, #4098
 183 00f0 C4F20203 		movt	r3, 16386
 184 00f4 FA79     		ldrb	r2, [r7, #7]
 185 00f6 1A70     		strb	r2, [r3, #0]
 246:../src/stm32f30x_rcc.c **** 
 247:../src/stm32f30x_rcc.c **** }
 186              		.loc 1 247 0
 187 00f8 07F10C07 		add	r7, r7, #12
 188 00fc BD46     		mov	sp, r7
 189 00fe 80BC     		pop	{r7}
 190 0100 7047     		bx	lr
 191              		.cfi_endproc
 192              	.LFE112:
 194 0102 00BF     		.align	2
 195              		.global	RCC_WaitForHSEStartUp
 196              		.thumb
 197              		.thumb_func
 199              	RCC_WaitForHSEStartUp:
 200              	.LFB113:
 248:../src/stm32f30x_rcc.c **** 
 249:../src/stm32f30x_rcc.c **** /**
 250:../src/stm32f30x_rcc.c ****   * @brief  Waits for HSE start-up.
 251:../src/stm32f30x_rcc.c ****   * @note   This function waits on HSERDY flag to be set and return SUCCESS if 
 252:../src/stm32f30x_rcc.c ****   *         this flag is set, otherwise returns ERROR if the timeout is reached 
 253:../src/stm32f30x_rcc.c ****   *         and this flag is not set. The timeout value is defined by the constant
 254:../src/stm32f30x_rcc.c ****   *         HSE_STARTUP_TIMEOUT in stm32f30x.h file. You can tailor it depending
 255:../src/stm32f30x_rcc.c ****   *         on the HSE crystal used in your application. 
 256:../src/stm32f30x_rcc.c ****   * @param  None
 257:../src/stm32f30x_rcc.c ****   * @retval An ErrorStatus enumeration value:
 258:../src/stm32f30x_rcc.c ****   *          - SUCCESS: HSE oscillator is stable and ready to use
 259:../src/stm32f30x_rcc.c ****   *          - ERROR: HSE oscillator not yet ready
 260:../src/stm32f30x_rcc.c ****   */
 261:../src/stm32f30x_rcc.c **** ErrorStatus RCC_WaitForHSEStartUp(void)
 262:../src/stm32f30x_rcc.c **** {
 201              		.loc 1 262 0
 202              		.cfi_startproc
 203              		@ args = 0, pretend = 0, frame = 8
 204              		@ frame_needed = 1, uses_anonymous_args = 0
 205 0104 80B5     		push	{r7, lr}
 206              	.LCFI5:
 207              		.cfi_def_cfa_offset 8
 208              		.cfi_offset 7, -8
 209              		.cfi_offset 14, -4
 210 0106 82B0     		sub	sp, sp, #8
 211              	.LCFI6:
 212              		.cfi_def_cfa_offset 16
 213 0108 00AF     		add	r7, sp, #0
 214              	.LCFI7:
 215              		.cfi_def_cfa_register 7
 263:../src/stm32f30x_rcc.c ****   __IO uint32_t StartUpCounter = 0;
 216              		.loc 1 263 0
 217 010a 4FF00003 		mov	r3, #0
 218 010e 3B60     		str	r3, [r7, #0]
 264:../src/stm32f30x_rcc.c ****   ErrorStatus status = ERROR;
 219              		.loc 1 264 0
 220 0110 4FF00003 		mov	r3, #0
 221 0114 FB71     		strb	r3, [r7, #7]
 265:../src/stm32f30x_rcc.c ****   FlagStatus HSEStatus = RESET;
 222              		.loc 1 265 0
 223 0116 4FF00003 		mov	r3, #0
 224 011a BB71     		strb	r3, [r7, #6]
 225              	.L5:
 266:../src/stm32f30x_rcc.c ****   
 267:../src/stm32f30x_rcc.c ****   /* Wait till HSE is ready and if timeout is reached exit */
 268:../src/stm32f30x_rcc.c ****   do
 269:../src/stm32f30x_rcc.c ****   {
 270:../src/stm32f30x_rcc.c ****     HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 226              		.loc 1 270 0 discriminator 1
 227 011c 4FF01100 		mov	r0, #17
 228 0120 FFF7FEFF 		bl	RCC_GetFlagStatus
 229 0124 0346     		mov	r3, r0
 230 0126 BB71     		strb	r3, [r7, #6]
 271:../src/stm32f30x_rcc.c ****     StartUpCounter++;  
 231              		.loc 1 271 0 discriminator 1
 232 0128 3B68     		ldr	r3, [r7, #0]
 233 012a 03F10103 		add	r3, r3, #1
 234 012e 3B60     		str	r3, [r7, #0]
 272:../src/stm32f30x_rcc.c ****   } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 235              		.loc 1 272 0 discriminator 1
 236 0130 3B68     		ldr	r3, [r7, #0]
 237 0132 B3F5A06F 		cmp	r3, #1280
 238 0136 02D0     		beq	.L4
 239 0138 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 240 013a 002B     		cmp	r3, #0
 241 013c EED0     		beq	.L5
 242              	.L4:
 273:../src/stm32f30x_rcc.c ****   
 274:../src/stm32f30x_rcc.c ****   if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 243              		.loc 1 274 0
 244 013e 4FF01100 		mov	r0, #17
 245 0142 FFF7FEFF 		bl	RCC_GetFlagStatus
 246 0146 0346     		mov	r3, r0
 247 0148 002B     		cmp	r3, #0
 248 014a 03D0     		beq	.L6
 275:../src/stm32f30x_rcc.c ****   {
 276:../src/stm32f30x_rcc.c ****     status = SUCCESS;
 249              		.loc 1 276 0
 250 014c 4FF00103 		mov	r3, #1
 251 0150 FB71     		strb	r3, [r7, #7]
 252 0152 02E0     		b	.L7
 253              	.L6:
 277:../src/stm32f30x_rcc.c ****   }
 278:../src/stm32f30x_rcc.c ****   else
 279:../src/stm32f30x_rcc.c ****   {
 280:../src/stm32f30x_rcc.c ****     status = ERROR;
 254              		.loc 1 280 0
 255 0154 4FF00003 		mov	r3, #0
 256 0158 FB71     		strb	r3, [r7, #7]
 257              	.L7:
 281:../src/stm32f30x_rcc.c ****   }  
 282:../src/stm32f30x_rcc.c ****   return (status);
 258              		.loc 1 282 0
 259 015a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 283:../src/stm32f30x_rcc.c **** }
 260              		.loc 1 283 0
 261 015c 1846     		mov	r0, r3
 262 015e 07F10807 		add	r7, r7, #8
 263 0162 BD46     		mov	sp, r7
 264 0164 80BD     		pop	{r7, pc}
 265              		.cfi_endproc
 266              	.LFE113:
 268 0166 00BF     		.align	2
 269              		.global	RCC_AdjustHSICalibrationValue
 270              		.thumb
 271              		.thumb_func
 273              	RCC_AdjustHSICalibrationValue:
 274              	.LFB114:
 284:../src/stm32f30x_rcc.c **** 
 285:../src/stm32f30x_rcc.c **** /**
 286:../src/stm32f30x_rcc.c ****   * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
 287:../src/stm32f30x_rcc.c ****   * @note   The calibration is used to compensate for the variations in voltage
 288:../src/stm32f30x_rcc.c ****   *         and temperature that influence the frequency of the internal HSI RC.
 289:../src/stm32f30x_rcc.c ****   *         Refer to the Application Note AN3300 for more details on how to  
 290:../src/stm32f30x_rcc.c ****   *         calibrate the HSI.
 291:../src/stm32f30x_rcc.c ****   * @param  HSICalibrationValue: specifies the HSI calibration trimming value.
 292:../src/stm32f30x_rcc.c ****   *         This parameter must be a number between 0 and 0x1F.
 293:../src/stm32f30x_rcc.c ****   * @retval None
 294:../src/stm32f30x_rcc.c ****   */
 295:../src/stm32f30x_rcc.c **** void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
 296:../src/stm32f30x_rcc.c **** {
 275              		.loc 1 296 0
 276              		.cfi_startproc
 277              		@ args = 0, pretend = 0, frame = 16
 278              		@ frame_needed = 1, uses_anonymous_args = 0
 279              		@ link register save eliminated.
 280 0168 80B4     		push	{r7}
 281              	.LCFI8:
 282              		.cfi_def_cfa_offset 4
 283              		.cfi_offset 7, -4
 284 016a 85B0     		sub	sp, sp, #20
 285              	.LCFI9:
 286              		.cfi_def_cfa_offset 24
 287 016c 00AF     		add	r7, sp, #0
 288              	.LCFI10:
 289              		.cfi_def_cfa_register 7
 290 016e 0346     		mov	r3, r0
 291 0170 FB71     		strb	r3, [r7, #7]
 297:../src/stm32f30x_rcc.c ****   uint32_t tmpreg = 0;
 292              		.loc 1 297 0
 293 0172 4FF00003 		mov	r3, #0
 294 0176 FB60     		str	r3, [r7, #12]
 298:../src/stm32f30x_rcc.c ****   
 299:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 300:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
 301:../src/stm32f30x_rcc.c ****   
 302:../src/stm32f30x_rcc.c ****   tmpreg = RCC->CR;
 295              		.loc 1 302 0
 296 0178 4FF48053 		mov	r3, #4096
 297 017c C4F20203 		movt	r3, 16386
 298 0180 1B68     		ldr	r3, [r3, #0]
 299 0182 FB60     		str	r3, [r7, #12]
 303:../src/stm32f30x_rcc.c ****   
 304:../src/stm32f30x_rcc.c ****   /* Clear HSITRIM[4:0] bits */
 305:../src/stm32f30x_rcc.c ****   tmpreg &= ~RCC_CR_HSITRIM;
 300              		.loc 1 305 0
 301 0184 FB68     		ldr	r3, [r7, #12]
 302 0186 23F0F803 		bic	r3, r3, #248
 303 018a FB60     		str	r3, [r7, #12]
 306:../src/stm32f30x_rcc.c ****   
 307:../src/stm32f30x_rcc.c ****   /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
 308:../src/stm32f30x_rcc.c ****   tmpreg |= (uint32_t)HSICalibrationValue << 3;
 304              		.loc 1 308 0
 305 018c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 306 018e 4FEAC303 		lsl	r3, r3, #3
 307 0192 FA68     		ldr	r2, [r7, #12]
 308 0194 1343     		orrs	r3, r3, r2
 309 0196 FB60     		str	r3, [r7, #12]
 309:../src/stm32f30x_rcc.c ****   
 310:../src/stm32f30x_rcc.c ****   /* Store the new value */
 311:../src/stm32f30x_rcc.c ****   RCC->CR = tmpreg;
 310              		.loc 1 311 0
 311 0198 4FF48053 		mov	r3, #4096
 312 019c C4F20203 		movt	r3, 16386
 313 01a0 FA68     		ldr	r2, [r7, #12]
 314 01a2 1A60     		str	r2, [r3, #0]
 312:../src/stm32f30x_rcc.c **** }
 315              		.loc 1 312 0
 316 01a4 07F11407 		add	r7, r7, #20
 317 01a8 BD46     		mov	sp, r7
 318 01aa 80BC     		pop	{r7}
 319 01ac 7047     		bx	lr
 320              		.cfi_endproc
 321              	.LFE114:
 323 01ae 00BF     		.align	2
 324              		.global	RCC_HSICmd
 325              		.thumb
 326              		.thumb_func
 328              	RCC_HSICmd:
 329              	.LFB115:
 313:../src/stm32f30x_rcc.c **** 
 314:../src/stm32f30x_rcc.c **** /**
 315:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the Internal High Speed oscillator (HSI).
 316:../src/stm32f30x_rcc.c ****   * @note   After enabling the HSI, the application software should wait on 
 317:../src/stm32f30x_rcc.c ****   *         HSIRDY flag to be set indicating that HSI clock is stable and can
 318:../src/stm32f30x_rcc.c ****   *         be used to clock the PLL and/or system clock.
 319:../src/stm32f30x_rcc.c ****   * @note   HSI can not be stopped if it is used directly or through the PLL
 320:../src/stm32f30x_rcc.c ****   *         as system clock. In this case, you have to select another source 
 321:../src/stm32f30x_rcc.c ****   *         of the system clock then stop the HSI.
 322:../src/stm32f30x_rcc.c ****   * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes. 
 323:../src/stm32f30x_rcc.c ****   * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
 324:../src/stm32f30x_rcc.c ****   *         clock cycles.    
 325:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the HSI.
 326:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
 327:../src/stm32f30x_rcc.c ****   * @retval None
 328:../src/stm32f30x_rcc.c ****   */
 329:../src/stm32f30x_rcc.c **** void RCC_HSICmd(FunctionalState NewState)
 330:../src/stm32f30x_rcc.c **** {
 330              		.loc 1 330 0
 331              		.cfi_startproc
 332              		@ args = 0, pretend = 0, frame = 8
 333              		@ frame_needed = 1, uses_anonymous_args = 0
 334              		@ link register save eliminated.
 335 01b0 80B4     		push	{r7}
 336              	.LCFI11:
 337              		.cfi_def_cfa_offset 4
 338              		.cfi_offset 7, -4
 339 01b2 83B0     		sub	sp, sp, #12
 340              	.LCFI12:
 341              		.cfi_def_cfa_offset 16
 342 01b4 00AF     		add	r7, sp, #0
 343              	.LCFI13:
 344              		.cfi_def_cfa_register 7
 345 01b6 0346     		mov	r3, r0
 346 01b8 FB71     		strb	r3, [r7, #7]
 331:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 332:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 333:../src/stm32f30x_rcc.c ****   
 334:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 347              		.loc 1 334 0
 348 01ba 4FF00003 		mov	r3, #0
 349 01be C4F24223 		movt	r3, 16962
 350 01c2 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 351 01c4 1A60     		str	r2, [r3, #0]
 335:../src/stm32f30x_rcc.c **** }
 352              		.loc 1 335 0
 353 01c6 07F10C07 		add	r7, r7, #12
 354 01ca BD46     		mov	sp, r7
 355 01cc 80BC     		pop	{r7}
 356 01ce 7047     		bx	lr
 357              		.cfi_endproc
 358              	.LFE115:
 360              		.align	2
 361              		.global	RCC_LSEConfig
 362              		.thumb
 363              		.thumb_func
 365              	RCC_LSEConfig:
 366              	.LFB116:
 336:../src/stm32f30x_rcc.c **** 
 337:../src/stm32f30x_rcc.c **** /**
 338:../src/stm32f30x_rcc.c ****   * @brief  Configures the External Low Speed oscillator (LSE).
 339:../src/stm32f30x_rcc.c ****   * @note     As the LSE is in the Backup domain and write access is denied to this
 340:../src/stm32f30x_rcc.c ****   *           domain after reset, you have to enable write access using 
 341:../src/stm32f30x_rcc.c ****   *           PWR_BackupAccessCmd(ENABLE) function before to configure the LSE
 342:../src/stm32f30x_rcc.c ****   *           (to be done once after reset).
 343:../src/stm32f30x_rcc.c ****   * @note     After enabling the LSE (RCC_LSE_ON or RCC_LSE_Bypass), the application
 344:../src/stm32f30x_rcc.c ****   *           software should wait on LSERDY flag to be set indicating that LSE clock
 345:../src/stm32f30x_rcc.c ****   *           is stable and can be used to clock the RTC.
 346:../src/stm32f30x_rcc.c ****   * @param  RCC_LSE: specifies the new state of the LSE.
 347:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 348:../src/stm32f30x_rcc.c ****   *     @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
 349:../src/stm32f30x_rcc.c ****   *                       6 LSE oscillator clock cycles.
 350:../src/stm32f30x_rcc.c ****   *     @arg RCC_LSE_ON: turn ON the LSE oscillator
 351:../src/stm32f30x_rcc.c ****   *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
 352:../src/stm32f30x_rcc.c ****   * @retval None
 353:../src/stm32f30x_rcc.c ****   */
 354:../src/stm32f30x_rcc.c **** void RCC_LSEConfig(uint32_t RCC_LSE)
 355:../src/stm32f30x_rcc.c **** {
 367              		.loc 1 355 0
 368              		.cfi_startproc
 369              		@ args = 0, pretend = 0, frame = 8
 370              		@ frame_needed = 1, uses_anonymous_args = 0
 371              		@ link register save eliminated.
 372 01d0 80B4     		push	{r7}
 373              	.LCFI14:
 374              		.cfi_def_cfa_offset 4
 375              		.cfi_offset 7, -4
 376 01d2 83B0     		sub	sp, sp, #12
 377              	.LCFI15:
 378              		.cfi_def_cfa_offset 16
 379 01d4 00AF     		add	r7, sp, #0
 380              	.LCFI16:
 381              		.cfi_def_cfa_register 7
 382 01d6 7860     		str	r0, [r7, #4]
 356:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 357:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_LSE(RCC_LSE));
 358:../src/stm32f30x_rcc.c **** 
 359:../src/stm32f30x_rcc.c ****   /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
 360:../src/stm32f30x_rcc.c ****   /* Reset LSEON bit */
 361:../src/stm32f30x_rcc.c ****   RCC->BDCR &= ~(RCC_BDCR_LSEON);
 383              		.loc 1 361 0
 384 01d8 4FF48053 		mov	r3, #4096
 385 01dc C4F20203 		movt	r3, 16386
 386 01e0 4FF48052 		mov	r2, #4096
 387 01e4 C4F20202 		movt	r2, 16386
 388 01e8 126A     		ldr	r2, [r2, #32]
 389 01ea 22F00102 		bic	r2, r2, #1
 390 01ee 1A62     		str	r2, [r3, #32]
 362:../src/stm32f30x_rcc.c **** 
 363:../src/stm32f30x_rcc.c ****   /* Reset LSEBYP bit */
 364:../src/stm32f30x_rcc.c ****   RCC->BDCR &= ~(RCC_BDCR_LSEBYP);
 391              		.loc 1 364 0
 392 01f0 4FF48053 		mov	r3, #4096
 393 01f4 C4F20203 		movt	r3, 16386
 394 01f8 4FF48052 		mov	r2, #4096
 395 01fc C4F20202 		movt	r2, 16386
 396 0200 126A     		ldr	r2, [r2, #32]
 397 0202 22F00402 		bic	r2, r2, #4
 398 0206 1A62     		str	r2, [r3, #32]
 365:../src/stm32f30x_rcc.c **** 
 366:../src/stm32f30x_rcc.c ****   /* Configure LSE */
 367:../src/stm32f30x_rcc.c ****   RCC->BDCR |= RCC_LSE;
 399              		.loc 1 367 0
 400 0208 4FF48053 		mov	r3, #4096
 401 020c C4F20203 		movt	r3, 16386
 402 0210 4FF48052 		mov	r2, #4096
 403 0214 C4F20202 		movt	r2, 16386
 404 0218 116A     		ldr	r1, [r2, #32]
 405 021a 7A68     		ldr	r2, [r7, #4]
 406 021c 0A43     		orrs	r2, r2, r1
 407 021e 1A62     		str	r2, [r3, #32]
 368:../src/stm32f30x_rcc.c **** }
 408              		.loc 1 368 0
 409 0220 07F10C07 		add	r7, r7, #12
 410 0224 BD46     		mov	sp, r7
 411 0226 80BC     		pop	{r7}
 412 0228 7047     		bx	lr
 413              		.cfi_endproc
 414              	.LFE116:
 416 022a 00BF     		.align	2
 417              		.global	RCC_LSEDriveConfig
 418              		.thumb
 419              		.thumb_func
 421              	RCC_LSEDriveConfig:
 422              	.LFB117:
 369:../src/stm32f30x_rcc.c **** 
 370:../src/stm32f30x_rcc.c **** /**
 371:../src/stm32f30x_rcc.c ****   * @brief  Configures the External Low Speed oscillator (LSE) drive capability.
 372:../src/stm32f30x_rcc.c ****   * @param  RCC_LSEDrive: specifies the new state of the LSE drive capability.
 373:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 374:../src/stm32f30x_rcc.c ****   *     @arg RCC_LSEDrive_Low: LSE oscillator low drive capability.
 375:../src/stm32f30x_rcc.c ****   *     @arg RCC_LSEDrive_MediumLow: LSE oscillator medium low drive capability.
 376:../src/stm32f30x_rcc.c ****   *     @arg RCC_LSEDrive_MediumHigh: LSE oscillator medium high drive capability.
 377:../src/stm32f30x_rcc.c ****   *     @arg RCC_LSEDrive_High: LSE oscillator high drive capability.
 378:../src/stm32f30x_rcc.c ****   * @retval None
 379:../src/stm32f30x_rcc.c ****   */
 380:../src/stm32f30x_rcc.c **** void RCC_LSEDriveConfig(uint32_t RCC_LSEDrive)
 381:../src/stm32f30x_rcc.c **** {
 423              		.loc 1 381 0
 424              		.cfi_startproc
 425              		@ args = 0, pretend = 0, frame = 8
 426              		@ frame_needed = 1, uses_anonymous_args = 0
 427              		@ link register save eliminated.
 428 022c 80B4     		push	{r7}
 429              	.LCFI17:
 430              		.cfi_def_cfa_offset 4
 431              		.cfi_offset 7, -4
 432 022e 83B0     		sub	sp, sp, #12
 433              	.LCFI18:
 434              		.cfi_def_cfa_offset 16
 435 0230 00AF     		add	r7, sp, #0
 436              	.LCFI19:
 437              		.cfi_def_cfa_register 7
 438 0232 7860     		str	r0, [r7, #4]
 382:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 383:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_LSE_DRIVE(RCC_LSEDrive));
 384:../src/stm32f30x_rcc.c ****   
 385:../src/stm32f30x_rcc.c ****   /* Clear LSEDRV[1:0] bits */
 386:../src/stm32f30x_rcc.c ****   RCC->BDCR &= ~(RCC_BDCR_LSEDRV);
 439              		.loc 1 386 0
 440 0234 4FF48053 		mov	r3, #4096
 441 0238 C4F20203 		movt	r3, 16386
 442 023c 4FF48052 		mov	r2, #4096
 443 0240 C4F20202 		movt	r2, 16386
 444 0244 126A     		ldr	r2, [r2, #32]
 445 0246 22F01802 		bic	r2, r2, #24
 446 024a 1A62     		str	r2, [r3, #32]
 387:../src/stm32f30x_rcc.c **** 
 388:../src/stm32f30x_rcc.c ****   /* Set the LSE Drive */
 389:../src/stm32f30x_rcc.c ****   RCC->BDCR |= RCC_LSEDrive;
 447              		.loc 1 389 0
 448 024c 4FF48053 		mov	r3, #4096
 449 0250 C4F20203 		movt	r3, 16386
 450 0254 4FF48052 		mov	r2, #4096
 451 0258 C4F20202 		movt	r2, 16386
 452 025c 116A     		ldr	r1, [r2, #32]
 453 025e 7A68     		ldr	r2, [r7, #4]
 454 0260 0A43     		orrs	r2, r2, r1
 455 0262 1A62     		str	r2, [r3, #32]
 390:../src/stm32f30x_rcc.c **** }
 456              		.loc 1 390 0
 457 0264 07F10C07 		add	r7, r7, #12
 458 0268 BD46     		mov	sp, r7
 459 026a 80BC     		pop	{r7}
 460 026c 7047     		bx	lr
 461              		.cfi_endproc
 462              	.LFE117:
 464 026e 00BF     		.align	2
 465              		.global	RCC_LSICmd
 466              		.thumb
 467              		.thumb_func
 469              	RCC_LSICmd:
 470              	.LFB118:
 391:../src/stm32f30x_rcc.c **** 
 392:../src/stm32f30x_rcc.c **** /**
 393:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the Internal Low Speed oscillator (LSI).  
 394:../src/stm32f30x_rcc.c ****   * @note   After enabling the LSI, the application software should wait on 
 395:../src/stm32f30x_rcc.c ****   *         LSIRDY flag to be set indicating that LSI clock is stable and can
 396:../src/stm32f30x_rcc.c ****   *         be used to clock the IWDG and/or the RTC.
 397:../src/stm32f30x_rcc.c ****   * @note   LSI can not be disabled if the IWDG is running.  
 398:../src/stm32f30x_rcc.c ****   * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
 399:../src/stm32f30x_rcc.c ****   *         clock cycles.
 400:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the LSI.
 401:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE. 
 402:../src/stm32f30x_rcc.c ****   * @retval None
 403:../src/stm32f30x_rcc.c ****   */
 404:../src/stm32f30x_rcc.c **** void RCC_LSICmd(FunctionalState NewState)
 405:../src/stm32f30x_rcc.c **** {
 471              		.loc 1 405 0
 472              		.cfi_startproc
 473              		@ args = 0, pretend = 0, frame = 8
 474              		@ frame_needed = 1, uses_anonymous_args = 0
 475              		@ link register save eliminated.
 476 0270 80B4     		push	{r7}
 477              	.LCFI20:
 478              		.cfi_def_cfa_offset 4
 479              		.cfi_offset 7, -4
 480 0272 83B0     		sub	sp, sp, #12
 481              	.LCFI21:
 482              		.cfi_def_cfa_offset 16
 483 0274 00AF     		add	r7, sp, #0
 484              	.LCFI22:
 485              		.cfi_def_cfa_register 7
 486 0276 0346     		mov	r3, r0
 487 0278 FB71     		strb	r3, [r7, #7]
 406:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 407:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 408:../src/stm32f30x_rcc.c ****   
 409:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 488              		.loc 1 409 0
 489 027a 4FF49063 		mov	r3, #1152
 490 027e C4F24223 		movt	r3, 16962
 491 0282 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 492 0284 1A60     		str	r2, [r3, #0]
 410:../src/stm32f30x_rcc.c **** }
 493              		.loc 1 410 0
 494 0286 07F10C07 		add	r7, r7, #12
 495 028a BD46     		mov	sp, r7
 496 028c 80BC     		pop	{r7}
 497 028e 7047     		bx	lr
 498              		.cfi_endproc
 499              	.LFE118:
 501              		.align	2
 502              		.global	RCC_PLLConfig
 503              		.thumb
 504              		.thumb_func
 506              	RCC_PLLConfig:
 507              	.LFB119:
 411:../src/stm32f30x_rcc.c **** 
 412:../src/stm32f30x_rcc.c **** /**
 413:../src/stm32f30x_rcc.c ****   * @brief  Configures the PLL clock source and multiplication factor.
 414:../src/stm32f30x_rcc.c ****   * @note   This function must be used only when the PLL is disabled.
 415:../src/stm32f30x_rcc.c ****   * @note   The minimum input clock frequency for PLL is 2 MHz (when using HSE as
 416:../src/stm32f30x_rcc.c ****   *         PLL source).   
 417:../src/stm32f30x_rcc.c ****   * @param  RCC_PLLSource: specifies the PLL entry clock source.
 418:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 419:../src/stm32f30x_rcc.c ****   *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as
 420:../src/stm32f30x_rcc.c ****   *         PLL clock entry
 421:../src/stm32f30x_rcc.c ****   *     @arg RCC_PLLSource_PREDIV1: PREDIV1 clock selected as PLL clock source              
 422:../src/stm32f30x_rcc.c ****   * @param  RCC_PLLMul: specifies the PLL multiplication factor, which drive the PLLVCO clock
 423:../src/stm32f30x_rcc.c ****   *   This parameter can be RCC_PLLMul_x where x:[2,16] 
 424:../src/stm32f30x_rcc.c ****   *                                               
 425:../src/stm32f30x_rcc.c ****   * @retval None
 426:../src/stm32f30x_rcc.c ****   */
 427:../src/stm32f30x_rcc.c **** void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
 428:../src/stm32f30x_rcc.c **** {
 508              		.loc 1 428 0
 509              		.cfi_startproc
 510              		@ args = 0, pretend = 0, frame = 8
 511              		@ frame_needed = 1, uses_anonymous_args = 0
 512              		@ link register save eliminated.
 513 0290 80B4     		push	{r7}
 514              	.LCFI23:
 515              		.cfi_def_cfa_offset 4
 516              		.cfi_offset 7, -4
 517 0292 83B0     		sub	sp, sp, #12
 518              	.LCFI24:
 519              		.cfi_def_cfa_offset 16
 520 0294 00AF     		add	r7, sp, #0
 521              	.LCFI25:
 522              		.cfi_def_cfa_register 7
 523 0296 7860     		str	r0, [r7, #4]
 524 0298 3960     		str	r1, [r7, #0]
 429:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 430:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
 431:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
 432:../src/stm32f30x_rcc.c ****   
 433:../src/stm32f30x_rcc.c ****   /* Clear PLL Source [16] and Multiplier [21:18] bits */
 434:../src/stm32f30x_rcc.c ****   RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
 525              		.loc 1 434 0
 526 029a 4FF48053 		mov	r3, #4096
 527 029e C4F20203 		movt	r3, 16386
 528 02a2 4FF48052 		mov	r2, #4096
 529 02a6 C4F20202 		movt	r2, 16386
 530 02aa 5268     		ldr	r2, [r2, #4]
 531 02ac 22F47412 		bic	r2, r2, #3997696
 532 02b0 5A60     		str	r2, [r3, #4]
 435:../src/stm32f30x_rcc.c **** 
 436:../src/stm32f30x_rcc.c ****   /* Set the PLL Source and Multiplier */
 437:../src/stm32f30x_rcc.c ****   RCC->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
 533              		.loc 1 437 0
 534 02b2 4FF48053 		mov	r3, #4096
 535 02b6 C4F20203 		movt	r3, 16386
 536 02ba 4FF48052 		mov	r2, #4096
 537 02be C4F20202 		movt	r2, 16386
 538 02c2 5168     		ldr	r1, [r2, #4]
 539 02c4 7868     		ldr	r0, [r7, #4]
 540 02c6 3A68     		ldr	r2, [r7, #0]
 541 02c8 0243     		orrs	r2, r2, r0
 542 02ca 0A43     		orrs	r2, r2, r1
 543 02cc 5A60     		str	r2, [r3, #4]
 438:../src/stm32f30x_rcc.c **** }
 544              		.loc 1 438 0
 545 02ce 07F10C07 		add	r7, r7, #12
 546 02d2 BD46     		mov	sp, r7
 547 02d4 80BC     		pop	{r7}
 548 02d6 7047     		bx	lr
 549              		.cfi_endproc
 550              	.LFE119:
 552              		.align	2
 553              		.global	RCC_PLLCmd
 554              		.thumb
 555              		.thumb_func
 557              	RCC_PLLCmd:
 558              	.LFB120:
 439:../src/stm32f30x_rcc.c **** 
 440:../src/stm32f30x_rcc.c **** /**
 441:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the PLL.
 442:../src/stm32f30x_rcc.c ****   * @note   After enabling the PLL, the application software should wait on 
 443:../src/stm32f30x_rcc.c ****   *         PLLRDY flag to be set indicating that PLL clock is stable and can
 444:../src/stm32f30x_rcc.c ****   *         be used as system clock source.
 445:../src/stm32f30x_rcc.c ****   * @note   The PLL can not be disabled if it is used as system clock source
 446:../src/stm32f30x_rcc.c ****   * @note   The PLL is disabled by hardware when entering STOP and STANDBY modes.    
 447:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the PLL.
 448:../src/stm32f30x_rcc.c ****   *   This parameter can be: ENABLE or DISABLE.
 449:../src/stm32f30x_rcc.c ****   * @retval None
 450:../src/stm32f30x_rcc.c ****   */
 451:../src/stm32f30x_rcc.c **** void RCC_PLLCmd(FunctionalState NewState)
 452:../src/stm32f30x_rcc.c **** {
 559              		.loc 1 452 0
 560              		.cfi_startproc
 561              		@ args = 0, pretend = 0, frame = 8
 562              		@ frame_needed = 1, uses_anonymous_args = 0
 563              		@ link register save eliminated.
 564 02d8 80B4     		push	{r7}
 565              	.LCFI26:
 566              		.cfi_def_cfa_offset 4
 567              		.cfi_offset 7, -4
 568 02da 83B0     		sub	sp, sp, #12
 569              	.LCFI27:
 570              		.cfi_def_cfa_offset 16
 571 02dc 00AF     		add	r7, sp, #0
 572              	.LCFI28:
 573              		.cfi_def_cfa_register 7
 574 02de 0346     		mov	r3, r0
 575 02e0 FB71     		strb	r3, [r7, #7]
 453:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 454:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 455:../src/stm32f30x_rcc.c **** 
 456:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 576              		.loc 1 456 0
 577 02e2 4FF06003 		mov	r3, #96
 578 02e6 C4F24223 		movt	r3, 16962
 579 02ea FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 580 02ec 1A60     		str	r2, [r3, #0]
 457:../src/stm32f30x_rcc.c **** }
 581              		.loc 1 457 0
 582 02ee 07F10C07 		add	r7, r7, #12
 583 02f2 BD46     		mov	sp, r7
 584 02f4 80BC     		pop	{r7}
 585 02f6 7047     		bx	lr
 586              		.cfi_endproc
 587              	.LFE120:
 589              		.align	2
 590              		.global	RCC_PREDIV1Config
 591              		.thumb
 592              		.thumb_func
 594              	RCC_PREDIV1Config:
 595              	.LFB121:
 458:../src/stm32f30x_rcc.c **** 
 459:../src/stm32f30x_rcc.c **** /**
 460:../src/stm32f30x_rcc.c ****   * @brief  Configures the PREDIV1 division factor.
 461:../src/stm32f30x_rcc.c ****   * @note   This function must be used only when the PLL is disabled.
 462:../src/stm32f30x_rcc.c ****   * @param  RCC_PREDIV1_Div: specifies the PREDIV1 clock division factor.
 463:../src/stm32f30x_rcc.c ****   *         This parameter can be RCC_PREDIV1_Divx where x:[1,16]
 464:../src/stm32f30x_rcc.c ****   * @retval None
 465:../src/stm32f30x_rcc.c ****   */
 466:../src/stm32f30x_rcc.c **** void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Div)
 467:../src/stm32f30x_rcc.c **** {
 596              		.loc 1 467 0
 597              		.cfi_startproc
 598              		@ args = 0, pretend = 0, frame = 16
 599              		@ frame_needed = 1, uses_anonymous_args = 0
 600              		@ link register save eliminated.
 601 02f8 80B4     		push	{r7}
 602              	.LCFI29:
 603              		.cfi_def_cfa_offset 4
 604              		.cfi_offset 7, -4
 605 02fa 85B0     		sub	sp, sp, #20
 606              	.LCFI30:
 607              		.cfi_def_cfa_offset 24
 608 02fc 00AF     		add	r7, sp, #0
 609              	.LCFI31:
 610              		.cfi_def_cfa_register 7
 611 02fe 7860     		str	r0, [r7, #4]
 468:../src/stm32f30x_rcc.c ****   uint32_t tmpreg = 0;
 612              		.loc 1 468 0
 613 0300 4FF00003 		mov	r3, #0
 614 0304 FB60     		str	r3, [r7, #12]
 469:../src/stm32f30x_rcc.c ****   
 470:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 471:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
 472:../src/stm32f30x_rcc.c **** 
 473:../src/stm32f30x_rcc.c ****   tmpreg = RCC->CFGR2;
 615              		.loc 1 473 0
 616 0306 4FF48053 		mov	r3, #4096
 617 030a C4F20203 		movt	r3, 16386
 618 030e DB6A     		ldr	r3, [r3, #44]
 619 0310 FB60     		str	r3, [r7, #12]
 474:../src/stm32f30x_rcc.c ****   /* Clear PREDIV1[3:0] bits */
 475:../src/stm32f30x_rcc.c ****   tmpreg &= ~(RCC_CFGR2_PREDIV1);
 620              		.loc 1 475 0
 621 0312 FB68     		ldr	r3, [r7, #12]
 622 0314 23F00F03 		bic	r3, r3, #15
 623 0318 FB60     		str	r3, [r7, #12]
 476:../src/stm32f30x_rcc.c **** 
 477:../src/stm32f30x_rcc.c ****   /* Set the PREDIV1 division factor */
 478:../src/stm32f30x_rcc.c ****   tmpreg |= RCC_PREDIV1_Div;
 624              		.loc 1 478 0
 625 031a FA68     		ldr	r2, [r7, #12]
 626 031c 7B68     		ldr	r3, [r7, #4]
 627 031e 1343     		orrs	r3, r3, r2
 628 0320 FB60     		str	r3, [r7, #12]
 479:../src/stm32f30x_rcc.c **** 
 480:../src/stm32f30x_rcc.c ****   /* Store the new value */
 481:../src/stm32f30x_rcc.c ****   RCC->CFGR2 = tmpreg;
 629              		.loc 1 481 0
 630 0322 4FF48053 		mov	r3, #4096
 631 0326 C4F20203 		movt	r3, 16386
 632 032a FA68     		ldr	r2, [r7, #12]
 633 032c DA62     		str	r2, [r3, #44]
 482:../src/stm32f30x_rcc.c **** }
 634              		.loc 1 482 0
 635 032e 07F11407 		add	r7, r7, #20
 636 0332 BD46     		mov	sp, r7
 637 0334 80BC     		pop	{r7}
 638 0336 7047     		bx	lr
 639              		.cfi_endproc
 640              	.LFE121:
 642              		.align	2
 643              		.global	RCC_ClockSecuritySystemCmd
 644              		.thumb
 645              		.thumb_func
 647              	RCC_ClockSecuritySystemCmd:
 648              	.LFB122:
 483:../src/stm32f30x_rcc.c **** 
 484:../src/stm32f30x_rcc.c **** /**
 485:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the Clock Security System.
 486:../src/stm32f30x_rcc.c ****   * @note   If a failure is detected on the HSE oscillator clock, this oscillator
 487:../src/stm32f30x_rcc.c ****   *         is automatically disabled and an interrupt is generated to inform the
 488:../src/stm32f30x_rcc.c ****   *         software about the failure (Clock Security System Interrupt, CSSI),
 489:../src/stm32f30x_rcc.c ****   *         allowing the MCU to perform rescue operations. The CSSI is linked to 
 490:../src/stm32f30x_rcc.c ****   *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.  
 491:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the Clock Security System.
 492:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
 493:../src/stm32f30x_rcc.c ****   * @retval None
 494:../src/stm32f30x_rcc.c ****   */
 495:../src/stm32f30x_rcc.c **** void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
 496:../src/stm32f30x_rcc.c **** {
 649              		.loc 1 496 0
 650              		.cfi_startproc
 651              		@ args = 0, pretend = 0, frame = 8
 652              		@ frame_needed = 1, uses_anonymous_args = 0
 653              		@ link register save eliminated.
 654 0338 80B4     		push	{r7}
 655              	.LCFI32:
 656              		.cfi_def_cfa_offset 4
 657              		.cfi_offset 7, -4
 658 033a 83B0     		sub	sp, sp, #12
 659              	.LCFI33:
 660              		.cfi_def_cfa_offset 16
 661 033c 00AF     		add	r7, sp, #0
 662              	.LCFI34:
 663              		.cfi_def_cfa_register 7
 664 033e 0346     		mov	r3, r0
 665 0340 FB71     		strb	r3, [r7, #7]
 497:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 498:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 499:../src/stm32f30x_rcc.c ****   
 500:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 666              		.loc 1 500 0
 667 0342 4FF04C03 		mov	r3, #76
 668 0346 C4F24223 		movt	r3, 16962
 669 034a FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 670 034c 1A60     		str	r2, [r3, #0]
 501:../src/stm32f30x_rcc.c **** }
 671              		.loc 1 501 0
 672 034e 07F10C07 		add	r7, r7, #12
 673 0352 BD46     		mov	sp, r7
 674 0354 80BC     		pop	{r7}
 675 0356 7047     		bx	lr
 676              		.cfi_endproc
 677              	.LFE122:
 679              		.align	2
 680              		.global	RCC_MCOConfig
 681              		.thumb
 682              		.thumb_func
 684              	RCC_MCOConfig:
 685              	.LFB123:
 502:../src/stm32f30x_rcc.c **** 
 503:../src/stm32f30x_rcc.c **** /**
 504:../src/stm32f30x_rcc.c ****   * @brief  Selects the clock source to output on MCO pin (PA8).
 505:../src/stm32f30x_rcc.c ****   * @note   PA8 should be configured in alternate function mode.
 506:../src/stm32f30x_rcc.c ****   * @note   The MCOF flag is set once the MCO clock source switch is effective.      
 507:../src/stm32f30x_rcc.c ****   * @param  RCC_MCOSource: specifies the clock source to output.
 508:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 509:../src/stm32f30x_rcc.c ****   *     @arg RCC_MCOSource_NoClock: No clock selected.
 510:../src/stm32f30x_rcc.c ****   *     @arg RCC_MCOSource_LSI: LSI oscillator clock selected.  
 511:../src/stm32f30x_rcc.c ****   *     @arg RCC_MCOSource_LSE: LSE oscillator clock selected.  
 512:../src/stm32f30x_rcc.c ****   *     @arg RCC_MCOSource_SYSCLK: System clock selected.
 513:../src/stm32f30x_rcc.c ****   *     @arg RCC_MCOSource_HSI: HSI oscillator clock selected.  
 514:../src/stm32f30x_rcc.c ****   *     @arg RCC_MCOSource_HSE: HSE oscillator clock selected.
 515:../src/stm32f30x_rcc.c ****   *     @arg RCC_MCOSource_PLLCLK_Div2: PLL clock selected.
 516:../src/stm32f30x_rcc.c ****   * @retval None
 517:../src/stm32f30x_rcc.c ****   */
 518:../src/stm32f30x_rcc.c **** void RCC_MCOConfig(uint8_t RCC_MCOSource)
 519:../src/stm32f30x_rcc.c **** {
 686              		.loc 1 519 0
 687              		.cfi_startproc
 688              		@ args = 0, pretend = 0, frame = 8
 689              		@ frame_needed = 1, uses_anonymous_args = 0
 690              		@ link register save eliminated.
 691 0358 80B4     		push	{r7}
 692              	.LCFI35:
 693              		.cfi_def_cfa_offset 4
 694              		.cfi_offset 7, -4
 695 035a 83B0     		sub	sp, sp, #12
 696              	.LCFI36:
 697              		.cfi_def_cfa_offset 16
 698 035c 00AF     		add	r7, sp, #0
 699              	.LCFI37:
 700              		.cfi_def_cfa_register 7
 701 035e 0346     		mov	r3, r0
 702 0360 FB71     		strb	r3, [r7, #7]
 520:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 521:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
 522:../src/stm32f30x_rcc.c ****     
 523:../src/stm32f30x_rcc.c ****   /* Select MCO clock source and prescaler */
 524:../src/stm32f30x_rcc.c ****   *(__IO uint8_t *) CFGR_BYTE3_ADDRESS =  RCC_MCOSource; 
 703              		.loc 1 524 0
 704 0362 41F20703 		movw	r3, #4103
 705 0366 C4F20203 		movt	r3, 16386
 706 036a FA79     		ldrb	r2, [r7, #7]
 707 036c 1A70     		strb	r2, [r3, #0]
 525:../src/stm32f30x_rcc.c **** }
 708              		.loc 1 525 0
 709 036e 07F10C07 		add	r7, r7, #12
 710 0372 BD46     		mov	sp, r7
 711 0374 80BC     		pop	{r7}
 712 0376 7047     		bx	lr
 713              		.cfi_endproc
 714              	.LFE123:
 716              		.align	2
 717              		.global	RCC_SYSCLKConfig
 718              		.thumb
 719              		.thumb_func
 721              	RCC_SYSCLKConfig:
 722              	.LFB124:
 526:../src/stm32f30x_rcc.c **** 
 527:../src/stm32f30x_rcc.c **** /**
 528:../src/stm32f30x_rcc.c ****   * @}
 529:../src/stm32f30x_rcc.c ****   */
 530:../src/stm32f30x_rcc.c **** 
 531:../src/stm32f30x_rcc.c **** /** @defgroup RCC_Group2 System AHB, APB1 and APB2 busses clocks configuration functions
 532:../src/stm32f30x_rcc.c ****  *  @brief   System, AHB and APB busses clocks configuration functions
 533:../src/stm32f30x_rcc.c ****  *
 534:../src/stm32f30x_rcc.c **** @verbatim   
 535:../src/stm32f30x_rcc.c ****  ===============================================================================
 536:../src/stm32f30x_rcc.c ****   ##### System, AHB, APB1 and APB2 busses clocks configuration functions #####
 537:../src/stm32f30x_rcc.c ****  ===============================================================================  
 538:../src/stm32f30x_rcc.c ****     [..] This section provide functions allowing to configure the System, AHB, APB1 and 
 539:../src/stm32f30x_rcc.c ****          APB2 busses clocks.
 540:../src/stm32f30x_rcc.c ****          (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,
 541:../src/stm32f30x_rcc.c ****              HSE and PLL.
 542:../src/stm32f30x_rcc.c ****              The AHB clock (HCLK) is derived from System clock through configurable prescaler
 543:../src/stm32f30x_rcc.c ****              and used to clock the CPU, memory and peripherals mapped on AHB bus (DMA and GPIO).
 544:../src/stm32f30x_rcc.c ****              APB1 (PCLK1) and APB2 (PCLK2) clocks are derived from AHB clock through 
 545:../src/stm32f30x_rcc.c ****              configurable prescalers and used to clock the peripherals mapped on these busses.
 546:../src/stm32f30x_rcc.c ****              You can use "RCC_GetClocksFreq()" function to retrieve the frequencies of these clocks
 547:../src/stm32f30x_rcc.c **** 
 548:../src/stm32f30x_rcc.c ****          (#) The maximum frequency of the SYSCLK, HCLK, PCLK1 and PCLK2 is 72 MHz.
 549:../src/stm32f30x_rcc.c ****              Depending on the maximum frequency, the FLASH wait states (WS) should be 
 550:../src/stm32f30x_rcc.c ****              adapted accordingly:
 551:../src/stm32f30x_rcc.c ****         +---------------------------------+
 552:../src/stm32f30x_rcc.c ****         |  Wait states  |   HCLK clock    |
 553:../src/stm32f30x_rcc.c ****         |   (Latency)   | frequency (MHz) |
 554:../src/stm32f30x_rcc.c ****         |-------------- |-----------------|             
 555:../src/stm32f30x_rcc.c ****         |0WS(1CPU cycle)| 0 < HCLK <= 24  |
 556:../src/stm32f30x_rcc.c ****         |---------------|-----------------| 
 557:../src/stm32f30x_rcc.c ****         |1WS(2CPU cycle)|24 < HCLK <=48   |
 558:../src/stm32f30x_rcc.c ****         |---------------|-----------------| 
 559:../src/stm32f30x_rcc.c ****         |2WS(3CPU cycle)|48 < HCLK <= 72  |
 560:../src/stm32f30x_rcc.c ****         +---------------------------------+
 561:../src/stm32f30x_rcc.c **** 
 562:../src/stm32f30x_rcc.c ****          (#) After reset, the System clock source is the HSI (8 MHz) with 0 WS and 
 563:../src/stm32f30x_rcc.c ****              prefetch is disabled.
 564:../src/stm32f30x_rcc.c ****         [..]
 565:../src/stm32f30x_rcc.c ****          (@) All the peripheral clocks are derived from the System clock (SYSCLK) 
 566:../src/stm32f30x_rcc.c ****              except:
 567:../src/stm32f30x_rcc.c ****              (+@) The FLASH program/erase clock  which is always HSI 8MHz clock.
 568:../src/stm32f30x_rcc.c ****              (+@) The USB 48 MHz clock which is derived from the PLL VCO clock.
 569:../src/stm32f30x_rcc.c ****              (+@) The USART clock which can be derived as well from HSI 8MHz, LSI or LSE.
 570:../src/stm32f30x_rcc.c ****              (+@) The I2C clock which can be derived as well from HSI 8MHz clock.
 571:../src/stm32f30x_rcc.c ****              (+@) The ADC clock which is derived from PLL output.
 572:../src/stm32f30x_rcc.c ****              (+@) The RTC clock which is derived from the LSE, LSI or 1 MHz HSE_RTC 
 573:../src/stm32f30x_rcc.c ****                   (HSE divided by a programmable prescaler). The System clock (SYSCLK) 
 574:../src/stm32f30x_rcc.c ****                   frequency must be higher or equal to the RTC clock frequency.
 575:../src/stm32f30x_rcc.c ****              (+@) IWDG clock which is always the LSI clock.
 576:../src/stm32f30x_rcc.c ****     [..] It is recommended to use the following software sequences to tune the number
 577:../src/stm32f30x_rcc.c ****          of wait states needed to access the Flash memory with the CPU frequency (HCLK).
 578:../src/stm32f30x_rcc.c ****          (+) Increasing the CPU frequency
 579:../src/stm32f30x_rcc.c ****             (++) Program the Flash Prefetch buffer, using "FLASH_PrefetchBufferCmd(ENABLE)" 
 580:../src/stm32f30x_rcc.c ****                  function
 581:../src/stm32f30x_rcc.c ****             (++) Check that Flash Prefetch buffer activation is taken into account by 
 582:../src/stm32f30x_rcc.c ****                  reading FLASH_ACR using the FLASH_GetPrefetchBufferStatus() function
 583:../src/stm32f30x_rcc.c ****             (++) Program Flash WS to 1 or 2, using "FLASH_SetLatency()" function
 584:../src/stm32f30x_rcc.c ****             (++) Check that the new number of WS is taken into account by reading FLASH_ACR
 585:../src/stm32f30x_rcc.c ****             (++) Modify the CPU clock source, using "RCC_SYSCLKConfig()" function
 586:../src/stm32f30x_rcc.c ****             (++) If needed, modify the CPU clock prescaler by using "RCC_HCLKConfig()" function
 587:../src/stm32f30x_rcc.c ****             (++) Check that the new CPU clock source is taken into account by reading 
 588:../src/stm32f30x_rcc.c ****                  the clock source status, using "RCC_GetSYSCLKSource()" function 
 589:../src/stm32f30x_rcc.c ****          (+) Decreasing the CPU frequency
 590:../src/stm32f30x_rcc.c ****             (++) Modify the CPU clock source, using "RCC_SYSCLKConfig()" function
 591:../src/stm32f30x_rcc.c ****             (++) If needed, modify the CPU clock prescaler by using "RCC_HCLKConfig()" function
 592:../src/stm32f30x_rcc.c ****             (++) Check that the new CPU clock source is taken into account by reading 
 593:../src/stm32f30x_rcc.c ****                  the clock source status, using "RCC_GetSYSCLKSource()" function
 594:../src/stm32f30x_rcc.c ****             (++) Program the new number of WS, using "FLASH_SetLatency()" function
 595:../src/stm32f30x_rcc.c ****             (++) Check that the new number of WS is taken into account by reading FLASH_ACR
 596:../src/stm32f30x_rcc.c ****             (++) Disable the Flash Prefetch buffer using "FLASH_PrefetchBufferCmd(DISABLE)" 
 597:../src/stm32f30x_rcc.c ****                  function
 598:../src/stm32f30x_rcc.c ****             (++) Check that Flash Prefetch buffer deactivation is taken into account by reading FLA
 599:../src/stm32f30x_rcc.c ****                  using the FLASH_GetPrefetchBufferStatus() function.
 600:../src/stm32f30x_rcc.c **** 
 601:../src/stm32f30x_rcc.c **** @endverbatim
 602:../src/stm32f30x_rcc.c ****   * @{
 603:../src/stm32f30x_rcc.c ****   */
 604:../src/stm32f30x_rcc.c **** 
 605:../src/stm32f30x_rcc.c **** /**
 606:../src/stm32f30x_rcc.c ****   * @brief  Configures the system clock (SYSCLK).
 607:../src/stm32f30x_rcc.c ****   * @note     The HSI is used (enabled by hardware) as system clock source after
 608:../src/stm32f30x_rcc.c ****   *           startup from Reset, wake-up from STOP and STANDBY mode, or in case
 609:../src/stm32f30x_rcc.c ****   *           of failure of the HSE used directly or indirectly as system clock
 610:../src/stm32f30x_rcc.c ****   *           (if the Clock Security System CSS is enabled).
 611:../src/stm32f30x_rcc.c ****   * @note     A switch from one clock source to another occurs only if the target
 612:../src/stm32f30x_rcc.c ****   *           clock source is ready (clock stable after startup delay or PLL locked). 
 613:../src/stm32f30x_rcc.c ****   *           If a clock source which is not yet ready is selected, the switch will
 614:../src/stm32f30x_rcc.c ****   *           occur when the clock source will be ready. 
 615:../src/stm32f30x_rcc.c ****   *           You can use RCC_GetSYSCLKSource() function to know which clock is
 616:../src/stm32f30x_rcc.c ****   *           currently used as system clock source.  
 617:../src/stm32f30x_rcc.c ****   * @param  RCC_SYSCLKSource: specifies the clock source used as system clock source 
 618:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 619:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLKSource_HSI:    HSI selected as system clock source
 620:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
 621:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
 622:../src/stm32f30x_rcc.c ****   * @retval None
 623:../src/stm32f30x_rcc.c ****   */
 624:../src/stm32f30x_rcc.c **** void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
 625:../src/stm32f30x_rcc.c **** {
 723              		.loc 1 625 0
 724              		.cfi_startproc
 725              		@ args = 0, pretend = 0, frame = 16
 726              		@ frame_needed = 1, uses_anonymous_args = 0
 727              		@ link register save eliminated.
 728 0378 80B4     		push	{r7}
 729              	.LCFI38:
 730              		.cfi_def_cfa_offset 4
 731              		.cfi_offset 7, -4
 732 037a 85B0     		sub	sp, sp, #20
 733              	.LCFI39:
 734              		.cfi_def_cfa_offset 24
 735 037c 00AF     		add	r7, sp, #0
 736              	.LCFI40:
 737              		.cfi_def_cfa_register 7
 738 037e 7860     		str	r0, [r7, #4]
 626:../src/stm32f30x_rcc.c ****   uint32_t tmpreg = 0;
 739              		.loc 1 626 0
 740 0380 4FF00003 		mov	r3, #0
 741 0384 FB60     		str	r3, [r7, #12]
 627:../src/stm32f30x_rcc.c ****   
 628:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 629:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
 630:../src/stm32f30x_rcc.c ****   
 631:../src/stm32f30x_rcc.c ****   tmpreg = RCC->CFGR;
 742              		.loc 1 631 0
 743 0386 4FF48053 		mov	r3, #4096
 744 038a C4F20203 		movt	r3, 16386
 745 038e 5B68     		ldr	r3, [r3, #4]
 746 0390 FB60     		str	r3, [r7, #12]
 632:../src/stm32f30x_rcc.c ****   
 633:../src/stm32f30x_rcc.c ****   /* Clear SW[1:0] bits */
 634:../src/stm32f30x_rcc.c ****   tmpreg &= ~RCC_CFGR_SW;
 747              		.loc 1 634 0
 748 0392 FB68     		ldr	r3, [r7, #12]
 749 0394 23F00303 		bic	r3, r3, #3
 750 0398 FB60     		str	r3, [r7, #12]
 635:../src/stm32f30x_rcc.c ****   
 636:../src/stm32f30x_rcc.c ****   /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
 637:../src/stm32f30x_rcc.c ****   tmpreg |= RCC_SYSCLKSource;
 751              		.loc 1 637 0
 752 039a FA68     		ldr	r2, [r7, #12]
 753 039c 7B68     		ldr	r3, [r7, #4]
 754 039e 1343     		orrs	r3, r3, r2
 755 03a0 FB60     		str	r3, [r7, #12]
 638:../src/stm32f30x_rcc.c ****   
 639:../src/stm32f30x_rcc.c ****   /* Store the new value */
 640:../src/stm32f30x_rcc.c ****   RCC->CFGR = tmpreg;
 756              		.loc 1 640 0
 757 03a2 4FF48053 		mov	r3, #4096
 758 03a6 C4F20203 		movt	r3, 16386
 759 03aa FA68     		ldr	r2, [r7, #12]
 760 03ac 5A60     		str	r2, [r3, #4]
 641:../src/stm32f30x_rcc.c **** }
 761              		.loc 1 641 0
 762 03ae 07F11407 		add	r7, r7, #20
 763 03b2 BD46     		mov	sp, r7
 764 03b4 80BC     		pop	{r7}
 765 03b6 7047     		bx	lr
 766              		.cfi_endproc
 767              	.LFE124:
 769              		.align	2
 770              		.global	RCC_GetSYSCLKSource
 771              		.thumb
 772              		.thumb_func
 774              	RCC_GetSYSCLKSource:
 775              	.LFB125:
 642:../src/stm32f30x_rcc.c **** 
 643:../src/stm32f30x_rcc.c **** /**
 644:../src/stm32f30x_rcc.c ****   * @brief  Returns the clock source used as system clock.
 645:../src/stm32f30x_rcc.c ****   * @param  None
 646:../src/stm32f30x_rcc.c ****   * @retval The clock source used as system clock. The returned value can be one 
 647:../src/stm32f30x_rcc.c ****   *         of the following values:
 648:../src/stm32f30x_rcc.c ****   *              - 0x00: HSI used as system clock
 649:../src/stm32f30x_rcc.c ****   *              - 0x04: HSE used as system clock  
 650:../src/stm32f30x_rcc.c ****   *              - 0x08: PLL used as system clock
 651:../src/stm32f30x_rcc.c ****   */
 652:../src/stm32f30x_rcc.c **** uint8_t RCC_GetSYSCLKSource(void)
 653:../src/stm32f30x_rcc.c **** {
 776              		.loc 1 653 0
 777              		.cfi_startproc
 778              		@ args = 0, pretend = 0, frame = 0
 779              		@ frame_needed = 1, uses_anonymous_args = 0
 780              		@ link register save eliminated.
 781 03b8 80B4     		push	{r7}
 782              	.LCFI41:
 783              		.cfi_def_cfa_offset 4
 784              		.cfi_offset 7, -4
 785 03ba 00AF     		add	r7, sp, #0
 786              	.LCFI42:
 787              		.cfi_def_cfa_register 7
 654:../src/stm32f30x_rcc.c ****   return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 788              		.loc 1 654 0
 789 03bc 4FF48053 		mov	r3, #4096
 790 03c0 C4F20203 		movt	r3, 16386
 791 03c4 5B68     		ldr	r3, [r3, #4]
 792 03c6 DBB2     		uxtb	r3, r3
 793 03c8 03F00C03 		and	r3, r3, #12
 794 03cc DBB2     		uxtb	r3, r3
 655:../src/stm32f30x_rcc.c **** }
 795              		.loc 1 655 0
 796 03ce 1846     		mov	r0, r3
 797 03d0 BD46     		mov	sp, r7
 798 03d2 80BC     		pop	{r7}
 799 03d4 7047     		bx	lr
 800              		.cfi_endproc
 801              	.LFE125:
 803 03d6 00BF     		.align	2
 804              		.global	RCC_HCLKConfig
 805              		.thumb
 806              		.thumb_func
 808              	RCC_HCLKConfig:
 809              	.LFB126:
 656:../src/stm32f30x_rcc.c **** 
 657:../src/stm32f30x_rcc.c **** /**
 658:../src/stm32f30x_rcc.c ****   * @brief  Configures the AHB clock (HCLK).
 659:../src/stm32f30x_rcc.c ****   * @note   Depending on the device voltage range, the software has to set correctly
 660:../src/stm32f30x_rcc.c ****   *         these bits to ensure that the system frequency does not exceed the
 661:../src/stm32f30x_rcc.c ****   *         maximum allowed frequency (for more details refer to section above
 662:../src/stm32f30x_rcc.c ****   *         "CPU, AHB and APB busses clocks configuration functions").
 663:../src/stm32f30x_rcc.c ****   * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
 664:../src/stm32f30x_rcc.c ****   *                     the system clock (SYSCLK).
 665:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 666:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div1:   AHB clock = SYSCLK
 667:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div2:   AHB clock = SYSCLK/2
 668:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div4:   AHB clock = SYSCLK/4
 669:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div8:   AHB clock = SYSCLK/8
 670:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div16:  AHB clock = SYSCLK/16
 671:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div64:  AHB clock = SYSCLK/64
 672:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
 673:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
 674:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
 675:../src/stm32f30x_rcc.c ****   * @retval None
 676:../src/stm32f30x_rcc.c ****   */
 677:../src/stm32f30x_rcc.c **** void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
 678:../src/stm32f30x_rcc.c **** {
 810              		.loc 1 678 0
 811              		.cfi_startproc
 812              		@ args = 0, pretend = 0, frame = 16
 813              		@ frame_needed = 1, uses_anonymous_args = 0
 814              		@ link register save eliminated.
 815 03d8 80B4     		push	{r7}
 816              	.LCFI43:
 817              		.cfi_def_cfa_offset 4
 818              		.cfi_offset 7, -4
 819 03da 85B0     		sub	sp, sp, #20
 820              	.LCFI44:
 821              		.cfi_def_cfa_offset 24
 822 03dc 00AF     		add	r7, sp, #0
 823              	.LCFI45:
 824              		.cfi_def_cfa_register 7
 825 03de 7860     		str	r0, [r7, #4]
 679:../src/stm32f30x_rcc.c ****   uint32_t tmpreg = 0;
 826              		.loc 1 679 0
 827 03e0 4FF00003 		mov	r3, #0
 828 03e4 FB60     		str	r3, [r7, #12]
 680:../src/stm32f30x_rcc.c ****   
 681:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 682:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_HCLK(RCC_SYSCLK));
 683:../src/stm32f30x_rcc.c ****   
 684:../src/stm32f30x_rcc.c ****   tmpreg = RCC->CFGR;
 829              		.loc 1 684 0
 830 03e6 4FF48053 		mov	r3, #4096
 831 03ea C4F20203 		movt	r3, 16386
 832 03ee 5B68     		ldr	r3, [r3, #4]
 833 03f0 FB60     		str	r3, [r7, #12]
 685:../src/stm32f30x_rcc.c ****   
 686:../src/stm32f30x_rcc.c ****   /* Clear HPRE[3:0] bits */
 687:../src/stm32f30x_rcc.c ****   tmpreg &= ~RCC_CFGR_HPRE;
 834              		.loc 1 687 0
 835 03f2 FB68     		ldr	r3, [r7, #12]
 836 03f4 23F0F003 		bic	r3, r3, #240
 837 03f8 FB60     		str	r3, [r7, #12]
 688:../src/stm32f30x_rcc.c ****   
 689:../src/stm32f30x_rcc.c ****   /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
 690:../src/stm32f30x_rcc.c ****   tmpreg |= RCC_SYSCLK;
 838              		.loc 1 690 0
 839 03fa FA68     		ldr	r2, [r7, #12]
 840 03fc 7B68     		ldr	r3, [r7, #4]
 841 03fe 1343     		orrs	r3, r3, r2
 842 0400 FB60     		str	r3, [r7, #12]
 691:../src/stm32f30x_rcc.c ****   
 692:../src/stm32f30x_rcc.c ****   /* Store the new value */
 693:../src/stm32f30x_rcc.c ****   RCC->CFGR = tmpreg;
 843              		.loc 1 693 0
 844 0402 4FF48053 		mov	r3, #4096
 845 0406 C4F20203 		movt	r3, 16386
 846 040a FA68     		ldr	r2, [r7, #12]
 847 040c 5A60     		str	r2, [r3, #4]
 694:../src/stm32f30x_rcc.c **** }
 848              		.loc 1 694 0
 849 040e 07F11407 		add	r7, r7, #20
 850 0412 BD46     		mov	sp, r7
 851 0414 80BC     		pop	{r7}
 852 0416 7047     		bx	lr
 853              		.cfi_endproc
 854              	.LFE126:
 856              		.align	2
 857              		.global	RCC_PCLK1Config
 858              		.thumb
 859              		.thumb_func
 861              	RCC_PCLK1Config:
 862              	.LFB127:
 695:../src/stm32f30x_rcc.c **** 
 696:../src/stm32f30x_rcc.c **** /**
 697:../src/stm32f30x_rcc.c ****   * @brief  Configures the Low Speed APB clock (PCLK1).
 698:../src/stm32f30x_rcc.c ****   * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
 699:../src/stm32f30x_rcc.c ****   *         the AHB clock (HCLK).
 700:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 701:../src/stm32f30x_rcc.c ****   *     @arg RCC_HCLK_Div1: APB1 clock = HCLK
 702:../src/stm32f30x_rcc.c ****   *     @arg RCC_HCLK_Div2: APB1 clock = HCLK/2
 703:../src/stm32f30x_rcc.c ****   *     @arg RCC_HCLK_Div4: APB1 clock = HCLK/4
 704:../src/stm32f30x_rcc.c ****   *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
 705:../src/stm32f30x_rcc.c ****   *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
 706:../src/stm32f30x_rcc.c ****   * @retval None
 707:../src/stm32f30x_rcc.c ****   */
 708:../src/stm32f30x_rcc.c **** void RCC_PCLK1Config(uint32_t RCC_HCLK)
 709:../src/stm32f30x_rcc.c **** {
 863              		.loc 1 709 0
 864              		.cfi_startproc
 865              		@ args = 0, pretend = 0, frame = 16
 866              		@ frame_needed = 1, uses_anonymous_args = 0
 867              		@ link register save eliminated.
 868 0418 80B4     		push	{r7}
 869              	.LCFI46:
 870              		.cfi_def_cfa_offset 4
 871              		.cfi_offset 7, -4
 872 041a 85B0     		sub	sp, sp, #20
 873              	.LCFI47:
 874              		.cfi_def_cfa_offset 24
 875 041c 00AF     		add	r7, sp, #0
 876              	.LCFI48:
 877              		.cfi_def_cfa_register 7
 878 041e 7860     		str	r0, [r7, #4]
 710:../src/stm32f30x_rcc.c ****   uint32_t tmpreg = 0;
 879              		.loc 1 710 0
 880 0420 4FF00003 		mov	r3, #0
 881 0424 FB60     		str	r3, [r7, #12]
 711:../src/stm32f30x_rcc.c ****   
 712:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 713:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_PCLK(RCC_HCLK));
 714:../src/stm32f30x_rcc.c ****   
 715:../src/stm32f30x_rcc.c ****   tmpreg = RCC->CFGR;
 882              		.loc 1 715 0
 883 0426 4FF48053 		mov	r3, #4096
 884 042a C4F20203 		movt	r3, 16386
 885 042e 5B68     		ldr	r3, [r3, #4]
 886 0430 FB60     		str	r3, [r7, #12]
 716:../src/stm32f30x_rcc.c ****   /* Clear PPRE1[2:0] bits */
 717:../src/stm32f30x_rcc.c ****   tmpreg &= ~RCC_CFGR_PPRE1;
 887              		.loc 1 717 0
 888 0432 FB68     		ldr	r3, [r7, #12]
 889 0434 23F4E063 		bic	r3, r3, #1792
 890 0438 FB60     		str	r3, [r7, #12]
 718:../src/stm32f30x_rcc.c ****   
 719:../src/stm32f30x_rcc.c ****   /* Set PPRE1[2:0] bits according to RCC_HCLK value */
 720:../src/stm32f30x_rcc.c ****   tmpreg |= RCC_HCLK;
 891              		.loc 1 720 0
 892 043a FA68     		ldr	r2, [r7, #12]
 893 043c 7B68     		ldr	r3, [r7, #4]
 894 043e 1343     		orrs	r3, r3, r2
 895 0440 FB60     		str	r3, [r7, #12]
 721:../src/stm32f30x_rcc.c ****   
 722:../src/stm32f30x_rcc.c ****   /* Store the new value */
 723:../src/stm32f30x_rcc.c ****   RCC->CFGR = tmpreg;
 896              		.loc 1 723 0
 897 0442 4FF48053 		mov	r3, #4096
 898 0446 C4F20203 		movt	r3, 16386
 899 044a FA68     		ldr	r2, [r7, #12]
 900 044c 5A60     		str	r2, [r3, #4]
 724:../src/stm32f30x_rcc.c **** }
 901              		.loc 1 724 0
 902 044e 07F11407 		add	r7, r7, #20
 903 0452 BD46     		mov	sp, r7
 904 0454 80BC     		pop	{r7}
 905 0456 7047     		bx	lr
 906              		.cfi_endproc
 907              	.LFE127:
 909              		.align	2
 910              		.global	RCC_PCLK2Config
 911              		.thumb
 912              		.thumb_func
 914              	RCC_PCLK2Config:
 915              	.LFB128:
 725:../src/stm32f30x_rcc.c **** 
 726:../src/stm32f30x_rcc.c **** /**
 727:../src/stm32f30x_rcc.c ****   * @brief  Configures the High Speed APB clock (PCLK2).
 728:../src/stm32f30x_rcc.c ****   * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
 729:../src/stm32f30x_rcc.c ****   *         the AHB clock (HCLK).
 730:../src/stm32f30x_rcc.c ****   *         This parameter can be one of the following values:
 731:../src/stm32f30x_rcc.c ****   *             @arg RCC_HCLK_Div1: APB2 clock = HCLK
 732:../src/stm32f30x_rcc.c ****   *             @arg RCC_HCLK_Div2: APB2 clock = HCLK/2
 733:../src/stm32f30x_rcc.c ****   *             @arg RCC_HCLK_Div4: APB2 clock = HCLK/4
 734:../src/stm32f30x_rcc.c ****   *             @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
 735:../src/stm32f30x_rcc.c ****   *             @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
 736:../src/stm32f30x_rcc.c ****   * @retval None
 737:../src/stm32f30x_rcc.c ****   */
 738:../src/stm32f30x_rcc.c **** void RCC_PCLK2Config(uint32_t RCC_HCLK)
 739:../src/stm32f30x_rcc.c **** {
 916              		.loc 1 739 0
 917              		.cfi_startproc
 918              		@ args = 0, pretend = 0, frame = 16
 919              		@ frame_needed = 1, uses_anonymous_args = 0
 920              		@ link register save eliminated.
 921 0458 80B4     		push	{r7}
 922              	.LCFI49:
 923              		.cfi_def_cfa_offset 4
 924              		.cfi_offset 7, -4
 925 045a 85B0     		sub	sp, sp, #20
 926              	.LCFI50:
 927              		.cfi_def_cfa_offset 24
 928 045c 00AF     		add	r7, sp, #0
 929              	.LCFI51:
 930              		.cfi_def_cfa_register 7
 931 045e 7860     		str	r0, [r7, #4]
 740:../src/stm32f30x_rcc.c ****   uint32_t tmpreg = 0;
 932              		.loc 1 740 0
 933 0460 4FF00003 		mov	r3, #0
 934 0464 FB60     		str	r3, [r7, #12]
 741:../src/stm32f30x_rcc.c ****   
 742:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 743:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_PCLK(RCC_HCLK));
 744:../src/stm32f30x_rcc.c ****   
 745:../src/stm32f30x_rcc.c ****   tmpreg = RCC->CFGR;
 935              		.loc 1 745 0
 936 0466 4FF48053 		mov	r3, #4096
 937 046a C4F20203 		movt	r3, 16386
 938 046e 5B68     		ldr	r3, [r3, #4]
 939 0470 FB60     		str	r3, [r7, #12]
 746:../src/stm32f30x_rcc.c ****   /* Clear PPRE2[2:0] bits */
 747:../src/stm32f30x_rcc.c ****   tmpreg &= ~RCC_CFGR_PPRE2;
 940              		.loc 1 747 0
 941 0472 FB68     		ldr	r3, [r7, #12]
 942 0474 23F46053 		bic	r3, r3, #14336
 943 0478 FB60     		str	r3, [r7, #12]
 748:../src/stm32f30x_rcc.c ****   /* Set PPRE2[2:0] bits according to RCC_HCLK value */
 749:../src/stm32f30x_rcc.c ****   tmpreg |= RCC_HCLK << 3;
 944              		.loc 1 749 0
 945 047a 7B68     		ldr	r3, [r7, #4]
 946 047c 4FEAC303 		lsl	r3, r3, #3
 947 0480 FA68     		ldr	r2, [r7, #12]
 948 0482 1343     		orrs	r3, r3, r2
 949 0484 FB60     		str	r3, [r7, #12]
 750:../src/stm32f30x_rcc.c ****   /* Store the new value */
 751:../src/stm32f30x_rcc.c ****   RCC->CFGR = tmpreg;
 950              		.loc 1 751 0
 951 0486 4FF48053 		mov	r3, #4096
 952 048a C4F20203 		movt	r3, 16386
 953 048e FA68     		ldr	r2, [r7, #12]
 954 0490 5A60     		str	r2, [r3, #4]
 752:../src/stm32f30x_rcc.c **** }
 955              		.loc 1 752 0
 956 0492 07F11407 		add	r7, r7, #20
 957 0496 BD46     		mov	sp, r7
 958 0498 80BC     		pop	{r7}
 959 049a 7047     		bx	lr
 960              		.cfi_endproc
 961              	.LFE128:
 963              		.align	2
 964              		.global	RCC_GetClocksFreq
 965              		.thumb
 966              		.thumb_func
 968              	RCC_GetClocksFreq:
 969              	.LFB129:
 753:../src/stm32f30x_rcc.c **** 
 754:../src/stm32f30x_rcc.c **** /**
 755:../src/stm32f30x_rcc.c ****   * @brief  Returns the frequencies of the System, AHB, APB2 and APB1 busses clocks.
 756:../src/stm32f30x_rcc.c ****   * 
 757:../src/stm32f30x_rcc.c ****   *  @note    This function returns the frequencies of :
 758:../src/stm32f30x_rcc.c ****   *           System, AHB, APB2 and APB1 busses clocks, ADC1/2/3/4 clocks, 
 759:../src/stm32f30x_rcc.c ****   *           USART1/2/3/4/5 clocks, I2C1/2 clocks and TIM1/8 Clocks.
 760:../src/stm32f30x_rcc.c ****   *                         
 761:../src/stm32f30x_rcc.c ****   * @note     The frequency returned by this function is not the real frequency
 762:../src/stm32f30x_rcc.c ****   *           in the chip. It is calculated based on the predefined constant and
 763:../src/stm32f30x_rcc.c ****   *           the source selected by RCC_SYSCLKConfig().
 764:../src/stm32f30x_rcc.c ****   *                                              
 765:../src/stm32f30x_rcc.c ****   * @note      If SYSCLK source is HSI, function returns constant HSI_VALUE(*)
 766:../src/stm32f30x_rcc.c ****   *                                              
 767:../src/stm32f30x_rcc.c ****   * @note      If SYSCLK source is HSE, function returns constant HSE_VALUE(**)
 768:../src/stm32f30x_rcc.c ****   *                          
 769:../src/stm32f30x_rcc.c ****   * @note      If SYSCLK source is PLL, function returns constant HSE_VALUE(**) 
 770:../src/stm32f30x_rcc.c ****   *             or HSI_VALUE(*) multiplied by the PLL factors.
 771:../src/stm32f30x_rcc.c ****   *         
 772:../src/stm32f30x_rcc.c ****   * @note     (*) HSI_VALUE is a constant defined in stm32f30x.h file (default value
 773:../src/stm32f30x_rcc.c ****   *               8 MHz) but the real value may vary depending on the variations
 774:../src/stm32f30x_rcc.c ****   *               in voltage and temperature, refer to RCC_AdjustHSICalibrationValue().   
 775:../src/stm32f30x_rcc.c ****   *    
 776:../src/stm32f30x_rcc.c ****   * @note     (**) HSE_VALUE is a constant defined in stm32f30x.h file (default value
 777:../src/stm32f30x_rcc.c ****   *                8 MHz), user has to ensure that HSE_VALUE is same as the real
 778:../src/stm32f30x_rcc.c ****   *                frequency of the crystal used. Otherwise, this function may
 779:../src/stm32f30x_rcc.c ****   *                return wrong result.
 780:../src/stm32f30x_rcc.c ****   *                
 781:../src/stm32f30x_rcc.c ****   * @note     The result of this function could be not correct when using fractional
 782:../src/stm32f30x_rcc.c ****   *           value for HSE crystal.   
 783:../src/stm32f30x_rcc.c ****   *             
 784:../src/stm32f30x_rcc.c ****   * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold 
 785:../src/stm32f30x_rcc.c ****   *         the clocks frequencies. 
 786:../src/stm32f30x_rcc.c ****   *     
 787:../src/stm32f30x_rcc.c ****   * @note     This function can be used by the user application to compute the 
 788:../src/stm32f30x_rcc.c ****   *           baudrate for the communication peripherals or configure other parameters.
 789:../src/stm32f30x_rcc.c ****   * @note     Each time SYSCLK, HCLK, PCLK1 and/or PCLK2 clock changes, this function
 790:../src/stm32f30x_rcc.c ****   *           must be called to update the structure's field. Otherwise, any
 791:../src/stm32f30x_rcc.c ****   *           configuration based on this function will be incorrect.
 792:../src/stm32f30x_rcc.c ****   *    
 793:../src/stm32f30x_rcc.c ****   * @retval None
 794:../src/stm32f30x_rcc.c ****   */
 795:../src/stm32f30x_rcc.c **** void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
 796:../src/stm32f30x_rcc.c **** {
 970              		.loc 1 796 0
 971              		.cfi_startproc
 972              		@ args = 0, pretend = 0, frame = 40
 973              		@ frame_needed = 1, uses_anonymous_args = 0
 974              		@ link register save eliminated.
 975 049c 80B4     		push	{r7}
 976              	.LCFI52:
 977              		.cfi_def_cfa_offset 4
 978              		.cfi_offset 7, -4
 979 049e 8BB0     		sub	sp, sp, #44
 980              	.LCFI53:
 981              		.cfi_def_cfa_offset 48
 982 04a0 00AF     		add	r7, sp, #0
 983              	.LCFI54:
 984              		.cfi_def_cfa_register 7
 985 04a2 7860     		str	r0, [r7, #4]
 797:../src/stm32f30x_rcc.c ****   uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
 986              		.loc 1 797 0
 987 04a4 4FF00003 		mov	r3, #0
 988 04a8 3B62     		str	r3, [r7, #32]
 989 04aa 4FF00003 		mov	r3, #0
 990 04ae FB61     		str	r3, [r7, #28]
 991 04b0 4FF00003 		mov	r3, #0
 992 04b4 BB61     		str	r3, [r7, #24]
 993 04b6 4FF00003 		mov	r3, #0
 994 04ba 7B61     		str	r3, [r7, #20]
 995 04bc 4FF00003 		mov	r3, #0
 996 04c0 3B61     		str	r3, [r7, #16]
 997 04c2 4FF00003 		mov	r3, #0
 998 04c6 7B62     		str	r3, [r7, #36]
 798:../src/stm32f30x_rcc.c ****   uint32_t apb2presc = 0, ahbpresc = 0;
 999              		.loc 1 798 0
 1000 04c8 4FF00003 		mov	r3, #0
 1001 04cc FB60     		str	r3, [r7, #12]
 1002 04ce 4FF00003 		mov	r3, #0
 1003 04d2 BB60     		str	r3, [r7, #8]
 799:../src/stm32f30x_rcc.c ****   
 800:../src/stm32f30x_rcc.c ****   /* Get SYSCLK source -------------------------------------------------------*/
 801:../src/stm32f30x_rcc.c ****   tmp = RCC->CFGR & RCC_CFGR_SWS;
 1004              		.loc 1 801 0
 1005 04d4 4FF48053 		mov	r3, #4096
 1006 04d8 C4F20203 		movt	r3, 16386
 1007 04dc 5B68     		ldr	r3, [r3, #4]
 1008 04de 03F00C03 		and	r3, r3, #12
 1009 04e2 3B62     		str	r3, [r7, #32]
 802:../src/stm32f30x_rcc.c ****   
 803:../src/stm32f30x_rcc.c ****   switch (tmp)
 1010              		.loc 1 803 0
 1011 04e4 3B6A     		ldr	r3, [r7, #32]
 1012 04e6 042B     		cmp	r3, #4
 1013 04e8 0AD0     		beq	.L28
 1014 04ea 082B     		cmp	r3, #8
 1015 04ec 0FD0     		beq	.L29
 1016 04ee 002B     		cmp	r3, #0
 1017 04f0 48D1     		bne	.L65
 1018              	.L27:
 804:../src/stm32f30x_rcc.c ****   {
 805:../src/stm32f30x_rcc.c ****     case 0x00:  /* HSI used as system clock */
 806:../src/stm32f30x_rcc.c ****       RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 1019              		.loc 1 806 0
 1020 04f2 7A68     		ldr	r2, [r7, #4]
 1021 04f4 4FF49053 		mov	r3, #4608
 1022 04f8 C0F27A03 		movt	r3, 122
 1023 04fc 1360     		str	r3, [r2, #0]
 807:../src/stm32f30x_rcc.c ****       break;
 1024              		.loc 1 807 0
 1025 04fe 48E0     		b	.L30
 1026              	.L28:
 808:../src/stm32f30x_rcc.c ****     case 0x04:  /* HSE used as system clock */
 809:../src/stm32f30x_rcc.c ****       RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 1027              		.loc 1 809 0
 1028 0500 7A68     		ldr	r2, [r7, #4]
 1029 0502 4FF49053 		mov	r3, #4608
 1030 0506 C0F27A03 		movt	r3, 122
 1031 050a 1360     		str	r3, [r2, #0]
 810:../src/stm32f30x_rcc.c ****       break;
 1032              		.loc 1 810 0
 1033 050c 41E0     		b	.L30
 1034              	.L29:
 811:../src/stm32f30x_rcc.c ****     case 0x08:  /* PLL used as system clock */
 812:../src/stm32f30x_rcc.c ****       /* Get PLL clock source and multiplication factor ----------------------*/
 813:../src/stm32f30x_rcc.c ****       pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 1035              		.loc 1 813 0
 1036 050e 4FF48053 		mov	r3, #4096
 1037 0512 C4F20203 		movt	r3, 16386
 1038 0516 5B68     		ldr	r3, [r3, #4]
 1039 0518 03F47013 		and	r3, r3, #3932160
 1040 051c FB61     		str	r3, [r7, #28]
 814:../src/stm32f30x_rcc.c ****       pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 1041              		.loc 1 814 0
 1042 051e 4FF48053 		mov	r3, #4096
 1043 0522 C4F20203 		movt	r3, 16386
 1044 0526 5B68     		ldr	r3, [r3, #4]
 1045 0528 03F48033 		and	r3, r3, #65536
 1046 052c BB61     		str	r3, [r7, #24]
 815:../src/stm32f30x_rcc.c ****       pllmull = ( pllmull >> 18) + 2;
 1047              		.loc 1 815 0
 1048 052e FB69     		ldr	r3, [r7, #28]
 1049 0530 4FEA9343 		lsr	r3, r3, #18
 1050 0534 03F10203 		add	r3, r3, #2
 1051 0538 FB61     		str	r3, [r7, #28]
 816:../src/stm32f30x_rcc.c ****       
 817:../src/stm32f30x_rcc.c ****       if (pllsource == 0x00)
 1052              		.loc 1 817 0
 1053 053a BB69     		ldr	r3, [r7, #24]
 1054 053c 002B     		cmp	r3, #0
 1055 053e 08D1     		bne	.L31
 818:../src/stm32f30x_rcc.c ****       {
 819:../src/stm32f30x_rcc.c ****         /* HSI oscillator clock divided by 2 selected as PLL clock entry */
 820:../src/stm32f30x_rcc.c ****         pllclk = (HSI_VALUE >> 1) * pllmull;
 1056              		.loc 1 820 0
 1057 0540 FA69     		ldr	r2, [r7, #28]
 1058 0542 4FF41063 		mov	r3, #2304
 1059 0546 C0F23D03 		movt	r3, 61
 1060 054a 03FB02F3 		mul	r3, r3, r2
 1061 054e 7B62     		str	r3, [r7, #36]
 1062 0550 14E0     		b	.L32
 1063              	.L31:
 821:../src/stm32f30x_rcc.c ****       }
 822:../src/stm32f30x_rcc.c ****       else
 823:../src/stm32f30x_rcc.c ****       {
 824:../src/stm32f30x_rcc.c ****         prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 1064              		.loc 1 824 0
 1065 0552 4FF48053 		mov	r3, #4096
 1066 0556 C4F20203 		movt	r3, 16386
 1067 055a DB6A     		ldr	r3, [r3, #44]
 1068 055c 03F00F03 		and	r3, r3, #15
 1069 0560 03F10103 		add	r3, r3, #1
 1070 0564 7B61     		str	r3, [r7, #20]
 825:../src/stm32f30x_rcc.c ****         /* HSE oscillator clock selected as PREDIV1 clock entry */
 826:../src/stm32f30x_rcc.c ****         pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
 1071              		.loc 1 826 0
 1072 0566 4FF49053 		mov	r3, #4608
 1073 056a C0F27A03 		movt	r3, 122
 1074 056e 7A69     		ldr	r2, [r7, #20]
 1075 0570 B3FBF2F3 		udiv	r3, r3, r2
 1076 0574 FA69     		ldr	r2, [r7, #28]
 1077 0576 02FB03F3 		mul	r3, r2, r3
 1078 057a 7B62     		str	r3, [r7, #36]
 1079              	.L32:
 827:../src/stm32f30x_rcc.c ****       }
 828:../src/stm32f30x_rcc.c ****       RCC_Clocks->SYSCLK_Frequency = pllclk;      
 1080              		.loc 1 828 0
 1081 057c 7B68     		ldr	r3, [r7, #4]
 1082 057e 7A6A     		ldr	r2, [r7, #36]
 1083 0580 1A60     		str	r2, [r3, #0]
 829:../src/stm32f30x_rcc.c ****       break;
 1084              		.loc 1 829 0
 1085 0582 06E0     		b	.L30
 1086              	.L65:
 830:../src/stm32f30x_rcc.c ****     default: /* HSI used as system clock */
 831:../src/stm32f30x_rcc.c ****       RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 1087              		.loc 1 831 0
 1088 0584 7A68     		ldr	r2, [r7, #4]
 1089 0586 4FF49053 		mov	r3, #4608
 1090 058a C0F27A03 		movt	r3, 122
 1091 058e 1360     		str	r3, [r2, #0]
 832:../src/stm32f30x_rcc.c ****       break;
 1092              		.loc 1 832 0
 1093 0590 00BF     		nop
 1094              	.L30:
 833:../src/stm32f30x_rcc.c ****   }
 834:../src/stm32f30x_rcc.c ****     /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
 835:../src/stm32f30x_rcc.c ****   /* Get HCLK prescaler */
 836:../src/stm32f30x_rcc.c ****   tmp = RCC->CFGR & RCC_CFGR_HPRE;
 1095              		.loc 1 836 0
 1096 0592 4FF48053 		mov	r3, #4096
 1097 0596 C4F20203 		movt	r3, 16386
 1098 059a 5B68     		ldr	r3, [r3, #4]
 1099 059c 03F0F003 		and	r3, r3, #240
 1100 05a0 3B62     		str	r3, [r7, #32]
 837:../src/stm32f30x_rcc.c ****   tmp = tmp >> 4;
 1101              		.loc 1 837 0
 1102 05a2 3B6A     		ldr	r3, [r7, #32]
 1103 05a4 4FEA1313 		lsr	r3, r3, #4
 1104 05a8 3B62     		str	r3, [r7, #32]
 838:../src/stm32f30x_rcc.c ****   ahbpresc = APBAHBPrescTable[tmp]; 
 1105              		.loc 1 838 0
 1106 05aa 40F20003 		movw	r3, #:lower16:APBAHBPrescTable
 1107 05ae C0F20003 		movt	r3, #:upper16:APBAHBPrescTable
 1108 05b2 3A6A     		ldr	r2, [r7, #32]
 1109 05b4 9B18     		adds	r3, r3, r2
 1110 05b6 1B78     		ldrb	r3, [r3, #0]
 1111 05b8 DBB2     		uxtb	r3, r3
 1112 05ba BB60     		str	r3, [r7, #8]
 839:../src/stm32f30x_rcc.c ****   /* HCLK clock frequency */
 840:../src/stm32f30x_rcc.c ****   RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> ahbpresc;
 1113              		.loc 1 840 0
 1114 05bc 7B68     		ldr	r3, [r7, #4]
 1115 05be 1A68     		ldr	r2, [r3, #0]
 1116 05c0 BB68     		ldr	r3, [r7, #8]
 1117 05c2 22FA03F2 		lsr	r2, r2, r3
 1118 05c6 7B68     		ldr	r3, [r7, #4]
 1119 05c8 5A60     		str	r2, [r3, #4]
 841:../src/stm32f30x_rcc.c **** 
 842:../src/stm32f30x_rcc.c ****   /* Get PCLK1 prescaler */
 843:../src/stm32f30x_rcc.c ****   tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 1120              		.loc 1 843 0
 1121 05ca 4FF48053 		mov	r3, #4096
 1122 05ce C4F20203 		movt	r3, 16386
 1123 05d2 5B68     		ldr	r3, [r3, #4]
 1124 05d4 03F4E063 		and	r3, r3, #1792
 1125 05d8 3B62     		str	r3, [r7, #32]
 844:../src/stm32f30x_rcc.c ****   tmp = tmp >> 8;
 1126              		.loc 1 844 0
 1127 05da 3B6A     		ldr	r3, [r7, #32]
 1128 05dc 4FEA1323 		lsr	r3, r3, #8
 1129 05e0 3B62     		str	r3, [r7, #32]
 845:../src/stm32f30x_rcc.c ****   presc = APBAHBPrescTable[tmp];
 1130              		.loc 1 845 0
 1131 05e2 40F20003 		movw	r3, #:lower16:APBAHBPrescTable
 1132 05e6 C0F20003 		movt	r3, #:upper16:APBAHBPrescTable
 1133 05ea 3A6A     		ldr	r2, [r7, #32]
 1134 05ec 9B18     		adds	r3, r3, r2
 1135 05ee 1B78     		ldrb	r3, [r3, #0]
 1136 05f0 DBB2     		uxtb	r3, r3
 1137 05f2 3B61     		str	r3, [r7, #16]
 846:../src/stm32f30x_rcc.c ****   /* PCLK1 clock frequency */
 847:../src/stm32f30x_rcc.c ****   RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 1138              		.loc 1 847 0
 1139 05f4 7B68     		ldr	r3, [r7, #4]
 1140 05f6 5A68     		ldr	r2, [r3, #4]
 1141 05f8 3B69     		ldr	r3, [r7, #16]
 1142 05fa 22FA03F2 		lsr	r2, r2, r3
 1143 05fe 7B68     		ldr	r3, [r7, #4]
 1144 0600 9A60     		str	r2, [r3, #8]
 848:../src/stm32f30x_rcc.c ****   
 849:../src/stm32f30x_rcc.c ****   /* Get PCLK2 prescaler */
 850:../src/stm32f30x_rcc.c ****   tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 1145              		.loc 1 850 0
 1146 0602 4FF48053 		mov	r3, #4096
 1147 0606 C4F20203 		movt	r3, 16386
 1148 060a 5B68     		ldr	r3, [r3, #4]
 1149 060c 03F46053 		and	r3, r3, #14336
 1150 0610 3B62     		str	r3, [r7, #32]
 851:../src/stm32f30x_rcc.c ****   tmp = tmp >> 11;
 1151              		.loc 1 851 0
 1152 0612 3B6A     		ldr	r3, [r7, #32]
 1153 0614 4FEAD323 		lsr	r3, r3, #11
 1154 0618 3B62     		str	r3, [r7, #32]
 852:../src/stm32f30x_rcc.c ****   apb2presc = APBAHBPrescTable[tmp];
 1155              		.loc 1 852 0
 1156 061a 40F20003 		movw	r3, #:lower16:APBAHBPrescTable
 1157 061e C0F20003 		movt	r3, #:upper16:APBAHBPrescTable
 1158 0622 3A6A     		ldr	r2, [r7, #32]
 1159 0624 9B18     		adds	r3, r3, r2
 1160 0626 1B78     		ldrb	r3, [r3, #0]
 1161 0628 DBB2     		uxtb	r3, r3
 1162 062a FB60     		str	r3, [r7, #12]
 853:../src/stm32f30x_rcc.c ****   /* PCLK2 clock frequency */
 854:../src/stm32f30x_rcc.c ****   RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> apb2presc;
 1163              		.loc 1 854 0
 1164 062c 7B68     		ldr	r3, [r7, #4]
 1165 062e 5A68     		ldr	r2, [r3, #4]
 1166 0630 FB68     		ldr	r3, [r7, #12]
 1167 0632 22FA03F2 		lsr	r2, r2, r3
 1168 0636 7B68     		ldr	r3, [r7, #4]
 1169 0638 DA60     		str	r2, [r3, #12]
 855:../src/stm32f30x_rcc.c ****   
 856:../src/stm32f30x_rcc.c ****   /* Get ADC12CLK prescaler */
 857:../src/stm32f30x_rcc.c ****   tmp = RCC->CFGR2 & RCC_CFGR2_ADCPRE12;
 1170              		.loc 1 857 0
 1171 063a 4FF48053 		mov	r3, #4096
 1172 063e C4F20203 		movt	r3, 16386
 1173 0642 DB6A     		ldr	r3, [r3, #44]
 1174 0644 03F4F873 		and	r3, r3, #496
 1175 0648 3B62     		str	r3, [r7, #32]
 858:../src/stm32f30x_rcc.c ****   tmp = tmp >> 4;
 1176              		.loc 1 858 0
 1177 064a 3B6A     		ldr	r3, [r7, #32]
 1178 064c 4FEA1313 		lsr	r3, r3, #4
 1179 0650 3B62     		str	r3, [r7, #32]
 859:../src/stm32f30x_rcc.c ****   presc = ADCPrescTable[tmp];
 1180              		.loc 1 859 0
 1181 0652 40F20003 		movw	r3, #:lower16:ADCPrescTable
 1182 0656 C0F20003 		movt	r3, #:upper16:ADCPrescTable
 1183 065a 3A6A     		ldr	r2, [r7, #32]
 1184 065c 33F81230 		ldrh	r3, [r3, r2, lsl #1]	@ movhi
 1185 0660 9BB2     		uxth	r3, r3
 1186 0662 3B61     		str	r3, [r7, #16]
 860:../src/stm32f30x_rcc.c ****   if ((presc & 0x10) != 0)
 1187              		.loc 1 860 0
 1188 0664 3B69     		ldr	r3, [r7, #16]
 1189 0666 03F01003 		and	r3, r3, #16
 1190 066a 002B     		cmp	r3, #0
 1191 066c 06D0     		beq	.L33
 861:../src/stm32f30x_rcc.c ****   {
 862:../src/stm32f30x_rcc.c ****      /* ADC12CLK clock frequency is derived from PLL clock */
 863:../src/stm32f30x_rcc.c ****      RCC_Clocks->ADC12CLK_Frequency = pllclk / presc;
 1192              		.loc 1 863 0
 1193 066e 7A6A     		ldr	r2, [r7, #36]
 1194 0670 3B69     		ldr	r3, [r7, #16]
 1195 0672 B2FBF3F2 		udiv	r2, r2, r3
 1196 0676 7B68     		ldr	r3, [r7, #4]
 1197 0678 1A61     		str	r2, [r3, #16]
 1198 067a 03E0     		b	.L34
 1199              	.L33:
 864:../src/stm32f30x_rcc.c ****   }
 865:../src/stm32f30x_rcc.c ****   else
 866:../src/stm32f30x_rcc.c ****   {
 867:../src/stm32f30x_rcc.c ****    /* ADC12CLK clock frequency is AHB clock */
 868:../src/stm32f30x_rcc.c ****      RCC_Clocks->ADC12CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1200              		.loc 1 868 0
 1201 067c 7B68     		ldr	r3, [r7, #4]
 1202 067e 1A68     		ldr	r2, [r3, #0]
 1203 0680 7B68     		ldr	r3, [r7, #4]
 1204 0682 1A61     		str	r2, [r3, #16]
 1205              	.L34:
 869:../src/stm32f30x_rcc.c ****   }
 870:../src/stm32f30x_rcc.c ****   
 871:../src/stm32f30x_rcc.c ****   /* Get ADC34CLK prescaler */
 872:../src/stm32f30x_rcc.c ****   tmp = RCC->CFGR2 & RCC_CFGR2_ADCPRE34;
 1206              		.loc 1 872 0
 1207 0684 4FF48053 		mov	r3, #4096
 1208 0688 C4F20203 		movt	r3, 16386
 1209 068c DB6A     		ldr	r3, [r3, #44]
 1210 068e 03F47853 		and	r3, r3, #15872
 1211 0692 3B62     		str	r3, [r7, #32]
 873:../src/stm32f30x_rcc.c ****   tmp = tmp >> 9;
 1212              		.loc 1 873 0
 1213 0694 3B6A     		ldr	r3, [r7, #32]
 1214 0696 4FEA5323 		lsr	r3, r3, #9
 1215 069a 3B62     		str	r3, [r7, #32]
 874:../src/stm32f30x_rcc.c ****   presc = ADCPrescTable[tmp];
 1216              		.loc 1 874 0
 1217 069c 40F20003 		movw	r3, #:lower16:ADCPrescTable
 1218 06a0 C0F20003 		movt	r3, #:upper16:ADCPrescTable
 1219 06a4 3A6A     		ldr	r2, [r7, #32]
 1220 06a6 33F81230 		ldrh	r3, [r3, r2, lsl #1]	@ movhi
 1221 06aa 9BB2     		uxth	r3, r3
 1222 06ac 3B61     		str	r3, [r7, #16]
 875:../src/stm32f30x_rcc.c ****   if ((presc & 0x10) != 0)
 1223              		.loc 1 875 0
 1224 06ae 3B69     		ldr	r3, [r7, #16]
 1225 06b0 03F01003 		and	r3, r3, #16
 1226 06b4 002B     		cmp	r3, #0
 1227 06b6 06D0     		beq	.L35
 876:../src/stm32f30x_rcc.c ****   {
 877:../src/stm32f30x_rcc.c ****      /* ADC34CLK clock frequency is derived from PLL clock */
 878:../src/stm32f30x_rcc.c ****      RCC_Clocks->ADC34CLK_Frequency = pllclk / presc;
 1228              		.loc 1 878 0
 1229 06b8 7A6A     		ldr	r2, [r7, #36]
 1230 06ba 3B69     		ldr	r3, [r7, #16]
 1231 06bc B2FBF3F2 		udiv	r2, r2, r3
 1232 06c0 7B68     		ldr	r3, [r7, #4]
 1233 06c2 5A61     		str	r2, [r3, #20]
 1234 06c4 03E0     		b	.L36
 1235              	.L35:
 879:../src/stm32f30x_rcc.c ****   }
 880:../src/stm32f30x_rcc.c ****   else
 881:../src/stm32f30x_rcc.c ****   {
 882:../src/stm32f30x_rcc.c ****    /* ADC34CLK clock frequency is AHB clock */
 883:../src/stm32f30x_rcc.c ****      RCC_Clocks->ADC34CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1236              		.loc 1 883 0
 1237 06c6 7B68     		ldr	r3, [r7, #4]
 1238 06c8 1A68     		ldr	r2, [r3, #0]
 1239 06ca 7B68     		ldr	r3, [r7, #4]
 1240 06cc 5A61     		str	r2, [r3, #20]
 1241              	.L36:
 884:../src/stm32f30x_rcc.c ****   }
 885:../src/stm32f30x_rcc.c **** 
 886:../src/stm32f30x_rcc.c ****   /* I2C1CLK clock frequency */
 887:../src/stm32f30x_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
 1242              		.loc 1 887 0
 1243 06ce 4FF48053 		mov	r3, #4096
 1244 06d2 C4F20203 		movt	r3, 16386
 1245 06d6 1B6B     		ldr	r3, [r3, #48]
 1246 06d8 03F01003 		and	r3, r3, #16
 1247 06dc 002B     		cmp	r3, #0
 1248 06de 06D1     		bne	.L37
 888:../src/stm32f30x_rcc.c ****   {
 889:../src/stm32f30x_rcc.c ****     /* I2C1 Clock is HSI Osc. */
 890:../src/stm32f30x_rcc.c ****     RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
 1249              		.loc 1 890 0
 1250 06e0 7A68     		ldr	r2, [r7, #4]
 1251 06e2 4FF49053 		mov	r3, #4608
 1252 06e6 C0F27A03 		movt	r3, 122
 1253 06ea 9361     		str	r3, [r2, #24]
 1254 06ec 03E0     		b	.L38
 1255              	.L37:
 891:../src/stm32f30x_rcc.c ****   }
 892:../src/stm32f30x_rcc.c ****   else
 893:../src/stm32f30x_rcc.c ****   {
 894:../src/stm32f30x_rcc.c ****     /* I2C1 Clock is System Clock */
 895:../src/stm32f30x_rcc.c ****     RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1256              		.loc 1 895 0
 1257 06ee 7B68     		ldr	r3, [r7, #4]
 1258 06f0 1A68     		ldr	r2, [r3, #0]
 1259 06f2 7B68     		ldr	r3, [r7, #4]
 1260 06f4 9A61     		str	r2, [r3, #24]
 1261              	.L38:
 896:../src/stm32f30x_rcc.c ****   }
 897:../src/stm32f30x_rcc.c **** 
 898:../src/stm32f30x_rcc.c ****   /* I2C2CLK clock frequency */
 899:../src/stm32f30x_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_I2C2SW) != RCC_CFGR3_I2C2SW)
 1262              		.loc 1 899 0
 1263 06f6 4FF48053 		mov	r3, #4096
 1264 06fa C4F20203 		movt	r3, 16386
 1265 06fe 1B6B     		ldr	r3, [r3, #48]
 1266 0700 03F02003 		and	r3, r3, #32
 1267 0704 002B     		cmp	r3, #0
 1268 0706 06D1     		bne	.L39
 900:../src/stm32f30x_rcc.c ****   {
 901:../src/stm32f30x_rcc.c ****     /* I2C2 Clock is HSI Osc. */
 902:../src/stm32f30x_rcc.c ****     RCC_Clocks->I2C2CLK_Frequency = HSI_VALUE;
 1269              		.loc 1 902 0
 1270 0708 7A68     		ldr	r2, [r7, #4]
 1271 070a 4FF49053 		mov	r3, #4608
 1272 070e C0F27A03 		movt	r3, 122
 1273 0712 D361     		str	r3, [r2, #28]
 1274 0714 03E0     		b	.L40
 1275              	.L39:
 903:../src/stm32f30x_rcc.c ****   }
 904:../src/stm32f30x_rcc.c ****   else
 905:../src/stm32f30x_rcc.c ****   {
 906:../src/stm32f30x_rcc.c ****     /* I2C2 Clock is System Clock */
 907:../src/stm32f30x_rcc.c ****     RCC_Clocks->I2C2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1276              		.loc 1 907 0
 1277 0716 7B68     		ldr	r3, [r7, #4]
 1278 0718 1A68     		ldr	r2, [r3, #0]
 1279 071a 7B68     		ldr	r3, [r7, #4]
 1280 071c DA61     		str	r2, [r3, #28]
 1281              	.L40:
 908:../src/stm32f30x_rcc.c ****   }
 909:../src/stm32f30x_rcc.c ****   
 910:../src/stm32f30x_rcc.c ****     /* TIM1CLK clock frequency */
 911:../src/stm32f30x_rcc.c ****   if(((RCC->CFGR3 & RCC_CFGR3_TIM1SW) == RCC_CFGR3_TIM1SW)&& (RCC_Clocks->SYSCLK_Frequency == pllcl
 1282              		.loc 1 911 0
 1283 071e 4FF48053 		mov	r3, #4096
 1284 0722 C4F20203 		movt	r3, 16386
 1285 0726 1B6B     		ldr	r3, [r3, #48]
 1286 0728 03F48073 		and	r3, r3, #256
 1287 072c 002B     		cmp	r3, #0
 1288 072e 0ED0     		beq	.L41
 1289              		.loc 1 911 0 is_stmt 0 discriminator 1
 1290 0730 7B68     		ldr	r3, [r7, #4]
 1291 0732 1A68     		ldr	r2, [r3, #0]
 1292 0734 7B6A     		ldr	r3, [r7, #36]
 1293 0736 9A42     		cmp	r2, r3
 1294 0738 09D1     		bne	.L41
 912:../src/stm32f30x_rcc.c ****   && (apb2presc == ahbpresc)) 
 1295              		.loc 1 912 0 is_stmt 1
 1296 073a FA68     		ldr	r2, [r7, #12]
 1297 073c BB68     		ldr	r3, [r7, #8]
 1298 073e 9A42     		cmp	r2, r3
 1299 0740 05D1     		bne	.L41
 913:../src/stm32f30x_rcc.c ****   {
 914:../src/stm32f30x_rcc.c ****     /* TIM1 Clock is 2 * pllclk */
 915:../src/stm32f30x_rcc.c ****     RCC_Clocks->TIM1CLK_Frequency = pllclk * 2;
 1300              		.loc 1 915 0
 1301 0742 7B6A     		ldr	r3, [r7, #36]
 1302 0744 4FEA4302 		lsl	r2, r3, #1
 1303 0748 7B68     		ldr	r3, [r7, #4]
 1304 074a 1A62     		str	r2, [r3, #32]
 1305 074c 03E0     		b	.L42
 1306              	.L41:
 916:../src/stm32f30x_rcc.c ****   }
 917:../src/stm32f30x_rcc.c ****   else
 918:../src/stm32f30x_rcc.c ****   {
 919:../src/stm32f30x_rcc.c ****     /* TIM1 Clock is APB2 clock. */
 920:../src/stm32f30x_rcc.c ****     RCC_Clocks->TIM1CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 1307              		.loc 1 920 0
 1308 074e 7B68     		ldr	r3, [r7, #4]
 1309 0750 DA68     		ldr	r2, [r3, #12]
 1310 0752 7B68     		ldr	r3, [r7, #4]
 1311 0754 1A62     		str	r2, [r3, #32]
 1312              	.L42:
 921:../src/stm32f30x_rcc.c ****   }
 922:../src/stm32f30x_rcc.c **** 
 923:../src/stm32f30x_rcc.c ****     /* TIM8CLK clock frequency */
 924:../src/stm32f30x_rcc.c ****   if(((RCC->CFGR3 & RCC_CFGR3_TIM8SW) == RCC_CFGR3_TIM8SW)&& (RCC_Clocks->SYSCLK_Frequency == pllcl
 1313              		.loc 1 924 0
 1314 0756 4FF48053 		mov	r3, #4096
 1315 075a C4F20203 		movt	r3, 16386
 1316 075e 1B6B     		ldr	r3, [r3, #48]
 1317 0760 03F40073 		and	r3, r3, #512
 1318 0764 002B     		cmp	r3, #0
 1319 0766 0ED0     		beq	.L43
 1320              		.loc 1 924 0 is_stmt 0 discriminator 1
 1321 0768 7B68     		ldr	r3, [r7, #4]
 1322 076a 1A68     		ldr	r2, [r3, #0]
 1323 076c 7B6A     		ldr	r3, [r7, #36]
 1324 076e 9A42     		cmp	r2, r3
 1325 0770 09D1     		bne	.L43
 925:../src/stm32f30x_rcc.c ****   && (apb2presc == ahbpresc))
 1326              		.loc 1 925 0 is_stmt 1
 1327 0772 FA68     		ldr	r2, [r7, #12]
 1328 0774 BB68     		ldr	r3, [r7, #8]
 1329 0776 9A42     		cmp	r2, r3
 1330 0778 05D1     		bne	.L43
 926:../src/stm32f30x_rcc.c ****   {
 927:../src/stm32f30x_rcc.c ****     /* TIM8 Clock is 2 * pllclk */
 928:../src/stm32f30x_rcc.c ****     RCC_Clocks->TIM8CLK_Frequency = pllclk * 2;
 1331              		.loc 1 928 0
 1332 077a 7B6A     		ldr	r3, [r7, #36]
 1333 077c 4FEA4302 		lsl	r2, r3, #1
 1334 0780 7B68     		ldr	r3, [r7, #4]
 1335 0782 5A62     		str	r2, [r3, #36]
 1336 0784 03E0     		b	.L44
 1337              	.L43:
 929:../src/stm32f30x_rcc.c ****   }
 930:../src/stm32f30x_rcc.c ****   else
 931:../src/stm32f30x_rcc.c ****   {
 932:../src/stm32f30x_rcc.c ****     /* TIM8 Clock is APB2 clock. */
 933:../src/stm32f30x_rcc.c ****     RCC_Clocks->TIM8CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 1338              		.loc 1 933 0
 1339 0786 7B68     		ldr	r3, [r7, #4]
 1340 0788 DA68     		ldr	r2, [r3, #12]
 1341 078a 7B68     		ldr	r3, [r7, #4]
 1342 078c 5A62     		str	r2, [r3, #36]
 1343              	.L44:
 934:../src/stm32f30x_rcc.c ****   }
 935:../src/stm32f30x_rcc.c ****   
 936:../src/stm32f30x_rcc.c ****   /* USART1CLK clock frequency */
 937:../src/stm32f30x_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
 1344              		.loc 1 937 0
 1345 078e 4FF48053 		mov	r3, #4096
 1346 0792 C4F20203 		movt	r3, 16386
 1347 0796 1B6B     		ldr	r3, [r3, #48]
 1348 0798 03F00303 		and	r3, r3, #3
 1349 079c 002B     		cmp	r3, #0
 1350 079e 04D1     		bne	.L45
 938:../src/stm32f30x_rcc.c ****   {
 939:../src/stm32f30x_rcc.c ****     /* USART Clock is PCLK */
 940:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 1351              		.loc 1 940 0
 1352 07a0 7B68     		ldr	r3, [r7, #4]
 1353 07a2 DA68     		ldr	r2, [r3, #12]
 1354 07a4 7B68     		ldr	r3, [r7, #4]
 1355 07a6 9A62     		str	r2, [r3, #40]
 1356 07a8 2AE0     		b	.L46
 1357              	.L45:
 941:../src/stm32f30x_rcc.c ****   }
 942:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
 1358              		.loc 1 942 0
 1359 07aa 4FF48053 		mov	r3, #4096
 1360 07ae C4F20203 		movt	r3, 16386
 1361 07b2 1B6B     		ldr	r3, [r3, #48]
 1362 07b4 03F00303 		and	r3, r3, #3
 1363 07b8 012B     		cmp	r3, #1
 1364 07ba 04D1     		bne	.L47
 943:../src/stm32f30x_rcc.c ****   {
 944:../src/stm32f30x_rcc.c ****     /* USART Clock is System Clock */
 945:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1365              		.loc 1 945 0
 1366 07bc 7B68     		ldr	r3, [r7, #4]
 1367 07be 1A68     		ldr	r2, [r3, #0]
 1368 07c0 7B68     		ldr	r3, [r7, #4]
 1369 07c2 9A62     		str	r2, [r3, #40]
 1370 07c4 1CE0     		b	.L46
 1371              	.L47:
 946:../src/stm32f30x_rcc.c ****   }
 947:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
 1372              		.loc 1 947 0
 1373 07c6 4FF48053 		mov	r3, #4096
 1374 07ca C4F20203 		movt	r3, 16386
 1375 07ce 1B6B     		ldr	r3, [r3, #48]
 1376 07d0 03F00303 		and	r3, r3, #3
 1377 07d4 022B     		cmp	r3, #2
 1378 07d6 04D1     		bne	.L48
 948:../src/stm32f30x_rcc.c ****   {
 949:../src/stm32f30x_rcc.c ****     /* USART Clock is LSE Osc. */
 950:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
 1379              		.loc 1 950 0
 1380 07d8 7B68     		ldr	r3, [r7, #4]
 1381 07da 4FF40042 		mov	r2, #32768
 1382 07de 9A62     		str	r2, [r3, #40]
 1383 07e0 0EE0     		b	.L46
 1384              	.L48:
 951:../src/stm32f30x_rcc.c ****   }
 952:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
 1385              		.loc 1 952 0
 1386 07e2 4FF48053 		mov	r3, #4096
 1387 07e6 C4F20203 		movt	r3, 16386
 1388 07ea 1B6B     		ldr	r3, [r3, #48]
 1389 07ec 03F00303 		and	r3, r3, #3
 1390 07f0 032B     		cmp	r3, #3
 1391 07f2 05D1     		bne	.L46
 953:../src/stm32f30x_rcc.c ****   {
 954:../src/stm32f30x_rcc.c ****     /* USART Clock is HSI Osc. */
 955:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
 1392              		.loc 1 955 0
 1393 07f4 7A68     		ldr	r2, [r7, #4]
 1394 07f6 4FF49053 		mov	r3, #4608
 1395 07fa C0F27A03 		movt	r3, 122
 1396 07fe 9362     		str	r3, [r2, #40]
 1397              	.L46:
 956:../src/stm32f30x_rcc.c ****   }
 957:../src/stm32f30x_rcc.c **** 
 958:../src/stm32f30x_rcc.c ****   /* USART2CLK clock frequency */
 959:../src/stm32f30x_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == 0x0)
 1398              		.loc 1 959 0
 1399 0800 4FF48053 		mov	r3, #4096
 1400 0804 C4F20203 		movt	r3, 16386
 1401 0808 1B6B     		ldr	r3, [r3, #48]
 1402 080a 03F44033 		and	r3, r3, #196608
 1403 080e 002B     		cmp	r3, #0
 1404 0810 04D1     		bne	.L49
 960:../src/stm32f30x_rcc.c ****   {
 961:../src/stm32f30x_rcc.c ****     /* USART Clock is PCLK */
 962:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 1405              		.loc 1 962 0
 1406 0812 7B68     		ldr	r3, [r7, #4]
 1407 0814 9A68     		ldr	r2, [r3, #8]
 1408 0816 7B68     		ldr	r3, [r7, #4]
 1409 0818 DA62     		str	r2, [r3, #44]
 1410 081a 2DE0     		b	.L50
 1411              	.L49:
 963:../src/stm32f30x_rcc.c ****   }
 964:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_0)
 1412              		.loc 1 964 0
 1413 081c 4FF48053 		mov	r3, #4096
 1414 0820 C4F20203 		movt	r3, 16386
 1415 0824 1B6B     		ldr	r3, [r3, #48]
 1416 0826 03F44033 		and	r3, r3, #196608
 1417 082a B3F5803F 		cmp	r3, #65536
 1418 082e 04D1     		bne	.L51
 965:../src/stm32f30x_rcc.c ****   {
 966:../src/stm32f30x_rcc.c ****     /* USART Clock is System Clock */
 967:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1419              		.loc 1 967 0
 1420 0830 7B68     		ldr	r3, [r7, #4]
 1421 0832 1A68     		ldr	r2, [r3, #0]
 1422 0834 7B68     		ldr	r3, [r7, #4]
 1423 0836 DA62     		str	r2, [r3, #44]
 1424 0838 1EE0     		b	.L50
 1425              	.L51:
 968:../src/stm32f30x_rcc.c ****   }
 969:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_1)
 1426              		.loc 1 969 0
 1427 083a 4FF48053 		mov	r3, #4096
 1428 083e C4F20203 		movt	r3, 16386
 1429 0842 1B6B     		ldr	r3, [r3, #48]
 1430 0844 03F44033 		and	r3, r3, #196608
 1431 0848 B3F5003F 		cmp	r3, #131072
 1432 084c 04D1     		bne	.L52
 970:../src/stm32f30x_rcc.c ****   {
 971:../src/stm32f30x_rcc.c ****     /* USART Clock is LSE Osc. */
 972:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART2CLK_Frequency = LSE_VALUE;
 1433              		.loc 1 972 0
 1434 084e 7B68     		ldr	r3, [r7, #4]
 1435 0850 4FF40042 		mov	r2, #32768
 1436 0854 DA62     		str	r2, [r3, #44]
 1437 0856 0FE0     		b	.L50
 1438              	.L52:
 973:../src/stm32f30x_rcc.c ****   }
 974:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW)
 1439              		.loc 1 974 0
 1440 0858 4FF48053 		mov	r3, #4096
 1441 085c C4F20203 		movt	r3, 16386
 1442 0860 1B6B     		ldr	r3, [r3, #48]
 1443 0862 03F44033 		and	r3, r3, #196608
 1444 0866 B3F5403F 		cmp	r3, #196608
 1445 086a 05D1     		bne	.L50
 975:../src/stm32f30x_rcc.c ****   {
 976:../src/stm32f30x_rcc.c ****     /* USART Clock is HSI Osc. */
 977:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART2CLK_Frequency = HSI_VALUE;
 1446              		.loc 1 977 0
 1447 086c 7A68     		ldr	r2, [r7, #4]
 1448 086e 4FF49053 		mov	r3, #4608
 1449 0872 C0F27A03 		movt	r3, 122
 1450 0876 D362     		str	r3, [r2, #44]
 1451              	.L50:
 978:../src/stm32f30x_rcc.c ****   }    
 979:../src/stm32f30x_rcc.c **** 
 980:../src/stm32f30x_rcc.c ****   /* USART3CLK clock frequency */
 981:../src/stm32f30x_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == 0x0)
 1452              		.loc 1 981 0
 1453 0878 4FF48053 		mov	r3, #4096
 1454 087c C4F20203 		movt	r3, 16386
 1455 0880 1B6B     		ldr	r3, [r3, #48]
 1456 0882 03F44023 		and	r3, r3, #786432
 1457 0886 002B     		cmp	r3, #0
 1458 0888 04D1     		bne	.L53
 982:../src/stm32f30x_rcc.c ****   {
 983:../src/stm32f30x_rcc.c ****     /* USART Clock is PCLK */
 984:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 1459              		.loc 1 984 0
 1460 088a 7B68     		ldr	r3, [r7, #4]
 1461 088c 9A68     		ldr	r2, [r3, #8]
 1462 088e 7B68     		ldr	r3, [r7, #4]
 1463 0890 1A63     		str	r2, [r3, #48]
 1464 0892 2DE0     		b	.L54
 1465              	.L53:
 985:../src/stm32f30x_rcc.c ****   }
 986:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_0)
 1466              		.loc 1 986 0
 1467 0894 4FF48053 		mov	r3, #4096
 1468 0898 C4F20203 		movt	r3, 16386
 1469 089c 1B6B     		ldr	r3, [r3, #48]
 1470 089e 03F44023 		and	r3, r3, #786432
 1471 08a2 B3F5802F 		cmp	r3, #262144
 1472 08a6 04D1     		bne	.L55
 987:../src/stm32f30x_rcc.c ****   {
 988:../src/stm32f30x_rcc.c ****     /* USART Clock is System Clock */
 989:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1473              		.loc 1 989 0
 1474 08a8 7B68     		ldr	r3, [r7, #4]
 1475 08aa 1A68     		ldr	r2, [r3, #0]
 1476 08ac 7B68     		ldr	r3, [r7, #4]
 1477 08ae 1A63     		str	r2, [r3, #48]
 1478 08b0 1EE0     		b	.L54
 1479              	.L55:
 990:../src/stm32f30x_rcc.c ****   }
 991:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_1)
 1480              		.loc 1 991 0
 1481 08b2 4FF48053 		mov	r3, #4096
 1482 08b6 C4F20203 		movt	r3, 16386
 1483 08ba 1B6B     		ldr	r3, [r3, #48]
 1484 08bc 03F44023 		and	r3, r3, #786432
 1485 08c0 B3F5002F 		cmp	r3, #524288
 1486 08c4 04D1     		bne	.L56
 992:../src/stm32f30x_rcc.c ****   {
 993:../src/stm32f30x_rcc.c ****     /* USART Clock is LSE Osc. */
 994:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART3CLK_Frequency = LSE_VALUE;
 1487              		.loc 1 994 0
 1488 08c6 7B68     		ldr	r3, [r7, #4]
 1489 08c8 4FF40042 		mov	r2, #32768
 1490 08cc 1A63     		str	r2, [r3, #48]
 1491 08ce 0FE0     		b	.L54
 1492              	.L56:
 995:../src/stm32f30x_rcc.c ****   }
 996:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW)
 1493              		.loc 1 996 0
 1494 08d0 4FF48053 		mov	r3, #4096
 1495 08d4 C4F20203 		movt	r3, 16386
 1496 08d8 1B6B     		ldr	r3, [r3, #48]
 1497 08da 03F44023 		and	r3, r3, #786432
 1498 08de B3F5402F 		cmp	r3, #786432
 1499 08e2 05D1     		bne	.L54
 997:../src/stm32f30x_rcc.c ****   {
 998:../src/stm32f30x_rcc.c ****     /* USART Clock is HSI Osc. */
 999:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART3CLK_Frequency = HSI_VALUE;
 1500              		.loc 1 999 0
 1501 08e4 7A68     		ldr	r2, [r7, #4]
 1502 08e6 4FF49053 		mov	r3, #4608
 1503 08ea C0F27A03 		movt	r3, 122
 1504 08ee 1363     		str	r3, [r2, #48]
 1505              	.L54:
1000:../src/stm32f30x_rcc.c ****   }
1001:../src/stm32f30x_rcc.c ****   
1002:../src/stm32f30x_rcc.c ****     /* UART4CLK clock frequency */
1003:../src/stm32f30x_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == 0x0)
 1506              		.loc 1 1003 0
 1507 08f0 4FF48053 		mov	r3, #4096
 1508 08f4 C4F20203 		movt	r3, 16386
 1509 08f8 1B6B     		ldr	r3, [r3, #48]
 1510 08fa 03F44013 		and	r3, r3, #3145728
 1511 08fe 002B     		cmp	r3, #0
 1512 0900 04D1     		bne	.L57
1004:../src/stm32f30x_rcc.c ****   {
1005:../src/stm32f30x_rcc.c ****     /* USART Clock is PCLK */
1006:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART4CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 1513              		.loc 1 1006 0
 1514 0902 7B68     		ldr	r3, [r7, #4]
 1515 0904 9A68     		ldr	r2, [r3, #8]
 1516 0906 7B68     		ldr	r3, [r7, #4]
 1517 0908 5A63     		str	r2, [r3, #52]
 1518 090a 2DE0     		b	.L58
 1519              	.L57:
1007:../src/stm32f30x_rcc.c ****   }
1008:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW_0)
 1520              		.loc 1 1008 0
 1521 090c 4FF48053 		mov	r3, #4096
 1522 0910 C4F20203 		movt	r3, 16386
 1523 0914 1B6B     		ldr	r3, [r3, #48]
 1524 0916 03F44013 		and	r3, r3, #3145728
 1525 091a B3F5801F 		cmp	r3, #1048576
 1526 091e 04D1     		bne	.L59
1009:../src/stm32f30x_rcc.c ****   {
1010:../src/stm32f30x_rcc.c ****     /* USART Clock is System Clock */
1011:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART4CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1527              		.loc 1 1011 0
 1528 0920 7B68     		ldr	r3, [r7, #4]
 1529 0922 1A68     		ldr	r2, [r3, #0]
 1530 0924 7B68     		ldr	r3, [r7, #4]
 1531 0926 5A63     		str	r2, [r3, #52]
 1532 0928 1EE0     		b	.L58
 1533              	.L59:
1012:../src/stm32f30x_rcc.c ****   }
1013:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW_1)
 1534              		.loc 1 1013 0
 1535 092a 4FF48053 		mov	r3, #4096
 1536 092e C4F20203 		movt	r3, 16386
 1537 0932 1B6B     		ldr	r3, [r3, #48]
 1538 0934 03F44013 		and	r3, r3, #3145728
 1539 0938 B3F5001F 		cmp	r3, #2097152
 1540 093c 04D1     		bne	.L60
1014:../src/stm32f30x_rcc.c ****   {
1015:../src/stm32f30x_rcc.c ****     /* USART Clock is LSE Osc. */
1016:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART4CLK_Frequency = LSE_VALUE;
 1541              		.loc 1 1016 0
 1542 093e 7B68     		ldr	r3, [r7, #4]
 1543 0940 4FF40042 		mov	r2, #32768
 1544 0944 5A63     		str	r2, [r3, #52]
 1545 0946 0FE0     		b	.L58
 1546              	.L60:
1017:../src/stm32f30x_rcc.c ****   }
1018:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW)
 1547              		.loc 1 1018 0
 1548 0948 4FF48053 		mov	r3, #4096
 1549 094c C4F20203 		movt	r3, 16386
 1550 0950 1B6B     		ldr	r3, [r3, #48]
 1551 0952 03F44013 		and	r3, r3, #3145728
 1552 0956 B3F5401F 		cmp	r3, #3145728
 1553 095a 05D1     		bne	.L58
1019:../src/stm32f30x_rcc.c ****   {
1020:../src/stm32f30x_rcc.c ****     /* USART Clock is HSI Osc. */
1021:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART4CLK_Frequency = HSI_VALUE;
 1554              		.loc 1 1021 0
 1555 095c 7A68     		ldr	r2, [r7, #4]
 1556 095e 4FF49053 		mov	r3, #4608
 1557 0962 C0F27A03 		movt	r3, 122
 1558 0966 5363     		str	r3, [r2, #52]
 1559              	.L58:
1022:../src/stm32f30x_rcc.c ****   }   
1023:../src/stm32f30x_rcc.c ****   
1024:../src/stm32f30x_rcc.c ****   /* UART5CLK clock frequency */
1025:../src/stm32f30x_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == 0x0)
 1560              		.loc 1 1025 0
 1561 0968 4FF48053 		mov	r3, #4096
 1562 096c C4F20203 		movt	r3, 16386
 1563 0970 1B6B     		ldr	r3, [r3, #48]
 1564 0972 03F44003 		and	r3, r3, #12582912
 1565 0976 002B     		cmp	r3, #0
 1566 0978 04D1     		bne	.L61
1026:../src/stm32f30x_rcc.c ****   {
1027:../src/stm32f30x_rcc.c ****     /* USART Clock is PCLK */
1028:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART5CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 1567              		.loc 1 1028 0
 1568 097a 7B68     		ldr	r3, [r7, #4]
 1569 097c 9A68     		ldr	r2, [r3, #8]
 1570 097e 7B68     		ldr	r3, [r7, #4]
 1571 0980 9A63     		str	r2, [r3, #56]
 1572 0982 2DE0     		b	.L25
 1573              	.L61:
1029:../src/stm32f30x_rcc.c ****   }
1030:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW_0)
 1574              		.loc 1 1030 0
 1575 0984 4FF48053 		mov	r3, #4096
 1576 0988 C4F20203 		movt	r3, 16386
 1577 098c 1B6B     		ldr	r3, [r3, #48]
 1578 098e 03F44003 		and	r3, r3, #12582912
 1579 0992 B3F5800F 		cmp	r3, #4194304
 1580 0996 04D1     		bne	.L63
1031:../src/stm32f30x_rcc.c ****   {
1032:../src/stm32f30x_rcc.c ****     /* USART Clock is System Clock */
1033:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART5CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1581              		.loc 1 1033 0
 1582 0998 7B68     		ldr	r3, [r7, #4]
 1583 099a 1A68     		ldr	r2, [r3, #0]
 1584 099c 7B68     		ldr	r3, [r7, #4]
 1585 099e 9A63     		str	r2, [r3, #56]
 1586 09a0 1EE0     		b	.L25
 1587              	.L63:
1034:../src/stm32f30x_rcc.c ****   }
1035:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW_1)
 1588              		.loc 1 1035 0
 1589 09a2 4FF48053 		mov	r3, #4096
 1590 09a6 C4F20203 		movt	r3, 16386
 1591 09aa 1B6B     		ldr	r3, [r3, #48]
 1592 09ac 03F44003 		and	r3, r3, #12582912
 1593 09b0 B3F5000F 		cmp	r3, #8388608
 1594 09b4 04D1     		bne	.L64
1036:../src/stm32f30x_rcc.c ****   {
1037:../src/stm32f30x_rcc.c ****     /* USART Clock is LSE Osc. */
1038:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART5CLK_Frequency = LSE_VALUE;
 1595              		.loc 1 1038 0
 1596 09b6 7B68     		ldr	r3, [r7, #4]
 1597 09b8 4FF40042 		mov	r2, #32768
 1598 09bc 9A63     		str	r2, [r3, #56]
 1599 09be 0FE0     		b	.L25
 1600              	.L64:
1039:../src/stm32f30x_rcc.c ****   }
1040:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW)
 1601              		.loc 1 1040 0
 1602 09c0 4FF48053 		mov	r3, #4096
 1603 09c4 C4F20203 		movt	r3, 16386
 1604 09c8 1B6B     		ldr	r3, [r3, #48]
 1605 09ca 03F44003 		and	r3, r3, #12582912
 1606 09ce B3F5400F 		cmp	r3, #12582912
 1607 09d2 05D1     		bne	.L25
1041:../src/stm32f30x_rcc.c ****   {
1042:../src/stm32f30x_rcc.c ****     /* USART Clock is HSI Osc. */
1043:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART5CLK_Frequency = HSI_VALUE;
 1608              		.loc 1 1043 0
 1609 09d4 7A68     		ldr	r2, [r7, #4]
 1610 09d6 4FF49053 		mov	r3, #4608
 1611 09da C0F27A03 		movt	r3, 122
 1612 09de 9363     		str	r3, [r2, #56]
 1613              	.L25:
1044:../src/stm32f30x_rcc.c ****   } 
1045:../src/stm32f30x_rcc.c **** }
 1614              		.loc 1 1045 0
 1615 09e0 07F12C07 		add	r7, r7, #44
 1616 09e4 BD46     		mov	sp, r7
 1617 09e6 80BC     		pop	{r7}
 1618 09e8 7047     		bx	lr
 1619              		.cfi_endproc
 1620              	.LFE129:
 1622 09ea 00BF     		.align	2
 1623              		.global	RCC_ADCCLKConfig
 1624              		.thumb
 1625              		.thumb_func
 1627              	RCC_ADCCLKConfig:
 1628              	.LFB130:
1046:../src/stm32f30x_rcc.c **** 
1047:../src/stm32f30x_rcc.c **** /**
1048:../src/stm32f30x_rcc.c ****   * @}
1049:../src/stm32f30x_rcc.c ****   */
1050:../src/stm32f30x_rcc.c **** 
1051:../src/stm32f30x_rcc.c **** /** @defgroup RCC_Group3 Peripheral clocks configuration functions
1052:../src/stm32f30x_rcc.c ****  *  @brief   Peripheral clocks configuration functions 
1053:../src/stm32f30x_rcc.c ****  *
1054:../src/stm32f30x_rcc.c **** @verbatim   
1055:../src/stm32f30x_rcc.c ****  ===============================================================================
1056:../src/stm32f30x_rcc.c ****             ##### Peripheral clocks configuration functions #####
1057:../src/stm32f30x_rcc.c ****  ===============================================================================  
1058:../src/stm32f30x_rcc.c ****     [..] This section provide functions allowing to configure the Peripheral clocks. 
1059:../src/stm32f30x_rcc.c ****          (#) The RTC clock which is derived from the LSE, LSI or  HSE_Div32 
1060:../src/stm32f30x_rcc.c ****              (HSE divided by 32).
1061:../src/stm32f30x_rcc.c ****          (#) After restart from Reset or wakeup from STANDBY, all peripherals are 
1062:../src/stm32f30x_rcc.c ****              off except internal SRAM, Flash and SWD. Before to start using 
1063:../src/stm32f30x_rcc.c ****              a peripheral you have to enable its interface clock. You can do this 
1064:../src/stm32f30x_rcc.c ****              using RCC_AHBPeriphClockCmd(), RCC_APB2PeriphClockCmd() 
1065:../src/stm32f30x_rcc.c ****              and RCC_APB1PeriphClockCmd() functions.
1066:../src/stm32f30x_rcc.c ****          (#) To reset the peripherals configuration (to the default state after 
1067:../src/stm32f30x_rcc.c ****              device reset) you can use RCC_AHBPeriphResetCmd(), RCC_APB2PeriphResetCmd() 
1068:../src/stm32f30x_rcc.c ****              and RCC_APB1PeriphResetCmd() functions.
1069:../src/stm32f30x_rcc.c **** @endverbatim
1070:../src/stm32f30x_rcc.c ****   * @{
1071:../src/stm32f30x_rcc.c ****   */
1072:../src/stm32f30x_rcc.c **** 
1073:../src/stm32f30x_rcc.c **** /**
1074:../src/stm32f30x_rcc.c ****   * @brief  Configures the ADC clock (ADCCLK).
1075:../src/stm32f30x_rcc.c ****   * @param  RCC_PLLCLK: defines the ADC clock divider. This clock is derived from 
1076:../src/stm32f30x_rcc.c ****   *         the PLL Clock.
1077:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1078:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_OFF: ADC12 clock disabled
1079:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div1: ADC12 clock = PLLCLK/1
1080:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div2: ADC12 clock = PLLCLK/2
1081:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div4: ADC12 clock = PLLCLK/4
1082:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div6: ADC12 clock = PLLCLK/6
1083:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div8: ADC12 clock = PLLCLK/8
1084:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div10: ADC12 clock = PLLCLK/10
1085:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div12: ADC12 clock = PLLCLK/12
1086:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div16: ADC12 clock = PLLCLK/16
1087:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div32: ADC12 clock = PLLCLK/32
1088:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div64: ADC12 clock = PLLCLK/64
1089:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div128: ADC12 clock = PLLCLK/128
1090:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div256: ADC12 clock = PLLCLK/256
1091:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_OFF: ADC34 clock disabled
1092:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div1: ADC34 clock = PLLCLK/1
1093:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div2: ADC34 clock = PLLCLK/2
1094:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div4: ADC34 clock = PLLCLK/4
1095:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div6: ADC34 clock = PLLCLK/6
1096:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div8: ADC34 clock = PLLCLK/8
1097:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div10: ADC34 clock = PLLCLK/10
1098:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div12: ADC34 clock = PLLCLK/12
1099:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div16: ADC34 clock = PLLCLK/16
1100:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div32: ADC34 clock = PLLCLK/32
1101:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div64: ADC34 clock = PLLCLK/64       
1102:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div128: ADC34 clock = PLLCLK/128                                  
1103:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div256: ADC34 clock = PLLCLK/256
1104:../src/stm32f30x_rcc.c ****   * @retval None
1105:../src/stm32f30x_rcc.c ****   */
1106:../src/stm32f30x_rcc.c **** void RCC_ADCCLKConfig(uint32_t RCC_PLLCLK)
1107:../src/stm32f30x_rcc.c **** {
 1629              		.loc 1 1107 0
 1630              		.cfi_startproc
 1631              		@ args = 0, pretend = 0, frame = 16
 1632              		@ frame_needed = 1, uses_anonymous_args = 0
 1633              		@ link register save eliminated.
 1634 09ec 80B4     		push	{r7}
 1635              	.LCFI55:
 1636              		.cfi_def_cfa_offset 4
 1637              		.cfi_offset 7, -4
 1638 09ee 85B0     		sub	sp, sp, #20
 1639              	.LCFI56:
 1640              		.cfi_def_cfa_offset 24
 1641 09f0 00AF     		add	r7, sp, #0
 1642              	.LCFI57:
 1643              		.cfi_def_cfa_register 7
 1644 09f2 7860     		str	r0, [r7, #4]
1108:../src/stm32f30x_rcc.c ****   uint32_t tmp = 0;
 1645              		.loc 1 1108 0
 1646 09f4 4FF00003 		mov	r3, #0
 1647 09f8 FB60     		str	r3, [r7, #12]
1109:../src/stm32f30x_rcc.c ****   
1110:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1111:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_ADCCLK(RCC_PLLCLK));
1112:../src/stm32f30x_rcc.c **** 
1113:../src/stm32f30x_rcc.c ****   tmp = (RCC_PLLCLK >> 28);
 1648              		.loc 1 1113 0
 1649 09fa 7B68     		ldr	r3, [r7, #4]
 1650 09fc 4FEA1373 		lsr	r3, r3, #28
 1651 0a00 FB60     		str	r3, [r7, #12]
1114:../src/stm32f30x_rcc.c ****   
1115:../src/stm32f30x_rcc.c ****   /* Clears ADCPRE34 bits */
1116:../src/stm32f30x_rcc.c ****   if (tmp != 0)
 1652              		.loc 1 1116 0
 1653 0a02 FB68     		ldr	r3, [r7, #12]
 1654 0a04 002B     		cmp	r3, #0
 1655 0a06 0CD0     		beq	.L67
1117:../src/stm32f30x_rcc.c ****   {
1118:../src/stm32f30x_rcc.c ****     RCC->CFGR2 &= ~RCC_CFGR2_ADCPRE34;
 1656              		.loc 1 1118 0
 1657 0a08 4FF48053 		mov	r3, #4096
 1658 0a0c C4F20203 		movt	r3, 16386
 1659 0a10 4FF48052 		mov	r2, #4096
 1660 0a14 C4F20202 		movt	r2, 16386
 1661 0a18 D26A     		ldr	r2, [r2, #44]
 1662 0a1a 22F47852 		bic	r2, r2, #15872
 1663 0a1e DA62     		str	r2, [r3, #44]
 1664 0a20 0BE0     		b	.L68
 1665              	.L67:
1119:../src/stm32f30x_rcc.c ****   }
1120:../src/stm32f30x_rcc.c ****    /* Clears ADCPRE12 bits */
1121:../src/stm32f30x_rcc.c ****   else
1122:../src/stm32f30x_rcc.c ****   {
1123:../src/stm32f30x_rcc.c ****     RCC->CFGR2 &= ~RCC_CFGR2_ADCPRE12;
 1666              		.loc 1 1123 0
 1667 0a22 4FF48053 		mov	r3, #4096
 1668 0a26 C4F20203 		movt	r3, 16386
 1669 0a2a 4FF48052 		mov	r2, #4096
 1670 0a2e C4F20202 		movt	r2, 16386
 1671 0a32 D26A     		ldr	r2, [r2, #44]
 1672 0a34 22F4F872 		bic	r2, r2, #496
 1673 0a38 DA62     		str	r2, [r3, #44]
 1674              	.L68:
1124:../src/stm32f30x_rcc.c ****   }
1125:../src/stm32f30x_rcc.c ****   /* Set ADCPRE bits according to RCC_PLLCLK value */
1126:../src/stm32f30x_rcc.c ****   RCC->CFGR2 |= RCC_PLLCLK;
 1675              		.loc 1 1126 0
 1676 0a3a 4FF48053 		mov	r3, #4096
 1677 0a3e C4F20203 		movt	r3, 16386
 1678 0a42 4FF48052 		mov	r2, #4096
 1679 0a46 C4F20202 		movt	r2, 16386
 1680 0a4a D16A     		ldr	r1, [r2, #44]
 1681 0a4c 7A68     		ldr	r2, [r7, #4]
 1682 0a4e 0A43     		orrs	r2, r2, r1
 1683 0a50 DA62     		str	r2, [r3, #44]
1127:../src/stm32f30x_rcc.c **** }
 1684              		.loc 1 1127 0
 1685 0a52 07F11407 		add	r7, r7, #20
 1686 0a56 BD46     		mov	sp, r7
 1687 0a58 80BC     		pop	{r7}
 1688 0a5a 7047     		bx	lr
 1689              		.cfi_endproc
 1690              	.LFE130:
 1692              		.align	2
 1693              		.global	RCC_I2CCLKConfig
 1694              		.thumb
 1695              		.thumb_func
 1697              	RCC_I2CCLKConfig:
 1698              	.LFB131:
1128:../src/stm32f30x_rcc.c **** 
1129:../src/stm32f30x_rcc.c **** /**
1130:../src/stm32f30x_rcc.c ****   * @brief  Configures the I2C clock (I2CCLK).
1131:../src/stm32f30x_rcc.c ****   * @param  RCC_I2CCLK: defines the I2C clock source. This clock is derived 
1132:../src/stm32f30x_rcc.c ****   *         from the HSI or System clock.
1133:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1134:../src/stm32f30x_rcc.c ****   *     @arg RCC_I2CxCLK_HSI: I2Cx clock = HSI
1135:../src/stm32f30x_rcc.c ****   *     @arg RCC_I2CxCLK_SYSCLK: I2Cx clock = System Clock
1136:../src/stm32f30x_rcc.c ****   *          (x can be 1 or 2).  
1137:../src/stm32f30x_rcc.c ****   * @retval None
1138:../src/stm32f30x_rcc.c ****   */
1139:../src/stm32f30x_rcc.c **** void RCC_I2CCLKConfig(uint32_t RCC_I2CCLK)
1140:../src/stm32f30x_rcc.c **** { 
 1699              		.loc 1 1140 0
 1700              		.cfi_startproc
 1701              		@ args = 0, pretend = 0, frame = 16
 1702              		@ frame_needed = 1, uses_anonymous_args = 0
 1703              		@ link register save eliminated.
 1704 0a5c 80B4     		push	{r7}
 1705              	.LCFI58:
 1706              		.cfi_def_cfa_offset 4
 1707              		.cfi_offset 7, -4
 1708 0a5e 85B0     		sub	sp, sp, #20
 1709              	.LCFI59:
 1710              		.cfi_def_cfa_offset 24
 1711 0a60 00AF     		add	r7, sp, #0
 1712              	.LCFI60:
 1713              		.cfi_def_cfa_register 7
 1714 0a62 7860     		str	r0, [r7, #4]
1141:../src/stm32f30x_rcc.c ****   uint32_t tmp = 0;
 1715              		.loc 1 1141 0
 1716 0a64 4FF00003 		mov	r3, #0
 1717 0a68 FB60     		str	r3, [r7, #12]
1142:../src/stm32f30x_rcc.c ****   
1143:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1144:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_I2CCLK(RCC_I2CCLK));
1145:../src/stm32f30x_rcc.c **** 
1146:../src/stm32f30x_rcc.c ****   tmp = (RCC_I2CCLK >> 28);
 1718              		.loc 1 1146 0
 1719 0a6a 7B68     		ldr	r3, [r7, #4]
 1720 0a6c 4FEA1373 		lsr	r3, r3, #28
 1721 0a70 FB60     		str	r3, [r7, #12]
1147:../src/stm32f30x_rcc.c ****   
1148:../src/stm32f30x_rcc.c ****   /* Clear I2CSW bit */
1149:../src/stm32f30x_rcc.c ****   if (tmp != 0)
 1722              		.loc 1 1149 0
 1723 0a72 FB68     		ldr	r3, [r7, #12]
 1724 0a74 002B     		cmp	r3, #0
 1725 0a76 0CD0     		beq	.L70
1150:../src/stm32f30x_rcc.c ****   {
1151:../src/stm32f30x_rcc.c ****     RCC->CFGR3 &= ~RCC_CFGR3_I2C2SW;
 1726              		.loc 1 1151 0
 1727 0a78 4FF48053 		mov	r3, #4096
 1728 0a7c C4F20203 		movt	r3, 16386
 1729 0a80 4FF48052 		mov	r2, #4096
 1730 0a84 C4F20202 		movt	r2, 16386
 1731 0a88 126B     		ldr	r2, [r2, #48]
 1732 0a8a 22F02002 		bic	r2, r2, #32
 1733 0a8e 1A63     		str	r2, [r3, #48]
 1734 0a90 0BE0     		b	.L71
 1735              	.L70:
1152:../src/stm32f30x_rcc.c ****   }
1153:../src/stm32f30x_rcc.c ****   else
1154:../src/stm32f30x_rcc.c ****   {
1155:../src/stm32f30x_rcc.c ****     RCC->CFGR3 &= ~RCC_CFGR3_I2C1SW;
 1736              		.loc 1 1155 0
 1737 0a92 4FF48053 		mov	r3, #4096
 1738 0a96 C4F20203 		movt	r3, 16386
 1739 0a9a 4FF48052 		mov	r2, #4096
 1740 0a9e C4F20202 		movt	r2, 16386
 1741 0aa2 126B     		ldr	r2, [r2, #48]
 1742 0aa4 22F01002 		bic	r2, r2, #16
 1743 0aa8 1A63     		str	r2, [r3, #48]
 1744              	.L71:
1156:../src/stm32f30x_rcc.c ****   }
1157:../src/stm32f30x_rcc.c ****   /* Set I2CSW bits according to RCC_I2CCLK value */
1158:../src/stm32f30x_rcc.c ****   RCC->CFGR3 |= RCC_I2CCLK;
 1745              		.loc 1 1158 0
 1746 0aaa 4FF48053 		mov	r3, #4096
 1747 0aae C4F20203 		movt	r3, 16386
 1748 0ab2 4FF48052 		mov	r2, #4096
 1749 0ab6 C4F20202 		movt	r2, 16386
 1750 0aba 116B     		ldr	r1, [r2, #48]
 1751 0abc 7A68     		ldr	r2, [r7, #4]
 1752 0abe 0A43     		orrs	r2, r2, r1
 1753 0ac0 1A63     		str	r2, [r3, #48]
1159:../src/stm32f30x_rcc.c **** }
 1754              		.loc 1 1159 0
 1755 0ac2 07F11407 		add	r7, r7, #20
 1756 0ac6 BD46     		mov	sp, r7
 1757 0ac8 80BC     		pop	{r7}
 1758 0aca 7047     		bx	lr
 1759              		.cfi_endproc
 1760              	.LFE131:
 1762              		.align	2
 1763              		.global	RCC_TIMCLKConfig
 1764              		.thumb
 1765              		.thumb_func
 1767              	RCC_TIMCLKConfig:
 1768              	.LFB132:
1160:../src/stm32f30x_rcc.c **** 
1161:../src/stm32f30x_rcc.c **** /**
1162:../src/stm32f30x_rcc.c ****   * @brief  Configures the TIM1 and TIM8 clock sources(TIMCLK).
1163:../src/stm32f30x_rcc.c ****   * @note     The configuration of the TIMx clock source is only possible when the 
1164:../src/stm32f30x_rcc.c ****   *           SYSCLK = PLL and HCLK and PCLK2 clocks are not divided in respect to SYSCLK
1165:../src/stm32f30x_rcc.c ****   * @note     If one of the previous conditions is missed, the TIM clock source 
1166:../src/stm32f30x_rcc.c ****   *           configuration is lost and calling again this function becomes mandatory.  
1167:../src/stm32f30x_rcc.c ****   * @param  RCC_TIMCLK: defines the TIMx clock source.
1168:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1169:../src/stm32f30x_rcc.c ****   *     @arg RCC_TIMxCLK_HCLK: TIMx clock = APB high speed clock (doubled frequency
1170:../src/stm32f30x_rcc.c ****   *          when prescaled)
1171:../src/stm32f30x_rcc.c ****   *     @arg RCC_TIMxCLK_PLLCLK: TIMx clock = PLL output (running up to 144 MHz)
1172:../src/stm32f30x_rcc.c ****   *          (x can be 1 or 8).
1173:../src/stm32f30x_rcc.c ****   * @retval None
1174:../src/stm32f30x_rcc.c ****   */
1175:../src/stm32f30x_rcc.c **** void RCC_TIMCLKConfig(uint32_t RCC_TIMCLK)
1176:../src/stm32f30x_rcc.c **** { 
 1769              		.loc 1 1176 0
 1770              		.cfi_startproc
 1771              		@ args = 0, pretend = 0, frame = 16
 1772              		@ frame_needed = 1, uses_anonymous_args = 0
 1773              		@ link register save eliminated.
 1774 0acc 80B4     		push	{r7}
 1775              	.LCFI61:
 1776              		.cfi_def_cfa_offset 4
 1777              		.cfi_offset 7, -4
 1778 0ace 85B0     		sub	sp, sp, #20
 1779              	.LCFI62:
 1780              		.cfi_def_cfa_offset 24
 1781 0ad0 00AF     		add	r7, sp, #0
 1782              	.LCFI63:
 1783              		.cfi_def_cfa_register 7
 1784 0ad2 7860     		str	r0, [r7, #4]
1177:../src/stm32f30x_rcc.c ****   uint32_t tmp = 0;
 1785              		.loc 1 1177 0
 1786 0ad4 4FF00003 		mov	r3, #0
 1787 0ad8 FB60     		str	r3, [r7, #12]
1178:../src/stm32f30x_rcc.c ****   
1179:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1180:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_TIMCLK(RCC_TIMCLK));
1181:../src/stm32f30x_rcc.c **** 
1182:../src/stm32f30x_rcc.c ****   tmp = (RCC_TIMCLK >> 28);
 1788              		.loc 1 1182 0
 1789 0ada 7B68     		ldr	r3, [r7, #4]
 1790 0adc 4FEA1373 		lsr	r3, r3, #28
 1791 0ae0 FB60     		str	r3, [r7, #12]
1183:../src/stm32f30x_rcc.c ****   
1184:../src/stm32f30x_rcc.c ****   /* Clear I2CSW bit */
1185:../src/stm32f30x_rcc.c ****   if (tmp != 0)
 1792              		.loc 1 1185 0
 1793 0ae2 FB68     		ldr	r3, [r7, #12]
 1794 0ae4 002B     		cmp	r3, #0
 1795 0ae6 0CD0     		beq	.L73
1186:../src/stm32f30x_rcc.c ****   {
1187:../src/stm32f30x_rcc.c ****     RCC->CFGR3 &= ~RCC_CFGR3_TIM8SW;
 1796              		.loc 1 1187 0
 1797 0ae8 4FF48053 		mov	r3, #4096
 1798 0aec C4F20203 		movt	r3, 16386
 1799 0af0 4FF48052 		mov	r2, #4096
 1800 0af4 C4F20202 		movt	r2, 16386
 1801 0af8 126B     		ldr	r2, [r2, #48]
 1802 0afa 22F40072 		bic	r2, r2, #512
 1803 0afe 1A63     		str	r2, [r3, #48]
 1804 0b00 0BE0     		b	.L74
 1805              	.L73:
1188:../src/stm32f30x_rcc.c ****   }
1189:../src/stm32f30x_rcc.c ****   else
1190:../src/stm32f30x_rcc.c ****   {
1191:../src/stm32f30x_rcc.c ****     RCC->CFGR3 &= ~RCC_CFGR3_TIM1SW;
 1806              		.loc 1 1191 0
 1807 0b02 4FF48053 		mov	r3, #4096
 1808 0b06 C4F20203 		movt	r3, 16386
 1809 0b0a 4FF48052 		mov	r2, #4096
 1810 0b0e C4F20202 		movt	r2, 16386
 1811 0b12 126B     		ldr	r2, [r2, #48]
 1812 0b14 22F48072 		bic	r2, r2, #256
 1813 0b18 1A63     		str	r2, [r3, #48]
 1814              	.L74:
1192:../src/stm32f30x_rcc.c ****   }
1193:../src/stm32f30x_rcc.c ****   /* Set I2CSW bits according to RCC_TIMCLK value */
1194:../src/stm32f30x_rcc.c ****   RCC->CFGR3 |= RCC_TIMCLK;
 1815              		.loc 1 1194 0
 1816 0b1a 4FF48053 		mov	r3, #4096
 1817 0b1e C4F20203 		movt	r3, 16386
 1818 0b22 4FF48052 		mov	r2, #4096
 1819 0b26 C4F20202 		movt	r2, 16386
 1820 0b2a 116B     		ldr	r1, [r2, #48]
 1821 0b2c 7A68     		ldr	r2, [r7, #4]
 1822 0b2e 0A43     		orrs	r2, r2, r1
 1823 0b30 1A63     		str	r2, [r3, #48]
1195:../src/stm32f30x_rcc.c **** }
 1824              		.loc 1 1195 0
 1825 0b32 07F11407 		add	r7, r7, #20
 1826 0b36 BD46     		mov	sp, r7
 1827 0b38 80BC     		pop	{r7}
 1828 0b3a 7047     		bx	lr
 1829              		.cfi_endproc
 1830              	.LFE132:
 1832              		.align	2
 1833              		.global	RCC_USARTCLKConfig
 1834              		.thumb
 1835              		.thumb_func
 1837              	RCC_USARTCLKConfig:
 1838              	.LFB133:
1196:../src/stm32f30x_rcc.c **** 
1197:../src/stm32f30x_rcc.c **** /**
1198:../src/stm32f30x_rcc.c ****   * @brief  Configures the USART clock (USARTCLK).
1199:../src/stm32f30x_rcc.c ****   * @param  RCC_USARTCLK: defines the USART clock source. This clock is derived 
1200:../src/stm32f30x_rcc.c ****   *         from the HSI or System clock.
1201:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1202:../src/stm32f30x_rcc.c ****   *     @arg RCC_USARTxCLK_PCLK: USART clock = APB Clock (PCLK)
1203:../src/stm32f30x_rcc.c ****   *     @arg RCC_USARTxCLK_SYSCLK: USART clock = System Clock
1204:../src/stm32f30x_rcc.c ****   *     @arg RCC_USARTxCLK_LSE: USART clock = LSE Clock
1205:../src/stm32f30x_rcc.c ****   *     @arg RCC_USARTxCLK_HSI: USART clock = HSI Clock
1206:../src/stm32f30x_rcc.c ****   *          (x can be 1, 2, 3, 4 or 5).  
1207:../src/stm32f30x_rcc.c ****   * @retval None
1208:../src/stm32f30x_rcc.c ****   */
1209:../src/stm32f30x_rcc.c **** void RCC_USARTCLKConfig(uint32_t RCC_USARTCLK)
1210:../src/stm32f30x_rcc.c **** { 
 1839              		.loc 1 1210 0
 1840              		.cfi_startproc
 1841              		@ args = 0, pretend = 0, frame = 16
 1842              		@ frame_needed = 1, uses_anonymous_args = 0
 1843              		@ link register save eliminated.
 1844 0b3c 80B4     		push	{r7}
 1845              	.LCFI64:
 1846              		.cfi_def_cfa_offset 4
 1847              		.cfi_offset 7, -4
 1848 0b3e 85B0     		sub	sp, sp, #20
 1849              	.LCFI65:
 1850              		.cfi_def_cfa_offset 24
 1851 0b40 00AF     		add	r7, sp, #0
 1852              	.LCFI66:
 1853              		.cfi_def_cfa_register 7
 1854 0b42 7860     		str	r0, [r7, #4]
1211:../src/stm32f30x_rcc.c ****   uint32_t tmp = 0;
 1855              		.loc 1 1211 0
 1856 0b44 4FF00003 		mov	r3, #0
 1857 0b48 FB60     		str	r3, [r7, #12]
1212:../src/stm32f30x_rcc.c ****   
1213:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1214:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));
1215:../src/stm32f30x_rcc.c **** 
1216:../src/stm32f30x_rcc.c ****   tmp = (RCC_USARTCLK >> 28);
 1858              		.loc 1 1216 0
 1859 0b4a 7B68     		ldr	r3, [r7, #4]
 1860 0b4c 4FEA1373 		lsr	r3, r3, #28
 1861 0b50 FB60     		str	r3, [r7, #12]
1217:../src/stm32f30x_rcc.c **** 
1218:../src/stm32f30x_rcc.c ****   /* Clear USARTSW[1:0] bit */
1219:../src/stm32f30x_rcc.c ****   switch (tmp)
 1862              		.loc 1 1219 0
 1863 0b52 FB68     		ldr	r3, [r7, #12]
 1864 0b54 03F1FF33 		add	r3, r3, #-1
 1865 0b58 042B     		cmp	r3, #4
 1866 0b5a 4ED8     		bhi	.L84
 1867 0b5c 01A2     		adr	r2, .L82
 1868 0b5e 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1869 0b62 00BF     		.align	2
 1870              	.L82:
 1871 0b64 790B0000 		.word	.L77+1
 1872 0b68 930B0000 		.word	.L78+1
 1873 0b6c AD0B0000 		.word	.L79+1
 1874 0b70 C70B0000 		.word	.L80+1
 1875 0b74 E10B0000 		.word	.L81+1
 1876              	.L77:
1220:../src/stm32f30x_rcc.c ****   {
1221:../src/stm32f30x_rcc.c ****     case 0x01:  /* clear USART1SW */
1222:../src/stm32f30x_rcc.c ****       RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
 1877              		.loc 1 1222 0
 1878 0b78 4FF48053 		mov	r3, #4096
 1879 0b7c C4F20203 		movt	r3, 16386
 1880 0b80 4FF48052 		mov	r2, #4096
 1881 0b84 C4F20202 		movt	r2, 16386
 1882 0b88 126B     		ldr	r2, [r2, #48]
 1883 0b8a 22F00302 		bic	r2, r2, #3
 1884 0b8e 1A63     		str	r2, [r3, #48]
1223:../src/stm32f30x_rcc.c ****       break;
 1885              		.loc 1 1223 0
 1886 0b90 34E0     		b	.L83
 1887              	.L78:
1224:../src/stm32f30x_rcc.c ****     case 0x02:  /* clear USART2SW */
1225:../src/stm32f30x_rcc.c ****       RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
 1888              		.loc 1 1225 0
 1889 0b92 4FF48053 		mov	r3, #4096
 1890 0b96 C4F20203 		movt	r3, 16386
 1891 0b9a 4FF48052 		mov	r2, #4096
 1892 0b9e C4F20202 		movt	r2, 16386
 1893 0ba2 126B     		ldr	r2, [r2, #48]
 1894 0ba4 22F44032 		bic	r2, r2, #196608
 1895 0ba8 1A63     		str	r2, [r3, #48]
1226:../src/stm32f30x_rcc.c ****       break;
 1896              		.loc 1 1226 0
 1897 0baa 27E0     		b	.L83
 1898              	.L79:
1227:../src/stm32f30x_rcc.c ****     case 0x03:  /* clear USART3SW */
1228:../src/stm32f30x_rcc.c ****       RCC->CFGR3 &= ~RCC_CFGR3_USART3SW;
 1899              		.loc 1 1228 0
 1900 0bac 4FF48053 		mov	r3, #4096
 1901 0bb0 C4F20203 		movt	r3, 16386
 1902 0bb4 4FF48052 		mov	r2, #4096
 1903 0bb8 C4F20202 		movt	r2, 16386
 1904 0bbc 126B     		ldr	r2, [r2, #48]
 1905 0bbe 22F44022 		bic	r2, r2, #786432
 1906 0bc2 1A63     		str	r2, [r3, #48]
1229:../src/stm32f30x_rcc.c ****       break;
 1907              		.loc 1 1229 0
 1908 0bc4 1AE0     		b	.L83
 1909              	.L80:
1230:../src/stm32f30x_rcc.c ****     case 0x04:  /* clear UART4SW */
1231:../src/stm32f30x_rcc.c ****       RCC->CFGR3 &= ~RCC_CFGR3_UART4SW;
 1910              		.loc 1 1231 0
 1911 0bc6 4FF48053 		mov	r3, #4096
 1912 0bca C4F20203 		movt	r3, 16386
 1913 0bce 4FF48052 		mov	r2, #4096
 1914 0bd2 C4F20202 		movt	r2, 16386
 1915 0bd6 126B     		ldr	r2, [r2, #48]
 1916 0bd8 22F44012 		bic	r2, r2, #3145728
 1917 0bdc 1A63     		str	r2, [r3, #48]
1232:../src/stm32f30x_rcc.c ****       break;
 1918              		.loc 1 1232 0
 1919 0bde 0DE0     		b	.L83
 1920              	.L81:
1233:../src/stm32f30x_rcc.c ****     case 0x05:  /* clear UART5SW */
1234:../src/stm32f30x_rcc.c ****       RCC->CFGR3 &= ~RCC_CFGR3_UART5SW;
 1921              		.loc 1 1234 0
 1922 0be0 4FF48053 		mov	r3, #4096
 1923 0be4 C4F20203 		movt	r3, 16386
 1924 0be8 4FF48052 		mov	r2, #4096
 1925 0bec C4F20202 		movt	r2, 16386
 1926 0bf0 126B     		ldr	r2, [r2, #48]
 1927 0bf2 22F44002 		bic	r2, r2, #12582912
 1928 0bf6 1A63     		str	r2, [r3, #48]
1235:../src/stm32f30x_rcc.c ****       break;
 1929              		.loc 1 1235 0
 1930 0bf8 00E0     		b	.L83
 1931              	.L84:
1236:../src/stm32f30x_rcc.c ****     default:
1237:../src/stm32f30x_rcc.c ****       break;
 1932              		.loc 1 1237 0
 1933 0bfa 00BF     		nop
 1934              	.L83:
1238:../src/stm32f30x_rcc.c ****   }
1239:../src/stm32f30x_rcc.c **** 
1240:../src/stm32f30x_rcc.c ****   /* Set USARTSW bits according to RCC_USARTCLK value */
1241:../src/stm32f30x_rcc.c ****   RCC->CFGR3 |= RCC_USARTCLK;
 1935              		.loc 1 1241 0
 1936 0bfc 4FF48053 		mov	r3, #4096
 1937 0c00 C4F20203 		movt	r3, 16386
 1938 0c04 4FF48052 		mov	r2, #4096
 1939 0c08 C4F20202 		movt	r2, 16386
 1940 0c0c 116B     		ldr	r1, [r2, #48]
 1941 0c0e 7A68     		ldr	r2, [r7, #4]
 1942 0c10 0A43     		orrs	r2, r2, r1
 1943 0c12 1A63     		str	r2, [r3, #48]
1242:../src/stm32f30x_rcc.c **** }
 1944              		.loc 1 1242 0
 1945 0c14 07F11407 		add	r7, r7, #20
 1946 0c18 BD46     		mov	sp, r7
 1947 0c1a 80BC     		pop	{r7}
 1948 0c1c 7047     		bx	lr
 1949              		.cfi_endproc
 1950              	.LFE133:
 1952 0c1e 00BF     		.align	2
 1953              		.global	RCC_USBCLKConfig
 1954              		.thumb
 1955              		.thumb_func
 1957              	RCC_USBCLKConfig:
 1958              	.LFB134:
1243:../src/stm32f30x_rcc.c **** 
1244:../src/stm32f30x_rcc.c **** /**
1245:../src/stm32f30x_rcc.c ****   * @brief  Configures the USB clock (USBCLK).
1246:../src/stm32f30x_rcc.c ****   * @param  RCC_USBCLKSource: specifies the USB clock source. This clock is 
1247:../src/stm32f30x_rcc.c ****   *   derived from the PLL output.
1248:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1249:../src/stm32f30x_rcc.c ****   *     @arg RCC_USBCLKSource_PLLCLK_1Div5: PLL clock divided by 1,5 selected as USB 
1250:../src/stm32f30x_rcc.c ****   *                                     clock source
1251:../src/stm32f30x_rcc.c ****   *     @arg RCC_USBCLKSource_PLLCLK_Div1: PLL clock selected as USB clock source
1252:../src/stm32f30x_rcc.c ****   * @retval None
1253:../src/stm32f30x_rcc.c ****   */
1254:../src/stm32f30x_rcc.c **** void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
1255:../src/stm32f30x_rcc.c **** {
 1959              		.loc 1 1255 0
 1960              		.cfi_startproc
 1961              		@ args = 0, pretend = 0, frame = 8
 1962              		@ frame_needed = 1, uses_anonymous_args = 0
 1963              		@ link register save eliminated.
 1964 0c20 80B4     		push	{r7}
 1965              	.LCFI67:
 1966              		.cfi_def_cfa_offset 4
 1967              		.cfi_offset 7, -4
 1968 0c22 83B0     		sub	sp, sp, #12
 1969              	.LCFI68:
 1970              		.cfi_def_cfa_offset 16
 1971 0c24 00AF     		add	r7, sp, #0
 1972              	.LCFI69:
 1973              		.cfi_def_cfa_register 7
 1974 0c26 7860     		str	r0, [r7, #4]
1256:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1257:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
1258:../src/stm32f30x_rcc.c **** 
1259:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 1975              		.loc 1 1259 0
 1976 0c28 4FF0D803 		mov	r3, #216
 1977 0c2c C4F24223 		movt	r3, 16962
 1978 0c30 7A68     		ldr	r2, [r7, #4]
 1979 0c32 1A60     		str	r2, [r3, #0]
1260:../src/stm32f30x_rcc.c **** }
 1980              		.loc 1 1260 0
 1981 0c34 07F10C07 		add	r7, r7, #12
 1982 0c38 BD46     		mov	sp, r7
 1983 0c3a 80BC     		pop	{r7}
 1984 0c3c 7047     		bx	lr
 1985              		.cfi_endproc
 1986              	.LFE134:
 1988 0c3e 00BF     		.align	2
 1989              		.global	RCC_RTCCLKConfig
 1990              		.thumb
 1991              		.thumb_func
 1993              	RCC_RTCCLKConfig:
 1994              	.LFB135:
1261:../src/stm32f30x_rcc.c **** 
1262:../src/stm32f30x_rcc.c **** /**
1263:../src/stm32f30x_rcc.c ****   * @brief  Configures the RTC clock (RTCCLK).
1264:../src/stm32f30x_rcc.c ****   * @note     As the RTC clock configuration bits are in the Backup domain and write
1265:../src/stm32f30x_rcc.c ****   *           access is denied to this domain after reset, you have to enable write
1266:../src/stm32f30x_rcc.c ****   *           access using PWR_BackupAccessCmd(ENABLE) function before to configure
1267:../src/stm32f30x_rcc.c ****   *           the RTC clock source (to be done once after reset).    
1268:../src/stm32f30x_rcc.c ****   * @note     Once the RTC clock is configured it can't be changed unless the RTC
1269:../src/stm32f30x_rcc.c ****   *           is reset using RCC_BackupResetCmd function, or by a Power On Reset (POR)
1270:../src/stm32f30x_rcc.c ****   *             
1271:../src/stm32f30x_rcc.c ****   * @param  RCC_RTCCLKSource: specifies the RTC clock source.
1272:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1273:../src/stm32f30x_rcc.c ****   *     @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
1274:../src/stm32f30x_rcc.c ****   *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
1275:../src/stm32f30x_rcc.c ****   *     @arg RCC_RTCCLKSource_HSE_Div32: HSE divided by 32 selected as RTC clock
1276:../src/stm32f30x_rcc.c ****   *       
1277:../src/stm32f30x_rcc.c ****   * @note     If the LSE or LSI is used as RTC clock source, the RTC continues to
1278:../src/stm32f30x_rcc.c ****   *           work in STOP and STANDBY modes, and can be used as wakeup source.
1279:../src/stm32f30x_rcc.c ****   *           However, when the HSE clock is used as RTC clock source, the RTC
1280:../src/stm32f30x_rcc.c ****   *           cannot be used in STOP and STANDBY modes.             
1281:../src/stm32f30x_rcc.c ****   * @note     The maximum input clock frequency for RTC is 2MHz (when using HSE as
1282:../src/stm32f30x_rcc.c ****   *           RTC clock source).             
1283:../src/stm32f30x_rcc.c ****   * @retval None
1284:../src/stm32f30x_rcc.c ****   */
1285:../src/stm32f30x_rcc.c **** void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
1286:../src/stm32f30x_rcc.c **** {
 1995              		.loc 1 1286 0
 1996              		.cfi_startproc
 1997              		@ args = 0, pretend = 0, frame = 8
 1998              		@ frame_needed = 1, uses_anonymous_args = 0
 1999              		@ link register save eliminated.
 2000 0c40 80B4     		push	{r7}
 2001              	.LCFI70:
 2002              		.cfi_def_cfa_offset 4
 2003              		.cfi_offset 7, -4
 2004 0c42 83B0     		sub	sp, sp, #12
 2005              	.LCFI71:
 2006              		.cfi_def_cfa_offset 16
 2007 0c44 00AF     		add	r7, sp, #0
 2008              	.LCFI72:
 2009              		.cfi_def_cfa_register 7
 2010 0c46 7860     		str	r0, [r7, #4]
1287:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1288:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
1289:../src/stm32f30x_rcc.c ****   
1290:../src/stm32f30x_rcc.c ****   /* Select the RTC clock source */
1291:../src/stm32f30x_rcc.c ****   RCC->BDCR |= RCC_RTCCLKSource;
 2011              		.loc 1 1291 0
 2012 0c48 4FF48053 		mov	r3, #4096
 2013 0c4c C4F20203 		movt	r3, 16386
 2014 0c50 4FF48052 		mov	r2, #4096
 2015 0c54 C4F20202 		movt	r2, 16386
 2016 0c58 116A     		ldr	r1, [r2, #32]
 2017 0c5a 7A68     		ldr	r2, [r7, #4]
 2018 0c5c 0A43     		orrs	r2, r2, r1
 2019 0c5e 1A62     		str	r2, [r3, #32]
1292:../src/stm32f30x_rcc.c **** }
 2020              		.loc 1 1292 0
 2021 0c60 07F10C07 		add	r7, r7, #12
 2022 0c64 BD46     		mov	sp, r7
 2023 0c66 80BC     		pop	{r7}
 2024 0c68 7047     		bx	lr
 2025              		.cfi_endproc
 2026              	.LFE135:
 2028 0c6a 00BF     		.align	2
 2029              		.global	RCC_I2SCLKConfig
 2030              		.thumb
 2031              		.thumb_func
 2033              	RCC_I2SCLKConfig:
 2034              	.LFB136:
1293:../src/stm32f30x_rcc.c **** 
1294:../src/stm32f30x_rcc.c **** /**
1295:../src/stm32f30x_rcc.c ****   * @brief  Configures the I2S clock source (I2SCLK).
1296:../src/stm32f30x_rcc.c ****   * @note   This function must be called before enabling the SPI2 and SPI3 clocks.
1297:../src/stm32f30x_rcc.c ****   * @param  RCC_I2SCLKSource: specifies the I2S clock source.
1298:../src/stm32f30x_rcc.c ****   *          This parameter can be one of the following values:
1299:../src/stm32f30x_rcc.c ****   *            @arg RCC_I2S2CLKSource_SYSCLK: SYSCLK clock used as I2S clock source
1300:../src/stm32f30x_rcc.c ****   *            @arg RCC_I2S2CLKSource_Ext: External clock mapped on the I2S_CKIN pin
1301:../src/stm32f30x_rcc.c ****   *                                        used as I2S clock source
1302:../src/stm32f30x_rcc.c ****   * @retval None
1303:../src/stm32f30x_rcc.c ****   */
1304:../src/stm32f30x_rcc.c **** void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
1305:../src/stm32f30x_rcc.c **** {
 2035              		.loc 1 1305 0
 2036              		.cfi_startproc
 2037              		@ args = 0, pretend = 0, frame = 8
 2038              		@ frame_needed = 1, uses_anonymous_args = 0
 2039              		@ link register save eliminated.
 2040 0c6c 80B4     		push	{r7}
 2041              	.LCFI73:
 2042              		.cfi_def_cfa_offset 4
 2043              		.cfi_offset 7, -4
 2044 0c6e 83B0     		sub	sp, sp, #12
 2045              	.LCFI74:
 2046              		.cfi_def_cfa_offset 16
 2047 0c70 00AF     		add	r7, sp, #0
 2048              	.LCFI75:
 2049              		.cfi_def_cfa_register 7
 2050 0c72 7860     		str	r0, [r7, #4]
1306:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1307:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
1308:../src/stm32f30x_rcc.c **** 
1309:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 2051              		.loc 1 1309 0
 2052 0c74 4FF0DC03 		mov	r3, #220
 2053 0c78 C4F24223 		movt	r3, 16962
 2054 0c7c 7A68     		ldr	r2, [r7, #4]
 2055 0c7e 1A60     		str	r2, [r3, #0]
1310:../src/stm32f30x_rcc.c **** }
 2056              		.loc 1 1310 0
 2057 0c80 07F10C07 		add	r7, r7, #12
 2058 0c84 BD46     		mov	sp, r7
 2059 0c86 80BC     		pop	{r7}
 2060 0c88 7047     		bx	lr
 2061              		.cfi_endproc
 2062              	.LFE136:
 2064 0c8a 00BF     		.align	2
 2065              		.global	RCC_RTCCLKCmd
 2066              		.thumb
 2067              		.thumb_func
 2069              	RCC_RTCCLKCmd:
 2070              	.LFB137:
1311:../src/stm32f30x_rcc.c **** 
1312:../src/stm32f30x_rcc.c **** /**
1313:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the RTC clock.
1314:../src/stm32f30x_rcc.c ****   * @note   This function must be used only after the RTC clock source was selected
1315:../src/stm32f30x_rcc.c ****   *         using the RCC_RTCCLKConfig function.
1316:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the RTC clock.
1317:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1318:../src/stm32f30x_rcc.c ****   * @retval None
1319:../src/stm32f30x_rcc.c ****   */
1320:../src/stm32f30x_rcc.c **** void RCC_RTCCLKCmd(FunctionalState NewState)
1321:../src/stm32f30x_rcc.c **** {
 2071              		.loc 1 1321 0
 2072              		.cfi_startproc
 2073              		@ args = 0, pretend = 0, frame = 8
 2074              		@ frame_needed = 1, uses_anonymous_args = 0
 2075              		@ link register save eliminated.
 2076 0c8c 80B4     		push	{r7}
 2077              	.LCFI76:
 2078              		.cfi_def_cfa_offset 4
 2079              		.cfi_offset 7, -4
 2080 0c8e 83B0     		sub	sp, sp, #12
 2081              	.LCFI77:
 2082              		.cfi_def_cfa_offset 16
 2083 0c90 00AF     		add	r7, sp, #0
 2084              	.LCFI78:
 2085              		.cfi_def_cfa_register 7
 2086 0c92 0346     		mov	r3, r0
 2087 0c94 FB71     		strb	r3, [r7, #7]
1322:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1323:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1324:../src/stm32f30x_rcc.c ****   
1325:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 2088              		.loc 1 1325 0
 2089 0c96 40F23C43 		movw	r3, #1084
 2090 0c9a C4F24223 		movt	r3, 16962
 2091 0c9e FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 2092 0ca0 1A60     		str	r2, [r3, #0]
1326:../src/stm32f30x_rcc.c **** }
 2093              		.loc 1 1326 0
 2094 0ca2 07F10C07 		add	r7, r7, #12
 2095 0ca6 BD46     		mov	sp, r7
 2096 0ca8 80BC     		pop	{r7}
 2097 0caa 7047     		bx	lr
 2098              		.cfi_endproc
 2099              	.LFE137:
 2101              		.align	2
 2102              		.global	RCC_BackupResetCmd
 2103              		.thumb
 2104              		.thumb_func
 2106              	RCC_BackupResetCmd:
 2107              	.LFB138:
1327:../src/stm32f30x_rcc.c **** 
1328:../src/stm32f30x_rcc.c **** /**
1329:../src/stm32f30x_rcc.c ****   * @brief  Forces or releases the Backup domain reset.
1330:../src/stm32f30x_rcc.c ****   * @note   This function resets the RTC peripheral (including the backup registers)
1331:../src/stm32f30x_rcc.c ****   *         and the RTC clock source selection in RCC_BDCR register.
1332:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the Backup domain reset.
1333:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1334:../src/stm32f30x_rcc.c ****   * @retval None
1335:../src/stm32f30x_rcc.c ****   */
1336:../src/stm32f30x_rcc.c **** void RCC_BackupResetCmd(FunctionalState NewState)
1337:../src/stm32f30x_rcc.c **** {
 2108              		.loc 1 1337 0
 2109              		.cfi_startproc
 2110              		@ args = 0, pretend = 0, frame = 8
 2111              		@ frame_needed = 1, uses_anonymous_args = 0
 2112              		@ link register save eliminated.
 2113 0cac 80B4     		push	{r7}
 2114              	.LCFI79:
 2115              		.cfi_def_cfa_offset 4
 2116              		.cfi_offset 7, -4
 2117 0cae 83B0     		sub	sp, sp, #12
 2118              	.LCFI80:
 2119              		.cfi_def_cfa_offset 16
 2120 0cb0 00AF     		add	r7, sp, #0
 2121              	.LCFI81:
 2122              		.cfi_def_cfa_register 7
 2123 0cb2 0346     		mov	r3, r0
 2124 0cb4 FB71     		strb	r3, [r7, #7]
1338:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1339:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1340:../src/stm32f30x_rcc.c ****   
1341:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 2125              		.loc 1 1341 0
 2126 0cb6 4FF48863 		mov	r3, #1088
 2127 0cba C4F24223 		movt	r3, 16962
 2128 0cbe FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 2129 0cc0 1A60     		str	r2, [r3, #0]
1342:../src/stm32f30x_rcc.c **** }
 2130              		.loc 1 1342 0
 2131 0cc2 07F10C07 		add	r7, r7, #12
 2132 0cc6 BD46     		mov	sp, r7
 2133 0cc8 80BC     		pop	{r7}
 2134 0cca 7047     		bx	lr
 2135              		.cfi_endproc
 2136              	.LFE138:
 2138              		.align	2
 2139              		.global	RCC_AHBPeriphClockCmd
 2140              		.thumb
 2141              		.thumb_func
 2143              	RCC_AHBPeriphClockCmd:
 2144              	.LFB139:
1343:../src/stm32f30x_rcc.c **** 
1344:../src/stm32f30x_rcc.c **** /**
1345:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the AHB peripheral clock.
1346:../src/stm32f30x_rcc.c ****   * @note   After reset, the peripheral clock (used for registers read/write access)
1347:../src/stm32f30x_rcc.c ****   *         is disabled and the application software has to enable this clock before 
1348:../src/stm32f30x_rcc.c ****   *         using it.    
1349:../src/stm32f30x_rcc.c ****   * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
1350:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1351:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOA
1352:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOB
1353:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOC  
1354:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOD
1355:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOE  
1356:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOF
1357:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_TS
1358:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_CRC
1359:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_FLITF (has effect only when the Flash memory is in power down mode)  
1360:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_SRAM
1361:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_DMA2
1362:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_DMA1
1363:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_ADC34
1364:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_ADC12      
1365:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the specified peripheral clock.
1366:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1367:../src/stm32f30x_rcc.c ****   * @retval None
1368:../src/stm32f30x_rcc.c ****   */
1369:../src/stm32f30x_rcc.c **** void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
1370:../src/stm32f30x_rcc.c **** {
 2145              		.loc 1 1370 0
 2146              		.cfi_startproc
 2147              		@ args = 0, pretend = 0, frame = 8
 2148              		@ frame_needed = 1, uses_anonymous_args = 0
 2149              		@ link register save eliminated.
 2150 0ccc 80B4     		push	{r7}
 2151              	.LCFI82:
 2152              		.cfi_def_cfa_offset 4
 2153              		.cfi_offset 7, -4
 2154 0cce 83B0     		sub	sp, sp, #12
 2155              	.LCFI83:
 2156              		.cfi_def_cfa_offset 16
 2157 0cd0 00AF     		add	r7, sp, #0
 2158              	.LCFI84:
 2159              		.cfi_def_cfa_register 7
 2160 0cd2 7860     		str	r0, [r7, #4]
 2161 0cd4 0B46     		mov	r3, r1
 2162 0cd6 FB70     		strb	r3, [r7, #3]
1371:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1372:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
1373:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1374:../src/stm32f30x_rcc.c ****   
1375:../src/stm32f30x_rcc.c ****   if (NewState != DISABLE)
 2163              		.loc 1 1375 0
 2164 0cd8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2165 0cda 002B     		cmp	r3, #0
 2166 0cdc 0CD0     		beq	.L91
1376:../src/stm32f30x_rcc.c ****   {
1377:../src/stm32f30x_rcc.c ****     RCC->AHBENR |= RCC_AHBPeriph;
 2167              		.loc 1 1377 0
 2168 0cde 4FF48053 		mov	r3, #4096
 2169 0ce2 C4F20203 		movt	r3, 16386
 2170 0ce6 4FF48052 		mov	r2, #4096
 2171 0cea C4F20202 		movt	r2, 16386
 2172 0cee 5169     		ldr	r1, [r2, #20]
 2173 0cf0 7A68     		ldr	r2, [r7, #4]
 2174 0cf2 0A43     		orrs	r2, r2, r1
 2175 0cf4 5A61     		str	r2, [r3, #20]
 2176 0cf6 0DE0     		b	.L90
 2177              	.L91:
1378:../src/stm32f30x_rcc.c ****   }
1379:../src/stm32f30x_rcc.c ****   else
1380:../src/stm32f30x_rcc.c ****   {
1381:../src/stm32f30x_rcc.c ****     RCC->AHBENR &= ~RCC_AHBPeriph;
 2178              		.loc 1 1381 0
 2179 0cf8 4FF48053 		mov	r3, #4096
 2180 0cfc C4F20203 		movt	r3, 16386
 2181 0d00 4FF48052 		mov	r2, #4096
 2182 0d04 C4F20202 		movt	r2, 16386
 2183 0d08 5169     		ldr	r1, [r2, #20]
 2184 0d0a 7A68     		ldr	r2, [r7, #4]
 2185 0d0c 6FEA0202 		mvn	r2, r2
 2186 0d10 0A40     		ands	r2, r2, r1
 2187 0d12 5A61     		str	r2, [r3, #20]
 2188              	.L90:
1382:../src/stm32f30x_rcc.c ****   }
1383:../src/stm32f30x_rcc.c **** }
 2189              		.loc 1 1383 0
 2190 0d14 07F10C07 		add	r7, r7, #12
 2191 0d18 BD46     		mov	sp, r7
 2192 0d1a 80BC     		pop	{r7}
 2193 0d1c 7047     		bx	lr
 2194              		.cfi_endproc
 2195              	.LFE139:
 2197 0d1e 00BF     		.align	2
 2198              		.global	RCC_APB2PeriphClockCmd
 2199              		.thumb
 2200              		.thumb_func
 2202              	RCC_APB2PeriphClockCmd:
 2203              	.LFB140:
1384:../src/stm32f30x_rcc.c **** 
1385:../src/stm32f30x_rcc.c **** /**
1386:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
1387:../src/stm32f30x_rcc.c ****   * @note   After reset, the peripheral clock (used for registers read/write access)
1388:../src/stm32f30x_rcc.c ****   *         is disabled and the application software has to enable this clock before 
1389:../src/stm32f30x_rcc.c ****   *         using it.
1390:../src/stm32f30x_rcc.c ****   * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
1391:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1392:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_SYSCFG
1393:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_SPI1
1394:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_USART1
1395:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM15
1396:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM16
1397:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM17
1398:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM1       
1399:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM8
1400:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the specified peripheral clock.
1401:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1402:../src/stm32f30x_rcc.c ****   * @retval None
1403:../src/stm32f30x_rcc.c ****   */
1404:../src/stm32f30x_rcc.c **** void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
1405:../src/stm32f30x_rcc.c **** {
 2204              		.loc 1 1405 0
 2205              		.cfi_startproc
 2206              		@ args = 0, pretend = 0, frame = 8
 2207              		@ frame_needed = 1, uses_anonymous_args = 0
 2208              		@ link register save eliminated.
 2209 0d20 80B4     		push	{r7}
 2210              	.LCFI85:
 2211              		.cfi_def_cfa_offset 4
 2212              		.cfi_offset 7, -4
 2213 0d22 83B0     		sub	sp, sp, #12
 2214              	.LCFI86:
 2215              		.cfi_def_cfa_offset 16
 2216 0d24 00AF     		add	r7, sp, #0
 2217              	.LCFI87:
 2218              		.cfi_def_cfa_register 7
 2219 0d26 7860     		str	r0, [r7, #4]
 2220 0d28 0B46     		mov	r3, r1
 2221 0d2a FB70     		strb	r3, [r7, #3]
1406:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1407:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
1408:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1409:../src/stm32f30x_rcc.c **** 
1410:../src/stm32f30x_rcc.c ****   if (NewState != DISABLE)
 2222              		.loc 1 1410 0
 2223 0d2c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2224 0d2e 002B     		cmp	r3, #0
 2225 0d30 0CD0     		beq	.L94
1411:../src/stm32f30x_rcc.c ****   {
1412:../src/stm32f30x_rcc.c ****     RCC->APB2ENR |= RCC_APB2Periph;
 2226              		.loc 1 1412 0
 2227 0d32 4FF48053 		mov	r3, #4096
 2228 0d36 C4F20203 		movt	r3, 16386
 2229 0d3a 4FF48052 		mov	r2, #4096
 2230 0d3e C4F20202 		movt	r2, 16386
 2231 0d42 9169     		ldr	r1, [r2, #24]
 2232 0d44 7A68     		ldr	r2, [r7, #4]
 2233 0d46 0A43     		orrs	r2, r2, r1
 2234 0d48 9A61     		str	r2, [r3, #24]
 2235 0d4a 0DE0     		b	.L93
 2236              	.L94:
1413:../src/stm32f30x_rcc.c ****   }
1414:../src/stm32f30x_rcc.c ****   else
1415:../src/stm32f30x_rcc.c ****   {
1416:../src/stm32f30x_rcc.c ****     RCC->APB2ENR &= ~RCC_APB2Periph;
 2237              		.loc 1 1416 0
 2238 0d4c 4FF48053 		mov	r3, #4096
 2239 0d50 C4F20203 		movt	r3, 16386
 2240 0d54 4FF48052 		mov	r2, #4096
 2241 0d58 C4F20202 		movt	r2, 16386
 2242 0d5c 9169     		ldr	r1, [r2, #24]
 2243 0d5e 7A68     		ldr	r2, [r7, #4]
 2244 0d60 6FEA0202 		mvn	r2, r2
 2245 0d64 0A40     		ands	r2, r2, r1
 2246 0d66 9A61     		str	r2, [r3, #24]
 2247              	.L93:
1417:../src/stm32f30x_rcc.c ****   }
1418:../src/stm32f30x_rcc.c **** }
 2248              		.loc 1 1418 0
 2249 0d68 07F10C07 		add	r7, r7, #12
 2250 0d6c BD46     		mov	sp, r7
 2251 0d6e 80BC     		pop	{r7}
 2252 0d70 7047     		bx	lr
 2253              		.cfi_endproc
 2254              	.LFE140:
 2256 0d72 00BF     		.align	2
 2257              		.global	RCC_APB1PeriphClockCmd
 2258              		.thumb
 2259              		.thumb_func
 2261              	RCC_APB1PeriphClockCmd:
 2262              	.LFB141:
1419:../src/stm32f30x_rcc.c **** 
1420:../src/stm32f30x_rcc.c **** /**
1421:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
1422:../src/stm32f30x_rcc.c ****   * @note   After reset, the peripheral clock (used for registers read/write access)
1423:../src/stm32f30x_rcc.c ****   *         is disabled and the application software has to enable this clock before 
1424:../src/stm32f30x_rcc.c ****   *         using it.
1425:../src/stm32f30x_rcc.c ****   * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
1426:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1427:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM2
1428:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM3
1429:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM4
1430:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM6
1431:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM7
1432:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_WWDG
1433:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_SPI2
1434:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_SPI3  
1435:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_USART2
1436:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_USART3
1437:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_UART4 
1438:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_UART5     
1439:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_I2C1
1440:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_I2C2
1441:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_USB
1442:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_CAN1
1443:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_PWR
1444:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_DAC
1445:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the specified peripheral clock.
1446:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1447:../src/stm32f30x_rcc.c ****   * @retval None
1448:../src/stm32f30x_rcc.c ****   */
1449:../src/stm32f30x_rcc.c **** void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
1450:../src/stm32f30x_rcc.c **** {
 2263              		.loc 1 1450 0
 2264              		.cfi_startproc
 2265              		@ args = 0, pretend = 0, frame = 8
 2266              		@ frame_needed = 1, uses_anonymous_args = 0
 2267              		@ link register save eliminated.
 2268 0d74 80B4     		push	{r7}
 2269              	.LCFI88:
 2270              		.cfi_def_cfa_offset 4
 2271              		.cfi_offset 7, -4
 2272 0d76 83B0     		sub	sp, sp, #12
 2273              	.LCFI89:
 2274              		.cfi_def_cfa_offset 16
 2275 0d78 00AF     		add	r7, sp, #0
 2276              	.LCFI90:
 2277              		.cfi_def_cfa_register 7
 2278 0d7a 7860     		str	r0, [r7, #4]
 2279 0d7c 0B46     		mov	r3, r1
 2280 0d7e FB70     		strb	r3, [r7, #3]
1451:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1452:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
1453:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1454:../src/stm32f30x_rcc.c **** 
1455:../src/stm32f30x_rcc.c ****   if (NewState != DISABLE)
 2281              		.loc 1 1455 0
 2282 0d80 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2283 0d82 002B     		cmp	r3, #0
 2284 0d84 0CD0     		beq	.L97
1456:../src/stm32f30x_rcc.c ****   {
1457:../src/stm32f30x_rcc.c ****     RCC->APB1ENR |= RCC_APB1Periph;
 2285              		.loc 1 1457 0
 2286 0d86 4FF48053 		mov	r3, #4096
 2287 0d8a C4F20203 		movt	r3, 16386
 2288 0d8e 4FF48052 		mov	r2, #4096
 2289 0d92 C4F20202 		movt	r2, 16386
 2290 0d96 D169     		ldr	r1, [r2, #28]
 2291 0d98 7A68     		ldr	r2, [r7, #4]
 2292 0d9a 0A43     		orrs	r2, r2, r1
 2293 0d9c DA61     		str	r2, [r3, #28]
 2294 0d9e 0DE0     		b	.L96
 2295              	.L97:
1458:../src/stm32f30x_rcc.c ****   }
1459:../src/stm32f30x_rcc.c ****   else
1460:../src/stm32f30x_rcc.c ****   {
1461:../src/stm32f30x_rcc.c ****     RCC->APB1ENR &= ~RCC_APB1Periph;
 2296              		.loc 1 1461 0
 2297 0da0 4FF48053 		mov	r3, #4096
 2298 0da4 C4F20203 		movt	r3, 16386
 2299 0da8 4FF48052 		mov	r2, #4096
 2300 0dac C4F20202 		movt	r2, 16386
 2301 0db0 D169     		ldr	r1, [r2, #28]
 2302 0db2 7A68     		ldr	r2, [r7, #4]
 2303 0db4 6FEA0202 		mvn	r2, r2
 2304 0db8 0A40     		ands	r2, r2, r1
 2305 0dba DA61     		str	r2, [r3, #28]
 2306              	.L96:
1462:../src/stm32f30x_rcc.c ****   }
1463:../src/stm32f30x_rcc.c **** }
 2307              		.loc 1 1463 0
 2308 0dbc 07F10C07 		add	r7, r7, #12
 2309 0dc0 BD46     		mov	sp, r7
 2310 0dc2 80BC     		pop	{r7}
 2311 0dc4 7047     		bx	lr
 2312              		.cfi_endproc
 2313              	.LFE141:
 2315 0dc6 00BF     		.align	2
 2316              		.global	RCC_AHBPeriphResetCmd
 2317              		.thumb
 2318              		.thumb_func
 2320              	RCC_AHBPeriphResetCmd:
 2321              	.LFB142:
1464:../src/stm32f30x_rcc.c **** 
1465:../src/stm32f30x_rcc.c **** /**
1466:../src/stm32f30x_rcc.c ****   * @brief  Forces or releases AHB peripheral reset.
1467:../src/stm32f30x_rcc.c ****   * @param  RCC_AHBPeriph: specifies the AHB peripheral to reset.
1468:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1469:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOA
1470:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOB
1471:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOC  
1472:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOD
1473:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOE  
1474:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOF
1475:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_TS
1476:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_ADC34
1477:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_ADC12    
1478:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the specified peripheral reset.
1479:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1480:../src/stm32f30x_rcc.c ****   * @retval None
1481:../src/stm32f30x_rcc.c ****   */
1482:../src/stm32f30x_rcc.c **** void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
1483:../src/stm32f30x_rcc.c **** {
 2322              		.loc 1 1483 0
 2323              		.cfi_startproc
 2324              		@ args = 0, pretend = 0, frame = 8
 2325              		@ frame_needed = 1, uses_anonymous_args = 0
 2326              		@ link register save eliminated.
 2327 0dc8 80B4     		push	{r7}
 2328              	.LCFI91:
 2329              		.cfi_def_cfa_offset 4
 2330              		.cfi_offset 7, -4
 2331 0dca 83B0     		sub	sp, sp, #12
 2332              	.LCFI92:
 2333              		.cfi_def_cfa_offset 16
 2334 0dcc 00AF     		add	r7, sp, #0
 2335              	.LCFI93:
 2336              		.cfi_def_cfa_register 7
 2337 0dce 7860     		str	r0, [r7, #4]
 2338 0dd0 0B46     		mov	r3, r1
 2339 0dd2 FB70     		strb	r3, [r7, #3]
1484:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1485:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
1486:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1487:../src/stm32f30x_rcc.c **** 
1488:../src/stm32f30x_rcc.c ****   if (NewState != DISABLE)
 2340              		.loc 1 1488 0
 2341 0dd4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2342 0dd6 002B     		cmp	r3, #0
 2343 0dd8 0CD0     		beq	.L100
1489:../src/stm32f30x_rcc.c ****   {
1490:../src/stm32f30x_rcc.c ****     RCC->AHBRSTR |= RCC_AHBPeriph;
 2344              		.loc 1 1490 0
 2345 0dda 4FF48053 		mov	r3, #4096
 2346 0dde C4F20203 		movt	r3, 16386
 2347 0de2 4FF48052 		mov	r2, #4096
 2348 0de6 C4F20202 		movt	r2, 16386
 2349 0dea 916A     		ldr	r1, [r2, #40]
 2350 0dec 7A68     		ldr	r2, [r7, #4]
 2351 0dee 0A43     		orrs	r2, r2, r1
 2352 0df0 9A62     		str	r2, [r3, #40]
 2353 0df2 0DE0     		b	.L99
 2354              	.L100:
1491:../src/stm32f30x_rcc.c ****   }
1492:../src/stm32f30x_rcc.c ****   else
1493:../src/stm32f30x_rcc.c ****   {
1494:../src/stm32f30x_rcc.c ****     RCC->AHBRSTR &= ~RCC_AHBPeriph;
 2355              		.loc 1 1494 0
 2356 0df4 4FF48053 		mov	r3, #4096
 2357 0df8 C4F20203 		movt	r3, 16386
 2358 0dfc 4FF48052 		mov	r2, #4096
 2359 0e00 C4F20202 		movt	r2, 16386
 2360 0e04 916A     		ldr	r1, [r2, #40]
 2361 0e06 7A68     		ldr	r2, [r7, #4]
 2362 0e08 6FEA0202 		mvn	r2, r2
 2363 0e0c 0A40     		ands	r2, r2, r1
 2364 0e0e 9A62     		str	r2, [r3, #40]
 2365              	.L99:
1495:../src/stm32f30x_rcc.c ****   }
1496:../src/stm32f30x_rcc.c **** }
 2366              		.loc 1 1496 0
 2367 0e10 07F10C07 		add	r7, r7, #12
 2368 0e14 BD46     		mov	sp, r7
 2369 0e16 80BC     		pop	{r7}
 2370 0e18 7047     		bx	lr
 2371              		.cfi_endproc
 2372              	.LFE142:
 2374 0e1a 00BF     		.align	2
 2375              		.global	RCC_APB2PeriphResetCmd
 2376              		.thumb
 2377              		.thumb_func
 2379              	RCC_APB2PeriphResetCmd:
 2380              	.LFB143:
1497:../src/stm32f30x_rcc.c **** 
1498:../src/stm32f30x_rcc.c **** /**
1499:../src/stm32f30x_rcc.c ****   * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
1500:../src/stm32f30x_rcc.c ****   * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
1501:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1502:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_SYSCFG
1503:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_SPI1
1504:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_USART1
1505:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM15
1506:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM16
1507:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM17
1508:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM1       
1509:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM8  
1510:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the specified peripheral reset.
1511:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1512:../src/stm32f30x_rcc.c ****   * @retval None
1513:../src/stm32f30x_rcc.c ****   */
1514:../src/stm32f30x_rcc.c **** void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
1515:../src/stm32f30x_rcc.c **** {
 2381              		.loc 1 1515 0
 2382              		.cfi_startproc
 2383              		@ args = 0, pretend = 0, frame = 8
 2384              		@ frame_needed = 1, uses_anonymous_args = 0
 2385              		@ link register save eliminated.
 2386 0e1c 80B4     		push	{r7}
 2387              	.LCFI94:
 2388              		.cfi_def_cfa_offset 4
 2389              		.cfi_offset 7, -4
 2390 0e1e 83B0     		sub	sp, sp, #12
 2391              	.LCFI95:
 2392              		.cfi_def_cfa_offset 16
 2393 0e20 00AF     		add	r7, sp, #0
 2394              	.LCFI96:
 2395              		.cfi_def_cfa_register 7
 2396 0e22 7860     		str	r0, [r7, #4]
 2397 0e24 0B46     		mov	r3, r1
 2398 0e26 FB70     		strb	r3, [r7, #3]
1516:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1517:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
1518:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1519:../src/stm32f30x_rcc.c **** 
1520:../src/stm32f30x_rcc.c ****   if (NewState != DISABLE)
 2399              		.loc 1 1520 0
 2400 0e28 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2401 0e2a 002B     		cmp	r3, #0
 2402 0e2c 0CD0     		beq	.L103
1521:../src/stm32f30x_rcc.c ****   {
1522:../src/stm32f30x_rcc.c ****     RCC->APB2RSTR |= RCC_APB2Periph;
 2403              		.loc 1 1522 0
 2404 0e2e 4FF48053 		mov	r3, #4096
 2405 0e32 C4F20203 		movt	r3, 16386
 2406 0e36 4FF48052 		mov	r2, #4096
 2407 0e3a C4F20202 		movt	r2, 16386
 2408 0e3e D168     		ldr	r1, [r2, #12]
 2409 0e40 7A68     		ldr	r2, [r7, #4]
 2410 0e42 0A43     		orrs	r2, r2, r1
 2411 0e44 DA60     		str	r2, [r3, #12]
 2412 0e46 0DE0     		b	.L102
 2413              	.L103:
1523:../src/stm32f30x_rcc.c ****   }
1524:../src/stm32f30x_rcc.c ****   else
1525:../src/stm32f30x_rcc.c ****   {
1526:../src/stm32f30x_rcc.c ****     RCC->APB2RSTR &= ~RCC_APB2Periph;
 2414              		.loc 1 1526 0
 2415 0e48 4FF48053 		mov	r3, #4096
 2416 0e4c C4F20203 		movt	r3, 16386
 2417 0e50 4FF48052 		mov	r2, #4096
 2418 0e54 C4F20202 		movt	r2, 16386
 2419 0e58 D168     		ldr	r1, [r2, #12]
 2420 0e5a 7A68     		ldr	r2, [r7, #4]
 2421 0e5c 6FEA0202 		mvn	r2, r2
 2422 0e60 0A40     		ands	r2, r2, r1
 2423 0e62 DA60     		str	r2, [r3, #12]
 2424              	.L102:
1527:../src/stm32f30x_rcc.c ****   }
1528:../src/stm32f30x_rcc.c **** }
 2425              		.loc 1 1528 0
 2426 0e64 07F10C07 		add	r7, r7, #12
 2427 0e68 BD46     		mov	sp, r7
 2428 0e6a 80BC     		pop	{r7}
 2429 0e6c 7047     		bx	lr
 2430              		.cfi_endproc
 2431              	.LFE143:
 2433 0e6e 00BF     		.align	2
 2434              		.global	RCC_APB1PeriphResetCmd
 2435              		.thumb
 2436              		.thumb_func
 2438              	RCC_APB1PeriphResetCmd:
 2439              	.LFB144:
1529:../src/stm32f30x_rcc.c **** 
1530:../src/stm32f30x_rcc.c **** /**
1531:../src/stm32f30x_rcc.c ****   * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
1532:../src/stm32f30x_rcc.c ****   * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
1533:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1534:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM2
1535:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM3
1536:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM4
1537:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM6
1538:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM7
1539:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_WWDG
1540:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_SPI2
1541:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_SPI3  
1542:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_USART2
1543:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_USART3
1544:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_UART4
1545:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_UART5      
1546:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_I2C1
1547:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_I2C2
1548:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_USB
1549:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_CAN1
1550:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_PWR
1551:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_DAC
1552:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the specified peripheral clock.
1553:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1554:../src/stm32f30x_rcc.c ****   * @retval None
1555:../src/stm32f30x_rcc.c ****   */
1556:../src/stm32f30x_rcc.c **** void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
1557:../src/stm32f30x_rcc.c **** {
 2440              		.loc 1 1557 0
 2441              		.cfi_startproc
 2442              		@ args = 0, pretend = 0, frame = 8
 2443              		@ frame_needed = 1, uses_anonymous_args = 0
 2444              		@ link register save eliminated.
 2445 0e70 80B4     		push	{r7}
 2446              	.LCFI97:
 2447              		.cfi_def_cfa_offset 4
 2448              		.cfi_offset 7, -4
 2449 0e72 83B0     		sub	sp, sp, #12
 2450              	.LCFI98:
 2451              		.cfi_def_cfa_offset 16
 2452 0e74 00AF     		add	r7, sp, #0
 2453              	.LCFI99:
 2454              		.cfi_def_cfa_register 7
 2455 0e76 7860     		str	r0, [r7, #4]
 2456 0e78 0B46     		mov	r3, r1
 2457 0e7a FB70     		strb	r3, [r7, #3]
1558:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1559:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
1560:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1561:../src/stm32f30x_rcc.c **** 
1562:../src/stm32f30x_rcc.c ****   if (NewState != DISABLE)
 2458              		.loc 1 1562 0
 2459 0e7c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2460 0e7e 002B     		cmp	r3, #0
 2461 0e80 0CD0     		beq	.L106
1563:../src/stm32f30x_rcc.c ****   {
1564:../src/stm32f30x_rcc.c ****     RCC->APB1RSTR |= RCC_APB1Periph;
 2462              		.loc 1 1564 0
 2463 0e82 4FF48053 		mov	r3, #4096
 2464 0e86 C4F20203 		movt	r3, 16386
 2465 0e8a 4FF48052 		mov	r2, #4096
 2466 0e8e C4F20202 		movt	r2, 16386
 2467 0e92 1169     		ldr	r1, [r2, #16]
 2468 0e94 7A68     		ldr	r2, [r7, #4]
 2469 0e96 0A43     		orrs	r2, r2, r1
 2470 0e98 1A61     		str	r2, [r3, #16]
 2471 0e9a 0DE0     		b	.L105
 2472              	.L106:
1565:../src/stm32f30x_rcc.c ****   }
1566:../src/stm32f30x_rcc.c ****   else
1567:../src/stm32f30x_rcc.c ****   {
1568:../src/stm32f30x_rcc.c ****     RCC->APB1RSTR &= ~RCC_APB1Periph;
 2473              		.loc 1 1568 0
 2474 0e9c 4FF48053 		mov	r3, #4096
 2475 0ea0 C4F20203 		movt	r3, 16386
 2476 0ea4 4FF48052 		mov	r2, #4096
 2477 0ea8 C4F20202 		movt	r2, 16386
 2478 0eac 1169     		ldr	r1, [r2, #16]
 2479 0eae 7A68     		ldr	r2, [r7, #4]
 2480 0eb0 6FEA0202 		mvn	r2, r2
 2481 0eb4 0A40     		ands	r2, r2, r1
 2482 0eb6 1A61     		str	r2, [r3, #16]
 2483              	.L105:
1569:../src/stm32f30x_rcc.c ****   }
1570:../src/stm32f30x_rcc.c **** }
 2484              		.loc 1 1570 0
 2485 0eb8 07F10C07 		add	r7, r7, #12
 2486 0ebc BD46     		mov	sp, r7
 2487 0ebe 80BC     		pop	{r7}
 2488 0ec0 7047     		bx	lr
 2489              		.cfi_endproc
 2490              	.LFE144:
 2492 0ec2 00BF     		.align	2
 2493              		.global	RCC_ITConfig
 2494              		.thumb
 2495              		.thumb_func
 2497              	RCC_ITConfig:
 2498              	.LFB145:
1571:../src/stm32f30x_rcc.c **** 
1572:../src/stm32f30x_rcc.c **** /**
1573:../src/stm32f30x_rcc.c ****   * @}
1574:../src/stm32f30x_rcc.c ****   */
1575:../src/stm32f30x_rcc.c **** 
1576:../src/stm32f30x_rcc.c **** /** @defgroup RCC_Group4 Interrupts and flags management functions
1577:../src/stm32f30x_rcc.c ****  *  @brief   Interrupts and flags management functions 
1578:../src/stm32f30x_rcc.c ****  *
1579:../src/stm32f30x_rcc.c **** @verbatim   
1580:../src/stm32f30x_rcc.c ****  ===============================================================================
1581:../src/stm32f30x_rcc.c ****             ##### Interrupts and flags management functions #####
1582:../src/stm32f30x_rcc.c ****  ===============================================================================  
1583:../src/stm32f30x_rcc.c **** 
1584:../src/stm32f30x_rcc.c **** @endverbatim
1585:../src/stm32f30x_rcc.c ****   * @{
1586:../src/stm32f30x_rcc.c ****   */
1587:../src/stm32f30x_rcc.c **** 
1588:../src/stm32f30x_rcc.c **** /**
1589:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the specified RCC interrupts.
1590:../src/stm32f30x_rcc.c ****   * @note   The CSS interrupt doesn't have an enable bit; once the CSS is enabled
1591:../src/stm32f30x_rcc.c ****   *         and if the HSE clock fails, the CSS interrupt occurs and an NMI is
1592:../src/stm32f30x_rcc.c ****   *         automatically generated. The NMI will be executed indefinitely, and 
1593:../src/stm32f30x_rcc.c ****   *         since NMI has higher priority than any other IRQ (and main program)
1594:../src/stm32f30x_rcc.c ****   *         the application will be stacked in the NMI ISR unless the CSS interrupt
1595:../src/stm32f30x_rcc.c ****   *         pending bit is cleared.
1596:../src/stm32f30x_rcc.c ****   * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
1597:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1598:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_LSIRDY: LSI ready interrupt
1599:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_LSERDY: LSE ready interrupt
1600:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_HSIRDY: HSI ready interrupt
1601:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_HSERDY: HSE ready interrupt
1602:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_PLLRDY: PLL ready interrupt
1603:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the specified RCC interrupts.
1604:../src/stm32f30x_rcc.c ****   *   This parameter can be: ENABLE or DISABLE.
1605:../src/stm32f30x_rcc.c ****   * @retval None
1606:../src/stm32f30x_rcc.c ****   */
1607:../src/stm32f30x_rcc.c **** void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
1608:../src/stm32f30x_rcc.c **** {
 2499              		.loc 1 1608 0
 2500              		.cfi_startproc
 2501              		@ args = 0, pretend = 0, frame = 8
 2502              		@ frame_needed = 1, uses_anonymous_args = 0
 2503              		@ link register save eliminated.
 2504 0ec4 80B4     		push	{r7}
 2505              	.LCFI100:
 2506              		.cfi_def_cfa_offset 4
 2507              		.cfi_offset 7, -4
 2508 0ec6 83B0     		sub	sp, sp, #12
 2509              	.LCFI101:
 2510              		.cfi_def_cfa_offset 16
 2511 0ec8 00AF     		add	r7, sp, #0
 2512              	.LCFI102:
 2513              		.cfi_def_cfa_register 7
 2514 0eca 0246     		mov	r2, r0
 2515 0ecc 0B46     		mov	r3, r1
 2516 0ece FA71     		strb	r2, [r7, #7]
 2517 0ed0 BB71     		strb	r3, [r7, #6]
1609:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1610:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_IT(RCC_IT));
1611:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1612:../src/stm32f30x_rcc.c ****   
1613:../src/stm32f30x_rcc.c ****   if (NewState != DISABLE)
 2518              		.loc 1 1613 0
 2519 0ed2 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 2520 0ed4 002B     		cmp	r3, #0
 2521 0ed6 0ED0     		beq	.L109
1614:../src/stm32f30x_rcc.c ****   {
1615:../src/stm32f30x_rcc.c ****     /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
1616:../src/stm32f30x_rcc.c ****     *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 2522              		.loc 1 1616 0
 2523 0ed8 41F20903 		movw	r3, #4105
 2524 0edc C4F20203 		movt	r3, 16386
 2525 0ee0 41F20902 		movw	r2, #4105
 2526 0ee4 C4F20202 		movt	r2, 16386
 2527 0ee8 1278     		ldrb	r2, [r2, #0]
 2528 0eea D1B2     		uxtb	r1, r2
 2529 0eec FA79     		ldrb	r2, [r7, #7]
 2530 0eee 0A43     		orrs	r2, r2, r1
 2531 0ef0 D2B2     		uxtb	r2, r2
 2532 0ef2 1A70     		strb	r2, [r3, #0]
 2533 0ef4 10E0     		b	.L108
 2534              	.L109:
1617:../src/stm32f30x_rcc.c ****   }
1618:../src/stm32f30x_rcc.c ****   else
1619:../src/stm32f30x_rcc.c ****   {
1620:../src/stm32f30x_rcc.c ****     /* Perform Byte access to RCC_CIR[13:8] bits to disable the selected interrupts */
1621:../src/stm32f30x_rcc.c ****     *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 2535              		.loc 1 1621 0
 2536 0ef6 41F20903 		movw	r3, #4105
 2537 0efa C4F20203 		movt	r3, 16386
 2538 0efe 41F20902 		movw	r2, #4105
 2539 0f02 C4F20202 		movt	r2, 16386
 2540 0f06 1278     		ldrb	r2, [r2, #0]
 2541 0f08 D1B2     		uxtb	r1, r2
 2542 0f0a FA79     		ldrb	r2, [r7, #7]
 2543 0f0c 6FEA0202 		mvn	r2, r2
 2544 0f10 D2B2     		uxtb	r2, r2
 2545 0f12 0A40     		ands	r2, r2, r1
 2546 0f14 D2B2     		uxtb	r2, r2
 2547 0f16 1A70     		strb	r2, [r3, #0]
 2548              	.L108:
1622:../src/stm32f30x_rcc.c ****   }
1623:../src/stm32f30x_rcc.c **** }
 2549              		.loc 1 1623 0
 2550 0f18 07F10C07 		add	r7, r7, #12
 2551 0f1c BD46     		mov	sp, r7
 2552 0f1e 80BC     		pop	{r7}
 2553 0f20 7047     		bx	lr
 2554              		.cfi_endproc
 2555              	.LFE145:
 2557 0f22 00BF     		.align	2
 2558              		.global	RCC_GetFlagStatus
 2559              		.thumb
 2560              		.thumb_func
 2562              	RCC_GetFlagStatus:
 2563              	.LFB146:
1624:../src/stm32f30x_rcc.c **** 
1625:../src/stm32f30x_rcc.c **** /**
1626:../src/stm32f30x_rcc.c ****   * @brief  Checks whether the specified RCC flag is set or not.
1627:../src/stm32f30x_rcc.c ****   * @param  RCC_FLAG: specifies the flag to check.
1628:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1629:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready  
1630:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
1631:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_PLLRDY: PLL clock ready
1632:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_MCOF: MCO Flag  
1633:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
1634:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
1635:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_OBLRST: Option Byte Loader (OBL) reset 
1636:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_PINRST: Pin reset
1637:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_PORRST: POR/PDR reset
1638:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_SFTRST: Software reset
1639:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
1640:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
1641:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_LPWRRST: Low Power reset
1642:../src/stm32f30x_rcc.c ****   * @retval The new state of RCC_FLAG (SET or RESET).
1643:../src/stm32f30x_rcc.c ****   */
1644:../src/stm32f30x_rcc.c **** FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
1645:../src/stm32f30x_rcc.c **** {
 2564              		.loc 1 1645 0
 2565              		.cfi_startproc
 2566              		@ args = 0, pretend = 0, frame = 24
 2567              		@ frame_needed = 1, uses_anonymous_args = 0
 2568              		@ link register save eliminated.
 2569 0f24 80B4     		push	{r7}
 2570              	.LCFI103:
 2571              		.cfi_def_cfa_offset 4
 2572              		.cfi_offset 7, -4
 2573 0f26 87B0     		sub	sp, sp, #28
 2574              	.LCFI104:
 2575              		.cfi_def_cfa_offset 32
 2576 0f28 00AF     		add	r7, sp, #0
 2577              	.LCFI105:
 2578              		.cfi_def_cfa_register 7
 2579 0f2a 0346     		mov	r3, r0
 2580 0f2c FB71     		strb	r3, [r7, #7]
1646:../src/stm32f30x_rcc.c ****   uint32_t tmp = 0;
 2581              		.loc 1 1646 0
 2582 0f2e 4FF00003 		mov	r3, #0
 2583 0f32 FB60     		str	r3, [r7, #12]
1647:../src/stm32f30x_rcc.c ****   uint32_t statusreg = 0;
 2584              		.loc 1 1647 0
 2585 0f34 4FF00003 		mov	r3, #0
 2586 0f38 7B61     		str	r3, [r7, #20]
1648:../src/stm32f30x_rcc.c ****   FlagStatus bitstatus = RESET;
 2587              		.loc 1 1648 0
 2588 0f3a 4FF00003 		mov	r3, #0
 2589 0f3e FB74     		strb	r3, [r7, #19]
1649:../src/stm32f30x_rcc.c **** 
1650:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1651:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_FLAG(RCC_FLAG));
1652:../src/stm32f30x_rcc.c **** 
1653:../src/stm32f30x_rcc.c ****   /* Get the RCC register index */
1654:../src/stm32f30x_rcc.c ****   tmp = RCC_FLAG >> 5;
 2590              		.loc 1 1654 0
 2591 0f40 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2592 0f42 4FEA5313 		lsr	r3, r3, #5
 2593 0f46 DBB2     		uxtb	r3, r3
 2594 0f48 FB60     		str	r3, [r7, #12]
1655:../src/stm32f30x_rcc.c **** 
1656:../src/stm32f30x_rcc.c ****    if (tmp == 0)               /* The flag to check is in CR register */
 2595              		.loc 1 1656 0
 2596 0f4a FB68     		ldr	r3, [r7, #12]
 2597 0f4c 002B     		cmp	r3, #0
 2598 0f4e 06D1     		bne	.L112
1657:../src/stm32f30x_rcc.c ****   {
1658:../src/stm32f30x_rcc.c ****     statusreg = RCC->CR;
 2599              		.loc 1 1658 0
 2600 0f50 4FF48053 		mov	r3, #4096
 2601 0f54 C4F20203 		movt	r3, 16386
 2602 0f58 1B68     		ldr	r3, [r3, #0]
 2603 0f5a 7B61     		str	r3, [r7, #20]
 2604 0f5c 19E0     		b	.L113
 2605              	.L112:
1659:../src/stm32f30x_rcc.c ****   }
1660:../src/stm32f30x_rcc.c ****   else if (tmp == 1)          /* The flag to check is in BDCR register */
 2606              		.loc 1 1660 0
 2607 0f5e FB68     		ldr	r3, [r7, #12]
 2608 0f60 012B     		cmp	r3, #1
 2609 0f62 06D1     		bne	.L114
1661:../src/stm32f30x_rcc.c ****   {
1662:../src/stm32f30x_rcc.c ****     statusreg = RCC->BDCR;
 2610              		.loc 1 1662 0
 2611 0f64 4FF48053 		mov	r3, #4096
 2612 0f68 C4F20203 		movt	r3, 16386
 2613 0f6c 1B6A     		ldr	r3, [r3, #32]
 2614 0f6e 7B61     		str	r3, [r7, #20]
 2615 0f70 0FE0     		b	.L113
 2616              	.L114:
1663:../src/stm32f30x_rcc.c ****   }
1664:../src/stm32f30x_rcc.c ****   else if (tmp == 4)          /* The flag to check is in CFGR register */
 2617              		.loc 1 1664 0
 2618 0f72 FB68     		ldr	r3, [r7, #12]
 2619 0f74 042B     		cmp	r3, #4
 2620 0f76 06D1     		bne	.L115
1665:../src/stm32f30x_rcc.c ****   {
1666:../src/stm32f30x_rcc.c ****     statusreg = RCC->CFGR;
 2621              		.loc 1 1666 0
 2622 0f78 4FF48053 		mov	r3, #4096
 2623 0f7c C4F20203 		movt	r3, 16386
 2624 0f80 5B68     		ldr	r3, [r3, #4]
 2625 0f82 7B61     		str	r3, [r7, #20]
 2626 0f84 05E0     		b	.L113
 2627              	.L115:
1667:../src/stm32f30x_rcc.c ****   }
1668:../src/stm32f30x_rcc.c ****   else                       /* The flag to check is in CSR register */
1669:../src/stm32f30x_rcc.c ****   {
1670:../src/stm32f30x_rcc.c ****     statusreg = RCC->CSR;
 2628              		.loc 1 1670 0
 2629 0f86 4FF48053 		mov	r3, #4096
 2630 0f8a C4F20203 		movt	r3, 16386
 2631 0f8e 5B6A     		ldr	r3, [r3, #36]
 2632 0f90 7B61     		str	r3, [r7, #20]
 2633              	.L113:
1671:../src/stm32f30x_rcc.c ****   }
1672:../src/stm32f30x_rcc.c **** 
1673:../src/stm32f30x_rcc.c ****   /* Get the flag position */
1674:../src/stm32f30x_rcc.c ****   tmp = RCC_FLAG & FLAG_MASK;
 2634              		.loc 1 1674 0
 2635 0f92 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2636 0f94 03F01F03 		and	r3, r3, #31
 2637 0f98 FB60     		str	r3, [r7, #12]
1675:../src/stm32f30x_rcc.c **** 
1676:../src/stm32f30x_rcc.c ****   if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 2638              		.loc 1 1676 0
 2639 0f9a FB68     		ldr	r3, [r7, #12]
 2640 0f9c 7A69     		ldr	r2, [r7, #20]
 2641 0f9e 22FA03F3 		lsr	r3, r2, r3
 2642 0fa2 03F00103 		and	r3, r3, #1
 2643 0fa6 002B     		cmp	r3, #0
 2644 0fa8 03D0     		beq	.L116
1677:../src/stm32f30x_rcc.c ****   {
1678:../src/stm32f30x_rcc.c ****     bitstatus = SET;
 2645              		.loc 1 1678 0
 2646 0faa 4FF00103 		mov	r3, #1
 2647 0fae FB74     		strb	r3, [r7, #19]
 2648 0fb0 02E0     		b	.L117
 2649              	.L116:
1679:../src/stm32f30x_rcc.c ****   }
1680:../src/stm32f30x_rcc.c ****   else
1681:../src/stm32f30x_rcc.c ****   {
1682:../src/stm32f30x_rcc.c ****     bitstatus = RESET;
 2650              		.loc 1 1682 0
 2651 0fb2 4FF00003 		mov	r3, #0
 2652 0fb6 FB74     		strb	r3, [r7, #19]
 2653              	.L117:
1683:../src/stm32f30x_rcc.c ****   }
1684:../src/stm32f30x_rcc.c ****   /* Return the flag status */
1685:../src/stm32f30x_rcc.c ****   return bitstatus;
 2654              		.loc 1 1685 0
 2655 0fb8 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
1686:../src/stm32f30x_rcc.c **** }
 2656              		.loc 1 1686 0
 2657 0fba 1846     		mov	r0, r3
 2658 0fbc 07F11C07 		add	r7, r7, #28
 2659 0fc0 BD46     		mov	sp, r7
 2660 0fc2 80BC     		pop	{r7}
 2661 0fc4 7047     		bx	lr
 2662              		.cfi_endproc
 2663              	.LFE146:
 2665 0fc6 00BF     		.align	2
 2666              		.global	RCC_ClearFlag
 2667              		.thumb
 2668              		.thumb_func
 2670              	RCC_ClearFlag:
 2671              	.LFB147:
1687:../src/stm32f30x_rcc.c **** 
1688:../src/stm32f30x_rcc.c **** /**
1689:../src/stm32f30x_rcc.c ****   * @brief  Clears the RCC reset flags.
1690:../src/stm32f30x_rcc.c ****   *         The reset flags are: RCC_FLAG_OBLRST, RCC_FLAG_PINRST, RCC_FLAG_PORRST, 
1691:../src/stm32f30x_rcc.c ****   *         RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST.
1692:../src/stm32f30x_rcc.c ****   * @param  None
1693:../src/stm32f30x_rcc.c ****   * @retval None
1694:../src/stm32f30x_rcc.c ****   */
1695:../src/stm32f30x_rcc.c **** void RCC_ClearFlag(void)
1696:../src/stm32f30x_rcc.c **** {
 2672              		.loc 1 1696 0
 2673              		.cfi_startproc
 2674              		@ args = 0, pretend = 0, frame = 0
 2675              		@ frame_needed = 1, uses_anonymous_args = 0
 2676              		@ link register save eliminated.
 2677 0fc8 80B4     		push	{r7}
 2678              	.LCFI106:
 2679              		.cfi_def_cfa_offset 4
 2680              		.cfi_offset 7, -4
 2681 0fca 00AF     		add	r7, sp, #0
 2682              	.LCFI107:
 2683              		.cfi_def_cfa_register 7
1697:../src/stm32f30x_rcc.c ****   /* Set RMVF bit to clear the reset flags */
1698:../src/stm32f30x_rcc.c ****   RCC->CSR |= RCC_CSR_RMVF;
 2684              		.loc 1 1698 0
 2685 0fcc 4FF48053 		mov	r3, #4096
 2686 0fd0 C4F20203 		movt	r3, 16386
 2687 0fd4 4FF48052 		mov	r2, #4096
 2688 0fd8 C4F20202 		movt	r2, 16386
 2689 0fdc 526A     		ldr	r2, [r2, #36]
 2690 0fde 42F08072 		orr	r2, r2, #16777216
 2691 0fe2 5A62     		str	r2, [r3, #36]
1699:../src/stm32f30x_rcc.c **** }
 2692              		.loc 1 1699 0
 2693 0fe4 BD46     		mov	sp, r7
 2694 0fe6 80BC     		pop	{r7}
 2695 0fe8 7047     		bx	lr
 2696              		.cfi_endproc
 2697              	.LFE147:
 2699 0fea 00BF     		.align	2
 2700              		.global	RCC_GetITStatus
 2701              		.thumb
 2702              		.thumb_func
 2704              	RCC_GetITStatus:
 2705              	.LFB148:
1700:../src/stm32f30x_rcc.c **** 
1701:../src/stm32f30x_rcc.c **** /**
1702:../src/stm32f30x_rcc.c ****   * @brief  Checks whether the specified RCC interrupt has occurred or not.
1703:../src/stm32f30x_rcc.c ****   * @param  RCC_IT: specifies the RCC interrupt source to check.
1704:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1705:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_LSIRDY: LSI ready interrupt
1706:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_LSERDY: LSE ready interrupt
1707:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_HSIRDY: HSI ready interrupt
1708:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_HSERDY: HSE ready interrupt
1709:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_PLLRDY: PLL ready interrupt
1710:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_CSS: Clock Security System interrupt
1711:../src/stm32f30x_rcc.c ****   * @retval The new state of RCC_IT (SET or RESET).
1712:../src/stm32f30x_rcc.c ****   */
1713:../src/stm32f30x_rcc.c **** ITStatus RCC_GetITStatus(uint8_t RCC_IT)
1714:../src/stm32f30x_rcc.c **** {
 2706              		.loc 1 1714 0
 2707              		.cfi_startproc
 2708              		@ args = 0, pretend = 0, frame = 16
 2709              		@ frame_needed = 1, uses_anonymous_args = 0
 2710              		@ link register save eliminated.
 2711 0fec 80B4     		push	{r7}
 2712              	.LCFI108:
 2713              		.cfi_def_cfa_offset 4
 2714              		.cfi_offset 7, -4
 2715 0fee 85B0     		sub	sp, sp, #20
 2716              	.LCFI109:
 2717              		.cfi_def_cfa_offset 24
 2718 0ff0 00AF     		add	r7, sp, #0
 2719              	.LCFI110:
 2720              		.cfi_def_cfa_register 7
 2721 0ff2 0346     		mov	r3, r0
 2722 0ff4 FB71     		strb	r3, [r7, #7]
1715:../src/stm32f30x_rcc.c ****   ITStatus bitstatus = RESET;
 2723              		.loc 1 1715 0
 2724 0ff6 4FF00003 		mov	r3, #0
 2725 0ffa FB73     		strb	r3, [r7, #15]
1716:../src/stm32f30x_rcc.c ****   
1717:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1718:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_GET_IT(RCC_IT));
1719:../src/stm32f30x_rcc.c ****   
1720:../src/stm32f30x_rcc.c ****   /* Check the status of the specified RCC interrupt */
1721:../src/stm32f30x_rcc.c ****   if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 2726              		.loc 1 1721 0
 2727 0ffc 4FF48053 		mov	r3, #4096
 2728 1000 C4F20203 		movt	r3, 16386
 2729 1004 9A68     		ldr	r2, [r3, #8]
 2730 1006 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2731 1008 1340     		ands	r3, r3, r2
 2732 100a 002B     		cmp	r3, #0
 2733 100c 03D0     		beq	.L121
1722:../src/stm32f30x_rcc.c ****   {
1723:../src/stm32f30x_rcc.c ****     bitstatus = SET;
 2734              		.loc 1 1723 0
 2735 100e 4FF00103 		mov	r3, #1
 2736 1012 FB73     		strb	r3, [r7, #15]
 2737 1014 02E0     		b	.L122
 2738              	.L121:
1724:../src/stm32f30x_rcc.c ****   }
1725:../src/stm32f30x_rcc.c ****   else
1726:../src/stm32f30x_rcc.c ****   {
1727:../src/stm32f30x_rcc.c ****     bitstatus = RESET;
 2739              		.loc 1 1727 0
 2740 1016 4FF00003 		mov	r3, #0
 2741 101a FB73     		strb	r3, [r7, #15]
 2742              	.L122:
1728:../src/stm32f30x_rcc.c ****   }
1729:../src/stm32f30x_rcc.c ****   /* Return the RCC_IT status */
1730:../src/stm32f30x_rcc.c ****   return  bitstatus;
 2743              		.loc 1 1730 0
 2744 101c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1731:../src/stm32f30x_rcc.c **** }
 2745              		.loc 1 1731 0
 2746 101e 1846     		mov	r0, r3
 2747 1020 07F11407 		add	r7, r7, #20
 2748 1024 BD46     		mov	sp, r7
 2749 1026 80BC     		pop	{r7}
 2750 1028 7047     		bx	lr
 2751              		.cfi_endproc
 2752              	.LFE148:
 2754 102a 00BF     		.align	2
 2755              		.global	RCC_ClearITPendingBit
 2756              		.thumb
 2757              		.thumb_func
 2759              	RCC_ClearITPendingBit:
 2760              	.LFB149:
1732:../src/stm32f30x_rcc.c **** 
1733:../src/stm32f30x_rcc.c **** /**
1734:../src/stm32f30x_rcc.c ****   * @brief  Clears the RCC's interrupt pending bits.
1735:../src/stm32f30x_rcc.c ****   * @param  RCC_IT: specifies the interrupt pending bit to clear.
1736:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1737:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_LSIRDY: LSI ready interrupt
1738:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_LSERDY: LSE ready interrupt
1739:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_HSIRDY: HSI ready interrupt
1740:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_HSERDY: HSE ready interrupt
1741:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_PLLRDY: PLL ready interrupt
1742:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_CSS: Clock Security System interrupt
1743:../src/stm32f30x_rcc.c ****   * @retval None
1744:../src/stm32f30x_rcc.c ****   */
1745:../src/stm32f30x_rcc.c **** void RCC_ClearITPendingBit(uint8_t RCC_IT)
1746:../src/stm32f30x_rcc.c **** {
 2761              		.loc 1 1746 0
 2762              		.cfi_startproc
 2763              		@ args = 0, pretend = 0, frame = 8
 2764              		@ frame_needed = 1, uses_anonymous_args = 0
 2765              		@ link register save eliminated.
 2766 102c 80B4     		push	{r7}
 2767              	.LCFI111:
 2768              		.cfi_def_cfa_offset 4
 2769              		.cfi_offset 7, -4
 2770 102e 83B0     		sub	sp, sp, #12
 2771              	.LCFI112:
 2772              		.cfi_def_cfa_offset 16
 2773 1030 00AF     		add	r7, sp, #0
 2774              	.LCFI113:
 2775              		.cfi_def_cfa_register 7
 2776 1032 0346     		mov	r3, r0
 2777 1034 FB71     		strb	r3, [r7, #7]
1747:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1748:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_CLEAR_IT(RCC_IT));
1749:../src/stm32f30x_rcc.c ****   
1750:../src/stm32f30x_rcc.c ****   /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
1751:../src/stm32f30x_rcc.c ****      pending bits */
1752:../src/stm32f30x_rcc.c ****   *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 2778              		.loc 1 1752 0
 2779 1036 41F20A03 		movw	r3, #4106
 2780 103a C4F20203 		movt	r3, 16386
 2781 103e FA79     		ldrb	r2, [r7, #7]
 2782 1040 1A70     		strb	r2, [r3, #0]
1753:../src/stm32f30x_rcc.c **** }
 2783              		.loc 1 1753 0
 2784 1042 07F10C07 		add	r7, r7, #12
 2785 1046 BD46     		mov	sp, r7
 2786 1048 80BC     		pop	{r7}
 2787 104a 7047     		bx	lr
 2788              		.cfi_endproc
 2789              	.LFE149:
 2791              	.Letext0:
 2792              		.file 2 "/home/aghosh01/gcc-arm-none-eabi-4_7-2012q4/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../.
 2793              		.file 3 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x.h"
 2794              		.file 4 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x_rcc.h"
 2795              		.file 5 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f30x_rcc.c
     /tmp/cc0e9h0P.s:20     .data:00000000 $d
     /tmp/cc0e9h0P.s:23     .data:00000000 APBAHBPrescTable
     /tmp/cc0e9h0P.s:43     .data:00000010 ADCPrescTable
     /tmp/cc0e9h0P.s:58     .text:00000000 $t
     /tmp/cc0e9h0P.s:63     .text:00000000 RCC_DeInit
     /tmp/cc0e9h0P.s:157    .text:000000d4 RCC_HSEConfig
     /tmp/cc0e9h0P.s:199    .text:00000104 RCC_WaitForHSEStartUp
     /tmp/cc0e9h0P.s:2562   .text:00000f24 RCC_GetFlagStatus
     /tmp/cc0e9h0P.s:273    .text:00000168 RCC_AdjustHSICalibrationValue
     /tmp/cc0e9h0P.s:328    .text:000001b0 RCC_HSICmd
     /tmp/cc0e9h0P.s:365    .text:000001d0 RCC_LSEConfig
     /tmp/cc0e9h0P.s:421    .text:0000022c RCC_LSEDriveConfig
     /tmp/cc0e9h0P.s:469    .text:00000270 RCC_LSICmd
     /tmp/cc0e9h0P.s:506    .text:00000290 RCC_PLLConfig
     /tmp/cc0e9h0P.s:557    .text:000002d8 RCC_PLLCmd
     /tmp/cc0e9h0P.s:594    .text:000002f8 RCC_PREDIV1Config
     /tmp/cc0e9h0P.s:647    .text:00000338 RCC_ClockSecuritySystemCmd
     /tmp/cc0e9h0P.s:684    .text:00000358 RCC_MCOConfig
     /tmp/cc0e9h0P.s:721    .text:00000378 RCC_SYSCLKConfig
     /tmp/cc0e9h0P.s:774    .text:000003b8 RCC_GetSYSCLKSource
     /tmp/cc0e9h0P.s:808    .text:000003d8 RCC_HCLKConfig
     /tmp/cc0e9h0P.s:861    .text:00000418 RCC_PCLK1Config
     /tmp/cc0e9h0P.s:914    .text:00000458 RCC_PCLK2Config
     /tmp/cc0e9h0P.s:968    .text:0000049c RCC_GetClocksFreq
     /tmp/cc0e9h0P.s:1627   .text:000009ec RCC_ADCCLKConfig
     /tmp/cc0e9h0P.s:1697   .text:00000a5c RCC_I2CCLKConfig
     /tmp/cc0e9h0P.s:1767   .text:00000acc RCC_TIMCLKConfig
     /tmp/cc0e9h0P.s:1837   .text:00000b3c RCC_USARTCLKConfig
     /tmp/cc0e9h0P.s:1871   .text:00000b64 $d
     /tmp/cc0e9h0P.s:1878   .text:00000b78 $t
     /tmp/cc0e9h0P.s:1957   .text:00000c20 RCC_USBCLKConfig
     /tmp/cc0e9h0P.s:1993   .text:00000c40 RCC_RTCCLKConfig
     /tmp/cc0e9h0P.s:2033   .text:00000c6c RCC_I2SCLKConfig
     /tmp/cc0e9h0P.s:2069   .text:00000c8c RCC_RTCCLKCmd
     /tmp/cc0e9h0P.s:2106   .text:00000cac RCC_BackupResetCmd
     /tmp/cc0e9h0P.s:2143   .text:00000ccc RCC_AHBPeriphClockCmd
     /tmp/cc0e9h0P.s:2202   .text:00000d20 RCC_APB2PeriphClockCmd
     /tmp/cc0e9h0P.s:2261   .text:00000d74 RCC_APB1PeriphClockCmd
     /tmp/cc0e9h0P.s:2320   .text:00000dc8 RCC_AHBPeriphResetCmd
     /tmp/cc0e9h0P.s:2379   .text:00000e1c RCC_APB2PeriphResetCmd
     /tmp/cc0e9h0P.s:2438   .text:00000e70 RCC_APB1PeriphResetCmd
     /tmp/cc0e9h0P.s:2497   .text:00000ec4 RCC_ITConfig
     /tmp/cc0e9h0P.s:2670   .text:00000fc8 RCC_ClearFlag
     /tmp/cc0e9h0P.s:2704   .text:00000fec RCC_GetITStatus
     /tmp/cc0e9h0P.s:2759   .text:0000102c RCC_ClearITPendingBit
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.323dce8664331a0daf4a2675e107c70c
                           .group:00000000 wm4.stm32f30x.h.56.6f19c65e98e3319a61449cb2b2455af5
                           .group:00000000 wm4.core_cm4.h.32.1434cd257ff5806b1b03cd32ab0641e9
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.core_cmInstr.h.25.d8165482ef3061013a2fc83e2d85f3d9
                           .group:00000000 wm4.core_cm4_simd.h.29.013e5bcf58dba2d27c60184174208e07
                           .group:00000000 wm4.core_cm4.h.155.cf7c793e178943e1bbf613f1b21cd51a
                           .group:00000000 wm4.stm32f30x.h.294.d8a54360eca16e4157694b52a095202d
                           .group:00000000 wm4.stm32f30x_adc.h.130.cbebad91f78fb87381fe0860eea6104e
                           .group:00000000 wm4.stm32f30x_can.h.50.8b8f5d301152c422a6e50622b33ef620
                           .group:00000000 wm4.stm32f30x_crc.h.54.66d4c5e565e18566aebd9abfd4bcd4b0
                           .group:00000000 wm4.stm32f30x_comp.h.91.06ae44150aaaa82c077b71df8db3541a
                           .group:00000000 wm4.stm32f30x_dac.h.49.b1b5b26e4ca241dbe67fa16dc86a615f
                           .group:00000000 wm4.stm32f30x_dbgmcu.h.53.b238a263ce6a2cc83f610cc35302a38b
                           .group:00000000 wm4.stm32f30x_dma.h.96.d7a2ddd10023e12781aa8ff5ac15d212
                           .group:00000000 wm4.stm32f30x_exti.h.60.8ca0809491a21dec6fc69cf7471e2bab
                           .group:00000000 wm4.stm32f30x_flash.h.70.32613455dfe7328932f786a224daac23
                           .group:00000000 wm4.stm32f30x_gpio.h.50.408e1f6250246e4cc28221970909d34c
                           .group:00000000 wm4.stm32f30x_syscfg.h.58.4cadeb4ec8e47d36b972bbb6b96b7161
                           .group:00000000 wm4.stm32f30x_i2c.h.86.3d51d4edc0e3b9ee9aae045ccbb7739a
                           .group:00000000 wm4.stm32f30x_iwdg.h.59.467d704fb073a015941f19b50fa6470a
                           .group:00000000 wm4.stm32f30x_opamp.h.75.704e2e5e2aab039de307aaa2dcc99fa5
                           .group:00000000 wm4.stm32f30x_pwr.h.59.5c85acff2a3e3c5085b2140c06025cfc
                           .group:00000000 wm4.stm32f30x_rtc.h.133.d184e08ff40bda44db4bed94f9633384
                           .group:00000000 wm4.stm32f30x_spi.h.119.4d21ec94ec14f3553a127e61c0a9874f
                           .group:00000000 wm4.stm32f30x_tim.h.175.d4a93cff2e7924577147254e501271b6
                           .group:00000000 wm4.stm32f30x_usart.h.110.c89016273702821ff4f9fe43881f70b5
                           .group:00000000 wm4.stm32f30x_wwdg.h.58.4688eee61a2709866472b4b4c07d9275
                           .group:00000000 wm4.stm32f30x_misc.h.113.6a52e4fe7c3825a3ab05990f30dddf92
                           .group:00000000 wm4.stm32f30x_rcc.h.79.5ba7cac1e74879861a72556c25322aa4

NO UNDEFINED SYMBOLS
