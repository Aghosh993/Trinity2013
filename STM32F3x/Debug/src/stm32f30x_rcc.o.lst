   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 6
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"stm32f30x_rcc.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.data
  21              		.align	2
  24              	APBAHBPrescTable:
  25 0000 00       		.byte	0
  26 0001 00       		.byte	0
  27 0002 00       		.byte	0
  28 0003 00       		.byte	0
  29 0004 01       		.byte	1
  30 0005 02       		.byte	2
  31 0006 03       		.byte	3
  32 0007 04       		.byte	4
  33 0008 01       		.byte	1
  34 0009 02       		.byte	2
  35 000a 03       		.byte	3
  36 000b 04       		.byte	4
  37 000c 06       		.byte	6
  38 000d 07       		.byte	7
  39 000e 08       		.byte	8
  40 000f 09       		.byte	9
  41              		.align	2
  44              	ADCPrescTable:
  45 0010 0000     		.short	0
  46 0012 0100     		.short	1
  47 0014 0200     		.short	2
  48 0016 0400     		.short	4
  49 0018 0600     		.short	6
  50 001a 0800     		.short	8
  51 001c 0A00     		.short	10
  52 001e 0C00     		.short	12
  53 0020 1000     		.short	16
  54 0022 2000     		.short	32
  55 0024 4000     		.short	64
  56 0026 8000     		.short	128
  57 0028 0001     		.short	256
  58 002a 0000     		.text
  59              		.align	2
  60              		.global	RCC_DeInit
  61              		.thumb
  62              		.thumb_func
  64              	RCC_DeInit:
  65              	.LFB111:
  66              		.file 1 "../src/stm32f30x_rcc.c"
   1:../src/stm32f30x_rcc.c **** /**
   2:../src/stm32f30x_rcc.c ****   ******************************************************************************
   3:../src/stm32f30x_rcc.c ****   * @file    stm32f30x_rcc.c
   4:../src/stm32f30x_rcc.c ****   * @author  MCD Application Team
   5:../src/stm32f30x_rcc.c ****   * @version V1.0.1
   6:../src/stm32f30x_rcc.c ****   * @date    23-October-2012
   7:../src/stm32f30x_rcc.c ****   * @brief   This file provides firmware functions to manage the following 
   8:../src/stm32f30x_rcc.c ****   *          functionalities of the Reset and clock control (RCC) peripheral:           
   9:../src/stm32f30x_rcc.c ****   *           + Internal/external clocks, PLL, CSS and MCO configuration
  10:../src/stm32f30x_rcc.c ****   *           + System, AHB and APB busses clocks configuration
  11:../src/stm32f30x_rcc.c ****   *           + Peripheral clocks configuration
  12:../src/stm32f30x_rcc.c ****   *           + Interrupts and flags management
  13:../src/stm32f30x_rcc.c ****   *
  14:../src/stm32f30x_rcc.c ****   @verbatim
  15:../src/stm32f30x_rcc.c ****                
  16:../src/stm32f30x_rcc.c ****  ===============================================================================
  17:../src/stm32f30x_rcc.c ****                       ##### RCC specific features #####
  18:../src/stm32f30x_rcc.c ****  ===============================================================================
  19:../src/stm32f30x_rcc.c ****     [..] After reset the device is running from HSI (8 MHz) with Flash 0 WS, 
  20:../src/stm32f30x_rcc.c ****          all peripherals are off except internal SRAM, Flash and SWD.
  21:../src/stm32f30x_rcc.c ****          (+) There is no prescaler on High speed (AHB) and Low speed (APB) busses;
  22:../src/stm32f30x_rcc.c ****              all peripherals mapped on these busses are running at HSI speed.
  23:../src/stm32f30x_rcc.c ****        	 (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
  24:../src/stm32f30x_rcc.c ****          (+) All GPIOs are in input floating state, except the SWD pins which
  25:../src/stm32f30x_rcc.c ****              are assigned to be used for debug purpose.
  26:../src/stm32f30x_rcc.c ****     [..] Once the device starts from reset, the user application has to:        
  27:../src/stm32f30x_rcc.c ****          (+) Configure the clock source to be used to drive the System clock
  28:../src/stm32f30x_rcc.c ****              (if the application needs higher frequency/performance).
  29:../src/stm32f30x_rcc.c ****          (+) Configure the System clock frequency and Flash settings.  
  30:../src/stm32f30x_rcc.c ****          (+) Configure the AHB and APB busses prescalers.
  31:../src/stm32f30x_rcc.c ****          (+) Enable the clock for the peripheral(s) to be used.
  32:../src/stm32f30x_rcc.c ****          (+) Configure the clock source(s) for peripherals which clocks are not
  33:../src/stm32f30x_rcc.c ****              derived from the System clock (ADC, TIM, I2C, USART, RTC and IWDG).      
  34:../src/stm32f30x_rcc.c ****                         
  35:../src/stm32f30x_rcc.c ****   @endverbatim
  36:../src/stm32f30x_rcc.c ****     
  37:../src/stm32f30x_rcc.c ****   ******************************************************************************
  38:../src/stm32f30x_rcc.c ****   * @attention
  39:../src/stm32f30x_rcc.c ****   *
  40:../src/stm32f30x_rcc.c ****   * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
  41:../src/stm32f30x_rcc.c ****   *
  42:../src/stm32f30x_rcc.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  43:../src/stm32f30x_rcc.c ****   * You may not use this file except in compliance with the License.
  44:../src/stm32f30x_rcc.c ****   * You may obtain a copy of the License at:
  45:../src/stm32f30x_rcc.c ****   *
  46:../src/stm32f30x_rcc.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  47:../src/stm32f30x_rcc.c ****   *
  48:../src/stm32f30x_rcc.c ****   * Unless required by applicable law or agreed to in writing, software 
  49:../src/stm32f30x_rcc.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  50:../src/stm32f30x_rcc.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  51:../src/stm32f30x_rcc.c ****   * See the License for the specific language governing permissions and
  52:../src/stm32f30x_rcc.c ****   * limitations under the License.
  53:../src/stm32f30x_rcc.c ****   *
  54:../src/stm32f30x_rcc.c ****   ******************************************************************************
  55:../src/stm32f30x_rcc.c ****   */
  56:../src/stm32f30x_rcc.c **** 
  57:../src/stm32f30x_rcc.c **** /* Includes ------------------------------------------------------------------*/
  58:../src/stm32f30x_rcc.c **** #include "stm32f30x_rcc.h"
  59:../src/stm32f30x_rcc.c **** 
  60:../src/stm32f30x_rcc.c **** /** @addtogroup STM32F30x_StdPeriph_Driver
  61:../src/stm32f30x_rcc.c ****   * @{
  62:../src/stm32f30x_rcc.c ****   */
  63:../src/stm32f30x_rcc.c **** 
  64:../src/stm32f30x_rcc.c **** /** @defgroup RCC 
  65:../src/stm32f30x_rcc.c ****   * @brief RCC driver modules
  66:../src/stm32f30x_rcc.c ****   * @{
  67:../src/stm32f30x_rcc.c ****   */ 
  68:../src/stm32f30x_rcc.c **** 
  69:../src/stm32f30x_rcc.c **** /* Private typedef -----------------------------------------------------------*/
  70:../src/stm32f30x_rcc.c **** /* Private define ------------------------------------------------------------*/
  71:../src/stm32f30x_rcc.c **** /* ------------ RCC registers bit address in the alias region ----------- */
  72:../src/stm32f30x_rcc.c **** #define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
  73:../src/stm32f30x_rcc.c **** 
  74:../src/stm32f30x_rcc.c **** /* --- CR Register ---*/
  75:../src/stm32f30x_rcc.c **** 
  76:../src/stm32f30x_rcc.c **** /* Alias word address of HSION bit */
  77:../src/stm32f30x_rcc.c **** #define CR_OFFSET                 (RCC_OFFSET + 0x00)
  78:../src/stm32f30x_rcc.c **** #define HSION_BitNumber           0x00
  79:../src/stm32f30x_rcc.c **** #define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
  80:../src/stm32f30x_rcc.c **** 
  81:../src/stm32f30x_rcc.c **** /* Alias word address of PLLON bit */
  82:../src/stm32f30x_rcc.c **** #define PLLON_BitNumber           0x18
  83:../src/stm32f30x_rcc.c **** #define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
  84:../src/stm32f30x_rcc.c **** 
  85:../src/stm32f30x_rcc.c **** /* Alias word address of CSSON bit */
  86:../src/stm32f30x_rcc.c **** #define CSSON_BitNumber           0x13
  87:../src/stm32f30x_rcc.c **** #define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
  88:../src/stm32f30x_rcc.c **** 
  89:../src/stm32f30x_rcc.c **** /* --- CFGR Register ---*/
  90:../src/stm32f30x_rcc.c **** /* Alias word address of USBPRE bit */
  91:../src/stm32f30x_rcc.c **** #define CFGR_OFFSET               (RCC_OFFSET + 0x04)
  92:../src/stm32f30x_rcc.c **** #define USBPRE_BitNumber          0x16
  93:../src/stm32f30x_rcc.c **** #define CFGR_USBPRE_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (USBPRE_BitNumber * 4))
  94:../src/stm32f30x_rcc.c **** /* Alias word address of I2SSRC bit */
  95:../src/stm32f30x_rcc.c **** #define I2SSRC_BitNumber          0x17
  96:../src/stm32f30x_rcc.c **** #define CFGR_I2SSRC_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (I2SSRC_BitNumber * 4))
  97:../src/stm32f30x_rcc.c **** 
  98:../src/stm32f30x_rcc.c **** /* --- BDCR Register ---*/
  99:../src/stm32f30x_rcc.c **** 
 100:../src/stm32f30x_rcc.c **** /* Alias word address of RTCEN bit */
 101:../src/stm32f30x_rcc.c **** #define BDCR_OFFSET               (RCC_OFFSET + 0x20)
 102:../src/stm32f30x_rcc.c **** #define RTCEN_BitNumber           0x0F
 103:../src/stm32f30x_rcc.c **** #define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
 104:../src/stm32f30x_rcc.c **** 
 105:../src/stm32f30x_rcc.c **** /* Alias word address of BDRST bit */
 106:../src/stm32f30x_rcc.c **** #define BDRST_BitNumber           0x10
 107:../src/stm32f30x_rcc.c **** #define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
 108:../src/stm32f30x_rcc.c **** 
 109:../src/stm32f30x_rcc.c **** /* --- CSR Register ---*/
 110:../src/stm32f30x_rcc.c **** 
 111:../src/stm32f30x_rcc.c **** /* Alias word address of LSION bit */
 112:../src/stm32f30x_rcc.c **** #define CSR_OFFSET                (RCC_OFFSET + 0x24)
 113:../src/stm32f30x_rcc.c **** #define LSION_BitNumber           0x00
 114:../src/stm32f30x_rcc.c **** #define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
 115:../src/stm32f30x_rcc.c **** 
 116:../src/stm32f30x_rcc.c **** /* ---------------------- RCC registers bit mask ------------------------ */
 117:../src/stm32f30x_rcc.c **** /* RCC Flag Mask */
 118:../src/stm32f30x_rcc.c **** #define FLAG_MASK                 ((uint8_t)0x1F)
 119:../src/stm32f30x_rcc.c **** 
 120:../src/stm32f30x_rcc.c **** /* CFGR register byte 3 (Bits[31:23]) base address */
 121:../src/stm32f30x_rcc.c **** #define CFGR_BYTE3_ADDRESS        ((uint32_t)0x40021007)
 122:../src/stm32f30x_rcc.c **** 
 123:../src/stm32f30x_rcc.c **** /* CIR register byte 2 (Bits[15:8]) base address */
 124:../src/stm32f30x_rcc.c **** #define CIR_BYTE2_ADDRESS         ((uint32_t)0x40021009)
 125:../src/stm32f30x_rcc.c **** 
 126:../src/stm32f30x_rcc.c **** /* CIR register byte 3 (Bits[23:16]) base address */
 127:../src/stm32f30x_rcc.c **** #define CIR_BYTE3_ADDRESS         ((uint32_t)0x4002100A)
 128:../src/stm32f30x_rcc.c **** 
 129:../src/stm32f30x_rcc.c **** /* CR register byte 2 (Bits[23:16]) base address */
 130:../src/stm32f30x_rcc.c **** #define CR_BYTE2_ADDRESS          ((uint32_t)0x40021002)
 131:../src/stm32f30x_rcc.c **** 
 132:../src/stm32f30x_rcc.c **** /* Private macro -------------------------------------------------------------*/
 133:../src/stm32f30x_rcc.c **** /* Private variables ---------------------------------------------------------*/
 134:../src/stm32f30x_rcc.c **** static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
 135:../src/stm32f30x_rcc.c **** static __I uint16_t ADCPrescTable[13] = {0, 1, 2, 4, 6, 8, 10, 12, 16, 32, 64, 128, 256};
 136:../src/stm32f30x_rcc.c **** 
 137:../src/stm32f30x_rcc.c **** /* Private function prototypes -----------------------------------------------*/
 138:../src/stm32f30x_rcc.c **** /* Private functions ---------------------------------------------------------*/
 139:../src/stm32f30x_rcc.c **** 
 140:../src/stm32f30x_rcc.c **** /** @defgroup RCC_Private_Functions
 141:../src/stm32f30x_rcc.c ****   * @{
 142:../src/stm32f30x_rcc.c ****   */
 143:../src/stm32f30x_rcc.c **** 
 144:../src/stm32f30x_rcc.c **** /** @defgroup RCC_Group1 Internal and external clocks, PLL, CSS and MCO configuration functions
 145:../src/stm32f30x_rcc.c ****  *  @brief   Internal and external clocks, PLL, CSS and MCO configuration functions 
 146:../src/stm32f30x_rcc.c ****  *
 147:../src/stm32f30x_rcc.c **** @verbatim   
 148:../src/stm32f30x_rcc.c ****  ===============================================================================
 149:../src/stm32f30x_rcc.c ****  ##### Internal-external clocks, PLL, CSS and MCO configuration functions #####
 150:../src/stm32f30x_rcc.c ****  ===============================================================================  
 151:../src/stm32f30x_rcc.c ****     [..] This section provides functions allowing to configure the internal/external 
 152:../src/stm32f30x_rcc.c ****          clocks, PLL, CSS and MCO.
 153:../src/stm32f30x_rcc.c ****          (#) HSI (high-speed internal), 8 MHz factory-trimmed RC used directly 
 154:../src/stm32f30x_rcc.c ****              or through the PLL as System clock source.
 155:../src/stm32f30x_rcc.c ****              The HSI clock can be used also to clock the USART and I2C peripherals.
 156:../src/stm32f30x_rcc.c ****          (#) LSI (low-speed internal), 40 KHz low consumption RC used as IWDG and/or RTC
 157:../src/stm32f30x_rcc.c ****              clock source.
 158:../src/stm32f30x_rcc.c ****          (#) HSE (high-speed external), 4 to 32 MHz crystal oscillator used directly or
 159:../src/stm32f30x_rcc.c ****              through the PLL as System clock source. Can be used also as RTC clock source.
 160:../src/stm32f30x_rcc.c ****          (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.
 161:../src/stm32f30x_rcc.c ****              LSE can be used also to clock the USART peripherals.
 162:../src/stm32f30x_rcc.c ****          (#) PLL (clocked by HSI or HSE), for System clock.
 163:../src/stm32f30x_rcc.c ****          (#) CSS (Clock security system), once enabled and if a HSE clock failure occurs 
 164:../src/stm32f30x_rcc.c ****              (HSE used directly or through PLL as System clock source), the System clock
 165:../src/stm32f30x_rcc.c ****              is automatically switched to HSI and an interrupt is generated if enabled. 
 166:../src/stm32f30x_rcc.c ****              The interrupt is linked to the Cortex-M4 NMI (Non-Maskable Interrupt) 
 167:../src/stm32f30x_rcc.c ****              exception vector.   
 168:../src/stm32f30x_rcc.c ****          (#) MCO (microcontroller clock output), used to output SYSCLK, HSI, HSE, LSI, LSE,
 169:../src/stm32f30x_rcc.c ****              PLL clock on PA8 pin.
 170:../src/stm32f30x_rcc.c **** 
 171:../src/stm32f30x_rcc.c **** @endverbatim
 172:../src/stm32f30x_rcc.c ****   * @{
 173:../src/stm32f30x_rcc.c ****   */
 174:../src/stm32f30x_rcc.c **** 
 175:../src/stm32f30x_rcc.c **** /**
 176:../src/stm32f30x_rcc.c ****   * @brief  Resets the RCC clock configuration to the default reset state.
 177:../src/stm32f30x_rcc.c ****   * @note   The default reset state of the clock configuration is given below:
 178:../src/stm32f30x_rcc.c ****   * @note     HSI ON and used as system clock source 
 179:../src/stm32f30x_rcc.c ****   * @note     HSE and PLL OFF
 180:../src/stm32f30x_rcc.c ****   * @note     AHB, APB1 and APB2 prescalers set to 1.
 181:../src/stm32f30x_rcc.c ****   * @note     CSS and MCO OFF
 182:../src/stm32f30x_rcc.c ****   * @note     All interrupts disabled
 183:../src/stm32f30x_rcc.c ****   * @note   However, this function doesn't modify the configuration of the
 184:../src/stm32f30x_rcc.c ****   * @note     Peripheral clocks
 185:../src/stm32f30x_rcc.c ****   * @note     LSI, LSE and RTC clocks                  
 186:../src/stm32f30x_rcc.c ****   * @param  None
 187:../src/stm32f30x_rcc.c ****   * @retval None
 188:../src/stm32f30x_rcc.c ****   */
 189:../src/stm32f30x_rcc.c **** void RCC_DeInit(void)
 190:../src/stm32f30x_rcc.c **** {
  67              		.loc 1 190 0
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 0
  70              		@ frame_needed = 1, uses_anonymous_args = 0
  71              		@ link register save eliminated.
  72 0000 80B4     		push	{r7}
  73              	.LCFI0:
  74              		.cfi_def_cfa_offset 4
  75              		.cfi_offset 7, -4
  76 0002 00AF     		add	r7, sp, #0
  77              	.LCFI1:
  78              		.cfi_def_cfa_register 7
 191:../src/stm32f30x_rcc.c ****   /* Set HSION bit */
 192:../src/stm32f30x_rcc.c ****   RCC->CR |= (uint32_t)0x00000001;
  79              		.loc 1 192 0
  80 0004 4FF48053 		mov	r3, #4096
  81 0008 C4F20203 		movt	r3, 16386
  82 000c 4FF48052 		mov	r2, #4096
  83 0010 C4F20202 		movt	r2, 16386
  84 0014 1268     		ldr	r2, [r2, #0]
  85 0016 42F00102 		orr	r2, r2, #1
  86 001a 1A60     		str	r2, [r3, #0]
 193:../src/stm32f30x_rcc.c **** 
 194:../src/stm32f30x_rcc.c ****   /* Reset SW[1:0], HPRE[3:0], PPRE[2:0] and MCOSEL[2:0] bits */
 195:../src/stm32f30x_rcc.c ****   RCC->CFGR &= (uint32_t)0xF8FFC000;
  87              		.loc 1 195 0
  88 001c 4FF48052 		mov	r2, #4096
  89 0020 C4F20202 		movt	r2, 16386
  90 0024 4FF48053 		mov	r3, #4096
  91 0028 C4F20203 		movt	r3, 16386
  92 002c 5968     		ldr	r1, [r3, #4]
  93 002e 4FF44043 		mov	r3, #49152
  94 0032 CFF6FF03 		movt	r3, 63743
  95 0036 0B40     		ands	r3, r3, r1
  96 0038 5360     		str	r3, [r2, #4]
 196:../src/stm32f30x_rcc.c ****   
 197:../src/stm32f30x_rcc.c ****   /* Reset HSEON, CSSON and PLLON bits */
 198:../src/stm32f30x_rcc.c ****   RCC->CR &= (uint32_t)0xFEF6FFFF;
  97              		.loc 1 198 0
  98 003a 4FF48053 		mov	r3, #4096
  99 003e C4F20203 		movt	r3, 16386
 100 0042 4FF48052 		mov	r2, #4096
 101 0046 C4F20202 		movt	r2, 16386
 102 004a 1268     		ldr	r2, [r2, #0]
 103 004c 22F08472 		bic	r2, r2, #17301504
 104 0050 22F48032 		bic	r2, r2, #65536
 105 0054 1A60     		str	r2, [r3, #0]
 199:../src/stm32f30x_rcc.c **** 
 200:../src/stm32f30x_rcc.c ****   /* Reset HSEBYP bit */
 201:../src/stm32f30x_rcc.c ****   RCC->CR &= (uint32_t)0xFFFBFFFF;
 106              		.loc 1 201 0
 107 0056 4FF48053 		mov	r3, #4096
 108 005a C4F20203 		movt	r3, 16386
 109 005e 4FF48052 		mov	r2, #4096
 110 0062 C4F20202 		movt	r2, 16386
 111 0066 1268     		ldr	r2, [r2, #0]
 112 0068 22F48022 		bic	r2, r2, #262144
 113 006c 1A60     		str	r2, [r3, #0]
 202:../src/stm32f30x_rcc.c **** 
 203:../src/stm32f30x_rcc.c ****   /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE bits */
 204:../src/stm32f30x_rcc.c ****   RCC->CFGR &= (uint32_t)0xFF80FFFF;
 114              		.loc 1 204 0
 115 006e 4FF48053 		mov	r3, #4096
 116 0072 C4F20203 		movt	r3, 16386
 117 0076 4FF48052 		mov	r2, #4096
 118 007a C4F20202 		movt	r2, 16386
 119 007e 5268     		ldr	r2, [r2, #4]
 120 0080 22F4FE02 		bic	r2, r2, #8323072
 121 0084 5A60     		str	r2, [r3, #4]
 205:../src/stm32f30x_rcc.c **** 
 206:../src/stm32f30x_rcc.c ****   /* Reset PREDIV1[3:0] and ADCPRE[13:4] bits */
 207:../src/stm32f30x_rcc.c ****   RCC->CFGR2 &= (uint32_t)0xFFFFC000;
 122              		.loc 1 207 0
 123 0086 4FF48053 		mov	r3, #4096
 124 008a C4F20203 		movt	r3, 16386
 125 008e 4FF48052 		mov	r2, #4096
 126 0092 C4F20202 		movt	r2, 16386
 127 0096 D26A     		ldr	r2, [r2, #44]
 128 0098 22F47F52 		bic	r2, r2, #16320
 129 009c 22F03F02 		bic	r2, r2, #63
 130 00a0 DA62     		str	r2, [r3, #44]
 208:../src/stm32f30x_rcc.c **** 
 209:../src/stm32f30x_rcc.c ****   /* Reset USARTSW[1:0], I2CSW and TIMSW bits */
 210:../src/stm32f30x_rcc.c ****   RCC->CFGR3 &= (uint32_t)0xF00FCCC;
 131              		.loc 1 210 0
 132 00a2 4FF48052 		mov	r2, #4096
 133 00a6 C4F20202 		movt	r2, 16386
 134 00aa 4FF48053 		mov	r3, #4096
 135 00ae C4F20203 		movt	r3, 16386
 136 00b2 196B     		ldr	r1, [r3, #48]
 137 00b4 4FF6CC43 		movw	r3, #64716
 138 00b8 C0F60073 		movt	r3, 3840
 139 00bc 0B40     		ands	r3, r3, r1
 140 00be 1363     		str	r3, [r2, #48]
 211:../src/stm32f30x_rcc.c ****   
 212:../src/stm32f30x_rcc.c ****   /* Disable all interrupts */
 213:../src/stm32f30x_rcc.c ****   RCC->CIR = 0x00000000;
 141              		.loc 1 213 0
 142 00c0 4FF48053 		mov	r3, #4096
 143 00c4 C4F20203 		movt	r3, 16386
 144 00c8 4FF00002 		mov	r2, #0
 145 00cc 9A60     		str	r2, [r3, #8]
 214:../src/stm32f30x_rcc.c **** }
 146              		.loc 1 214 0
 147 00ce BD46     		mov	sp, r7
 148 00d0 80BC     		pop	{r7}
 149 00d2 7047     		bx	lr
 150              		.cfi_endproc
 151              	.LFE111:
 153              		.align	2
 154              		.global	RCC_HSEConfig
 155              		.thumb
 156              		.thumb_func
 158              	RCC_HSEConfig:
 159              	.LFB112:
 215:../src/stm32f30x_rcc.c **** 
 216:../src/stm32f30x_rcc.c **** /**
 217:../src/stm32f30x_rcc.c ****   * @brief  Configures the External High Speed oscillator (HSE).
 218:../src/stm32f30x_rcc.c ****   * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
 219:../src/stm32f30x_rcc.c ****   *         software should wait on HSERDY flag to be set indicating that HSE clock
 220:../src/stm32f30x_rcc.c ****   *         is stable and can be used to clock the PLL and/or system clock.
 221:../src/stm32f30x_rcc.c ****   * @note   HSE state can not be changed if it is used directly or through the
 222:../src/stm32f30x_rcc.c ****   *         PLL as system clock. In this case, you have to select another source
 223:../src/stm32f30x_rcc.c ****   *         of the system clock then change the HSE state (ex. disable it).
 224:../src/stm32f30x_rcc.c ****   * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.         
 225:../src/stm32f30x_rcc.c ****   * @note   This function resets the CSSON bit, so if the Clock security system(CSS)
 226:../src/stm32f30x_rcc.c ****   *         was previously enabled you have to enable it again after calling this
 227:../src/stm32f30x_rcc.c ****   *         function.
 228:../src/stm32f30x_rcc.c ****   * @param  RCC_HSE: specifies the new state of the HSE.
 229:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 230:../src/stm32f30x_rcc.c ****   *     @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
 231:../src/stm32f30x_rcc.c ****   *                       6 HSE oscillator clock cycles.
 232:../src/stm32f30x_rcc.c ****   *     @arg RCC_HSE_ON: turn ON the HSE oscillator
 233:../src/stm32f30x_rcc.c ****   *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
 234:../src/stm32f30x_rcc.c ****   * @retval None
 235:../src/stm32f30x_rcc.c ****   */
 236:../src/stm32f30x_rcc.c **** void RCC_HSEConfig(uint8_t RCC_HSE)
 237:../src/stm32f30x_rcc.c **** {
 160              		.loc 1 237 0
 161              		.cfi_startproc
 162              		@ args = 0, pretend = 0, frame = 8
 163              		@ frame_needed = 1, uses_anonymous_args = 0
 164              		@ link register save eliminated.
 165 00d4 80B4     		push	{r7}
 166              	.LCFI2:
 167              		.cfi_def_cfa_offset 4
 168              		.cfi_offset 7, -4
 169 00d6 83B0     		sub	sp, sp, #12
 170              	.LCFI3:
 171              		.cfi_def_cfa_offset 16
 172 00d8 00AF     		add	r7, sp, #0
 173              	.LCFI4:
 174              		.cfi_def_cfa_register 7
 175 00da 0346     		mov	r3, r0
 176 00dc FB71     		strb	r3, [r7, #7]
 238:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 239:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_HSE(RCC_HSE));
 240:../src/stm32f30x_rcc.c **** 
 241:../src/stm32f30x_rcc.c ****   /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
 242:../src/stm32f30x_rcc.c ****   *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE_OFF;
 177              		.loc 1 242 0
 178 00de 41F20203 		movw	r3, #4098
 179 00e2 C4F20203 		movt	r3, 16386
 180 00e6 4FF00002 		mov	r2, #0
 181 00ea 1A70     		strb	r2, [r3, #0]
 243:../src/stm32f30x_rcc.c **** 
 244:../src/stm32f30x_rcc.c ****   /* Set the new HSE configuration -------------------------------------------*/
 245:../src/stm32f30x_rcc.c ****   *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE;
 182              		.loc 1 245 0
 183 00ec 41F20203 		movw	r3, #4098
 184 00f0 C4F20203 		movt	r3, 16386
 185 00f4 FA79     		ldrb	r2, [r7, #7]
 186 00f6 1A70     		strb	r2, [r3, #0]
 246:../src/stm32f30x_rcc.c **** 
 247:../src/stm32f30x_rcc.c **** }
 187              		.loc 1 247 0
 188 00f8 07F10C07 		add	r7, r7, #12
 189 00fc BD46     		mov	sp, r7
 190 00fe 80BC     		pop	{r7}
 191 0100 7047     		bx	lr
 192              		.cfi_endproc
 193              	.LFE112:
 195 0102 00BF     		.align	2
 196              		.global	RCC_WaitForHSEStartUp
 197              		.thumb
 198              		.thumb_func
 200              	RCC_WaitForHSEStartUp:
 201              	.LFB113:
 248:../src/stm32f30x_rcc.c **** 
 249:../src/stm32f30x_rcc.c **** /**
 250:../src/stm32f30x_rcc.c ****   * @brief  Waits for HSE start-up.
 251:../src/stm32f30x_rcc.c ****   * @note   This function waits on HSERDY flag to be set and return SUCCESS if 
 252:../src/stm32f30x_rcc.c ****   *         this flag is set, otherwise returns ERROR if the timeout is reached 
 253:../src/stm32f30x_rcc.c ****   *         and this flag is not set. The timeout value is defined by the constant
 254:../src/stm32f30x_rcc.c ****   *         HSE_STARTUP_TIMEOUT in stm32f30x.h file. You can tailor it depending
 255:../src/stm32f30x_rcc.c ****   *         on the HSE crystal used in your application. 
 256:../src/stm32f30x_rcc.c ****   * @param  None
 257:../src/stm32f30x_rcc.c ****   * @retval An ErrorStatus enumeration value:
 258:../src/stm32f30x_rcc.c ****   *          - SUCCESS: HSE oscillator is stable and ready to use
 259:../src/stm32f30x_rcc.c ****   *          - ERROR: HSE oscillator not yet ready
 260:../src/stm32f30x_rcc.c ****   */
 261:../src/stm32f30x_rcc.c **** ErrorStatus RCC_WaitForHSEStartUp(void)
 262:../src/stm32f30x_rcc.c **** {
 202              		.loc 1 262 0
 203              		.cfi_startproc
 204              		@ args = 0, pretend = 0, frame = 8
 205              		@ frame_needed = 1, uses_anonymous_args = 0
 206 0104 80B5     		push	{r7, lr}
 207              	.LCFI5:
 208              		.cfi_def_cfa_offset 8
 209              		.cfi_offset 7, -8
 210              		.cfi_offset 14, -4
 211 0106 82B0     		sub	sp, sp, #8
 212              	.LCFI6:
 213              		.cfi_def_cfa_offset 16
 214 0108 00AF     		add	r7, sp, #0
 215              	.LCFI7:
 216              		.cfi_def_cfa_register 7
 263:../src/stm32f30x_rcc.c ****   __IO uint32_t StartUpCounter = 0;
 217              		.loc 1 263 0
 218 010a 4FF00003 		mov	r3, #0
 219 010e 3B60     		str	r3, [r7, #0]
 264:../src/stm32f30x_rcc.c ****   ErrorStatus status = ERROR;
 220              		.loc 1 264 0
 221 0110 4FF00003 		mov	r3, #0
 222 0114 FB71     		strb	r3, [r7, #7]
 265:../src/stm32f30x_rcc.c ****   FlagStatus HSEStatus = RESET;
 223              		.loc 1 265 0
 224 0116 4FF00003 		mov	r3, #0
 225 011a BB71     		strb	r3, [r7, #6]
 226              	.L5:
 266:../src/stm32f30x_rcc.c ****   
 267:../src/stm32f30x_rcc.c ****   /* Wait till HSE is ready and if timeout is reached exit */
 268:../src/stm32f30x_rcc.c ****   do
 269:../src/stm32f30x_rcc.c ****   {
 270:../src/stm32f30x_rcc.c ****     HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 227              		.loc 1 270 0 discriminator 1
 228 011c 4FF01100 		mov	r0, #17
 229 0120 FFF7FEFF 		bl	RCC_GetFlagStatus
 230 0124 0346     		mov	r3, r0
 231 0126 BB71     		strb	r3, [r7, #6]
 271:../src/stm32f30x_rcc.c ****     StartUpCounter++;  
 232              		.loc 1 271 0 discriminator 1
 233 0128 3B68     		ldr	r3, [r7, #0]
 234 012a 03F10103 		add	r3, r3, #1
 235 012e 3B60     		str	r3, [r7, #0]
 272:../src/stm32f30x_rcc.c ****   } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 236              		.loc 1 272 0 discriminator 1
 237 0130 3B68     		ldr	r3, [r7, #0]
 238 0132 B3F5A06F 		cmp	r3, #1280
 239 0136 02D0     		beq	.L4
 240 0138 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 241 013a 002B     		cmp	r3, #0
 242 013c EED0     		beq	.L5
 243              	.L4:
 273:../src/stm32f30x_rcc.c ****   
 274:../src/stm32f30x_rcc.c ****   if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 244              		.loc 1 274 0
 245 013e 4FF01100 		mov	r0, #17
 246 0142 FFF7FEFF 		bl	RCC_GetFlagStatus
 247 0146 0346     		mov	r3, r0
 248 0148 002B     		cmp	r3, #0
 249 014a 03D0     		beq	.L6
 275:../src/stm32f30x_rcc.c ****   {
 276:../src/stm32f30x_rcc.c ****     status = SUCCESS;
 250              		.loc 1 276 0
 251 014c 4FF00103 		mov	r3, #1
 252 0150 FB71     		strb	r3, [r7, #7]
 253 0152 02E0     		b	.L7
 254              	.L6:
 277:../src/stm32f30x_rcc.c ****   }
 278:../src/stm32f30x_rcc.c ****   else
 279:../src/stm32f30x_rcc.c ****   {
 280:../src/stm32f30x_rcc.c ****     status = ERROR;
 255              		.loc 1 280 0
 256 0154 4FF00003 		mov	r3, #0
 257 0158 FB71     		strb	r3, [r7, #7]
 258              	.L7:
 281:../src/stm32f30x_rcc.c ****   }  
 282:../src/stm32f30x_rcc.c ****   return (status);
 259              		.loc 1 282 0
 260 015a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 283:../src/stm32f30x_rcc.c **** }
 261              		.loc 1 283 0
 262 015c 1846     		mov	r0, r3
 263 015e 07F10807 		add	r7, r7, #8
 264 0162 BD46     		mov	sp, r7
 265 0164 80BD     		pop	{r7, pc}
 266              		.cfi_endproc
 267              	.LFE113:
 269 0166 00BF     		.align	2
 270              		.global	RCC_AdjustHSICalibrationValue
 271              		.thumb
 272              		.thumb_func
 274              	RCC_AdjustHSICalibrationValue:
 275              	.LFB114:
 284:../src/stm32f30x_rcc.c **** 
 285:../src/stm32f30x_rcc.c **** /**
 286:../src/stm32f30x_rcc.c ****   * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
 287:../src/stm32f30x_rcc.c ****   * @note   The calibration is used to compensate for the variations in voltage
 288:../src/stm32f30x_rcc.c ****   *         and temperature that influence the frequency of the internal HSI RC.
 289:../src/stm32f30x_rcc.c ****   *         Refer to the Application Note AN3300 for more details on how to  
 290:../src/stm32f30x_rcc.c ****   *         calibrate the HSI.
 291:../src/stm32f30x_rcc.c ****   * @param  HSICalibrationValue: specifies the HSI calibration trimming value.
 292:../src/stm32f30x_rcc.c ****   *         This parameter must be a number between 0 and 0x1F.
 293:../src/stm32f30x_rcc.c ****   * @retval None
 294:../src/stm32f30x_rcc.c ****   */
 295:../src/stm32f30x_rcc.c **** void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
 296:../src/stm32f30x_rcc.c **** {
 276              		.loc 1 296 0
 277              		.cfi_startproc
 278              		@ args = 0, pretend = 0, frame = 16
 279              		@ frame_needed = 1, uses_anonymous_args = 0
 280              		@ link register save eliminated.
 281 0168 80B4     		push	{r7}
 282              	.LCFI8:
 283              		.cfi_def_cfa_offset 4
 284              		.cfi_offset 7, -4
 285 016a 85B0     		sub	sp, sp, #20
 286              	.LCFI9:
 287              		.cfi_def_cfa_offset 24
 288 016c 00AF     		add	r7, sp, #0
 289              	.LCFI10:
 290              		.cfi_def_cfa_register 7
 291 016e 0346     		mov	r3, r0
 292 0170 FB71     		strb	r3, [r7, #7]
 297:../src/stm32f30x_rcc.c ****   uint32_t tmpreg = 0;
 293              		.loc 1 297 0
 294 0172 4FF00003 		mov	r3, #0
 295 0176 FB60     		str	r3, [r7, #12]
 298:../src/stm32f30x_rcc.c ****   
 299:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 300:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
 301:../src/stm32f30x_rcc.c ****   
 302:../src/stm32f30x_rcc.c ****   tmpreg = RCC->CR;
 296              		.loc 1 302 0
 297 0178 4FF48053 		mov	r3, #4096
 298 017c C4F20203 		movt	r3, 16386
 299 0180 1B68     		ldr	r3, [r3, #0]
 300 0182 FB60     		str	r3, [r7, #12]
 303:../src/stm32f30x_rcc.c ****   
 304:../src/stm32f30x_rcc.c ****   /* Clear HSITRIM[4:0] bits */
 305:../src/stm32f30x_rcc.c ****   tmpreg &= ~RCC_CR_HSITRIM;
 301              		.loc 1 305 0
 302 0184 FB68     		ldr	r3, [r7, #12]
 303 0186 23F0F803 		bic	r3, r3, #248
 304 018a FB60     		str	r3, [r7, #12]
 306:../src/stm32f30x_rcc.c ****   
 307:../src/stm32f30x_rcc.c ****   /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
 308:../src/stm32f30x_rcc.c ****   tmpreg |= (uint32_t)HSICalibrationValue << 3;
 305              		.loc 1 308 0
 306 018c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 307 018e 4FEAC303 		lsl	r3, r3, #3
 308 0192 FA68     		ldr	r2, [r7, #12]
 309 0194 1343     		orrs	r3, r3, r2
 310 0196 FB60     		str	r3, [r7, #12]
 309:../src/stm32f30x_rcc.c ****   
 310:../src/stm32f30x_rcc.c ****   /* Store the new value */
 311:../src/stm32f30x_rcc.c ****   RCC->CR = tmpreg;
 311              		.loc 1 311 0
 312 0198 4FF48053 		mov	r3, #4096
 313 019c C4F20203 		movt	r3, 16386
 314 01a0 FA68     		ldr	r2, [r7, #12]
 315 01a2 1A60     		str	r2, [r3, #0]
 312:../src/stm32f30x_rcc.c **** }
 316              		.loc 1 312 0
 317 01a4 07F11407 		add	r7, r7, #20
 318 01a8 BD46     		mov	sp, r7
 319 01aa 80BC     		pop	{r7}
 320 01ac 7047     		bx	lr
 321              		.cfi_endproc
 322              	.LFE114:
 324 01ae 00BF     		.align	2
 325              		.global	RCC_HSICmd
 326              		.thumb
 327              		.thumb_func
 329              	RCC_HSICmd:
 330              	.LFB115:
 313:../src/stm32f30x_rcc.c **** 
 314:../src/stm32f30x_rcc.c **** /**
 315:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the Internal High Speed oscillator (HSI).
 316:../src/stm32f30x_rcc.c ****   * @note   After enabling the HSI, the application software should wait on 
 317:../src/stm32f30x_rcc.c ****   *         HSIRDY flag to be set indicating that HSI clock is stable and can
 318:../src/stm32f30x_rcc.c ****   *         be used to clock the PLL and/or system clock.
 319:../src/stm32f30x_rcc.c ****   * @note   HSI can not be stopped if it is used directly or through the PLL
 320:../src/stm32f30x_rcc.c ****   *         as system clock. In this case, you have to select another source 
 321:../src/stm32f30x_rcc.c ****   *         of the system clock then stop the HSI.
 322:../src/stm32f30x_rcc.c ****   * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes. 
 323:../src/stm32f30x_rcc.c ****   * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
 324:../src/stm32f30x_rcc.c ****   *         clock cycles.    
 325:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the HSI.
 326:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
 327:../src/stm32f30x_rcc.c ****   * @retval None
 328:../src/stm32f30x_rcc.c ****   */
 329:../src/stm32f30x_rcc.c **** void RCC_HSICmd(FunctionalState NewState)
 330:../src/stm32f30x_rcc.c **** {
 331              		.loc 1 330 0
 332              		.cfi_startproc
 333              		@ args = 0, pretend = 0, frame = 8
 334              		@ frame_needed = 1, uses_anonymous_args = 0
 335              		@ link register save eliminated.
 336 01b0 80B4     		push	{r7}
 337              	.LCFI11:
 338              		.cfi_def_cfa_offset 4
 339              		.cfi_offset 7, -4
 340 01b2 83B0     		sub	sp, sp, #12
 341              	.LCFI12:
 342              		.cfi_def_cfa_offset 16
 343 01b4 00AF     		add	r7, sp, #0
 344              	.LCFI13:
 345              		.cfi_def_cfa_register 7
 346 01b6 0346     		mov	r3, r0
 347 01b8 FB71     		strb	r3, [r7, #7]
 331:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 332:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 333:../src/stm32f30x_rcc.c ****   
 334:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 348              		.loc 1 334 0
 349 01ba 4FF00003 		mov	r3, #0
 350 01be C4F24223 		movt	r3, 16962
 351 01c2 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 352 01c4 1A60     		str	r2, [r3, #0]
 335:../src/stm32f30x_rcc.c **** }
 353              		.loc 1 335 0
 354 01c6 07F10C07 		add	r7, r7, #12
 355 01ca BD46     		mov	sp, r7
 356 01cc 80BC     		pop	{r7}
 357 01ce 7047     		bx	lr
 358              		.cfi_endproc
 359              	.LFE115:
 361              		.align	2
 362              		.global	RCC_LSEConfig
 363              		.thumb
 364              		.thumb_func
 366              	RCC_LSEConfig:
 367              	.LFB116:
 336:../src/stm32f30x_rcc.c **** 
 337:../src/stm32f30x_rcc.c **** /**
 338:../src/stm32f30x_rcc.c ****   * @brief  Configures the External Low Speed oscillator (LSE).
 339:../src/stm32f30x_rcc.c ****   * @note     As the LSE is in the Backup domain and write access is denied to this
 340:../src/stm32f30x_rcc.c ****   *           domain after reset, you have to enable write access using 
 341:../src/stm32f30x_rcc.c ****   *           PWR_BackupAccessCmd(ENABLE) function before to configure the LSE
 342:../src/stm32f30x_rcc.c ****   *           (to be done once after reset).
 343:../src/stm32f30x_rcc.c ****   * @note     After enabling the LSE (RCC_LSE_ON or RCC_LSE_Bypass), the application
 344:../src/stm32f30x_rcc.c ****   *           software should wait on LSERDY flag to be set indicating that LSE clock
 345:../src/stm32f30x_rcc.c ****   *           is stable and can be used to clock the RTC.
 346:../src/stm32f30x_rcc.c ****   * @param  RCC_LSE: specifies the new state of the LSE.
 347:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 348:../src/stm32f30x_rcc.c ****   *     @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
 349:../src/stm32f30x_rcc.c ****   *                       6 LSE oscillator clock cycles.
 350:../src/stm32f30x_rcc.c ****   *     @arg RCC_LSE_ON: turn ON the LSE oscillator
 351:../src/stm32f30x_rcc.c ****   *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
 352:../src/stm32f30x_rcc.c ****   * @retval None
 353:../src/stm32f30x_rcc.c ****   */
 354:../src/stm32f30x_rcc.c **** void RCC_LSEConfig(uint32_t RCC_LSE)
 355:../src/stm32f30x_rcc.c **** {
 368              		.loc 1 355 0
 369              		.cfi_startproc
 370              		@ args = 0, pretend = 0, frame = 8
 371              		@ frame_needed = 1, uses_anonymous_args = 0
 372              		@ link register save eliminated.
 373 01d0 80B4     		push	{r7}
 374              	.LCFI14:
 375              		.cfi_def_cfa_offset 4
 376              		.cfi_offset 7, -4
 377 01d2 83B0     		sub	sp, sp, #12
 378              	.LCFI15:
 379              		.cfi_def_cfa_offset 16
 380 01d4 00AF     		add	r7, sp, #0
 381              	.LCFI16:
 382              		.cfi_def_cfa_register 7
 383 01d6 7860     		str	r0, [r7, #4]
 356:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 357:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_LSE(RCC_LSE));
 358:../src/stm32f30x_rcc.c **** 
 359:../src/stm32f30x_rcc.c ****   /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
 360:../src/stm32f30x_rcc.c ****   /* Reset LSEON bit */
 361:../src/stm32f30x_rcc.c ****   RCC->BDCR &= ~(RCC_BDCR_LSEON);
 384              		.loc 1 361 0
 385 01d8 4FF48053 		mov	r3, #4096
 386 01dc C4F20203 		movt	r3, 16386
 387 01e0 4FF48052 		mov	r2, #4096
 388 01e4 C4F20202 		movt	r2, 16386
 389 01e8 126A     		ldr	r2, [r2, #32]
 390 01ea 22F00102 		bic	r2, r2, #1
 391 01ee 1A62     		str	r2, [r3, #32]
 362:../src/stm32f30x_rcc.c **** 
 363:../src/stm32f30x_rcc.c ****   /* Reset LSEBYP bit */
 364:../src/stm32f30x_rcc.c ****   RCC->BDCR &= ~(RCC_BDCR_LSEBYP);
 392              		.loc 1 364 0
 393 01f0 4FF48053 		mov	r3, #4096
 394 01f4 C4F20203 		movt	r3, 16386
 395 01f8 4FF48052 		mov	r2, #4096
 396 01fc C4F20202 		movt	r2, 16386
 397 0200 126A     		ldr	r2, [r2, #32]
 398 0202 22F00402 		bic	r2, r2, #4
 399 0206 1A62     		str	r2, [r3, #32]
 365:../src/stm32f30x_rcc.c **** 
 366:../src/stm32f30x_rcc.c ****   /* Configure LSE */
 367:../src/stm32f30x_rcc.c ****   RCC->BDCR |= RCC_LSE;
 400              		.loc 1 367 0
 401 0208 4FF48053 		mov	r3, #4096
 402 020c C4F20203 		movt	r3, 16386
 403 0210 4FF48052 		mov	r2, #4096
 404 0214 C4F20202 		movt	r2, 16386
 405 0218 116A     		ldr	r1, [r2, #32]
 406 021a 7A68     		ldr	r2, [r7, #4]
 407 021c 0A43     		orrs	r2, r2, r1
 408 021e 1A62     		str	r2, [r3, #32]
 368:../src/stm32f30x_rcc.c **** }
 409              		.loc 1 368 0
 410 0220 07F10C07 		add	r7, r7, #12
 411 0224 BD46     		mov	sp, r7
 412 0226 80BC     		pop	{r7}
 413 0228 7047     		bx	lr
 414              		.cfi_endproc
 415              	.LFE116:
 417 022a 00BF     		.align	2
 418              		.global	RCC_LSEDriveConfig
 419              		.thumb
 420              		.thumb_func
 422              	RCC_LSEDriveConfig:
 423              	.LFB117:
 369:../src/stm32f30x_rcc.c **** 
 370:../src/stm32f30x_rcc.c **** /**
 371:../src/stm32f30x_rcc.c ****   * @brief  Configures the External Low Speed oscillator (LSE) drive capability.
 372:../src/stm32f30x_rcc.c ****   * @param  RCC_LSEDrive: specifies the new state of the LSE drive capability.
 373:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 374:../src/stm32f30x_rcc.c ****   *     @arg RCC_LSEDrive_Low: LSE oscillator low drive capability.
 375:../src/stm32f30x_rcc.c ****   *     @arg RCC_LSEDrive_MediumLow: LSE oscillator medium low drive capability.
 376:../src/stm32f30x_rcc.c ****   *     @arg RCC_LSEDrive_MediumHigh: LSE oscillator medium high drive capability.
 377:../src/stm32f30x_rcc.c ****   *     @arg RCC_LSEDrive_High: LSE oscillator high drive capability.
 378:../src/stm32f30x_rcc.c ****   * @retval None
 379:../src/stm32f30x_rcc.c ****   */
 380:../src/stm32f30x_rcc.c **** void RCC_LSEDriveConfig(uint32_t RCC_LSEDrive)
 381:../src/stm32f30x_rcc.c **** {
 424              		.loc 1 381 0
 425              		.cfi_startproc
 426              		@ args = 0, pretend = 0, frame = 8
 427              		@ frame_needed = 1, uses_anonymous_args = 0
 428              		@ link register save eliminated.
 429 022c 80B4     		push	{r7}
 430              	.LCFI17:
 431              		.cfi_def_cfa_offset 4
 432              		.cfi_offset 7, -4
 433 022e 83B0     		sub	sp, sp, #12
 434              	.LCFI18:
 435              		.cfi_def_cfa_offset 16
 436 0230 00AF     		add	r7, sp, #0
 437              	.LCFI19:
 438              		.cfi_def_cfa_register 7
 439 0232 7860     		str	r0, [r7, #4]
 382:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 383:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_LSE_DRIVE(RCC_LSEDrive));
 384:../src/stm32f30x_rcc.c ****   
 385:../src/stm32f30x_rcc.c ****   /* Clear LSEDRV[1:0] bits */
 386:../src/stm32f30x_rcc.c ****   RCC->BDCR &= ~(RCC_BDCR_LSEDRV);
 440              		.loc 1 386 0
 441 0234 4FF48053 		mov	r3, #4096
 442 0238 C4F20203 		movt	r3, 16386
 443 023c 4FF48052 		mov	r2, #4096
 444 0240 C4F20202 		movt	r2, 16386
 445 0244 126A     		ldr	r2, [r2, #32]
 446 0246 22F01802 		bic	r2, r2, #24
 447 024a 1A62     		str	r2, [r3, #32]
 387:../src/stm32f30x_rcc.c **** 
 388:../src/stm32f30x_rcc.c ****   /* Set the LSE Drive */
 389:../src/stm32f30x_rcc.c ****   RCC->BDCR |= RCC_LSEDrive;
 448              		.loc 1 389 0
 449 024c 4FF48053 		mov	r3, #4096
 450 0250 C4F20203 		movt	r3, 16386
 451 0254 4FF48052 		mov	r2, #4096
 452 0258 C4F20202 		movt	r2, 16386
 453 025c 116A     		ldr	r1, [r2, #32]
 454 025e 7A68     		ldr	r2, [r7, #4]
 455 0260 0A43     		orrs	r2, r2, r1
 456 0262 1A62     		str	r2, [r3, #32]
 390:../src/stm32f30x_rcc.c **** }
 457              		.loc 1 390 0
 458 0264 07F10C07 		add	r7, r7, #12
 459 0268 BD46     		mov	sp, r7
 460 026a 80BC     		pop	{r7}
 461 026c 7047     		bx	lr
 462              		.cfi_endproc
 463              	.LFE117:
 465 026e 00BF     		.align	2
 466              		.global	RCC_LSICmd
 467              		.thumb
 468              		.thumb_func
 470              	RCC_LSICmd:
 471              	.LFB118:
 391:../src/stm32f30x_rcc.c **** 
 392:../src/stm32f30x_rcc.c **** /**
 393:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the Internal Low Speed oscillator (LSI).  
 394:../src/stm32f30x_rcc.c ****   * @note   After enabling the LSI, the application software should wait on 
 395:../src/stm32f30x_rcc.c ****   *         LSIRDY flag to be set indicating that LSI clock is stable and can
 396:../src/stm32f30x_rcc.c ****   *         be used to clock the IWDG and/or the RTC.
 397:../src/stm32f30x_rcc.c ****   * @note   LSI can not be disabled if the IWDG is running.  
 398:../src/stm32f30x_rcc.c ****   * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
 399:../src/stm32f30x_rcc.c ****   *         clock cycles.
 400:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the LSI.
 401:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE. 
 402:../src/stm32f30x_rcc.c ****   * @retval None
 403:../src/stm32f30x_rcc.c ****   */
 404:../src/stm32f30x_rcc.c **** void RCC_LSICmd(FunctionalState NewState)
 405:../src/stm32f30x_rcc.c **** {
 472              		.loc 1 405 0
 473              		.cfi_startproc
 474              		@ args = 0, pretend = 0, frame = 8
 475              		@ frame_needed = 1, uses_anonymous_args = 0
 476              		@ link register save eliminated.
 477 0270 80B4     		push	{r7}
 478              	.LCFI20:
 479              		.cfi_def_cfa_offset 4
 480              		.cfi_offset 7, -4
 481 0272 83B0     		sub	sp, sp, #12
 482              	.LCFI21:
 483              		.cfi_def_cfa_offset 16
 484 0274 00AF     		add	r7, sp, #0
 485              	.LCFI22:
 486              		.cfi_def_cfa_register 7
 487 0276 0346     		mov	r3, r0
 488 0278 FB71     		strb	r3, [r7, #7]
 406:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 407:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 408:../src/stm32f30x_rcc.c ****   
 409:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 489              		.loc 1 409 0
 490 027a 4FF49063 		mov	r3, #1152
 491 027e C4F24223 		movt	r3, 16962
 492 0282 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 493 0284 1A60     		str	r2, [r3, #0]
 410:../src/stm32f30x_rcc.c **** }
 494              		.loc 1 410 0
 495 0286 07F10C07 		add	r7, r7, #12
 496 028a BD46     		mov	sp, r7
 497 028c 80BC     		pop	{r7}
 498 028e 7047     		bx	lr
 499              		.cfi_endproc
 500              	.LFE118:
 502              		.align	2
 503              		.global	RCC_PLLConfig
 504              		.thumb
 505              		.thumb_func
 507              	RCC_PLLConfig:
 508              	.LFB119:
 411:../src/stm32f30x_rcc.c **** 
 412:../src/stm32f30x_rcc.c **** /**
 413:../src/stm32f30x_rcc.c ****   * @brief  Configures the PLL clock source and multiplication factor.
 414:../src/stm32f30x_rcc.c ****   * @note   This function must be used only when the PLL is disabled.
 415:../src/stm32f30x_rcc.c ****   * @note   The minimum input clock frequency for PLL is 2 MHz (when using HSE as
 416:../src/stm32f30x_rcc.c ****   *         PLL source).   
 417:../src/stm32f30x_rcc.c ****   * @param  RCC_PLLSource: specifies the PLL entry clock source.
 418:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 419:../src/stm32f30x_rcc.c ****   *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as
 420:../src/stm32f30x_rcc.c ****   *         PLL clock entry
 421:../src/stm32f30x_rcc.c ****   *     @arg RCC_PLLSource_PREDIV1: PREDIV1 clock selected as PLL clock source              
 422:../src/stm32f30x_rcc.c ****   * @param  RCC_PLLMul: specifies the PLL multiplication factor, which drive the PLLVCO clock
 423:../src/stm32f30x_rcc.c ****   *   This parameter can be RCC_PLLMul_x where x:[2,16] 
 424:../src/stm32f30x_rcc.c ****   *                                               
 425:../src/stm32f30x_rcc.c ****   * @retval None
 426:../src/stm32f30x_rcc.c ****   */
 427:../src/stm32f30x_rcc.c **** void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
 428:../src/stm32f30x_rcc.c **** {
 509              		.loc 1 428 0
 510              		.cfi_startproc
 511              		@ args = 0, pretend = 0, frame = 8
 512              		@ frame_needed = 1, uses_anonymous_args = 0
 513              		@ link register save eliminated.
 514 0290 80B4     		push	{r7}
 515              	.LCFI23:
 516              		.cfi_def_cfa_offset 4
 517              		.cfi_offset 7, -4
 518 0292 83B0     		sub	sp, sp, #12
 519              	.LCFI24:
 520              		.cfi_def_cfa_offset 16
 521 0294 00AF     		add	r7, sp, #0
 522              	.LCFI25:
 523              		.cfi_def_cfa_register 7
 524 0296 7860     		str	r0, [r7, #4]
 525 0298 3960     		str	r1, [r7, #0]
 429:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 430:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
 431:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
 432:../src/stm32f30x_rcc.c ****   
 433:../src/stm32f30x_rcc.c ****   /* Clear PLL Source [16] and Multiplier [21:18] bits */
 434:../src/stm32f30x_rcc.c ****   RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
 526              		.loc 1 434 0
 527 029a 4FF48053 		mov	r3, #4096
 528 029e C4F20203 		movt	r3, 16386
 529 02a2 4FF48052 		mov	r2, #4096
 530 02a6 C4F20202 		movt	r2, 16386
 531 02aa 5268     		ldr	r2, [r2, #4]
 532 02ac 22F47412 		bic	r2, r2, #3997696
 533 02b0 5A60     		str	r2, [r3, #4]
 435:../src/stm32f30x_rcc.c **** 
 436:../src/stm32f30x_rcc.c ****   /* Set the PLL Source and Multiplier */
 437:../src/stm32f30x_rcc.c ****   RCC->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
 534              		.loc 1 437 0
 535 02b2 4FF48053 		mov	r3, #4096
 536 02b6 C4F20203 		movt	r3, 16386
 537 02ba 4FF48052 		mov	r2, #4096
 538 02be C4F20202 		movt	r2, 16386
 539 02c2 5168     		ldr	r1, [r2, #4]
 540 02c4 7868     		ldr	r0, [r7, #4]
 541 02c6 3A68     		ldr	r2, [r7, #0]
 542 02c8 0243     		orrs	r2, r2, r0
 543 02ca 0A43     		orrs	r2, r2, r1
 544 02cc 5A60     		str	r2, [r3, #4]
 438:../src/stm32f30x_rcc.c **** }
 545              		.loc 1 438 0
 546 02ce 07F10C07 		add	r7, r7, #12
 547 02d2 BD46     		mov	sp, r7
 548 02d4 80BC     		pop	{r7}
 549 02d6 7047     		bx	lr
 550              		.cfi_endproc
 551              	.LFE119:
 553              		.align	2
 554              		.global	RCC_PLLCmd
 555              		.thumb
 556              		.thumb_func
 558              	RCC_PLLCmd:
 559              	.LFB120:
 439:../src/stm32f30x_rcc.c **** 
 440:../src/stm32f30x_rcc.c **** /**
 441:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the PLL.
 442:../src/stm32f30x_rcc.c ****   * @note   After enabling the PLL, the application software should wait on 
 443:../src/stm32f30x_rcc.c ****   *         PLLRDY flag to be set indicating that PLL clock is stable and can
 444:../src/stm32f30x_rcc.c ****   *         be used as system clock source.
 445:../src/stm32f30x_rcc.c ****   * @note   The PLL can not be disabled if it is used as system clock source
 446:../src/stm32f30x_rcc.c ****   * @note   The PLL is disabled by hardware when entering STOP and STANDBY modes.    
 447:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the PLL.
 448:../src/stm32f30x_rcc.c ****   *   This parameter can be: ENABLE or DISABLE.
 449:../src/stm32f30x_rcc.c ****   * @retval None
 450:../src/stm32f30x_rcc.c ****   */
 451:../src/stm32f30x_rcc.c **** void RCC_PLLCmd(FunctionalState NewState)
 452:../src/stm32f30x_rcc.c **** {
 560              		.loc 1 452 0
 561              		.cfi_startproc
 562              		@ args = 0, pretend = 0, frame = 8
 563              		@ frame_needed = 1, uses_anonymous_args = 0
 564              		@ link register save eliminated.
 565 02d8 80B4     		push	{r7}
 566              	.LCFI26:
 567              		.cfi_def_cfa_offset 4
 568              		.cfi_offset 7, -4
 569 02da 83B0     		sub	sp, sp, #12
 570              	.LCFI27:
 571              		.cfi_def_cfa_offset 16
 572 02dc 00AF     		add	r7, sp, #0
 573              	.LCFI28:
 574              		.cfi_def_cfa_register 7
 575 02de 0346     		mov	r3, r0
 576 02e0 FB71     		strb	r3, [r7, #7]
 453:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 454:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 455:../src/stm32f30x_rcc.c **** 
 456:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 577              		.loc 1 456 0
 578 02e2 4FF06003 		mov	r3, #96
 579 02e6 C4F24223 		movt	r3, 16962
 580 02ea FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 581 02ec 1A60     		str	r2, [r3, #0]
 457:../src/stm32f30x_rcc.c **** }
 582              		.loc 1 457 0
 583 02ee 07F10C07 		add	r7, r7, #12
 584 02f2 BD46     		mov	sp, r7
 585 02f4 80BC     		pop	{r7}
 586 02f6 7047     		bx	lr
 587              		.cfi_endproc
 588              	.LFE120:
 590              		.align	2
 591              		.global	RCC_PREDIV1Config
 592              		.thumb
 593              		.thumb_func
 595              	RCC_PREDIV1Config:
 596              	.LFB121:
 458:../src/stm32f30x_rcc.c **** 
 459:../src/stm32f30x_rcc.c **** /**
 460:../src/stm32f30x_rcc.c ****   * @brief  Configures the PREDIV1 division factor.
 461:../src/stm32f30x_rcc.c ****   * @note   This function must be used only when the PLL is disabled.
 462:../src/stm32f30x_rcc.c ****   * @param  RCC_PREDIV1_Div: specifies the PREDIV1 clock division factor.
 463:../src/stm32f30x_rcc.c ****   *         This parameter can be RCC_PREDIV1_Divx where x:[1,16]
 464:../src/stm32f30x_rcc.c ****   * @retval None
 465:../src/stm32f30x_rcc.c ****   */
 466:../src/stm32f30x_rcc.c **** void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Div)
 467:../src/stm32f30x_rcc.c **** {
 597              		.loc 1 467 0
 598              		.cfi_startproc
 599              		@ args = 0, pretend = 0, frame = 16
 600              		@ frame_needed = 1, uses_anonymous_args = 0
 601              		@ link register save eliminated.
 602 02f8 80B4     		push	{r7}
 603              	.LCFI29:
 604              		.cfi_def_cfa_offset 4
 605              		.cfi_offset 7, -4
 606 02fa 85B0     		sub	sp, sp, #20
 607              	.LCFI30:
 608              		.cfi_def_cfa_offset 24
 609 02fc 00AF     		add	r7, sp, #0
 610              	.LCFI31:
 611              		.cfi_def_cfa_register 7
 612 02fe 7860     		str	r0, [r7, #4]
 468:../src/stm32f30x_rcc.c ****   uint32_t tmpreg = 0;
 613              		.loc 1 468 0
 614 0300 4FF00003 		mov	r3, #0
 615 0304 FB60     		str	r3, [r7, #12]
 469:../src/stm32f30x_rcc.c ****   
 470:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 471:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
 472:../src/stm32f30x_rcc.c **** 
 473:../src/stm32f30x_rcc.c ****   tmpreg = RCC->CFGR2;
 616              		.loc 1 473 0
 617 0306 4FF48053 		mov	r3, #4096
 618 030a C4F20203 		movt	r3, 16386
 619 030e DB6A     		ldr	r3, [r3, #44]
 620 0310 FB60     		str	r3, [r7, #12]
 474:../src/stm32f30x_rcc.c ****   /* Clear PREDIV1[3:0] bits */
 475:../src/stm32f30x_rcc.c ****   tmpreg &= ~(RCC_CFGR2_PREDIV1);
 621              		.loc 1 475 0
 622 0312 FB68     		ldr	r3, [r7, #12]
 623 0314 23F00F03 		bic	r3, r3, #15
 624 0318 FB60     		str	r3, [r7, #12]
 476:../src/stm32f30x_rcc.c **** 
 477:../src/stm32f30x_rcc.c ****   /* Set the PREDIV1 division factor */
 478:../src/stm32f30x_rcc.c ****   tmpreg |= RCC_PREDIV1_Div;
 625              		.loc 1 478 0
 626 031a FA68     		ldr	r2, [r7, #12]
 627 031c 7B68     		ldr	r3, [r7, #4]
 628 031e 1343     		orrs	r3, r3, r2
 629 0320 FB60     		str	r3, [r7, #12]
 479:../src/stm32f30x_rcc.c **** 
 480:../src/stm32f30x_rcc.c ****   /* Store the new value */
 481:../src/stm32f30x_rcc.c ****   RCC->CFGR2 = tmpreg;
 630              		.loc 1 481 0
 631 0322 4FF48053 		mov	r3, #4096
 632 0326 C4F20203 		movt	r3, 16386
 633 032a FA68     		ldr	r2, [r7, #12]
 634 032c DA62     		str	r2, [r3, #44]
 482:../src/stm32f30x_rcc.c **** }
 635              		.loc 1 482 0
 636 032e 07F11407 		add	r7, r7, #20
 637 0332 BD46     		mov	sp, r7
 638 0334 80BC     		pop	{r7}
 639 0336 7047     		bx	lr
 640              		.cfi_endproc
 641              	.LFE121:
 643              		.align	2
 644              		.global	RCC_ClockSecuritySystemCmd
 645              		.thumb
 646              		.thumb_func
 648              	RCC_ClockSecuritySystemCmd:
 649              	.LFB122:
 483:../src/stm32f30x_rcc.c **** 
 484:../src/stm32f30x_rcc.c **** /**
 485:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the Clock Security System.
 486:../src/stm32f30x_rcc.c ****   * @note   If a failure is detected on the HSE oscillator clock, this oscillator
 487:../src/stm32f30x_rcc.c ****   *         is automatically disabled and an interrupt is generated to inform the
 488:../src/stm32f30x_rcc.c ****   *         software about the failure (Clock Security System Interrupt, CSSI),
 489:../src/stm32f30x_rcc.c ****   *         allowing the MCU to perform rescue operations. The CSSI is linked to 
 490:../src/stm32f30x_rcc.c ****   *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.  
 491:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the Clock Security System.
 492:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
 493:../src/stm32f30x_rcc.c ****   * @retval None
 494:../src/stm32f30x_rcc.c ****   */
 495:../src/stm32f30x_rcc.c **** void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
 496:../src/stm32f30x_rcc.c **** {
 650              		.loc 1 496 0
 651              		.cfi_startproc
 652              		@ args = 0, pretend = 0, frame = 8
 653              		@ frame_needed = 1, uses_anonymous_args = 0
 654              		@ link register save eliminated.
 655 0338 80B4     		push	{r7}
 656              	.LCFI32:
 657              		.cfi_def_cfa_offset 4
 658              		.cfi_offset 7, -4
 659 033a 83B0     		sub	sp, sp, #12
 660              	.LCFI33:
 661              		.cfi_def_cfa_offset 16
 662 033c 00AF     		add	r7, sp, #0
 663              	.LCFI34:
 664              		.cfi_def_cfa_register 7
 665 033e 0346     		mov	r3, r0
 666 0340 FB71     		strb	r3, [r7, #7]
 497:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 498:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 499:../src/stm32f30x_rcc.c ****   
 500:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 667              		.loc 1 500 0
 668 0342 4FF04C03 		mov	r3, #76
 669 0346 C4F24223 		movt	r3, 16962
 670 034a FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 671 034c 1A60     		str	r2, [r3, #0]
 501:../src/stm32f30x_rcc.c **** }
 672              		.loc 1 501 0
 673 034e 07F10C07 		add	r7, r7, #12
 674 0352 BD46     		mov	sp, r7
 675 0354 80BC     		pop	{r7}
 676 0356 7047     		bx	lr
 677              		.cfi_endproc
 678              	.LFE122:
 680              		.align	2
 681              		.global	RCC_MCOConfig
 682              		.thumb
 683              		.thumb_func
 685              	RCC_MCOConfig:
 686              	.LFB123:
 502:../src/stm32f30x_rcc.c **** 
 503:../src/stm32f30x_rcc.c **** /**
 504:../src/stm32f30x_rcc.c ****   * @brief  Selects the clock source to output on MCO pin (PA8).
 505:../src/stm32f30x_rcc.c ****   * @note   PA8 should be configured in alternate function mode.
 506:../src/stm32f30x_rcc.c ****   * @note   The MCOF flag is set once the MCO clock source switch is effective.      
 507:../src/stm32f30x_rcc.c ****   * @param  RCC_MCOSource: specifies the clock source to output.
 508:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 509:../src/stm32f30x_rcc.c ****   *     @arg RCC_MCOSource_NoClock: No clock selected.
 510:../src/stm32f30x_rcc.c ****   *     @arg RCC_MCOSource_LSI: LSI oscillator clock selected.  
 511:../src/stm32f30x_rcc.c ****   *     @arg RCC_MCOSource_LSE: LSE oscillator clock selected.  
 512:../src/stm32f30x_rcc.c ****   *     @arg RCC_MCOSource_SYSCLK: System clock selected.
 513:../src/stm32f30x_rcc.c ****   *     @arg RCC_MCOSource_HSI: HSI oscillator clock selected.  
 514:../src/stm32f30x_rcc.c ****   *     @arg RCC_MCOSource_HSE: HSE oscillator clock selected.
 515:../src/stm32f30x_rcc.c ****   *     @arg RCC_MCOSource_PLLCLK_Div2: PLL clock selected.
 516:../src/stm32f30x_rcc.c ****   * @retval None
 517:../src/stm32f30x_rcc.c ****   */
 518:../src/stm32f30x_rcc.c **** void RCC_MCOConfig(uint8_t RCC_MCOSource)
 519:../src/stm32f30x_rcc.c **** {
 687              		.loc 1 519 0
 688              		.cfi_startproc
 689              		@ args = 0, pretend = 0, frame = 8
 690              		@ frame_needed = 1, uses_anonymous_args = 0
 691              		@ link register save eliminated.
 692 0358 80B4     		push	{r7}
 693              	.LCFI35:
 694              		.cfi_def_cfa_offset 4
 695              		.cfi_offset 7, -4
 696 035a 83B0     		sub	sp, sp, #12
 697              	.LCFI36:
 698              		.cfi_def_cfa_offset 16
 699 035c 00AF     		add	r7, sp, #0
 700              	.LCFI37:
 701              		.cfi_def_cfa_register 7
 702 035e 0346     		mov	r3, r0
 703 0360 FB71     		strb	r3, [r7, #7]
 520:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 521:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
 522:../src/stm32f30x_rcc.c ****     
 523:../src/stm32f30x_rcc.c ****   /* Select MCO clock source and prescaler */
 524:../src/stm32f30x_rcc.c ****   *(__IO uint8_t *) CFGR_BYTE3_ADDRESS =  RCC_MCOSource; 
 704              		.loc 1 524 0
 705 0362 41F20703 		movw	r3, #4103
 706 0366 C4F20203 		movt	r3, 16386
 707 036a FA79     		ldrb	r2, [r7, #7]
 708 036c 1A70     		strb	r2, [r3, #0]
 525:../src/stm32f30x_rcc.c **** }
 709              		.loc 1 525 0
 710 036e 07F10C07 		add	r7, r7, #12
 711 0372 BD46     		mov	sp, r7
 712 0374 80BC     		pop	{r7}
 713 0376 7047     		bx	lr
 714              		.cfi_endproc
 715              	.LFE123:
 717              		.align	2
 718              		.global	RCC_SYSCLKConfig
 719              		.thumb
 720              		.thumb_func
 722              	RCC_SYSCLKConfig:
 723              	.LFB124:
 526:../src/stm32f30x_rcc.c **** 
 527:../src/stm32f30x_rcc.c **** /**
 528:../src/stm32f30x_rcc.c ****   * @}
 529:../src/stm32f30x_rcc.c ****   */
 530:../src/stm32f30x_rcc.c **** 
 531:../src/stm32f30x_rcc.c **** /** @defgroup RCC_Group2 System AHB, APB1 and APB2 busses clocks configuration functions
 532:../src/stm32f30x_rcc.c ****  *  @brief   System, AHB and APB busses clocks configuration functions
 533:../src/stm32f30x_rcc.c ****  *
 534:../src/stm32f30x_rcc.c **** @verbatim   
 535:../src/stm32f30x_rcc.c ****  ===============================================================================
 536:../src/stm32f30x_rcc.c ****   ##### System, AHB, APB1 and APB2 busses clocks configuration functions #####
 537:../src/stm32f30x_rcc.c ****  ===============================================================================  
 538:../src/stm32f30x_rcc.c ****     [..] This section provide functions allowing to configure the System, AHB, APB1 and 
 539:../src/stm32f30x_rcc.c ****          APB2 busses clocks.
 540:../src/stm32f30x_rcc.c ****          (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,
 541:../src/stm32f30x_rcc.c ****              HSE and PLL.
 542:../src/stm32f30x_rcc.c ****              The AHB clock (HCLK) is derived from System clock through configurable prescaler
 543:../src/stm32f30x_rcc.c ****              and used to clock the CPU, memory and peripherals mapped on AHB bus (DMA and GPIO).
 544:../src/stm32f30x_rcc.c ****              APB1 (PCLK1) and APB2 (PCLK2) clocks are derived from AHB clock through 
 545:../src/stm32f30x_rcc.c ****              configurable prescalers and used to clock the peripherals mapped on these busses.
 546:../src/stm32f30x_rcc.c ****              You can use "RCC_GetClocksFreq()" function to retrieve the frequencies of these clocks
 547:../src/stm32f30x_rcc.c **** 
 548:../src/stm32f30x_rcc.c ****          (#) The maximum frequency of the SYSCLK, HCLK, PCLK1 and PCLK2 is 72 MHz.
 549:../src/stm32f30x_rcc.c ****              Depending on the maximum frequency, the FLASH wait states (WS) should be 
 550:../src/stm32f30x_rcc.c ****              adapted accordingly:
 551:../src/stm32f30x_rcc.c ****         +---------------------------------+
 552:../src/stm32f30x_rcc.c ****         |  Wait states  |   HCLK clock    |
 553:../src/stm32f30x_rcc.c ****         |   (Latency)   | frequency (MHz) |
 554:../src/stm32f30x_rcc.c ****         |-------------- |-----------------|             
 555:../src/stm32f30x_rcc.c ****         |0WS(1CPU cycle)| 0 < HCLK <= 24  |
 556:../src/stm32f30x_rcc.c ****         |---------------|-----------------| 
 557:../src/stm32f30x_rcc.c ****         |1WS(2CPU cycle)|24 < HCLK <=48   |
 558:../src/stm32f30x_rcc.c ****         |---------------|-----------------| 
 559:../src/stm32f30x_rcc.c ****         |2WS(3CPU cycle)|48 < HCLK <= 72  |
 560:../src/stm32f30x_rcc.c ****         +---------------------------------+
 561:../src/stm32f30x_rcc.c **** 
 562:../src/stm32f30x_rcc.c ****          (#) After reset, the System clock source is the HSI (8 MHz) with 0 WS and 
 563:../src/stm32f30x_rcc.c ****              prefetch is disabled.
 564:../src/stm32f30x_rcc.c ****         [..]
 565:../src/stm32f30x_rcc.c ****          (@) All the peripheral clocks are derived from the System clock (SYSCLK) 
 566:../src/stm32f30x_rcc.c ****              except:
 567:../src/stm32f30x_rcc.c ****              (+@) The FLASH program/erase clock  which is always HSI 8MHz clock.
 568:../src/stm32f30x_rcc.c ****              (+@) The USB 48 MHz clock which is derived from the PLL VCO clock.
 569:../src/stm32f30x_rcc.c ****              (+@) The USART clock which can be derived as well from HSI 8MHz, LSI or LSE.
 570:../src/stm32f30x_rcc.c ****              (+@) The I2C clock which can be derived as well from HSI 8MHz clock.
 571:../src/stm32f30x_rcc.c ****              (+@) The ADC clock which is derived from PLL output.
 572:../src/stm32f30x_rcc.c ****              (+@) The RTC clock which is derived from the LSE, LSI or 1 MHz HSE_RTC 
 573:../src/stm32f30x_rcc.c ****                   (HSE divided by a programmable prescaler). The System clock (SYSCLK) 
 574:../src/stm32f30x_rcc.c ****                   frequency must be higher or equal to the RTC clock frequency.
 575:../src/stm32f30x_rcc.c ****              (+@) IWDG clock which is always the LSI clock.
 576:../src/stm32f30x_rcc.c ****     [..] It is recommended to use the following software sequences to tune the number
 577:../src/stm32f30x_rcc.c ****          of wait states needed to access the Flash memory with the CPU frequency (HCLK).
 578:../src/stm32f30x_rcc.c ****          (+) Increasing the CPU frequency
 579:../src/stm32f30x_rcc.c ****             (++) Program the Flash Prefetch buffer, using "FLASH_PrefetchBufferCmd(ENABLE)" 
 580:../src/stm32f30x_rcc.c ****                  function
 581:../src/stm32f30x_rcc.c ****             (++) Check that Flash Prefetch buffer activation is taken into account by 
 582:../src/stm32f30x_rcc.c ****                  reading FLASH_ACR using the FLASH_GetPrefetchBufferStatus() function
 583:../src/stm32f30x_rcc.c ****             (++) Program Flash WS to 1 or 2, using "FLASH_SetLatency()" function
 584:../src/stm32f30x_rcc.c ****             (++) Check that the new number of WS is taken into account by reading FLASH_ACR
 585:../src/stm32f30x_rcc.c ****             (++) Modify the CPU clock source, using "RCC_SYSCLKConfig()" function
 586:../src/stm32f30x_rcc.c ****             (++) If needed, modify the CPU clock prescaler by using "RCC_HCLKConfig()" function
 587:../src/stm32f30x_rcc.c ****             (++) Check that the new CPU clock source is taken into account by reading 
 588:../src/stm32f30x_rcc.c ****                  the clock source status, using "RCC_GetSYSCLKSource()" function 
 589:../src/stm32f30x_rcc.c ****          (+) Decreasing the CPU frequency
 590:../src/stm32f30x_rcc.c ****             (++) Modify the CPU clock source, using "RCC_SYSCLKConfig()" function
 591:../src/stm32f30x_rcc.c ****             (++) If needed, modify the CPU clock prescaler by using "RCC_HCLKConfig()" function
 592:../src/stm32f30x_rcc.c ****             (++) Check that the new CPU clock source is taken into account by reading 
 593:../src/stm32f30x_rcc.c ****                  the clock source status, using "RCC_GetSYSCLKSource()" function
 594:../src/stm32f30x_rcc.c ****             (++) Program the new number of WS, using "FLASH_SetLatency()" function
 595:../src/stm32f30x_rcc.c ****             (++) Check that the new number of WS is taken into account by reading FLASH_ACR
 596:../src/stm32f30x_rcc.c ****             (++) Disable the Flash Prefetch buffer using "FLASH_PrefetchBufferCmd(DISABLE)" 
 597:../src/stm32f30x_rcc.c ****                  function
 598:../src/stm32f30x_rcc.c ****             (++) Check that Flash Prefetch buffer deactivation is taken into account by reading FLA
 599:../src/stm32f30x_rcc.c ****                  using the FLASH_GetPrefetchBufferStatus() function.
 600:../src/stm32f30x_rcc.c **** 
 601:../src/stm32f30x_rcc.c **** @endverbatim
 602:../src/stm32f30x_rcc.c ****   * @{
 603:../src/stm32f30x_rcc.c ****   */
 604:../src/stm32f30x_rcc.c **** 
 605:../src/stm32f30x_rcc.c **** /**
 606:../src/stm32f30x_rcc.c ****   * @brief  Configures the system clock (SYSCLK).
 607:../src/stm32f30x_rcc.c ****   * @note     The HSI is used (enabled by hardware) as system clock source after
 608:../src/stm32f30x_rcc.c ****   *           startup from Reset, wake-up from STOP and STANDBY mode, or in case
 609:../src/stm32f30x_rcc.c ****   *           of failure of the HSE used directly or indirectly as system clock
 610:../src/stm32f30x_rcc.c ****   *           (if the Clock Security System CSS is enabled).
 611:../src/stm32f30x_rcc.c ****   * @note     A switch from one clock source to another occurs only if the target
 612:../src/stm32f30x_rcc.c ****   *           clock source is ready (clock stable after startup delay or PLL locked). 
 613:../src/stm32f30x_rcc.c ****   *           If a clock source which is not yet ready is selected, the switch will
 614:../src/stm32f30x_rcc.c ****   *           occur when the clock source will be ready. 
 615:../src/stm32f30x_rcc.c ****   *           You can use RCC_GetSYSCLKSource() function to know which clock is
 616:../src/stm32f30x_rcc.c ****   *           currently used as system clock source.  
 617:../src/stm32f30x_rcc.c ****   * @param  RCC_SYSCLKSource: specifies the clock source used as system clock source 
 618:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 619:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLKSource_HSI:    HSI selected as system clock source
 620:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
 621:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
 622:../src/stm32f30x_rcc.c ****   * @retval None
 623:../src/stm32f30x_rcc.c ****   */
 624:../src/stm32f30x_rcc.c **** void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
 625:../src/stm32f30x_rcc.c **** {
 724              		.loc 1 625 0
 725              		.cfi_startproc
 726              		@ args = 0, pretend = 0, frame = 16
 727              		@ frame_needed = 1, uses_anonymous_args = 0
 728              		@ link register save eliminated.
 729 0378 80B4     		push	{r7}
 730              	.LCFI38:
 731              		.cfi_def_cfa_offset 4
 732              		.cfi_offset 7, -4
 733 037a 85B0     		sub	sp, sp, #20
 734              	.LCFI39:
 735              		.cfi_def_cfa_offset 24
 736 037c 00AF     		add	r7, sp, #0
 737              	.LCFI40:
 738              		.cfi_def_cfa_register 7
 739 037e 7860     		str	r0, [r7, #4]
 626:../src/stm32f30x_rcc.c ****   uint32_t tmpreg = 0;
 740              		.loc 1 626 0
 741 0380 4FF00003 		mov	r3, #0
 742 0384 FB60     		str	r3, [r7, #12]
 627:../src/stm32f30x_rcc.c ****   
 628:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 629:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
 630:../src/stm32f30x_rcc.c ****   
 631:../src/stm32f30x_rcc.c ****   tmpreg = RCC->CFGR;
 743              		.loc 1 631 0
 744 0386 4FF48053 		mov	r3, #4096
 745 038a C4F20203 		movt	r3, 16386
 746 038e 5B68     		ldr	r3, [r3, #4]
 747 0390 FB60     		str	r3, [r7, #12]
 632:../src/stm32f30x_rcc.c ****   
 633:../src/stm32f30x_rcc.c ****   /* Clear SW[1:0] bits */
 634:../src/stm32f30x_rcc.c ****   tmpreg &= ~RCC_CFGR_SW;
 748              		.loc 1 634 0
 749 0392 FB68     		ldr	r3, [r7, #12]
 750 0394 23F00303 		bic	r3, r3, #3
 751 0398 FB60     		str	r3, [r7, #12]
 635:../src/stm32f30x_rcc.c ****   
 636:../src/stm32f30x_rcc.c ****   /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
 637:../src/stm32f30x_rcc.c ****   tmpreg |= RCC_SYSCLKSource;
 752              		.loc 1 637 0
 753 039a FA68     		ldr	r2, [r7, #12]
 754 039c 7B68     		ldr	r3, [r7, #4]
 755 039e 1343     		orrs	r3, r3, r2
 756 03a0 FB60     		str	r3, [r7, #12]
 638:../src/stm32f30x_rcc.c ****   
 639:../src/stm32f30x_rcc.c ****   /* Store the new value */
 640:../src/stm32f30x_rcc.c ****   RCC->CFGR = tmpreg;
 757              		.loc 1 640 0
 758 03a2 4FF48053 		mov	r3, #4096
 759 03a6 C4F20203 		movt	r3, 16386
 760 03aa FA68     		ldr	r2, [r7, #12]
 761 03ac 5A60     		str	r2, [r3, #4]
 641:../src/stm32f30x_rcc.c **** }
 762              		.loc 1 641 0
 763 03ae 07F11407 		add	r7, r7, #20
 764 03b2 BD46     		mov	sp, r7
 765 03b4 80BC     		pop	{r7}
 766 03b6 7047     		bx	lr
 767              		.cfi_endproc
 768              	.LFE124:
 770              		.align	2
 771              		.global	RCC_GetSYSCLKSource
 772              		.thumb
 773              		.thumb_func
 775              	RCC_GetSYSCLKSource:
 776              	.LFB125:
 642:../src/stm32f30x_rcc.c **** 
 643:../src/stm32f30x_rcc.c **** /**
 644:../src/stm32f30x_rcc.c ****   * @brief  Returns the clock source used as system clock.
 645:../src/stm32f30x_rcc.c ****   * @param  None
 646:../src/stm32f30x_rcc.c ****   * @retval The clock source used as system clock. The returned value can be one 
 647:../src/stm32f30x_rcc.c ****   *         of the following values:
 648:../src/stm32f30x_rcc.c ****   *              - 0x00: HSI used as system clock
 649:../src/stm32f30x_rcc.c ****   *              - 0x04: HSE used as system clock  
 650:../src/stm32f30x_rcc.c ****   *              - 0x08: PLL used as system clock
 651:../src/stm32f30x_rcc.c ****   */
 652:../src/stm32f30x_rcc.c **** uint8_t RCC_GetSYSCLKSource(void)
 653:../src/stm32f30x_rcc.c **** {
 777              		.loc 1 653 0
 778              		.cfi_startproc
 779              		@ args = 0, pretend = 0, frame = 0
 780              		@ frame_needed = 1, uses_anonymous_args = 0
 781              		@ link register save eliminated.
 782 03b8 80B4     		push	{r7}
 783              	.LCFI41:
 784              		.cfi_def_cfa_offset 4
 785              		.cfi_offset 7, -4
 786 03ba 00AF     		add	r7, sp, #0
 787              	.LCFI42:
 788              		.cfi_def_cfa_register 7
 654:../src/stm32f30x_rcc.c ****   return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 789              		.loc 1 654 0
 790 03bc 4FF48053 		mov	r3, #4096
 791 03c0 C4F20203 		movt	r3, 16386
 792 03c4 5B68     		ldr	r3, [r3, #4]
 793 03c6 DBB2     		uxtb	r3, r3
 794 03c8 03F00C03 		and	r3, r3, #12
 795 03cc DBB2     		uxtb	r3, r3
 655:../src/stm32f30x_rcc.c **** }
 796              		.loc 1 655 0
 797 03ce 1846     		mov	r0, r3
 798 03d0 BD46     		mov	sp, r7
 799 03d2 80BC     		pop	{r7}
 800 03d4 7047     		bx	lr
 801              		.cfi_endproc
 802              	.LFE125:
 804 03d6 00BF     		.align	2
 805              		.global	RCC_HCLKConfig
 806              		.thumb
 807              		.thumb_func
 809              	RCC_HCLKConfig:
 810              	.LFB126:
 656:../src/stm32f30x_rcc.c **** 
 657:../src/stm32f30x_rcc.c **** /**
 658:../src/stm32f30x_rcc.c ****   * @brief  Configures the AHB clock (HCLK).
 659:../src/stm32f30x_rcc.c ****   * @note   Depending on the device voltage range, the software has to set correctly
 660:../src/stm32f30x_rcc.c ****   *         these bits to ensure that the system frequency does not exceed the
 661:../src/stm32f30x_rcc.c ****   *         maximum allowed frequency (for more details refer to section above
 662:../src/stm32f30x_rcc.c ****   *         "CPU, AHB and APB busses clocks configuration functions").
 663:../src/stm32f30x_rcc.c ****   * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
 664:../src/stm32f30x_rcc.c ****   *                     the system clock (SYSCLK).
 665:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 666:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div1:   AHB clock = SYSCLK
 667:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div2:   AHB clock = SYSCLK/2
 668:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div4:   AHB clock = SYSCLK/4
 669:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div8:   AHB clock = SYSCLK/8
 670:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div16:  AHB clock = SYSCLK/16
 671:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div64:  AHB clock = SYSCLK/64
 672:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
 673:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
 674:../src/stm32f30x_rcc.c ****   *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
 675:../src/stm32f30x_rcc.c ****   * @retval None
 676:../src/stm32f30x_rcc.c ****   */
 677:../src/stm32f30x_rcc.c **** void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
 678:../src/stm32f30x_rcc.c **** {
 811              		.loc 1 678 0
 812              		.cfi_startproc
 813              		@ args = 0, pretend = 0, frame = 16
 814              		@ frame_needed = 1, uses_anonymous_args = 0
 815              		@ link register save eliminated.
 816 03d8 80B4     		push	{r7}
 817              	.LCFI43:
 818              		.cfi_def_cfa_offset 4
 819              		.cfi_offset 7, -4
 820 03da 85B0     		sub	sp, sp, #20
 821              	.LCFI44:
 822              		.cfi_def_cfa_offset 24
 823 03dc 00AF     		add	r7, sp, #0
 824              	.LCFI45:
 825              		.cfi_def_cfa_register 7
 826 03de 7860     		str	r0, [r7, #4]
 679:../src/stm32f30x_rcc.c ****   uint32_t tmpreg = 0;
 827              		.loc 1 679 0
 828 03e0 4FF00003 		mov	r3, #0
 829 03e4 FB60     		str	r3, [r7, #12]
 680:../src/stm32f30x_rcc.c ****   
 681:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 682:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_HCLK(RCC_SYSCLK));
 683:../src/stm32f30x_rcc.c ****   
 684:../src/stm32f30x_rcc.c ****   tmpreg = RCC->CFGR;
 830              		.loc 1 684 0
 831 03e6 4FF48053 		mov	r3, #4096
 832 03ea C4F20203 		movt	r3, 16386
 833 03ee 5B68     		ldr	r3, [r3, #4]
 834 03f0 FB60     		str	r3, [r7, #12]
 685:../src/stm32f30x_rcc.c ****   
 686:../src/stm32f30x_rcc.c ****   /* Clear HPRE[3:0] bits */
 687:../src/stm32f30x_rcc.c ****   tmpreg &= ~RCC_CFGR_HPRE;
 835              		.loc 1 687 0
 836 03f2 FB68     		ldr	r3, [r7, #12]
 837 03f4 23F0F003 		bic	r3, r3, #240
 838 03f8 FB60     		str	r3, [r7, #12]
 688:../src/stm32f30x_rcc.c ****   
 689:../src/stm32f30x_rcc.c ****   /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
 690:../src/stm32f30x_rcc.c ****   tmpreg |= RCC_SYSCLK;
 839              		.loc 1 690 0
 840 03fa FA68     		ldr	r2, [r7, #12]
 841 03fc 7B68     		ldr	r3, [r7, #4]
 842 03fe 1343     		orrs	r3, r3, r2
 843 0400 FB60     		str	r3, [r7, #12]
 691:../src/stm32f30x_rcc.c ****   
 692:../src/stm32f30x_rcc.c ****   /* Store the new value */
 693:../src/stm32f30x_rcc.c ****   RCC->CFGR = tmpreg;
 844              		.loc 1 693 0
 845 0402 4FF48053 		mov	r3, #4096
 846 0406 C4F20203 		movt	r3, 16386
 847 040a FA68     		ldr	r2, [r7, #12]
 848 040c 5A60     		str	r2, [r3, #4]
 694:../src/stm32f30x_rcc.c **** }
 849              		.loc 1 694 0
 850 040e 07F11407 		add	r7, r7, #20
 851 0412 BD46     		mov	sp, r7
 852 0414 80BC     		pop	{r7}
 853 0416 7047     		bx	lr
 854              		.cfi_endproc
 855              	.LFE126:
 857              		.align	2
 858              		.global	RCC_PCLK1Config
 859              		.thumb
 860              		.thumb_func
 862              	RCC_PCLK1Config:
 863              	.LFB127:
 695:../src/stm32f30x_rcc.c **** 
 696:../src/stm32f30x_rcc.c **** /**
 697:../src/stm32f30x_rcc.c ****   * @brief  Configures the Low Speed APB clock (PCLK1).
 698:../src/stm32f30x_rcc.c ****   * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
 699:../src/stm32f30x_rcc.c ****   *         the AHB clock (HCLK).
 700:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
 701:../src/stm32f30x_rcc.c ****   *     @arg RCC_HCLK_Div1: APB1 clock = HCLK
 702:../src/stm32f30x_rcc.c ****   *     @arg RCC_HCLK_Div2: APB1 clock = HCLK/2
 703:../src/stm32f30x_rcc.c ****   *     @arg RCC_HCLK_Div4: APB1 clock = HCLK/4
 704:../src/stm32f30x_rcc.c ****   *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
 705:../src/stm32f30x_rcc.c ****   *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
 706:../src/stm32f30x_rcc.c ****   * @retval None
 707:../src/stm32f30x_rcc.c ****   */
 708:../src/stm32f30x_rcc.c **** void RCC_PCLK1Config(uint32_t RCC_HCLK)
 709:../src/stm32f30x_rcc.c **** {
 864              		.loc 1 709 0
 865              		.cfi_startproc
 866              		@ args = 0, pretend = 0, frame = 16
 867              		@ frame_needed = 1, uses_anonymous_args = 0
 868              		@ link register save eliminated.
 869 0418 80B4     		push	{r7}
 870              	.LCFI46:
 871              		.cfi_def_cfa_offset 4
 872              		.cfi_offset 7, -4
 873 041a 85B0     		sub	sp, sp, #20
 874              	.LCFI47:
 875              		.cfi_def_cfa_offset 24
 876 041c 00AF     		add	r7, sp, #0
 877              	.LCFI48:
 878              		.cfi_def_cfa_register 7
 879 041e 7860     		str	r0, [r7, #4]
 710:../src/stm32f30x_rcc.c ****   uint32_t tmpreg = 0;
 880              		.loc 1 710 0
 881 0420 4FF00003 		mov	r3, #0
 882 0424 FB60     		str	r3, [r7, #12]
 711:../src/stm32f30x_rcc.c ****   
 712:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 713:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_PCLK(RCC_HCLK));
 714:../src/stm32f30x_rcc.c ****   
 715:../src/stm32f30x_rcc.c ****   tmpreg = RCC->CFGR;
 883              		.loc 1 715 0
 884 0426 4FF48053 		mov	r3, #4096
 885 042a C4F20203 		movt	r3, 16386
 886 042e 5B68     		ldr	r3, [r3, #4]
 887 0430 FB60     		str	r3, [r7, #12]
 716:../src/stm32f30x_rcc.c ****   /* Clear PPRE1[2:0] bits */
 717:../src/stm32f30x_rcc.c ****   tmpreg &= ~RCC_CFGR_PPRE1;
 888              		.loc 1 717 0
 889 0432 FB68     		ldr	r3, [r7, #12]
 890 0434 23F4E063 		bic	r3, r3, #1792
 891 0438 FB60     		str	r3, [r7, #12]
 718:../src/stm32f30x_rcc.c ****   
 719:../src/stm32f30x_rcc.c ****   /* Set PPRE1[2:0] bits according to RCC_HCLK value */
 720:../src/stm32f30x_rcc.c ****   tmpreg |= RCC_HCLK;
 892              		.loc 1 720 0
 893 043a FA68     		ldr	r2, [r7, #12]
 894 043c 7B68     		ldr	r3, [r7, #4]
 895 043e 1343     		orrs	r3, r3, r2
 896 0440 FB60     		str	r3, [r7, #12]
 721:../src/stm32f30x_rcc.c ****   
 722:../src/stm32f30x_rcc.c ****   /* Store the new value */
 723:../src/stm32f30x_rcc.c ****   RCC->CFGR = tmpreg;
 897              		.loc 1 723 0
 898 0442 4FF48053 		mov	r3, #4096
 899 0446 C4F20203 		movt	r3, 16386
 900 044a FA68     		ldr	r2, [r7, #12]
 901 044c 5A60     		str	r2, [r3, #4]
 724:../src/stm32f30x_rcc.c **** }
 902              		.loc 1 724 0
 903 044e 07F11407 		add	r7, r7, #20
 904 0452 BD46     		mov	sp, r7
 905 0454 80BC     		pop	{r7}
 906 0456 7047     		bx	lr
 907              		.cfi_endproc
 908              	.LFE127:
 910              		.align	2
 911              		.global	RCC_PCLK2Config
 912              		.thumb
 913              		.thumb_func
 915              	RCC_PCLK2Config:
 916              	.LFB128:
 725:../src/stm32f30x_rcc.c **** 
 726:../src/stm32f30x_rcc.c **** /**
 727:../src/stm32f30x_rcc.c ****   * @brief  Configures the High Speed APB clock (PCLK2).
 728:../src/stm32f30x_rcc.c ****   * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
 729:../src/stm32f30x_rcc.c ****   *         the AHB clock (HCLK).
 730:../src/stm32f30x_rcc.c ****   *         This parameter can be one of the following values:
 731:../src/stm32f30x_rcc.c ****   *             @arg RCC_HCLK_Div1: APB2 clock = HCLK
 732:../src/stm32f30x_rcc.c ****   *             @arg RCC_HCLK_Div2: APB2 clock = HCLK/2
 733:../src/stm32f30x_rcc.c ****   *             @arg RCC_HCLK_Div4: APB2 clock = HCLK/4
 734:../src/stm32f30x_rcc.c ****   *             @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
 735:../src/stm32f30x_rcc.c ****   *             @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
 736:../src/stm32f30x_rcc.c ****   * @retval None
 737:../src/stm32f30x_rcc.c ****   */
 738:../src/stm32f30x_rcc.c **** void RCC_PCLK2Config(uint32_t RCC_HCLK)
 739:../src/stm32f30x_rcc.c **** {
 917              		.loc 1 739 0
 918              		.cfi_startproc
 919              		@ args = 0, pretend = 0, frame = 16
 920              		@ frame_needed = 1, uses_anonymous_args = 0
 921              		@ link register save eliminated.
 922 0458 80B4     		push	{r7}
 923              	.LCFI49:
 924              		.cfi_def_cfa_offset 4
 925              		.cfi_offset 7, -4
 926 045a 85B0     		sub	sp, sp, #20
 927              	.LCFI50:
 928              		.cfi_def_cfa_offset 24
 929 045c 00AF     		add	r7, sp, #0
 930              	.LCFI51:
 931              		.cfi_def_cfa_register 7
 932 045e 7860     		str	r0, [r7, #4]
 740:../src/stm32f30x_rcc.c ****   uint32_t tmpreg = 0;
 933              		.loc 1 740 0
 934 0460 4FF00003 		mov	r3, #0
 935 0464 FB60     		str	r3, [r7, #12]
 741:../src/stm32f30x_rcc.c ****   
 742:../src/stm32f30x_rcc.c ****   /* Check the parameters */
 743:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_PCLK(RCC_HCLK));
 744:../src/stm32f30x_rcc.c ****   
 745:../src/stm32f30x_rcc.c ****   tmpreg = RCC->CFGR;
 936              		.loc 1 745 0
 937 0466 4FF48053 		mov	r3, #4096
 938 046a C4F20203 		movt	r3, 16386
 939 046e 5B68     		ldr	r3, [r3, #4]
 940 0470 FB60     		str	r3, [r7, #12]
 746:../src/stm32f30x_rcc.c ****   /* Clear PPRE2[2:0] bits */
 747:../src/stm32f30x_rcc.c ****   tmpreg &= ~RCC_CFGR_PPRE2;
 941              		.loc 1 747 0
 942 0472 FB68     		ldr	r3, [r7, #12]
 943 0474 23F46053 		bic	r3, r3, #14336
 944 0478 FB60     		str	r3, [r7, #12]
 748:../src/stm32f30x_rcc.c ****   /* Set PPRE2[2:0] bits according to RCC_HCLK value */
 749:../src/stm32f30x_rcc.c ****   tmpreg |= RCC_HCLK << 3;
 945              		.loc 1 749 0
 946 047a 7B68     		ldr	r3, [r7, #4]
 947 047c 4FEAC303 		lsl	r3, r3, #3
 948 0480 FA68     		ldr	r2, [r7, #12]
 949 0482 1343     		orrs	r3, r3, r2
 950 0484 FB60     		str	r3, [r7, #12]
 750:../src/stm32f30x_rcc.c ****   /* Store the new value */
 751:../src/stm32f30x_rcc.c ****   RCC->CFGR = tmpreg;
 951              		.loc 1 751 0
 952 0486 4FF48053 		mov	r3, #4096
 953 048a C4F20203 		movt	r3, 16386
 954 048e FA68     		ldr	r2, [r7, #12]
 955 0490 5A60     		str	r2, [r3, #4]
 752:../src/stm32f30x_rcc.c **** }
 956              		.loc 1 752 0
 957 0492 07F11407 		add	r7, r7, #20
 958 0496 BD46     		mov	sp, r7
 959 0498 80BC     		pop	{r7}
 960 049a 7047     		bx	lr
 961              		.cfi_endproc
 962              	.LFE128:
 964              		.align	2
 965              		.global	RCC_GetClocksFreq
 966              		.thumb
 967              		.thumb_func
 969              	RCC_GetClocksFreq:
 970              	.LFB129:
 753:../src/stm32f30x_rcc.c **** 
 754:../src/stm32f30x_rcc.c **** /**
 755:../src/stm32f30x_rcc.c ****   * @brief  Returns the frequencies of the System, AHB, APB2 and APB1 busses clocks.
 756:../src/stm32f30x_rcc.c ****   * 
 757:../src/stm32f30x_rcc.c ****   *  @note    This function returns the frequencies of :
 758:../src/stm32f30x_rcc.c ****   *           System, AHB, APB2 and APB1 busses clocks, ADC1/2/3/4 clocks, 
 759:../src/stm32f30x_rcc.c ****   *           USART1/2/3/4/5 clocks, I2C1/2 clocks and TIM1/8 Clocks.
 760:../src/stm32f30x_rcc.c ****   *                         
 761:../src/stm32f30x_rcc.c ****   * @note     The frequency returned by this function is not the real frequency
 762:../src/stm32f30x_rcc.c ****   *           in the chip. It is calculated based on the predefined constant and
 763:../src/stm32f30x_rcc.c ****   *           the source selected by RCC_SYSCLKConfig().
 764:../src/stm32f30x_rcc.c ****   *                                              
 765:../src/stm32f30x_rcc.c ****   * @note      If SYSCLK source is HSI, function returns constant HSI_VALUE(*)
 766:../src/stm32f30x_rcc.c ****   *                                              
 767:../src/stm32f30x_rcc.c ****   * @note      If SYSCLK source is HSE, function returns constant HSE_VALUE(**)
 768:../src/stm32f30x_rcc.c ****   *                          
 769:../src/stm32f30x_rcc.c ****   * @note      If SYSCLK source is PLL, function returns constant HSE_VALUE(**) 
 770:../src/stm32f30x_rcc.c ****   *             or HSI_VALUE(*) multiplied by the PLL factors.
 771:../src/stm32f30x_rcc.c ****   *         
 772:../src/stm32f30x_rcc.c ****   * @note     (*) HSI_VALUE is a constant defined in stm32f30x.h file (default value
 773:../src/stm32f30x_rcc.c ****   *               8 MHz) but the real value may vary depending on the variations
 774:../src/stm32f30x_rcc.c ****   *               in voltage and temperature, refer to RCC_AdjustHSICalibrationValue().   
 775:../src/stm32f30x_rcc.c ****   *    
 776:../src/stm32f30x_rcc.c ****   * @note     (**) HSE_VALUE is a constant defined in stm32f30x.h file (default value
 777:../src/stm32f30x_rcc.c ****   *                8 MHz), user has to ensure that HSE_VALUE is same as the real
 778:../src/stm32f30x_rcc.c ****   *                frequency of the crystal used. Otherwise, this function may
 779:../src/stm32f30x_rcc.c ****   *                return wrong result.
 780:../src/stm32f30x_rcc.c ****   *                
 781:../src/stm32f30x_rcc.c ****   * @note     The result of this function could be not correct when using fractional
 782:../src/stm32f30x_rcc.c ****   *           value for HSE crystal.   
 783:../src/stm32f30x_rcc.c ****   *             
 784:../src/stm32f30x_rcc.c ****   * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold 
 785:../src/stm32f30x_rcc.c ****   *         the clocks frequencies. 
 786:../src/stm32f30x_rcc.c ****   *     
 787:../src/stm32f30x_rcc.c ****   * @note     This function can be used by the user application to compute the 
 788:../src/stm32f30x_rcc.c ****   *           baudrate for the communication peripherals or configure other parameters.
 789:../src/stm32f30x_rcc.c ****   * @note     Each time SYSCLK, HCLK, PCLK1 and/or PCLK2 clock changes, this function
 790:../src/stm32f30x_rcc.c ****   *           must be called to update the structure's field. Otherwise, any
 791:../src/stm32f30x_rcc.c ****   *           configuration based on this function will be incorrect.
 792:../src/stm32f30x_rcc.c ****   *    
 793:../src/stm32f30x_rcc.c ****   * @retval None
 794:../src/stm32f30x_rcc.c ****   */
 795:../src/stm32f30x_rcc.c **** void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
 796:../src/stm32f30x_rcc.c **** {
 971              		.loc 1 796 0
 972              		.cfi_startproc
 973              		@ args = 0, pretend = 0, frame = 40
 974              		@ frame_needed = 1, uses_anonymous_args = 0
 975              		@ link register save eliminated.
 976 049c 80B4     		push	{r7}
 977              	.LCFI52:
 978              		.cfi_def_cfa_offset 4
 979              		.cfi_offset 7, -4
 980 049e 8BB0     		sub	sp, sp, #44
 981              	.LCFI53:
 982              		.cfi_def_cfa_offset 48
 983 04a0 00AF     		add	r7, sp, #0
 984              	.LCFI54:
 985              		.cfi_def_cfa_register 7
 986 04a2 7860     		str	r0, [r7, #4]
 797:../src/stm32f30x_rcc.c ****   uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
 987              		.loc 1 797 0
 988 04a4 4FF00003 		mov	r3, #0
 989 04a8 3B62     		str	r3, [r7, #32]
 990 04aa 4FF00003 		mov	r3, #0
 991 04ae FB61     		str	r3, [r7, #28]
 992 04b0 4FF00003 		mov	r3, #0
 993 04b4 BB61     		str	r3, [r7, #24]
 994 04b6 4FF00003 		mov	r3, #0
 995 04ba 7B61     		str	r3, [r7, #20]
 996 04bc 4FF00003 		mov	r3, #0
 997 04c0 3B61     		str	r3, [r7, #16]
 998 04c2 4FF00003 		mov	r3, #0
 999 04c6 7B62     		str	r3, [r7, #36]
 798:../src/stm32f30x_rcc.c ****   uint32_t apb2presc = 0, ahbpresc = 0;
 1000              		.loc 1 798 0
 1001 04c8 4FF00003 		mov	r3, #0
 1002 04cc FB60     		str	r3, [r7, #12]
 1003 04ce 4FF00003 		mov	r3, #0
 1004 04d2 BB60     		str	r3, [r7, #8]
 799:../src/stm32f30x_rcc.c ****   
 800:../src/stm32f30x_rcc.c ****   /* Get SYSCLK source -------------------------------------------------------*/
 801:../src/stm32f30x_rcc.c ****   tmp = RCC->CFGR & RCC_CFGR_SWS;
 1005              		.loc 1 801 0
 1006 04d4 4FF48053 		mov	r3, #4096
 1007 04d8 C4F20203 		movt	r3, 16386
 1008 04dc 5B68     		ldr	r3, [r3, #4]
 1009 04de 03F00C03 		and	r3, r3, #12
 1010 04e2 3B62     		str	r3, [r7, #32]
 802:../src/stm32f30x_rcc.c ****   
 803:../src/stm32f30x_rcc.c ****   switch (tmp)
 1011              		.loc 1 803 0
 1012 04e4 3B6A     		ldr	r3, [r7, #32]
 1013 04e6 042B     		cmp	r3, #4
 1014 04e8 0AD0     		beq	.L28
 1015 04ea 082B     		cmp	r3, #8
 1016 04ec 0FD0     		beq	.L29
 1017 04ee 002B     		cmp	r3, #0
 1018 04f0 48D1     		bne	.L65
 1019              	.L27:
 804:../src/stm32f30x_rcc.c ****   {
 805:../src/stm32f30x_rcc.c ****     case 0x00:  /* HSI used as system clock */
 806:../src/stm32f30x_rcc.c ****       RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 1020              		.loc 1 806 0
 1021 04f2 7A68     		ldr	r2, [r7, #4]
 1022 04f4 4FF49053 		mov	r3, #4608
 1023 04f8 C0F27A03 		movt	r3, 122
 1024 04fc 1360     		str	r3, [r2, #0]
 807:../src/stm32f30x_rcc.c ****       break;
 1025              		.loc 1 807 0
 1026 04fe 48E0     		b	.L30
 1027              	.L28:
 808:../src/stm32f30x_rcc.c ****     case 0x04:  /* HSE used as system clock */
 809:../src/stm32f30x_rcc.c ****       RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 1028              		.loc 1 809 0
 1029 0500 7A68     		ldr	r2, [r7, #4]
 1030 0502 4FF49053 		mov	r3, #4608
 1031 0506 C0F27A03 		movt	r3, 122
 1032 050a 1360     		str	r3, [r2, #0]
 810:../src/stm32f30x_rcc.c ****       break;
 1033              		.loc 1 810 0
 1034 050c 41E0     		b	.L30
 1035              	.L29:
 811:../src/stm32f30x_rcc.c ****     case 0x08:  /* PLL used as system clock */
 812:../src/stm32f30x_rcc.c ****       /* Get PLL clock source and multiplication factor ----------------------*/
 813:../src/stm32f30x_rcc.c ****       pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 1036              		.loc 1 813 0
 1037 050e 4FF48053 		mov	r3, #4096
 1038 0512 C4F20203 		movt	r3, 16386
 1039 0516 5B68     		ldr	r3, [r3, #4]
 1040 0518 03F47013 		and	r3, r3, #3932160
 1041 051c FB61     		str	r3, [r7, #28]
 814:../src/stm32f30x_rcc.c ****       pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 1042              		.loc 1 814 0
 1043 051e 4FF48053 		mov	r3, #4096
 1044 0522 C4F20203 		movt	r3, 16386
 1045 0526 5B68     		ldr	r3, [r3, #4]
 1046 0528 03F48033 		and	r3, r3, #65536
 1047 052c BB61     		str	r3, [r7, #24]
 815:../src/stm32f30x_rcc.c ****       pllmull = ( pllmull >> 18) + 2;
 1048              		.loc 1 815 0
 1049 052e FB69     		ldr	r3, [r7, #28]
 1050 0530 4FEA9343 		lsr	r3, r3, #18
 1051 0534 03F10203 		add	r3, r3, #2
 1052 0538 FB61     		str	r3, [r7, #28]
 816:../src/stm32f30x_rcc.c ****       
 817:../src/stm32f30x_rcc.c ****       if (pllsource == 0x00)
 1053              		.loc 1 817 0
 1054 053a BB69     		ldr	r3, [r7, #24]
 1055 053c 002B     		cmp	r3, #0
 1056 053e 08D1     		bne	.L31
 818:../src/stm32f30x_rcc.c ****       {
 819:../src/stm32f30x_rcc.c ****         /* HSI oscillator clock divided by 2 selected as PLL clock entry */
 820:../src/stm32f30x_rcc.c ****         pllclk = (HSI_VALUE >> 1) * pllmull;
 1057              		.loc 1 820 0
 1058 0540 FA69     		ldr	r2, [r7, #28]
 1059 0542 4FF41063 		mov	r3, #2304
 1060 0546 C0F23D03 		movt	r3, 61
 1061 054a 03FB02F3 		mul	r3, r3, r2
 1062 054e 7B62     		str	r3, [r7, #36]
 1063 0550 14E0     		b	.L32
 1064              	.L31:
 821:../src/stm32f30x_rcc.c ****       }
 822:../src/stm32f30x_rcc.c ****       else
 823:../src/stm32f30x_rcc.c ****       {
 824:../src/stm32f30x_rcc.c ****         prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 1065              		.loc 1 824 0
 1066 0552 4FF48053 		mov	r3, #4096
 1067 0556 C4F20203 		movt	r3, 16386
 1068 055a DB6A     		ldr	r3, [r3, #44]
 1069 055c 03F00F03 		and	r3, r3, #15
 1070 0560 03F10103 		add	r3, r3, #1
 1071 0564 7B61     		str	r3, [r7, #20]
 825:../src/stm32f30x_rcc.c ****         /* HSE oscillator clock selected as PREDIV1 clock entry */
 826:../src/stm32f30x_rcc.c ****         pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
 1072              		.loc 1 826 0
 1073 0566 4FF49053 		mov	r3, #4608
 1074 056a C0F27A03 		movt	r3, 122
 1075 056e 7A69     		ldr	r2, [r7, #20]
 1076 0570 B3FBF2F3 		udiv	r3, r3, r2
 1077 0574 FA69     		ldr	r2, [r7, #28]
 1078 0576 02FB03F3 		mul	r3, r2, r3
 1079 057a 7B62     		str	r3, [r7, #36]
 1080              	.L32:
 827:../src/stm32f30x_rcc.c ****       }
 828:../src/stm32f30x_rcc.c ****       RCC_Clocks->SYSCLK_Frequency = pllclk;      
 1081              		.loc 1 828 0
 1082 057c 7B68     		ldr	r3, [r7, #4]
 1083 057e 7A6A     		ldr	r2, [r7, #36]
 1084 0580 1A60     		str	r2, [r3, #0]
 829:../src/stm32f30x_rcc.c ****       break;
 1085              		.loc 1 829 0
 1086 0582 06E0     		b	.L30
 1087              	.L65:
 830:../src/stm32f30x_rcc.c ****     default: /* HSI used as system clock */
 831:../src/stm32f30x_rcc.c ****       RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 1088              		.loc 1 831 0
 1089 0584 7A68     		ldr	r2, [r7, #4]
 1090 0586 4FF49053 		mov	r3, #4608
 1091 058a C0F27A03 		movt	r3, 122
 1092 058e 1360     		str	r3, [r2, #0]
 832:../src/stm32f30x_rcc.c ****       break;
 1093              		.loc 1 832 0
 1094 0590 00BF     		nop
 1095              	.L30:
 833:../src/stm32f30x_rcc.c ****   }
 834:../src/stm32f30x_rcc.c ****     /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
 835:../src/stm32f30x_rcc.c ****   /* Get HCLK prescaler */
 836:../src/stm32f30x_rcc.c ****   tmp = RCC->CFGR & RCC_CFGR_HPRE;
 1096              		.loc 1 836 0
 1097 0592 4FF48053 		mov	r3, #4096
 1098 0596 C4F20203 		movt	r3, 16386
 1099 059a 5B68     		ldr	r3, [r3, #4]
 1100 059c 03F0F003 		and	r3, r3, #240
 1101 05a0 3B62     		str	r3, [r7, #32]
 837:../src/stm32f30x_rcc.c ****   tmp = tmp >> 4;
 1102              		.loc 1 837 0
 1103 05a2 3B6A     		ldr	r3, [r7, #32]
 1104 05a4 4FEA1313 		lsr	r3, r3, #4
 1105 05a8 3B62     		str	r3, [r7, #32]
 838:../src/stm32f30x_rcc.c ****   ahbpresc = APBAHBPrescTable[tmp]; 
 1106              		.loc 1 838 0
 1107 05aa 40F20003 		movw	r3, #:lower16:APBAHBPrescTable
 1108 05ae C0F20003 		movt	r3, #:upper16:APBAHBPrescTable
 1109 05b2 3A6A     		ldr	r2, [r7, #32]
 1110 05b4 9B18     		adds	r3, r3, r2
 1111 05b6 1B78     		ldrb	r3, [r3, #0]
 1112 05b8 DBB2     		uxtb	r3, r3
 1113 05ba BB60     		str	r3, [r7, #8]
 839:../src/stm32f30x_rcc.c ****   /* HCLK clock frequency */
 840:../src/stm32f30x_rcc.c ****   RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> ahbpresc;
 1114              		.loc 1 840 0
 1115 05bc 7B68     		ldr	r3, [r7, #4]
 1116 05be 1A68     		ldr	r2, [r3, #0]
 1117 05c0 BB68     		ldr	r3, [r7, #8]
 1118 05c2 22FA03F2 		lsr	r2, r2, r3
 1119 05c6 7B68     		ldr	r3, [r7, #4]
 1120 05c8 5A60     		str	r2, [r3, #4]
 841:../src/stm32f30x_rcc.c **** 
 842:../src/stm32f30x_rcc.c ****   /* Get PCLK1 prescaler */
 843:../src/stm32f30x_rcc.c ****   tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 1121              		.loc 1 843 0
 1122 05ca 4FF48053 		mov	r3, #4096
 1123 05ce C4F20203 		movt	r3, 16386
 1124 05d2 5B68     		ldr	r3, [r3, #4]
 1125 05d4 03F4E063 		and	r3, r3, #1792
 1126 05d8 3B62     		str	r3, [r7, #32]
 844:../src/stm32f30x_rcc.c ****   tmp = tmp >> 8;
 1127              		.loc 1 844 0
 1128 05da 3B6A     		ldr	r3, [r7, #32]
 1129 05dc 4FEA1323 		lsr	r3, r3, #8
 1130 05e0 3B62     		str	r3, [r7, #32]
 845:../src/stm32f30x_rcc.c ****   presc = APBAHBPrescTable[tmp];
 1131              		.loc 1 845 0
 1132 05e2 40F20003 		movw	r3, #:lower16:APBAHBPrescTable
 1133 05e6 C0F20003 		movt	r3, #:upper16:APBAHBPrescTable
 1134 05ea 3A6A     		ldr	r2, [r7, #32]
 1135 05ec 9B18     		adds	r3, r3, r2
 1136 05ee 1B78     		ldrb	r3, [r3, #0]
 1137 05f0 DBB2     		uxtb	r3, r3
 1138 05f2 3B61     		str	r3, [r7, #16]
 846:../src/stm32f30x_rcc.c ****   /* PCLK1 clock frequency */
 847:../src/stm32f30x_rcc.c ****   RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 1139              		.loc 1 847 0
 1140 05f4 7B68     		ldr	r3, [r7, #4]
 1141 05f6 5A68     		ldr	r2, [r3, #4]
 1142 05f8 3B69     		ldr	r3, [r7, #16]
 1143 05fa 22FA03F2 		lsr	r2, r2, r3
 1144 05fe 7B68     		ldr	r3, [r7, #4]
 1145 0600 9A60     		str	r2, [r3, #8]
 848:../src/stm32f30x_rcc.c ****   
 849:../src/stm32f30x_rcc.c ****   /* Get PCLK2 prescaler */
 850:../src/stm32f30x_rcc.c ****   tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 1146              		.loc 1 850 0
 1147 0602 4FF48053 		mov	r3, #4096
 1148 0606 C4F20203 		movt	r3, 16386
 1149 060a 5B68     		ldr	r3, [r3, #4]
 1150 060c 03F46053 		and	r3, r3, #14336
 1151 0610 3B62     		str	r3, [r7, #32]
 851:../src/stm32f30x_rcc.c ****   tmp = tmp >> 11;
 1152              		.loc 1 851 0
 1153 0612 3B6A     		ldr	r3, [r7, #32]
 1154 0614 4FEAD323 		lsr	r3, r3, #11
 1155 0618 3B62     		str	r3, [r7, #32]
 852:../src/stm32f30x_rcc.c ****   apb2presc = APBAHBPrescTable[tmp];
 1156              		.loc 1 852 0
 1157 061a 40F20003 		movw	r3, #:lower16:APBAHBPrescTable
 1158 061e C0F20003 		movt	r3, #:upper16:APBAHBPrescTable
 1159 0622 3A6A     		ldr	r2, [r7, #32]
 1160 0624 9B18     		adds	r3, r3, r2
 1161 0626 1B78     		ldrb	r3, [r3, #0]
 1162 0628 DBB2     		uxtb	r3, r3
 1163 062a FB60     		str	r3, [r7, #12]
 853:../src/stm32f30x_rcc.c ****   /* PCLK2 clock frequency */
 854:../src/stm32f30x_rcc.c ****   RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> apb2presc;
 1164              		.loc 1 854 0
 1165 062c 7B68     		ldr	r3, [r7, #4]
 1166 062e 5A68     		ldr	r2, [r3, #4]
 1167 0630 FB68     		ldr	r3, [r7, #12]
 1168 0632 22FA03F2 		lsr	r2, r2, r3
 1169 0636 7B68     		ldr	r3, [r7, #4]
 1170 0638 DA60     		str	r2, [r3, #12]
 855:../src/stm32f30x_rcc.c ****   
 856:../src/stm32f30x_rcc.c ****   /* Get ADC12CLK prescaler */
 857:../src/stm32f30x_rcc.c ****   tmp = RCC->CFGR2 & RCC_CFGR2_ADCPRE12;
 1171              		.loc 1 857 0
 1172 063a 4FF48053 		mov	r3, #4096
 1173 063e C4F20203 		movt	r3, 16386
 1174 0642 DB6A     		ldr	r3, [r3, #44]
 1175 0644 03F4F873 		and	r3, r3, #496
 1176 0648 3B62     		str	r3, [r7, #32]
 858:../src/stm32f30x_rcc.c ****   tmp = tmp >> 4;
 1177              		.loc 1 858 0
 1178 064a 3B6A     		ldr	r3, [r7, #32]
 1179 064c 4FEA1313 		lsr	r3, r3, #4
 1180 0650 3B62     		str	r3, [r7, #32]
 859:../src/stm32f30x_rcc.c ****   presc = ADCPrescTable[tmp];
 1181              		.loc 1 859 0
 1182 0652 40F20003 		movw	r3, #:lower16:ADCPrescTable
 1183 0656 C0F20003 		movt	r3, #:upper16:ADCPrescTable
 1184 065a 3A6A     		ldr	r2, [r7, #32]
 1185 065c 33F81230 		ldrh	r3, [r3, r2, lsl #1]	@ movhi
 1186 0660 9BB2     		uxth	r3, r3
 1187 0662 3B61     		str	r3, [r7, #16]
 860:../src/stm32f30x_rcc.c ****   if ((presc & 0x10) != 0)
 1188              		.loc 1 860 0
 1189 0664 3B69     		ldr	r3, [r7, #16]
 1190 0666 03F01003 		and	r3, r3, #16
 1191 066a 002B     		cmp	r3, #0
 1192 066c 06D0     		beq	.L33
 861:../src/stm32f30x_rcc.c ****   {
 862:../src/stm32f30x_rcc.c ****      /* ADC12CLK clock frequency is derived from PLL clock */
 863:../src/stm32f30x_rcc.c ****      RCC_Clocks->ADC12CLK_Frequency = pllclk / presc;
 1193              		.loc 1 863 0
 1194 066e 7A6A     		ldr	r2, [r7, #36]
 1195 0670 3B69     		ldr	r3, [r7, #16]
 1196 0672 B2FBF3F2 		udiv	r2, r2, r3
 1197 0676 7B68     		ldr	r3, [r7, #4]
 1198 0678 1A61     		str	r2, [r3, #16]
 1199 067a 03E0     		b	.L34
 1200              	.L33:
 864:../src/stm32f30x_rcc.c ****   }
 865:../src/stm32f30x_rcc.c ****   else
 866:../src/stm32f30x_rcc.c ****   {
 867:../src/stm32f30x_rcc.c ****    /* ADC12CLK clock frequency is AHB clock */
 868:../src/stm32f30x_rcc.c ****      RCC_Clocks->ADC12CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1201              		.loc 1 868 0
 1202 067c 7B68     		ldr	r3, [r7, #4]
 1203 067e 1A68     		ldr	r2, [r3, #0]
 1204 0680 7B68     		ldr	r3, [r7, #4]
 1205 0682 1A61     		str	r2, [r3, #16]
 1206              	.L34:
 869:../src/stm32f30x_rcc.c ****   }
 870:../src/stm32f30x_rcc.c ****   
 871:../src/stm32f30x_rcc.c ****   /* Get ADC34CLK prescaler */
 872:../src/stm32f30x_rcc.c ****   tmp = RCC->CFGR2 & RCC_CFGR2_ADCPRE34;
 1207              		.loc 1 872 0
 1208 0684 4FF48053 		mov	r3, #4096
 1209 0688 C4F20203 		movt	r3, 16386
 1210 068c DB6A     		ldr	r3, [r3, #44]
 1211 068e 03F47853 		and	r3, r3, #15872
 1212 0692 3B62     		str	r3, [r7, #32]
 873:../src/stm32f30x_rcc.c ****   tmp = tmp >> 9;
 1213              		.loc 1 873 0
 1214 0694 3B6A     		ldr	r3, [r7, #32]
 1215 0696 4FEA5323 		lsr	r3, r3, #9
 1216 069a 3B62     		str	r3, [r7, #32]
 874:../src/stm32f30x_rcc.c ****   presc = ADCPrescTable[tmp];
 1217              		.loc 1 874 0
 1218 069c 40F20003 		movw	r3, #:lower16:ADCPrescTable
 1219 06a0 C0F20003 		movt	r3, #:upper16:ADCPrescTable
 1220 06a4 3A6A     		ldr	r2, [r7, #32]
 1221 06a6 33F81230 		ldrh	r3, [r3, r2, lsl #1]	@ movhi
 1222 06aa 9BB2     		uxth	r3, r3
 1223 06ac 3B61     		str	r3, [r7, #16]
 875:../src/stm32f30x_rcc.c ****   if ((presc & 0x10) != 0)
 1224              		.loc 1 875 0
 1225 06ae 3B69     		ldr	r3, [r7, #16]
 1226 06b0 03F01003 		and	r3, r3, #16
 1227 06b4 002B     		cmp	r3, #0
 1228 06b6 06D0     		beq	.L35
 876:../src/stm32f30x_rcc.c ****   {
 877:../src/stm32f30x_rcc.c ****      /* ADC34CLK clock frequency is derived from PLL clock */
 878:../src/stm32f30x_rcc.c ****      RCC_Clocks->ADC34CLK_Frequency = pllclk / presc;
 1229              		.loc 1 878 0
 1230 06b8 7A6A     		ldr	r2, [r7, #36]
 1231 06ba 3B69     		ldr	r3, [r7, #16]
 1232 06bc B2FBF3F2 		udiv	r2, r2, r3
 1233 06c0 7B68     		ldr	r3, [r7, #4]
 1234 06c2 5A61     		str	r2, [r3, #20]
 1235 06c4 03E0     		b	.L36
 1236              	.L35:
 879:../src/stm32f30x_rcc.c ****   }
 880:../src/stm32f30x_rcc.c ****   else
 881:../src/stm32f30x_rcc.c ****   {
 882:../src/stm32f30x_rcc.c ****    /* ADC34CLK clock frequency is AHB clock */
 883:../src/stm32f30x_rcc.c ****      RCC_Clocks->ADC34CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1237              		.loc 1 883 0
 1238 06c6 7B68     		ldr	r3, [r7, #4]
 1239 06c8 1A68     		ldr	r2, [r3, #0]
 1240 06ca 7B68     		ldr	r3, [r7, #4]
 1241 06cc 5A61     		str	r2, [r3, #20]
 1242              	.L36:
 884:../src/stm32f30x_rcc.c ****   }
 885:../src/stm32f30x_rcc.c **** 
 886:../src/stm32f30x_rcc.c ****   /* I2C1CLK clock frequency */
 887:../src/stm32f30x_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
 1243              		.loc 1 887 0
 1244 06ce 4FF48053 		mov	r3, #4096
 1245 06d2 C4F20203 		movt	r3, 16386
 1246 06d6 1B6B     		ldr	r3, [r3, #48]
 1247 06d8 03F01003 		and	r3, r3, #16
 1248 06dc 002B     		cmp	r3, #0
 1249 06de 06D1     		bne	.L37
 888:../src/stm32f30x_rcc.c ****   {
 889:../src/stm32f30x_rcc.c ****     /* I2C1 Clock is HSI Osc. */
 890:../src/stm32f30x_rcc.c ****     RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
 1250              		.loc 1 890 0
 1251 06e0 7A68     		ldr	r2, [r7, #4]
 1252 06e2 4FF49053 		mov	r3, #4608
 1253 06e6 C0F27A03 		movt	r3, 122
 1254 06ea 9361     		str	r3, [r2, #24]
 1255 06ec 03E0     		b	.L38
 1256              	.L37:
 891:../src/stm32f30x_rcc.c ****   }
 892:../src/stm32f30x_rcc.c ****   else
 893:../src/stm32f30x_rcc.c ****   {
 894:../src/stm32f30x_rcc.c ****     /* I2C1 Clock is System Clock */
 895:../src/stm32f30x_rcc.c ****     RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1257              		.loc 1 895 0
 1258 06ee 7B68     		ldr	r3, [r7, #4]
 1259 06f0 1A68     		ldr	r2, [r3, #0]
 1260 06f2 7B68     		ldr	r3, [r7, #4]
 1261 06f4 9A61     		str	r2, [r3, #24]
 1262              	.L38:
 896:../src/stm32f30x_rcc.c ****   }
 897:../src/stm32f30x_rcc.c **** 
 898:../src/stm32f30x_rcc.c ****   /* I2C2CLK clock frequency */
 899:../src/stm32f30x_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_I2C2SW) != RCC_CFGR3_I2C2SW)
 1263              		.loc 1 899 0
 1264 06f6 4FF48053 		mov	r3, #4096
 1265 06fa C4F20203 		movt	r3, 16386
 1266 06fe 1B6B     		ldr	r3, [r3, #48]
 1267 0700 03F02003 		and	r3, r3, #32
 1268 0704 002B     		cmp	r3, #0
 1269 0706 06D1     		bne	.L39
 900:../src/stm32f30x_rcc.c ****   {
 901:../src/stm32f30x_rcc.c ****     /* I2C2 Clock is HSI Osc. */
 902:../src/stm32f30x_rcc.c ****     RCC_Clocks->I2C2CLK_Frequency = HSI_VALUE;
 1270              		.loc 1 902 0
 1271 0708 7A68     		ldr	r2, [r7, #4]
 1272 070a 4FF49053 		mov	r3, #4608
 1273 070e C0F27A03 		movt	r3, 122
 1274 0712 D361     		str	r3, [r2, #28]
 1275 0714 03E0     		b	.L40
 1276              	.L39:
 903:../src/stm32f30x_rcc.c ****   }
 904:../src/stm32f30x_rcc.c ****   else
 905:../src/stm32f30x_rcc.c ****   {
 906:../src/stm32f30x_rcc.c ****     /* I2C2 Clock is System Clock */
 907:../src/stm32f30x_rcc.c ****     RCC_Clocks->I2C2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1277              		.loc 1 907 0
 1278 0716 7B68     		ldr	r3, [r7, #4]
 1279 0718 1A68     		ldr	r2, [r3, #0]
 1280 071a 7B68     		ldr	r3, [r7, #4]
 1281 071c DA61     		str	r2, [r3, #28]
 1282              	.L40:
 908:../src/stm32f30x_rcc.c ****   }
 909:../src/stm32f30x_rcc.c ****   
 910:../src/stm32f30x_rcc.c ****     /* TIM1CLK clock frequency */
 911:../src/stm32f30x_rcc.c ****   if(((RCC->CFGR3 & RCC_CFGR3_TIM1SW) == RCC_CFGR3_TIM1SW)&& (RCC_Clocks->SYSCLK_Frequency == pllcl
 1283              		.loc 1 911 0
 1284 071e 4FF48053 		mov	r3, #4096
 1285 0722 C4F20203 		movt	r3, 16386
 1286 0726 1B6B     		ldr	r3, [r3, #48]
 1287 0728 03F48073 		and	r3, r3, #256
 1288 072c 002B     		cmp	r3, #0
 1289 072e 0ED0     		beq	.L41
 1290              		.loc 1 911 0 is_stmt 0 discriminator 1
 1291 0730 7B68     		ldr	r3, [r7, #4]
 1292 0732 1A68     		ldr	r2, [r3, #0]
 1293 0734 7B6A     		ldr	r3, [r7, #36]
 1294 0736 9A42     		cmp	r2, r3
 1295 0738 09D1     		bne	.L41
 912:../src/stm32f30x_rcc.c ****   && (apb2presc == ahbpresc)) 
 1296              		.loc 1 912 0 is_stmt 1
 1297 073a FA68     		ldr	r2, [r7, #12]
 1298 073c BB68     		ldr	r3, [r7, #8]
 1299 073e 9A42     		cmp	r2, r3
 1300 0740 05D1     		bne	.L41
 913:../src/stm32f30x_rcc.c ****   {
 914:../src/stm32f30x_rcc.c ****     /* TIM1 Clock is 2 * pllclk */
 915:../src/stm32f30x_rcc.c ****     RCC_Clocks->TIM1CLK_Frequency = pllclk * 2;
 1301              		.loc 1 915 0
 1302 0742 7B6A     		ldr	r3, [r7, #36]
 1303 0744 4FEA4302 		lsl	r2, r3, #1
 1304 0748 7B68     		ldr	r3, [r7, #4]
 1305 074a 1A62     		str	r2, [r3, #32]
 1306 074c 03E0     		b	.L42
 1307              	.L41:
 916:../src/stm32f30x_rcc.c ****   }
 917:../src/stm32f30x_rcc.c ****   else
 918:../src/stm32f30x_rcc.c ****   {
 919:../src/stm32f30x_rcc.c ****     /* TIM1 Clock is APB2 clock. */
 920:../src/stm32f30x_rcc.c ****     RCC_Clocks->TIM1CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 1308              		.loc 1 920 0
 1309 074e 7B68     		ldr	r3, [r7, #4]
 1310 0750 DA68     		ldr	r2, [r3, #12]
 1311 0752 7B68     		ldr	r3, [r7, #4]
 1312 0754 1A62     		str	r2, [r3, #32]
 1313              	.L42:
 921:../src/stm32f30x_rcc.c ****   }
 922:../src/stm32f30x_rcc.c **** 
 923:../src/stm32f30x_rcc.c ****     /* TIM8CLK clock frequency */
 924:../src/stm32f30x_rcc.c ****   if(((RCC->CFGR3 & RCC_CFGR3_TIM8SW) == RCC_CFGR3_TIM8SW)&& (RCC_Clocks->SYSCLK_Frequency == pllcl
 1314              		.loc 1 924 0
 1315 0756 4FF48053 		mov	r3, #4096
 1316 075a C4F20203 		movt	r3, 16386
 1317 075e 1B6B     		ldr	r3, [r3, #48]
 1318 0760 03F40073 		and	r3, r3, #512
 1319 0764 002B     		cmp	r3, #0
 1320 0766 0ED0     		beq	.L43
 1321              		.loc 1 924 0 is_stmt 0 discriminator 1
 1322 0768 7B68     		ldr	r3, [r7, #4]
 1323 076a 1A68     		ldr	r2, [r3, #0]
 1324 076c 7B6A     		ldr	r3, [r7, #36]
 1325 076e 9A42     		cmp	r2, r3
 1326 0770 09D1     		bne	.L43
 925:../src/stm32f30x_rcc.c ****   && (apb2presc == ahbpresc))
 1327              		.loc 1 925 0 is_stmt 1
 1328 0772 FA68     		ldr	r2, [r7, #12]
 1329 0774 BB68     		ldr	r3, [r7, #8]
 1330 0776 9A42     		cmp	r2, r3
 1331 0778 05D1     		bne	.L43
 926:../src/stm32f30x_rcc.c ****   {
 927:../src/stm32f30x_rcc.c ****     /* TIM8 Clock is 2 * pllclk */
 928:../src/stm32f30x_rcc.c ****     RCC_Clocks->TIM8CLK_Frequency = pllclk * 2;
 1332              		.loc 1 928 0
 1333 077a 7B6A     		ldr	r3, [r7, #36]
 1334 077c 4FEA4302 		lsl	r2, r3, #1
 1335 0780 7B68     		ldr	r3, [r7, #4]
 1336 0782 5A62     		str	r2, [r3, #36]
 1337 0784 03E0     		b	.L44
 1338              	.L43:
 929:../src/stm32f30x_rcc.c ****   }
 930:../src/stm32f30x_rcc.c ****   else
 931:../src/stm32f30x_rcc.c ****   {
 932:../src/stm32f30x_rcc.c ****     /* TIM8 Clock is APB2 clock. */
 933:../src/stm32f30x_rcc.c ****     RCC_Clocks->TIM8CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 1339              		.loc 1 933 0
 1340 0786 7B68     		ldr	r3, [r7, #4]
 1341 0788 DA68     		ldr	r2, [r3, #12]
 1342 078a 7B68     		ldr	r3, [r7, #4]
 1343 078c 5A62     		str	r2, [r3, #36]
 1344              	.L44:
 934:../src/stm32f30x_rcc.c ****   }
 935:../src/stm32f30x_rcc.c ****   
 936:../src/stm32f30x_rcc.c ****   /* USART1CLK clock frequency */
 937:../src/stm32f30x_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
 1345              		.loc 1 937 0
 1346 078e 4FF48053 		mov	r3, #4096
 1347 0792 C4F20203 		movt	r3, 16386
 1348 0796 1B6B     		ldr	r3, [r3, #48]
 1349 0798 03F00303 		and	r3, r3, #3
 1350 079c 002B     		cmp	r3, #0
 1351 079e 04D1     		bne	.L45
 938:../src/stm32f30x_rcc.c ****   {
 939:../src/stm32f30x_rcc.c ****     /* USART Clock is PCLK */
 940:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 1352              		.loc 1 940 0
 1353 07a0 7B68     		ldr	r3, [r7, #4]
 1354 07a2 DA68     		ldr	r2, [r3, #12]
 1355 07a4 7B68     		ldr	r3, [r7, #4]
 1356 07a6 9A62     		str	r2, [r3, #40]
 1357 07a8 2AE0     		b	.L46
 1358              	.L45:
 941:../src/stm32f30x_rcc.c ****   }
 942:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
 1359              		.loc 1 942 0
 1360 07aa 4FF48053 		mov	r3, #4096
 1361 07ae C4F20203 		movt	r3, 16386
 1362 07b2 1B6B     		ldr	r3, [r3, #48]
 1363 07b4 03F00303 		and	r3, r3, #3
 1364 07b8 012B     		cmp	r3, #1
 1365 07ba 04D1     		bne	.L47
 943:../src/stm32f30x_rcc.c ****   {
 944:../src/stm32f30x_rcc.c ****     /* USART Clock is System Clock */
 945:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1366              		.loc 1 945 0
 1367 07bc 7B68     		ldr	r3, [r7, #4]
 1368 07be 1A68     		ldr	r2, [r3, #0]
 1369 07c0 7B68     		ldr	r3, [r7, #4]
 1370 07c2 9A62     		str	r2, [r3, #40]
 1371 07c4 1CE0     		b	.L46
 1372              	.L47:
 946:../src/stm32f30x_rcc.c ****   }
 947:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
 1373              		.loc 1 947 0
 1374 07c6 4FF48053 		mov	r3, #4096
 1375 07ca C4F20203 		movt	r3, 16386
 1376 07ce 1B6B     		ldr	r3, [r3, #48]
 1377 07d0 03F00303 		and	r3, r3, #3
 1378 07d4 022B     		cmp	r3, #2
 1379 07d6 04D1     		bne	.L48
 948:../src/stm32f30x_rcc.c ****   {
 949:../src/stm32f30x_rcc.c ****     /* USART Clock is LSE Osc. */
 950:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
 1380              		.loc 1 950 0
 1381 07d8 7B68     		ldr	r3, [r7, #4]
 1382 07da 4FF40042 		mov	r2, #32768
 1383 07de 9A62     		str	r2, [r3, #40]
 1384 07e0 0EE0     		b	.L46
 1385              	.L48:
 951:../src/stm32f30x_rcc.c ****   }
 952:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
 1386              		.loc 1 952 0
 1387 07e2 4FF48053 		mov	r3, #4096
 1388 07e6 C4F20203 		movt	r3, 16386
 1389 07ea 1B6B     		ldr	r3, [r3, #48]
 1390 07ec 03F00303 		and	r3, r3, #3
 1391 07f0 032B     		cmp	r3, #3
 1392 07f2 05D1     		bne	.L46
 953:../src/stm32f30x_rcc.c ****   {
 954:../src/stm32f30x_rcc.c ****     /* USART Clock is HSI Osc. */
 955:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
 1393              		.loc 1 955 0
 1394 07f4 7A68     		ldr	r2, [r7, #4]
 1395 07f6 4FF49053 		mov	r3, #4608
 1396 07fa C0F27A03 		movt	r3, 122
 1397 07fe 9362     		str	r3, [r2, #40]
 1398              	.L46:
 956:../src/stm32f30x_rcc.c ****   }
 957:../src/stm32f30x_rcc.c **** 
 958:../src/stm32f30x_rcc.c ****   /* USART2CLK clock frequency */
 959:../src/stm32f30x_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == 0x0)
 1399              		.loc 1 959 0
 1400 0800 4FF48053 		mov	r3, #4096
 1401 0804 C4F20203 		movt	r3, 16386
 1402 0808 1B6B     		ldr	r3, [r3, #48]
 1403 080a 03F44033 		and	r3, r3, #196608
 1404 080e 002B     		cmp	r3, #0
 1405 0810 04D1     		bne	.L49
 960:../src/stm32f30x_rcc.c ****   {
 961:../src/stm32f30x_rcc.c ****     /* USART Clock is PCLK */
 962:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 1406              		.loc 1 962 0
 1407 0812 7B68     		ldr	r3, [r7, #4]
 1408 0814 9A68     		ldr	r2, [r3, #8]
 1409 0816 7B68     		ldr	r3, [r7, #4]
 1410 0818 DA62     		str	r2, [r3, #44]
 1411 081a 2DE0     		b	.L50
 1412              	.L49:
 963:../src/stm32f30x_rcc.c ****   }
 964:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_0)
 1413              		.loc 1 964 0
 1414 081c 4FF48053 		mov	r3, #4096
 1415 0820 C4F20203 		movt	r3, 16386
 1416 0824 1B6B     		ldr	r3, [r3, #48]
 1417 0826 03F44033 		and	r3, r3, #196608
 1418 082a B3F5803F 		cmp	r3, #65536
 1419 082e 04D1     		bne	.L51
 965:../src/stm32f30x_rcc.c ****   {
 966:../src/stm32f30x_rcc.c ****     /* USART Clock is System Clock */
 967:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1420              		.loc 1 967 0
 1421 0830 7B68     		ldr	r3, [r7, #4]
 1422 0832 1A68     		ldr	r2, [r3, #0]
 1423 0834 7B68     		ldr	r3, [r7, #4]
 1424 0836 DA62     		str	r2, [r3, #44]
 1425 0838 1EE0     		b	.L50
 1426              	.L51:
 968:../src/stm32f30x_rcc.c ****   }
 969:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_1)
 1427              		.loc 1 969 0
 1428 083a 4FF48053 		mov	r3, #4096
 1429 083e C4F20203 		movt	r3, 16386
 1430 0842 1B6B     		ldr	r3, [r3, #48]
 1431 0844 03F44033 		and	r3, r3, #196608
 1432 0848 B3F5003F 		cmp	r3, #131072
 1433 084c 04D1     		bne	.L52
 970:../src/stm32f30x_rcc.c ****   {
 971:../src/stm32f30x_rcc.c ****     /* USART Clock is LSE Osc. */
 972:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART2CLK_Frequency = LSE_VALUE;
 1434              		.loc 1 972 0
 1435 084e 7B68     		ldr	r3, [r7, #4]
 1436 0850 4FF40042 		mov	r2, #32768
 1437 0854 DA62     		str	r2, [r3, #44]
 1438 0856 0FE0     		b	.L50
 1439              	.L52:
 973:../src/stm32f30x_rcc.c ****   }
 974:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW)
 1440              		.loc 1 974 0
 1441 0858 4FF48053 		mov	r3, #4096
 1442 085c C4F20203 		movt	r3, 16386
 1443 0860 1B6B     		ldr	r3, [r3, #48]
 1444 0862 03F44033 		and	r3, r3, #196608
 1445 0866 B3F5403F 		cmp	r3, #196608
 1446 086a 05D1     		bne	.L50
 975:../src/stm32f30x_rcc.c ****   {
 976:../src/stm32f30x_rcc.c ****     /* USART Clock is HSI Osc. */
 977:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART2CLK_Frequency = HSI_VALUE;
 1447              		.loc 1 977 0
 1448 086c 7A68     		ldr	r2, [r7, #4]
 1449 086e 4FF49053 		mov	r3, #4608
 1450 0872 C0F27A03 		movt	r3, 122
 1451 0876 D362     		str	r3, [r2, #44]
 1452              	.L50:
 978:../src/stm32f30x_rcc.c ****   }    
 979:../src/stm32f30x_rcc.c **** 
 980:../src/stm32f30x_rcc.c ****   /* USART3CLK clock frequency */
 981:../src/stm32f30x_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == 0x0)
 1453              		.loc 1 981 0
 1454 0878 4FF48053 		mov	r3, #4096
 1455 087c C4F20203 		movt	r3, 16386
 1456 0880 1B6B     		ldr	r3, [r3, #48]
 1457 0882 03F44023 		and	r3, r3, #786432
 1458 0886 002B     		cmp	r3, #0
 1459 0888 04D1     		bne	.L53
 982:../src/stm32f30x_rcc.c ****   {
 983:../src/stm32f30x_rcc.c ****     /* USART Clock is PCLK */
 984:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 1460              		.loc 1 984 0
 1461 088a 7B68     		ldr	r3, [r7, #4]
 1462 088c 9A68     		ldr	r2, [r3, #8]
 1463 088e 7B68     		ldr	r3, [r7, #4]
 1464 0890 1A63     		str	r2, [r3, #48]
 1465 0892 2DE0     		b	.L54
 1466              	.L53:
 985:../src/stm32f30x_rcc.c ****   }
 986:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_0)
 1467              		.loc 1 986 0
 1468 0894 4FF48053 		mov	r3, #4096
 1469 0898 C4F20203 		movt	r3, 16386
 1470 089c 1B6B     		ldr	r3, [r3, #48]
 1471 089e 03F44023 		and	r3, r3, #786432
 1472 08a2 B3F5802F 		cmp	r3, #262144
 1473 08a6 04D1     		bne	.L55
 987:../src/stm32f30x_rcc.c ****   {
 988:../src/stm32f30x_rcc.c ****     /* USART Clock is System Clock */
 989:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1474              		.loc 1 989 0
 1475 08a8 7B68     		ldr	r3, [r7, #4]
 1476 08aa 1A68     		ldr	r2, [r3, #0]
 1477 08ac 7B68     		ldr	r3, [r7, #4]
 1478 08ae 1A63     		str	r2, [r3, #48]
 1479 08b0 1EE0     		b	.L54
 1480              	.L55:
 990:../src/stm32f30x_rcc.c ****   }
 991:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_1)
 1481              		.loc 1 991 0
 1482 08b2 4FF48053 		mov	r3, #4096
 1483 08b6 C4F20203 		movt	r3, 16386
 1484 08ba 1B6B     		ldr	r3, [r3, #48]
 1485 08bc 03F44023 		and	r3, r3, #786432
 1486 08c0 B3F5002F 		cmp	r3, #524288
 1487 08c4 04D1     		bne	.L56
 992:../src/stm32f30x_rcc.c ****   {
 993:../src/stm32f30x_rcc.c ****     /* USART Clock is LSE Osc. */
 994:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART3CLK_Frequency = LSE_VALUE;
 1488              		.loc 1 994 0
 1489 08c6 7B68     		ldr	r3, [r7, #4]
 1490 08c8 4FF40042 		mov	r2, #32768
 1491 08cc 1A63     		str	r2, [r3, #48]
 1492 08ce 0FE0     		b	.L54
 1493              	.L56:
 995:../src/stm32f30x_rcc.c ****   }
 996:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW)
 1494              		.loc 1 996 0
 1495 08d0 4FF48053 		mov	r3, #4096
 1496 08d4 C4F20203 		movt	r3, 16386
 1497 08d8 1B6B     		ldr	r3, [r3, #48]
 1498 08da 03F44023 		and	r3, r3, #786432
 1499 08de B3F5402F 		cmp	r3, #786432
 1500 08e2 05D1     		bne	.L54
 997:../src/stm32f30x_rcc.c ****   {
 998:../src/stm32f30x_rcc.c ****     /* USART Clock is HSI Osc. */
 999:../src/stm32f30x_rcc.c ****     RCC_Clocks->USART3CLK_Frequency = HSI_VALUE;
 1501              		.loc 1 999 0
 1502 08e4 7A68     		ldr	r2, [r7, #4]
 1503 08e6 4FF49053 		mov	r3, #4608
 1504 08ea C0F27A03 		movt	r3, 122
 1505 08ee 1363     		str	r3, [r2, #48]
 1506              	.L54:
1000:../src/stm32f30x_rcc.c ****   }
1001:../src/stm32f30x_rcc.c ****   
1002:../src/stm32f30x_rcc.c ****     /* UART4CLK clock frequency */
1003:../src/stm32f30x_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == 0x0)
 1507              		.loc 1 1003 0
 1508 08f0 4FF48053 		mov	r3, #4096
 1509 08f4 C4F20203 		movt	r3, 16386
 1510 08f8 1B6B     		ldr	r3, [r3, #48]
 1511 08fa 03F44013 		and	r3, r3, #3145728
 1512 08fe 002B     		cmp	r3, #0
 1513 0900 04D1     		bne	.L57
1004:../src/stm32f30x_rcc.c ****   {
1005:../src/stm32f30x_rcc.c ****     /* USART Clock is PCLK */
1006:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART4CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 1514              		.loc 1 1006 0
 1515 0902 7B68     		ldr	r3, [r7, #4]
 1516 0904 9A68     		ldr	r2, [r3, #8]
 1517 0906 7B68     		ldr	r3, [r7, #4]
 1518 0908 5A63     		str	r2, [r3, #52]
 1519 090a 2DE0     		b	.L58
 1520              	.L57:
1007:../src/stm32f30x_rcc.c ****   }
1008:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW_0)
 1521              		.loc 1 1008 0
 1522 090c 4FF48053 		mov	r3, #4096
 1523 0910 C4F20203 		movt	r3, 16386
 1524 0914 1B6B     		ldr	r3, [r3, #48]
 1525 0916 03F44013 		and	r3, r3, #3145728
 1526 091a B3F5801F 		cmp	r3, #1048576
 1527 091e 04D1     		bne	.L59
1009:../src/stm32f30x_rcc.c ****   {
1010:../src/stm32f30x_rcc.c ****     /* USART Clock is System Clock */
1011:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART4CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1528              		.loc 1 1011 0
 1529 0920 7B68     		ldr	r3, [r7, #4]
 1530 0922 1A68     		ldr	r2, [r3, #0]
 1531 0924 7B68     		ldr	r3, [r7, #4]
 1532 0926 5A63     		str	r2, [r3, #52]
 1533 0928 1EE0     		b	.L58
 1534              	.L59:
1012:../src/stm32f30x_rcc.c ****   }
1013:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW_1)
 1535              		.loc 1 1013 0
 1536 092a 4FF48053 		mov	r3, #4096
 1537 092e C4F20203 		movt	r3, 16386
 1538 0932 1B6B     		ldr	r3, [r3, #48]
 1539 0934 03F44013 		and	r3, r3, #3145728
 1540 0938 B3F5001F 		cmp	r3, #2097152
 1541 093c 04D1     		bne	.L60
1014:../src/stm32f30x_rcc.c ****   {
1015:../src/stm32f30x_rcc.c ****     /* USART Clock is LSE Osc. */
1016:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART4CLK_Frequency = LSE_VALUE;
 1542              		.loc 1 1016 0
 1543 093e 7B68     		ldr	r3, [r7, #4]
 1544 0940 4FF40042 		mov	r2, #32768
 1545 0944 5A63     		str	r2, [r3, #52]
 1546 0946 0FE0     		b	.L58
 1547              	.L60:
1017:../src/stm32f30x_rcc.c ****   }
1018:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW)
 1548              		.loc 1 1018 0
 1549 0948 4FF48053 		mov	r3, #4096
 1550 094c C4F20203 		movt	r3, 16386
 1551 0950 1B6B     		ldr	r3, [r3, #48]
 1552 0952 03F44013 		and	r3, r3, #3145728
 1553 0956 B3F5401F 		cmp	r3, #3145728
 1554 095a 05D1     		bne	.L58
1019:../src/stm32f30x_rcc.c ****   {
1020:../src/stm32f30x_rcc.c ****     /* USART Clock is HSI Osc. */
1021:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART4CLK_Frequency = HSI_VALUE;
 1555              		.loc 1 1021 0
 1556 095c 7A68     		ldr	r2, [r7, #4]
 1557 095e 4FF49053 		mov	r3, #4608
 1558 0962 C0F27A03 		movt	r3, 122
 1559 0966 5363     		str	r3, [r2, #52]
 1560              	.L58:
1022:../src/stm32f30x_rcc.c ****   }   
1023:../src/stm32f30x_rcc.c ****   
1024:../src/stm32f30x_rcc.c ****   /* UART5CLK clock frequency */
1025:../src/stm32f30x_rcc.c ****   if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == 0x0)
 1561              		.loc 1 1025 0
 1562 0968 4FF48053 		mov	r3, #4096
 1563 096c C4F20203 		movt	r3, 16386
 1564 0970 1B6B     		ldr	r3, [r3, #48]
 1565 0972 03F44003 		and	r3, r3, #12582912
 1566 0976 002B     		cmp	r3, #0
 1567 0978 04D1     		bne	.L61
1026:../src/stm32f30x_rcc.c ****   {
1027:../src/stm32f30x_rcc.c ****     /* USART Clock is PCLK */
1028:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART5CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 1568              		.loc 1 1028 0
 1569 097a 7B68     		ldr	r3, [r7, #4]
 1570 097c 9A68     		ldr	r2, [r3, #8]
 1571 097e 7B68     		ldr	r3, [r7, #4]
 1572 0980 9A63     		str	r2, [r3, #56]
 1573 0982 2DE0     		b	.L25
 1574              	.L61:
1029:../src/stm32f30x_rcc.c ****   }
1030:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW_0)
 1575              		.loc 1 1030 0
 1576 0984 4FF48053 		mov	r3, #4096
 1577 0988 C4F20203 		movt	r3, 16386
 1578 098c 1B6B     		ldr	r3, [r3, #48]
 1579 098e 03F44003 		and	r3, r3, #12582912
 1580 0992 B3F5800F 		cmp	r3, #4194304
 1581 0996 04D1     		bne	.L63
1031:../src/stm32f30x_rcc.c ****   {
1032:../src/stm32f30x_rcc.c ****     /* USART Clock is System Clock */
1033:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART5CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 1582              		.loc 1 1033 0
 1583 0998 7B68     		ldr	r3, [r7, #4]
 1584 099a 1A68     		ldr	r2, [r3, #0]
 1585 099c 7B68     		ldr	r3, [r7, #4]
 1586 099e 9A63     		str	r2, [r3, #56]
 1587 09a0 1EE0     		b	.L25
 1588              	.L63:
1034:../src/stm32f30x_rcc.c ****   }
1035:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW_1)
 1589              		.loc 1 1035 0
 1590 09a2 4FF48053 		mov	r3, #4096
 1591 09a6 C4F20203 		movt	r3, 16386
 1592 09aa 1B6B     		ldr	r3, [r3, #48]
 1593 09ac 03F44003 		and	r3, r3, #12582912
 1594 09b0 B3F5000F 		cmp	r3, #8388608
 1595 09b4 04D1     		bne	.L64
1036:../src/stm32f30x_rcc.c ****   {
1037:../src/stm32f30x_rcc.c ****     /* USART Clock is LSE Osc. */
1038:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART5CLK_Frequency = LSE_VALUE;
 1596              		.loc 1 1038 0
 1597 09b6 7B68     		ldr	r3, [r7, #4]
 1598 09b8 4FF40042 		mov	r2, #32768
 1599 09bc 9A63     		str	r2, [r3, #56]
 1600 09be 0FE0     		b	.L25
 1601              	.L64:
1039:../src/stm32f30x_rcc.c ****   }
1040:../src/stm32f30x_rcc.c ****   else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW)
 1602              		.loc 1 1040 0
 1603 09c0 4FF48053 		mov	r3, #4096
 1604 09c4 C4F20203 		movt	r3, 16386
 1605 09c8 1B6B     		ldr	r3, [r3, #48]
 1606 09ca 03F44003 		and	r3, r3, #12582912
 1607 09ce B3F5400F 		cmp	r3, #12582912
 1608 09d2 05D1     		bne	.L25
1041:../src/stm32f30x_rcc.c ****   {
1042:../src/stm32f30x_rcc.c ****     /* USART Clock is HSI Osc. */
1043:../src/stm32f30x_rcc.c ****     RCC_Clocks->UART5CLK_Frequency = HSI_VALUE;
 1609              		.loc 1 1043 0
 1610 09d4 7A68     		ldr	r2, [r7, #4]
 1611 09d6 4FF49053 		mov	r3, #4608
 1612 09da C0F27A03 		movt	r3, 122
 1613 09de 9363     		str	r3, [r2, #56]
 1614              	.L25:
1044:../src/stm32f30x_rcc.c ****   } 
1045:../src/stm32f30x_rcc.c **** }
 1615              		.loc 1 1045 0
 1616 09e0 07F12C07 		add	r7, r7, #44
 1617 09e4 BD46     		mov	sp, r7
 1618 09e6 80BC     		pop	{r7}
 1619 09e8 7047     		bx	lr
 1620              		.cfi_endproc
 1621              	.LFE129:
 1623 09ea 00BF     		.align	2
 1624              		.global	RCC_ADCCLKConfig
 1625              		.thumb
 1626              		.thumb_func
 1628              	RCC_ADCCLKConfig:
 1629              	.LFB130:
1046:../src/stm32f30x_rcc.c **** 
1047:../src/stm32f30x_rcc.c **** /**
1048:../src/stm32f30x_rcc.c ****   * @}
1049:../src/stm32f30x_rcc.c ****   */
1050:../src/stm32f30x_rcc.c **** 
1051:../src/stm32f30x_rcc.c **** /** @defgroup RCC_Group3 Peripheral clocks configuration functions
1052:../src/stm32f30x_rcc.c ****  *  @brief   Peripheral clocks configuration functions 
1053:../src/stm32f30x_rcc.c ****  *
1054:../src/stm32f30x_rcc.c **** @verbatim   
1055:../src/stm32f30x_rcc.c ****  ===============================================================================
1056:../src/stm32f30x_rcc.c ****             ##### Peripheral clocks configuration functions #####
1057:../src/stm32f30x_rcc.c ****  ===============================================================================  
1058:../src/stm32f30x_rcc.c ****     [..] This section provide functions allowing to configure the Peripheral clocks. 
1059:../src/stm32f30x_rcc.c ****          (#) The RTC clock which is derived from the LSE, LSI or  HSE_Div32 
1060:../src/stm32f30x_rcc.c ****              (HSE divided by 32).
1061:../src/stm32f30x_rcc.c ****          (#) After restart from Reset or wakeup from STANDBY, all peripherals are 
1062:../src/stm32f30x_rcc.c ****              off except internal SRAM, Flash and SWD. Before to start using 
1063:../src/stm32f30x_rcc.c ****              a peripheral you have to enable its interface clock. You can do this 
1064:../src/stm32f30x_rcc.c ****              using RCC_AHBPeriphClockCmd(), RCC_APB2PeriphClockCmd() 
1065:../src/stm32f30x_rcc.c ****              and RCC_APB1PeriphClockCmd() functions.
1066:../src/stm32f30x_rcc.c ****          (#) To reset the peripherals configuration (to the default state after 
1067:../src/stm32f30x_rcc.c ****              device reset) you can use RCC_AHBPeriphResetCmd(), RCC_APB2PeriphResetCmd() 
1068:../src/stm32f30x_rcc.c ****              and RCC_APB1PeriphResetCmd() functions.
1069:../src/stm32f30x_rcc.c **** @endverbatim
1070:../src/stm32f30x_rcc.c ****   * @{
1071:../src/stm32f30x_rcc.c ****   */
1072:../src/stm32f30x_rcc.c **** 
1073:../src/stm32f30x_rcc.c **** /**
1074:../src/stm32f30x_rcc.c ****   * @brief  Configures the ADC clock (ADCCLK).
1075:../src/stm32f30x_rcc.c ****   * @param  RCC_PLLCLK: defines the ADC clock divider. This clock is derived from 
1076:../src/stm32f30x_rcc.c ****   *         the PLL Clock.
1077:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1078:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_OFF: ADC12 clock disabled
1079:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div1: ADC12 clock = PLLCLK/1
1080:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div2: ADC12 clock = PLLCLK/2
1081:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div4: ADC12 clock = PLLCLK/4
1082:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div6: ADC12 clock = PLLCLK/6
1083:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div8: ADC12 clock = PLLCLK/8
1084:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div10: ADC12 clock = PLLCLK/10
1085:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div12: ADC12 clock = PLLCLK/12
1086:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div16: ADC12 clock = PLLCLK/16
1087:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div32: ADC12 clock = PLLCLK/32
1088:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div64: ADC12 clock = PLLCLK/64
1089:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div128: ADC12 clock = PLLCLK/128
1090:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC12PLLCLK_Div256: ADC12 clock = PLLCLK/256
1091:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_OFF: ADC34 clock disabled
1092:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div1: ADC34 clock = PLLCLK/1
1093:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div2: ADC34 clock = PLLCLK/2
1094:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div4: ADC34 clock = PLLCLK/4
1095:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div6: ADC34 clock = PLLCLK/6
1096:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div8: ADC34 clock = PLLCLK/8
1097:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div10: ADC34 clock = PLLCLK/10
1098:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div12: ADC34 clock = PLLCLK/12
1099:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div16: ADC34 clock = PLLCLK/16
1100:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div32: ADC34 clock = PLLCLK/32
1101:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div64: ADC34 clock = PLLCLK/64       
1102:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div128: ADC34 clock = PLLCLK/128                                  
1103:../src/stm32f30x_rcc.c ****   *     @arg RCC_ADC34PLLCLK_Div256: ADC34 clock = PLLCLK/256
1104:../src/stm32f30x_rcc.c ****   * @retval None
1105:../src/stm32f30x_rcc.c ****   */
1106:../src/stm32f30x_rcc.c **** void RCC_ADCCLKConfig(uint32_t RCC_PLLCLK)
1107:../src/stm32f30x_rcc.c **** {
 1630              		.loc 1 1107 0
 1631              		.cfi_startproc
 1632              		@ args = 0, pretend = 0, frame = 16
 1633              		@ frame_needed = 1, uses_anonymous_args = 0
 1634              		@ link register save eliminated.
 1635 09ec 80B4     		push	{r7}
 1636              	.LCFI55:
 1637              		.cfi_def_cfa_offset 4
 1638              		.cfi_offset 7, -4
 1639 09ee 85B0     		sub	sp, sp, #20
 1640              	.LCFI56:
 1641              		.cfi_def_cfa_offset 24
 1642 09f0 00AF     		add	r7, sp, #0
 1643              	.LCFI57:
 1644              		.cfi_def_cfa_register 7
 1645 09f2 7860     		str	r0, [r7, #4]
1108:../src/stm32f30x_rcc.c ****   uint32_t tmp = 0;
 1646              		.loc 1 1108 0
 1647 09f4 4FF00003 		mov	r3, #0
 1648 09f8 FB60     		str	r3, [r7, #12]
1109:../src/stm32f30x_rcc.c ****   
1110:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1111:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_ADCCLK(RCC_PLLCLK));
1112:../src/stm32f30x_rcc.c **** 
1113:../src/stm32f30x_rcc.c ****   tmp = (RCC_PLLCLK >> 28);
 1649              		.loc 1 1113 0
 1650 09fa 7B68     		ldr	r3, [r7, #4]
 1651 09fc 4FEA1373 		lsr	r3, r3, #28
 1652 0a00 FB60     		str	r3, [r7, #12]
1114:../src/stm32f30x_rcc.c ****   
1115:../src/stm32f30x_rcc.c ****   /* Clears ADCPRE34 bits */
1116:../src/stm32f30x_rcc.c ****   if (tmp != 0)
 1653              		.loc 1 1116 0
 1654 0a02 FB68     		ldr	r3, [r7, #12]
 1655 0a04 002B     		cmp	r3, #0
 1656 0a06 0CD0     		beq	.L67
1117:../src/stm32f30x_rcc.c ****   {
1118:../src/stm32f30x_rcc.c ****     RCC->CFGR2 &= ~RCC_CFGR2_ADCPRE34;
 1657              		.loc 1 1118 0
 1658 0a08 4FF48053 		mov	r3, #4096
 1659 0a0c C4F20203 		movt	r3, 16386
 1660 0a10 4FF48052 		mov	r2, #4096
 1661 0a14 C4F20202 		movt	r2, 16386
 1662 0a18 D26A     		ldr	r2, [r2, #44]
 1663 0a1a 22F47852 		bic	r2, r2, #15872
 1664 0a1e DA62     		str	r2, [r3, #44]
 1665 0a20 0BE0     		b	.L68
 1666              	.L67:
1119:../src/stm32f30x_rcc.c ****   }
1120:../src/stm32f30x_rcc.c ****    /* Clears ADCPRE12 bits */
1121:../src/stm32f30x_rcc.c ****   else
1122:../src/stm32f30x_rcc.c ****   {
1123:../src/stm32f30x_rcc.c ****     RCC->CFGR2 &= ~RCC_CFGR2_ADCPRE12;
 1667              		.loc 1 1123 0
 1668 0a22 4FF48053 		mov	r3, #4096
 1669 0a26 C4F20203 		movt	r3, 16386
 1670 0a2a 4FF48052 		mov	r2, #4096
 1671 0a2e C4F20202 		movt	r2, 16386
 1672 0a32 D26A     		ldr	r2, [r2, #44]
 1673 0a34 22F4F872 		bic	r2, r2, #496
 1674 0a38 DA62     		str	r2, [r3, #44]
 1675              	.L68:
1124:../src/stm32f30x_rcc.c ****   }
1125:../src/stm32f30x_rcc.c ****   /* Set ADCPRE bits according to RCC_PLLCLK value */
1126:../src/stm32f30x_rcc.c ****   RCC->CFGR2 |= RCC_PLLCLK;
 1676              		.loc 1 1126 0
 1677 0a3a 4FF48053 		mov	r3, #4096
 1678 0a3e C4F20203 		movt	r3, 16386
 1679 0a42 4FF48052 		mov	r2, #4096
 1680 0a46 C4F20202 		movt	r2, 16386
 1681 0a4a D16A     		ldr	r1, [r2, #44]
 1682 0a4c 7A68     		ldr	r2, [r7, #4]
 1683 0a4e 0A43     		orrs	r2, r2, r1
 1684 0a50 DA62     		str	r2, [r3, #44]
1127:../src/stm32f30x_rcc.c **** }
 1685              		.loc 1 1127 0
 1686 0a52 07F11407 		add	r7, r7, #20
 1687 0a56 BD46     		mov	sp, r7
 1688 0a58 80BC     		pop	{r7}
 1689 0a5a 7047     		bx	lr
 1690              		.cfi_endproc
 1691              	.LFE130:
 1693              		.align	2
 1694              		.global	RCC_I2CCLKConfig
 1695              		.thumb
 1696              		.thumb_func
 1698              	RCC_I2CCLKConfig:
 1699              	.LFB131:
1128:../src/stm32f30x_rcc.c **** 
1129:../src/stm32f30x_rcc.c **** /**
1130:../src/stm32f30x_rcc.c ****   * @brief  Configures the I2C clock (I2CCLK).
1131:../src/stm32f30x_rcc.c ****   * @param  RCC_I2CCLK: defines the I2C clock source. This clock is derived 
1132:../src/stm32f30x_rcc.c ****   *         from the HSI or System clock.
1133:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1134:../src/stm32f30x_rcc.c ****   *     @arg RCC_I2CxCLK_HSI: I2Cx clock = HSI
1135:../src/stm32f30x_rcc.c ****   *     @arg RCC_I2CxCLK_SYSCLK: I2Cx clock = System Clock
1136:../src/stm32f30x_rcc.c ****   *          (x can be 1 or 2).  
1137:../src/stm32f30x_rcc.c ****   * @retval None
1138:../src/stm32f30x_rcc.c ****   */
1139:../src/stm32f30x_rcc.c **** void RCC_I2CCLKConfig(uint32_t RCC_I2CCLK)
1140:../src/stm32f30x_rcc.c **** { 
 1700              		.loc 1 1140 0
 1701              		.cfi_startproc
 1702              		@ args = 0, pretend = 0, frame = 16
 1703              		@ frame_needed = 1, uses_anonymous_args = 0
 1704              		@ link register save eliminated.
 1705 0a5c 80B4     		push	{r7}
 1706              	.LCFI58:
 1707              		.cfi_def_cfa_offset 4
 1708              		.cfi_offset 7, -4
 1709 0a5e 85B0     		sub	sp, sp, #20
 1710              	.LCFI59:
 1711              		.cfi_def_cfa_offset 24
 1712 0a60 00AF     		add	r7, sp, #0
 1713              	.LCFI60:
 1714              		.cfi_def_cfa_register 7
 1715 0a62 7860     		str	r0, [r7, #4]
1141:../src/stm32f30x_rcc.c ****   uint32_t tmp = 0;
 1716              		.loc 1 1141 0
 1717 0a64 4FF00003 		mov	r3, #0
 1718 0a68 FB60     		str	r3, [r7, #12]
1142:../src/stm32f30x_rcc.c ****   
1143:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1144:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_I2CCLK(RCC_I2CCLK));
1145:../src/stm32f30x_rcc.c **** 
1146:../src/stm32f30x_rcc.c ****   tmp = (RCC_I2CCLK >> 28);
 1719              		.loc 1 1146 0
 1720 0a6a 7B68     		ldr	r3, [r7, #4]
 1721 0a6c 4FEA1373 		lsr	r3, r3, #28
 1722 0a70 FB60     		str	r3, [r7, #12]
1147:../src/stm32f30x_rcc.c ****   
1148:../src/stm32f30x_rcc.c ****   /* Clear I2CSW bit */
1149:../src/stm32f30x_rcc.c ****   if (tmp != 0)
 1723              		.loc 1 1149 0
 1724 0a72 FB68     		ldr	r3, [r7, #12]
 1725 0a74 002B     		cmp	r3, #0
 1726 0a76 0CD0     		beq	.L70
1150:../src/stm32f30x_rcc.c ****   {
1151:../src/stm32f30x_rcc.c ****     RCC->CFGR3 &= ~RCC_CFGR3_I2C2SW;
 1727              		.loc 1 1151 0
 1728 0a78 4FF48053 		mov	r3, #4096
 1729 0a7c C4F20203 		movt	r3, 16386
 1730 0a80 4FF48052 		mov	r2, #4096
 1731 0a84 C4F20202 		movt	r2, 16386
 1732 0a88 126B     		ldr	r2, [r2, #48]
 1733 0a8a 22F02002 		bic	r2, r2, #32
 1734 0a8e 1A63     		str	r2, [r3, #48]
 1735 0a90 0BE0     		b	.L71
 1736              	.L70:
1152:../src/stm32f30x_rcc.c ****   }
1153:../src/stm32f30x_rcc.c ****   else
1154:../src/stm32f30x_rcc.c ****   {
1155:../src/stm32f30x_rcc.c ****     RCC->CFGR3 &= ~RCC_CFGR3_I2C1SW;
 1737              		.loc 1 1155 0
 1738 0a92 4FF48053 		mov	r3, #4096
 1739 0a96 C4F20203 		movt	r3, 16386
 1740 0a9a 4FF48052 		mov	r2, #4096
 1741 0a9e C4F20202 		movt	r2, 16386
 1742 0aa2 126B     		ldr	r2, [r2, #48]
 1743 0aa4 22F01002 		bic	r2, r2, #16
 1744 0aa8 1A63     		str	r2, [r3, #48]
 1745              	.L71:
1156:../src/stm32f30x_rcc.c ****   }
1157:../src/stm32f30x_rcc.c ****   /* Set I2CSW bits according to RCC_I2CCLK value */
1158:../src/stm32f30x_rcc.c ****   RCC->CFGR3 |= RCC_I2CCLK;
 1746              		.loc 1 1158 0
 1747 0aaa 4FF48053 		mov	r3, #4096
 1748 0aae C4F20203 		movt	r3, 16386
 1749 0ab2 4FF48052 		mov	r2, #4096
 1750 0ab6 C4F20202 		movt	r2, 16386
 1751 0aba 116B     		ldr	r1, [r2, #48]
 1752 0abc 7A68     		ldr	r2, [r7, #4]
 1753 0abe 0A43     		orrs	r2, r2, r1
 1754 0ac0 1A63     		str	r2, [r3, #48]
1159:../src/stm32f30x_rcc.c **** }
 1755              		.loc 1 1159 0
 1756 0ac2 07F11407 		add	r7, r7, #20
 1757 0ac6 BD46     		mov	sp, r7
 1758 0ac8 80BC     		pop	{r7}
 1759 0aca 7047     		bx	lr
 1760              		.cfi_endproc
 1761              	.LFE131:
 1763              		.align	2
 1764              		.global	RCC_TIMCLKConfig
 1765              		.thumb
 1766              		.thumb_func
 1768              	RCC_TIMCLKConfig:
 1769              	.LFB132:
1160:../src/stm32f30x_rcc.c **** 
1161:../src/stm32f30x_rcc.c **** /**
1162:../src/stm32f30x_rcc.c ****   * @brief  Configures the TIM1 and TIM8 clock sources(TIMCLK).
1163:../src/stm32f30x_rcc.c ****   * @note     The configuration of the TIMx clock source is only possible when the 
1164:../src/stm32f30x_rcc.c ****   *           SYSCLK = PLL and HCLK and PCLK2 clocks are not divided in respect to SYSCLK
1165:../src/stm32f30x_rcc.c ****   * @note     If one of the previous conditions is missed, the TIM clock source 
1166:../src/stm32f30x_rcc.c ****   *           configuration is lost and calling again this function becomes mandatory.  
1167:../src/stm32f30x_rcc.c ****   * @param  RCC_TIMCLK: defines the TIMx clock source.
1168:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1169:../src/stm32f30x_rcc.c ****   *     @arg RCC_TIMxCLK_HCLK: TIMx clock = APB high speed clock (doubled frequency
1170:../src/stm32f30x_rcc.c ****   *          when prescaled)
1171:../src/stm32f30x_rcc.c ****   *     @arg RCC_TIMxCLK_PLLCLK: TIMx clock = PLL output (running up to 144 MHz)
1172:../src/stm32f30x_rcc.c ****   *          (x can be 1 or 8).
1173:../src/stm32f30x_rcc.c ****   * @retval None
1174:../src/stm32f30x_rcc.c ****   */
1175:../src/stm32f30x_rcc.c **** void RCC_TIMCLKConfig(uint32_t RCC_TIMCLK)
1176:../src/stm32f30x_rcc.c **** { 
 1770              		.loc 1 1176 0
 1771              		.cfi_startproc
 1772              		@ args = 0, pretend = 0, frame = 16
 1773              		@ frame_needed = 1, uses_anonymous_args = 0
 1774              		@ link register save eliminated.
 1775 0acc 80B4     		push	{r7}
 1776              	.LCFI61:
 1777              		.cfi_def_cfa_offset 4
 1778              		.cfi_offset 7, -4
 1779 0ace 85B0     		sub	sp, sp, #20
 1780              	.LCFI62:
 1781              		.cfi_def_cfa_offset 24
 1782 0ad0 00AF     		add	r7, sp, #0
 1783              	.LCFI63:
 1784              		.cfi_def_cfa_register 7
 1785 0ad2 7860     		str	r0, [r7, #4]
1177:../src/stm32f30x_rcc.c ****   uint32_t tmp = 0;
 1786              		.loc 1 1177 0
 1787 0ad4 4FF00003 		mov	r3, #0
 1788 0ad8 FB60     		str	r3, [r7, #12]
1178:../src/stm32f30x_rcc.c ****   
1179:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1180:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_TIMCLK(RCC_TIMCLK));
1181:../src/stm32f30x_rcc.c **** 
1182:../src/stm32f30x_rcc.c ****   tmp = (RCC_TIMCLK >> 28);
 1789              		.loc 1 1182 0
 1790 0ada 7B68     		ldr	r3, [r7, #4]
 1791 0adc 4FEA1373 		lsr	r3, r3, #28
 1792 0ae0 FB60     		str	r3, [r7, #12]
1183:../src/stm32f30x_rcc.c ****   
1184:../src/stm32f30x_rcc.c ****   /* Clear I2CSW bit */
1185:../src/stm32f30x_rcc.c ****   if (tmp != 0)
 1793              		.loc 1 1185 0
 1794 0ae2 FB68     		ldr	r3, [r7, #12]
 1795 0ae4 002B     		cmp	r3, #0
 1796 0ae6 0CD0     		beq	.L73
1186:../src/stm32f30x_rcc.c ****   {
1187:../src/stm32f30x_rcc.c ****     RCC->CFGR3 &= ~RCC_CFGR3_TIM8SW;
 1797              		.loc 1 1187 0
 1798 0ae8 4FF48053 		mov	r3, #4096
 1799 0aec C4F20203 		movt	r3, 16386
 1800 0af0 4FF48052 		mov	r2, #4096
 1801 0af4 C4F20202 		movt	r2, 16386
 1802 0af8 126B     		ldr	r2, [r2, #48]
 1803 0afa 22F40072 		bic	r2, r2, #512
 1804 0afe 1A63     		str	r2, [r3, #48]
 1805 0b00 0BE0     		b	.L74
 1806              	.L73:
1188:../src/stm32f30x_rcc.c ****   }
1189:../src/stm32f30x_rcc.c ****   else
1190:../src/stm32f30x_rcc.c ****   {
1191:../src/stm32f30x_rcc.c ****     RCC->CFGR3 &= ~RCC_CFGR3_TIM1SW;
 1807              		.loc 1 1191 0
 1808 0b02 4FF48053 		mov	r3, #4096
 1809 0b06 C4F20203 		movt	r3, 16386
 1810 0b0a 4FF48052 		mov	r2, #4096
 1811 0b0e C4F20202 		movt	r2, 16386
 1812 0b12 126B     		ldr	r2, [r2, #48]
 1813 0b14 22F48072 		bic	r2, r2, #256
 1814 0b18 1A63     		str	r2, [r3, #48]
 1815              	.L74:
1192:../src/stm32f30x_rcc.c ****   }
1193:../src/stm32f30x_rcc.c ****   /* Set I2CSW bits according to RCC_TIMCLK value */
1194:../src/stm32f30x_rcc.c ****   RCC->CFGR3 |= RCC_TIMCLK;
 1816              		.loc 1 1194 0
 1817 0b1a 4FF48053 		mov	r3, #4096
 1818 0b1e C4F20203 		movt	r3, 16386
 1819 0b22 4FF48052 		mov	r2, #4096
 1820 0b26 C4F20202 		movt	r2, 16386
 1821 0b2a 116B     		ldr	r1, [r2, #48]
 1822 0b2c 7A68     		ldr	r2, [r7, #4]
 1823 0b2e 0A43     		orrs	r2, r2, r1
 1824 0b30 1A63     		str	r2, [r3, #48]
1195:../src/stm32f30x_rcc.c **** }
 1825              		.loc 1 1195 0
 1826 0b32 07F11407 		add	r7, r7, #20
 1827 0b36 BD46     		mov	sp, r7
 1828 0b38 80BC     		pop	{r7}
 1829 0b3a 7047     		bx	lr
 1830              		.cfi_endproc
 1831              	.LFE132:
 1833              		.align	2
 1834              		.global	RCC_USARTCLKConfig
 1835              		.thumb
 1836              		.thumb_func
 1838              	RCC_USARTCLKConfig:
 1839              	.LFB133:
1196:../src/stm32f30x_rcc.c **** 
1197:../src/stm32f30x_rcc.c **** /**
1198:../src/stm32f30x_rcc.c ****   * @brief  Configures the USART clock (USARTCLK).
1199:../src/stm32f30x_rcc.c ****   * @param  RCC_USARTCLK: defines the USART clock source. This clock is derived 
1200:../src/stm32f30x_rcc.c ****   *         from the HSI or System clock.
1201:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1202:../src/stm32f30x_rcc.c ****   *     @arg RCC_USARTxCLK_PCLK: USART clock = APB Clock (PCLK)
1203:../src/stm32f30x_rcc.c ****   *     @arg RCC_USARTxCLK_SYSCLK: USART clock = System Clock
1204:../src/stm32f30x_rcc.c ****   *     @arg RCC_USARTxCLK_LSE: USART clock = LSE Clock
1205:../src/stm32f30x_rcc.c ****   *     @arg RCC_USARTxCLK_HSI: USART clock = HSI Clock
1206:../src/stm32f30x_rcc.c ****   *          (x can be 1, 2, 3, 4 or 5).  
1207:../src/stm32f30x_rcc.c ****   * @retval None
1208:../src/stm32f30x_rcc.c ****   */
1209:../src/stm32f30x_rcc.c **** void RCC_USARTCLKConfig(uint32_t RCC_USARTCLK)
1210:../src/stm32f30x_rcc.c **** { 
 1840              		.loc 1 1210 0
 1841              		.cfi_startproc
 1842              		@ args = 0, pretend = 0, frame = 16
 1843              		@ frame_needed = 1, uses_anonymous_args = 0
 1844              		@ link register save eliminated.
 1845 0b3c 80B4     		push	{r7}
 1846              	.LCFI64:
 1847              		.cfi_def_cfa_offset 4
 1848              		.cfi_offset 7, -4
 1849 0b3e 85B0     		sub	sp, sp, #20
 1850              	.LCFI65:
 1851              		.cfi_def_cfa_offset 24
 1852 0b40 00AF     		add	r7, sp, #0
 1853              	.LCFI66:
 1854              		.cfi_def_cfa_register 7
 1855 0b42 7860     		str	r0, [r7, #4]
1211:../src/stm32f30x_rcc.c ****   uint32_t tmp = 0;
 1856              		.loc 1 1211 0
 1857 0b44 4FF00003 		mov	r3, #0
 1858 0b48 FB60     		str	r3, [r7, #12]
1212:../src/stm32f30x_rcc.c ****   
1213:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1214:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));
1215:../src/stm32f30x_rcc.c **** 
1216:../src/stm32f30x_rcc.c ****   tmp = (RCC_USARTCLK >> 28);
 1859              		.loc 1 1216 0
 1860 0b4a 7B68     		ldr	r3, [r7, #4]
 1861 0b4c 4FEA1373 		lsr	r3, r3, #28
 1862 0b50 FB60     		str	r3, [r7, #12]
1217:../src/stm32f30x_rcc.c **** 
1218:../src/stm32f30x_rcc.c ****   /* Clear USARTSW[1:0] bit */
1219:../src/stm32f30x_rcc.c ****   switch (tmp)
 1863              		.loc 1 1219 0
 1864 0b52 FB68     		ldr	r3, [r7, #12]
 1865 0b54 03F1FF33 		add	r3, r3, #-1
 1866 0b58 042B     		cmp	r3, #4
 1867 0b5a 4ED8     		bhi	.L84
 1868 0b5c 01A2     		adr	r2, .L82
 1869 0b5e 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 1870 0b62 00BF     		.align	2
 1871              	.L82:
 1872 0b64 790B0000 		.word	.L77+1
 1873 0b68 930B0000 		.word	.L78+1
 1874 0b6c AD0B0000 		.word	.L79+1
 1875 0b70 C70B0000 		.word	.L80+1
 1876 0b74 E10B0000 		.word	.L81+1
 1877              	.L77:
1220:../src/stm32f30x_rcc.c ****   {
1221:../src/stm32f30x_rcc.c ****     case 0x01:  /* clear USART1SW */
1222:../src/stm32f30x_rcc.c ****       RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
 1878              		.loc 1 1222 0
 1879 0b78 4FF48053 		mov	r3, #4096
 1880 0b7c C4F20203 		movt	r3, 16386
 1881 0b80 4FF48052 		mov	r2, #4096
 1882 0b84 C4F20202 		movt	r2, 16386
 1883 0b88 126B     		ldr	r2, [r2, #48]
 1884 0b8a 22F00302 		bic	r2, r2, #3
 1885 0b8e 1A63     		str	r2, [r3, #48]
1223:../src/stm32f30x_rcc.c ****       break;
 1886              		.loc 1 1223 0
 1887 0b90 34E0     		b	.L83
 1888              	.L78:
1224:../src/stm32f30x_rcc.c ****     case 0x02:  /* clear USART2SW */
1225:../src/stm32f30x_rcc.c ****       RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
 1889              		.loc 1 1225 0
 1890 0b92 4FF48053 		mov	r3, #4096
 1891 0b96 C4F20203 		movt	r3, 16386
 1892 0b9a 4FF48052 		mov	r2, #4096
 1893 0b9e C4F20202 		movt	r2, 16386
 1894 0ba2 126B     		ldr	r2, [r2, #48]
 1895 0ba4 22F44032 		bic	r2, r2, #196608
 1896 0ba8 1A63     		str	r2, [r3, #48]
1226:../src/stm32f30x_rcc.c ****       break;
 1897              		.loc 1 1226 0
 1898 0baa 27E0     		b	.L83
 1899              	.L79:
1227:../src/stm32f30x_rcc.c ****     case 0x03:  /* clear USART3SW */
1228:../src/stm32f30x_rcc.c ****       RCC->CFGR3 &= ~RCC_CFGR3_USART3SW;
 1900              		.loc 1 1228 0
 1901 0bac 4FF48053 		mov	r3, #4096
 1902 0bb0 C4F20203 		movt	r3, 16386
 1903 0bb4 4FF48052 		mov	r2, #4096
 1904 0bb8 C4F20202 		movt	r2, 16386
 1905 0bbc 126B     		ldr	r2, [r2, #48]
 1906 0bbe 22F44022 		bic	r2, r2, #786432
 1907 0bc2 1A63     		str	r2, [r3, #48]
1229:../src/stm32f30x_rcc.c ****       break;
 1908              		.loc 1 1229 0
 1909 0bc4 1AE0     		b	.L83
 1910              	.L80:
1230:../src/stm32f30x_rcc.c ****     case 0x04:  /* clear UART4SW */
1231:../src/stm32f30x_rcc.c ****       RCC->CFGR3 &= ~RCC_CFGR3_UART4SW;
 1911              		.loc 1 1231 0
 1912 0bc6 4FF48053 		mov	r3, #4096
 1913 0bca C4F20203 		movt	r3, 16386
 1914 0bce 4FF48052 		mov	r2, #4096
 1915 0bd2 C4F20202 		movt	r2, 16386
 1916 0bd6 126B     		ldr	r2, [r2, #48]
 1917 0bd8 22F44012 		bic	r2, r2, #3145728
 1918 0bdc 1A63     		str	r2, [r3, #48]
1232:../src/stm32f30x_rcc.c ****       break;
 1919              		.loc 1 1232 0
 1920 0bde 0DE0     		b	.L83
 1921              	.L81:
1233:../src/stm32f30x_rcc.c ****     case 0x05:  /* clear UART5SW */
1234:../src/stm32f30x_rcc.c ****       RCC->CFGR3 &= ~RCC_CFGR3_UART5SW;
 1922              		.loc 1 1234 0
 1923 0be0 4FF48053 		mov	r3, #4096
 1924 0be4 C4F20203 		movt	r3, 16386
 1925 0be8 4FF48052 		mov	r2, #4096
 1926 0bec C4F20202 		movt	r2, 16386
 1927 0bf0 126B     		ldr	r2, [r2, #48]
 1928 0bf2 22F44002 		bic	r2, r2, #12582912
 1929 0bf6 1A63     		str	r2, [r3, #48]
1235:../src/stm32f30x_rcc.c ****       break;
 1930              		.loc 1 1235 0
 1931 0bf8 00E0     		b	.L83
 1932              	.L84:
1236:../src/stm32f30x_rcc.c ****     default:
1237:../src/stm32f30x_rcc.c ****       break;
 1933              		.loc 1 1237 0
 1934 0bfa 00BF     		nop
 1935              	.L83:
1238:../src/stm32f30x_rcc.c ****   }
1239:../src/stm32f30x_rcc.c **** 
1240:../src/stm32f30x_rcc.c ****   /* Set USARTSW bits according to RCC_USARTCLK value */
1241:../src/stm32f30x_rcc.c ****   RCC->CFGR3 |= RCC_USARTCLK;
 1936              		.loc 1 1241 0
 1937 0bfc 4FF48053 		mov	r3, #4096
 1938 0c00 C4F20203 		movt	r3, 16386
 1939 0c04 4FF48052 		mov	r2, #4096
 1940 0c08 C4F20202 		movt	r2, 16386
 1941 0c0c 116B     		ldr	r1, [r2, #48]
 1942 0c0e 7A68     		ldr	r2, [r7, #4]
 1943 0c10 0A43     		orrs	r2, r2, r1
 1944 0c12 1A63     		str	r2, [r3, #48]
1242:../src/stm32f30x_rcc.c **** }
 1945              		.loc 1 1242 0
 1946 0c14 07F11407 		add	r7, r7, #20
 1947 0c18 BD46     		mov	sp, r7
 1948 0c1a 80BC     		pop	{r7}
 1949 0c1c 7047     		bx	lr
 1950              		.cfi_endproc
 1951              	.LFE133:
 1953 0c1e 00BF     		.align	2
 1954              		.global	RCC_USBCLKConfig
 1955              		.thumb
 1956              		.thumb_func
 1958              	RCC_USBCLKConfig:
 1959              	.LFB134:
1243:../src/stm32f30x_rcc.c **** 
1244:../src/stm32f30x_rcc.c **** /**
1245:../src/stm32f30x_rcc.c ****   * @brief  Configures the USB clock (USBCLK).
1246:../src/stm32f30x_rcc.c ****   * @param  RCC_USBCLKSource: specifies the USB clock source. This clock is 
1247:../src/stm32f30x_rcc.c ****   *   derived from the PLL output.
1248:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1249:../src/stm32f30x_rcc.c ****   *     @arg RCC_USBCLKSource_PLLCLK_1Div5: PLL clock divided by 1,5 selected as USB 
1250:../src/stm32f30x_rcc.c ****   *                                     clock source
1251:../src/stm32f30x_rcc.c ****   *     @arg RCC_USBCLKSource_PLLCLK_Div1: PLL clock selected as USB clock source
1252:../src/stm32f30x_rcc.c ****   * @retval None
1253:../src/stm32f30x_rcc.c ****   */
1254:../src/stm32f30x_rcc.c **** void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
1255:../src/stm32f30x_rcc.c **** {
 1960              		.loc 1 1255 0
 1961              		.cfi_startproc
 1962              		@ args = 0, pretend = 0, frame = 8
 1963              		@ frame_needed = 1, uses_anonymous_args = 0
 1964              		@ link register save eliminated.
 1965 0c20 80B4     		push	{r7}
 1966              	.LCFI67:
 1967              		.cfi_def_cfa_offset 4
 1968              		.cfi_offset 7, -4
 1969 0c22 83B0     		sub	sp, sp, #12
 1970              	.LCFI68:
 1971              		.cfi_def_cfa_offset 16
 1972 0c24 00AF     		add	r7, sp, #0
 1973              	.LCFI69:
 1974              		.cfi_def_cfa_register 7
 1975 0c26 7860     		str	r0, [r7, #4]
1256:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1257:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
1258:../src/stm32f30x_rcc.c **** 
1259:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 1976              		.loc 1 1259 0
 1977 0c28 4FF0D803 		mov	r3, #216
 1978 0c2c C4F24223 		movt	r3, 16962
 1979 0c30 7A68     		ldr	r2, [r7, #4]
 1980 0c32 1A60     		str	r2, [r3, #0]
1260:../src/stm32f30x_rcc.c **** }
 1981              		.loc 1 1260 0
 1982 0c34 07F10C07 		add	r7, r7, #12
 1983 0c38 BD46     		mov	sp, r7
 1984 0c3a 80BC     		pop	{r7}
 1985 0c3c 7047     		bx	lr
 1986              		.cfi_endproc
 1987              	.LFE134:
 1989 0c3e 00BF     		.align	2
 1990              		.global	RCC_RTCCLKConfig
 1991              		.thumb
 1992              		.thumb_func
 1994              	RCC_RTCCLKConfig:
 1995              	.LFB135:
1261:../src/stm32f30x_rcc.c **** 
1262:../src/stm32f30x_rcc.c **** /**
1263:../src/stm32f30x_rcc.c ****   * @brief  Configures the RTC clock (RTCCLK).
1264:../src/stm32f30x_rcc.c ****   * @note     As the RTC clock configuration bits are in the Backup domain and write
1265:../src/stm32f30x_rcc.c ****   *           access is denied to this domain after reset, you have to enable write
1266:../src/stm32f30x_rcc.c ****   *           access using PWR_BackupAccessCmd(ENABLE) function before to configure
1267:../src/stm32f30x_rcc.c ****   *           the RTC clock source (to be done once after reset).    
1268:../src/stm32f30x_rcc.c ****   * @note     Once the RTC clock is configured it can't be changed unless the RTC
1269:../src/stm32f30x_rcc.c ****   *           is reset using RCC_BackupResetCmd function, or by a Power On Reset (POR)
1270:../src/stm32f30x_rcc.c ****   *             
1271:../src/stm32f30x_rcc.c ****   * @param  RCC_RTCCLKSource: specifies the RTC clock source.
1272:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1273:../src/stm32f30x_rcc.c ****   *     @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
1274:../src/stm32f30x_rcc.c ****   *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
1275:../src/stm32f30x_rcc.c ****   *     @arg RCC_RTCCLKSource_HSE_Div32: HSE divided by 32 selected as RTC clock
1276:../src/stm32f30x_rcc.c ****   *       
1277:../src/stm32f30x_rcc.c ****   * @note     If the LSE or LSI is used as RTC clock source, the RTC continues to
1278:../src/stm32f30x_rcc.c ****   *           work in STOP and STANDBY modes, and can be used as wakeup source.
1279:../src/stm32f30x_rcc.c ****   *           However, when the HSE clock is used as RTC clock source, the RTC
1280:../src/stm32f30x_rcc.c ****   *           cannot be used in STOP and STANDBY modes.             
1281:../src/stm32f30x_rcc.c ****   * @note     The maximum input clock frequency for RTC is 2MHz (when using HSE as
1282:../src/stm32f30x_rcc.c ****   *           RTC clock source).             
1283:../src/stm32f30x_rcc.c ****   * @retval None
1284:../src/stm32f30x_rcc.c ****   */
1285:../src/stm32f30x_rcc.c **** void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
1286:../src/stm32f30x_rcc.c **** {
 1996              		.loc 1 1286 0
 1997              		.cfi_startproc
 1998              		@ args = 0, pretend = 0, frame = 8
 1999              		@ frame_needed = 1, uses_anonymous_args = 0
 2000              		@ link register save eliminated.
 2001 0c40 80B4     		push	{r7}
 2002              	.LCFI70:
 2003              		.cfi_def_cfa_offset 4
 2004              		.cfi_offset 7, -4
 2005 0c42 83B0     		sub	sp, sp, #12
 2006              	.LCFI71:
 2007              		.cfi_def_cfa_offset 16
 2008 0c44 00AF     		add	r7, sp, #0
 2009              	.LCFI72:
 2010              		.cfi_def_cfa_register 7
 2011 0c46 7860     		str	r0, [r7, #4]
1287:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1288:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
1289:../src/stm32f30x_rcc.c ****   
1290:../src/stm32f30x_rcc.c ****   /* Select the RTC clock source */
1291:../src/stm32f30x_rcc.c ****   RCC->BDCR |= RCC_RTCCLKSource;
 2012              		.loc 1 1291 0
 2013 0c48 4FF48053 		mov	r3, #4096
 2014 0c4c C4F20203 		movt	r3, 16386
 2015 0c50 4FF48052 		mov	r2, #4096
 2016 0c54 C4F20202 		movt	r2, 16386
 2017 0c58 116A     		ldr	r1, [r2, #32]
 2018 0c5a 7A68     		ldr	r2, [r7, #4]
 2019 0c5c 0A43     		orrs	r2, r2, r1
 2020 0c5e 1A62     		str	r2, [r3, #32]
1292:../src/stm32f30x_rcc.c **** }
 2021              		.loc 1 1292 0
 2022 0c60 07F10C07 		add	r7, r7, #12
 2023 0c64 BD46     		mov	sp, r7
 2024 0c66 80BC     		pop	{r7}
 2025 0c68 7047     		bx	lr
 2026              		.cfi_endproc
 2027              	.LFE135:
 2029 0c6a 00BF     		.align	2
 2030              		.global	RCC_I2SCLKConfig
 2031              		.thumb
 2032              		.thumb_func
 2034              	RCC_I2SCLKConfig:
 2035              	.LFB136:
1293:../src/stm32f30x_rcc.c **** 
1294:../src/stm32f30x_rcc.c **** /**
1295:../src/stm32f30x_rcc.c ****   * @brief  Configures the I2S clock source (I2SCLK).
1296:../src/stm32f30x_rcc.c ****   * @note   This function must be called before enabling the SPI2 and SPI3 clocks.
1297:../src/stm32f30x_rcc.c ****   * @param  RCC_I2SCLKSource: specifies the I2S clock source.
1298:../src/stm32f30x_rcc.c ****   *          This parameter can be one of the following values:
1299:../src/stm32f30x_rcc.c ****   *            @arg RCC_I2S2CLKSource_SYSCLK: SYSCLK clock used as I2S clock source
1300:../src/stm32f30x_rcc.c ****   *            @arg RCC_I2S2CLKSource_Ext: External clock mapped on the I2S_CKIN pin
1301:../src/stm32f30x_rcc.c ****   *                                        used as I2S clock source
1302:../src/stm32f30x_rcc.c ****   * @retval None
1303:../src/stm32f30x_rcc.c ****   */
1304:../src/stm32f30x_rcc.c **** void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
1305:../src/stm32f30x_rcc.c **** {
 2036              		.loc 1 1305 0
 2037              		.cfi_startproc
 2038              		@ args = 0, pretend = 0, frame = 8
 2039              		@ frame_needed = 1, uses_anonymous_args = 0
 2040              		@ link register save eliminated.
 2041 0c6c 80B4     		push	{r7}
 2042              	.LCFI73:
 2043              		.cfi_def_cfa_offset 4
 2044              		.cfi_offset 7, -4
 2045 0c6e 83B0     		sub	sp, sp, #12
 2046              	.LCFI74:
 2047              		.cfi_def_cfa_offset 16
 2048 0c70 00AF     		add	r7, sp, #0
 2049              	.LCFI75:
 2050              		.cfi_def_cfa_register 7
 2051 0c72 7860     		str	r0, [r7, #4]
1306:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1307:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
1308:../src/stm32f30x_rcc.c **** 
1309:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 2052              		.loc 1 1309 0
 2053 0c74 4FF0DC03 		mov	r3, #220
 2054 0c78 C4F24223 		movt	r3, 16962
 2055 0c7c 7A68     		ldr	r2, [r7, #4]
 2056 0c7e 1A60     		str	r2, [r3, #0]
1310:../src/stm32f30x_rcc.c **** }
 2057              		.loc 1 1310 0
 2058 0c80 07F10C07 		add	r7, r7, #12
 2059 0c84 BD46     		mov	sp, r7
 2060 0c86 80BC     		pop	{r7}
 2061 0c88 7047     		bx	lr
 2062              		.cfi_endproc
 2063              	.LFE136:
 2065 0c8a 00BF     		.align	2
 2066              		.global	RCC_RTCCLKCmd
 2067              		.thumb
 2068              		.thumb_func
 2070              	RCC_RTCCLKCmd:
 2071              	.LFB137:
1311:../src/stm32f30x_rcc.c **** 
1312:../src/stm32f30x_rcc.c **** /**
1313:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the RTC clock.
1314:../src/stm32f30x_rcc.c ****   * @note   This function must be used only after the RTC clock source was selected
1315:../src/stm32f30x_rcc.c ****   *         using the RCC_RTCCLKConfig function.
1316:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the RTC clock.
1317:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1318:../src/stm32f30x_rcc.c ****   * @retval None
1319:../src/stm32f30x_rcc.c ****   */
1320:../src/stm32f30x_rcc.c **** void RCC_RTCCLKCmd(FunctionalState NewState)
1321:../src/stm32f30x_rcc.c **** {
 2072              		.loc 1 1321 0
 2073              		.cfi_startproc
 2074              		@ args = 0, pretend = 0, frame = 8
 2075              		@ frame_needed = 1, uses_anonymous_args = 0
 2076              		@ link register save eliminated.
 2077 0c8c 80B4     		push	{r7}
 2078              	.LCFI76:
 2079              		.cfi_def_cfa_offset 4
 2080              		.cfi_offset 7, -4
 2081 0c8e 83B0     		sub	sp, sp, #12
 2082              	.LCFI77:
 2083              		.cfi_def_cfa_offset 16
 2084 0c90 00AF     		add	r7, sp, #0
 2085              	.LCFI78:
 2086              		.cfi_def_cfa_register 7
 2087 0c92 0346     		mov	r3, r0
 2088 0c94 FB71     		strb	r3, [r7, #7]
1322:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1323:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1324:../src/stm32f30x_rcc.c ****   
1325:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 2089              		.loc 1 1325 0
 2090 0c96 40F23C43 		movw	r3, #1084
 2091 0c9a C4F24223 		movt	r3, 16962
 2092 0c9e FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 2093 0ca0 1A60     		str	r2, [r3, #0]
1326:../src/stm32f30x_rcc.c **** }
 2094              		.loc 1 1326 0
 2095 0ca2 07F10C07 		add	r7, r7, #12
 2096 0ca6 BD46     		mov	sp, r7
 2097 0ca8 80BC     		pop	{r7}
 2098 0caa 7047     		bx	lr
 2099              		.cfi_endproc
 2100              	.LFE137:
 2102              		.align	2
 2103              		.global	RCC_BackupResetCmd
 2104              		.thumb
 2105              		.thumb_func
 2107              	RCC_BackupResetCmd:
 2108              	.LFB138:
1327:../src/stm32f30x_rcc.c **** 
1328:../src/stm32f30x_rcc.c **** /**
1329:../src/stm32f30x_rcc.c ****   * @brief  Forces or releases the Backup domain reset.
1330:../src/stm32f30x_rcc.c ****   * @note   This function resets the RTC peripheral (including the backup registers)
1331:../src/stm32f30x_rcc.c ****   *         and the RTC clock source selection in RCC_BDCR register.
1332:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the Backup domain reset.
1333:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1334:../src/stm32f30x_rcc.c ****   * @retval None
1335:../src/stm32f30x_rcc.c ****   */
1336:../src/stm32f30x_rcc.c **** void RCC_BackupResetCmd(FunctionalState NewState)
1337:../src/stm32f30x_rcc.c **** {
 2109              		.loc 1 1337 0
 2110              		.cfi_startproc
 2111              		@ args = 0, pretend = 0, frame = 8
 2112              		@ frame_needed = 1, uses_anonymous_args = 0
 2113              		@ link register save eliminated.
 2114 0cac 80B4     		push	{r7}
 2115              	.LCFI79:
 2116              		.cfi_def_cfa_offset 4
 2117              		.cfi_offset 7, -4
 2118 0cae 83B0     		sub	sp, sp, #12
 2119              	.LCFI80:
 2120              		.cfi_def_cfa_offset 16
 2121 0cb0 00AF     		add	r7, sp, #0
 2122              	.LCFI81:
 2123              		.cfi_def_cfa_register 7
 2124 0cb2 0346     		mov	r3, r0
 2125 0cb4 FB71     		strb	r3, [r7, #7]
1338:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1339:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1340:../src/stm32f30x_rcc.c ****   
1341:../src/stm32f30x_rcc.c ****   *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 2126              		.loc 1 1341 0
 2127 0cb6 4FF48863 		mov	r3, #1088
 2128 0cba C4F24223 		movt	r3, 16962
 2129 0cbe FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 2130 0cc0 1A60     		str	r2, [r3, #0]
1342:../src/stm32f30x_rcc.c **** }
 2131              		.loc 1 1342 0
 2132 0cc2 07F10C07 		add	r7, r7, #12
 2133 0cc6 BD46     		mov	sp, r7
 2134 0cc8 80BC     		pop	{r7}
 2135 0cca 7047     		bx	lr
 2136              		.cfi_endproc
 2137              	.LFE138:
 2139              		.align	2
 2140              		.global	RCC_AHBPeriphClockCmd
 2141              		.thumb
 2142              		.thumb_func
 2144              	RCC_AHBPeriphClockCmd:
 2145              	.LFB139:
1343:../src/stm32f30x_rcc.c **** 
1344:../src/stm32f30x_rcc.c **** /**
1345:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the AHB peripheral clock.
1346:../src/stm32f30x_rcc.c ****   * @note   After reset, the peripheral clock (used for registers read/write access)
1347:../src/stm32f30x_rcc.c ****   *         is disabled and the application software has to enable this clock before 
1348:../src/stm32f30x_rcc.c ****   *         using it.    
1349:../src/stm32f30x_rcc.c ****   * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
1350:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1351:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOA
1352:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOB
1353:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOC  
1354:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOD
1355:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOE  
1356:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOF
1357:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_TS
1358:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_CRC
1359:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_FLITF (has effect only when the Flash memory is in power down mode)  
1360:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_SRAM
1361:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_DMA2
1362:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_DMA1
1363:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_ADC34
1364:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_ADC12      
1365:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the specified peripheral clock.
1366:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1367:../src/stm32f30x_rcc.c ****   * @retval None
1368:../src/stm32f30x_rcc.c ****   */
1369:../src/stm32f30x_rcc.c **** void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
1370:../src/stm32f30x_rcc.c **** {
 2146              		.loc 1 1370 0
 2147              		.cfi_startproc
 2148              		@ args = 0, pretend = 0, frame = 8
 2149              		@ frame_needed = 1, uses_anonymous_args = 0
 2150              		@ link register save eliminated.
 2151 0ccc 80B4     		push	{r7}
 2152              	.LCFI82:
 2153              		.cfi_def_cfa_offset 4
 2154              		.cfi_offset 7, -4
 2155 0cce 83B0     		sub	sp, sp, #12
 2156              	.LCFI83:
 2157              		.cfi_def_cfa_offset 16
 2158 0cd0 00AF     		add	r7, sp, #0
 2159              	.LCFI84:
 2160              		.cfi_def_cfa_register 7
 2161 0cd2 7860     		str	r0, [r7, #4]
 2162 0cd4 0B46     		mov	r3, r1
 2163 0cd6 FB70     		strb	r3, [r7, #3]
1371:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1372:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
1373:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1374:../src/stm32f30x_rcc.c ****   
1375:../src/stm32f30x_rcc.c ****   if (NewState != DISABLE)
 2164              		.loc 1 1375 0
 2165 0cd8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2166 0cda 002B     		cmp	r3, #0
 2167 0cdc 0CD0     		beq	.L91
1376:../src/stm32f30x_rcc.c ****   {
1377:../src/stm32f30x_rcc.c ****     RCC->AHBENR |= RCC_AHBPeriph;
 2168              		.loc 1 1377 0
 2169 0cde 4FF48053 		mov	r3, #4096
 2170 0ce2 C4F20203 		movt	r3, 16386
 2171 0ce6 4FF48052 		mov	r2, #4096
 2172 0cea C4F20202 		movt	r2, 16386
 2173 0cee 5169     		ldr	r1, [r2, #20]
 2174 0cf0 7A68     		ldr	r2, [r7, #4]
 2175 0cf2 0A43     		orrs	r2, r2, r1
 2176 0cf4 5A61     		str	r2, [r3, #20]
 2177 0cf6 0DE0     		b	.L90
 2178              	.L91:
1378:../src/stm32f30x_rcc.c ****   }
1379:../src/stm32f30x_rcc.c ****   else
1380:../src/stm32f30x_rcc.c ****   {
1381:../src/stm32f30x_rcc.c ****     RCC->AHBENR &= ~RCC_AHBPeriph;
 2179              		.loc 1 1381 0
 2180 0cf8 4FF48053 		mov	r3, #4096
 2181 0cfc C4F20203 		movt	r3, 16386
 2182 0d00 4FF48052 		mov	r2, #4096
 2183 0d04 C4F20202 		movt	r2, 16386
 2184 0d08 5169     		ldr	r1, [r2, #20]
 2185 0d0a 7A68     		ldr	r2, [r7, #4]
 2186 0d0c 6FEA0202 		mvn	r2, r2
 2187 0d10 0A40     		ands	r2, r2, r1
 2188 0d12 5A61     		str	r2, [r3, #20]
 2189              	.L90:
1382:../src/stm32f30x_rcc.c ****   }
1383:../src/stm32f30x_rcc.c **** }
 2190              		.loc 1 1383 0
 2191 0d14 07F10C07 		add	r7, r7, #12
 2192 0d18 BD46     		mov	sp, r7
 2193 0d1a 80BC     		pop	{r7}
 2194 0d1c 7047     		bx	lr
 2195              		.cfi_endproc
 2196              	.LFE139:
 2198 0d1e 00BF     		.align	2
 2199              		.global	RCC_APB2PeriphClockCmd
 2200              		.thumb
 2201              		.thumb_func
 2203              	RCC_APB2PeriphClockCmd:
 2204              	.LFB140:
1384:../src/stm32f30x_rcc.c **** 
1385:../src/stm32f30x_rcc.c **** /**
1386:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
1387:../src/stm32f30x_rcc.c ****   * @note   After reset, the peripheral clock (used for registers read/write access)
1388:../src/stm32f30x_rcc.c ****   *         is disabled and the application software has to enable this clock before 
1389:../src/stm32f30x_rcc.c ****   *         using it.
1390:../src/stm32f30x_rcc.c ****   * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
1391:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1392:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_SYSCFG
1393:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_SPI1
1394:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_USART1
1395:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM15
1396:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM16
1397:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM17
1398:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM1       
1399:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM8
1400:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the specified peripheral clock.
1401:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1402:../src/stm32f30x_rcc.c ****   * @retval None
1403:../src/stm32f30x_rcc.c ****   */
1404:../src/stm32f30x_rcc.c **** void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
1405:../src/stm32f30x_rcc.c **** {
 2205              		.loc 1 1405 0
 2206              		.cfi_startproc
 2207              		@ args = 0, pretend = 0, frame = 8
 2208              		@ frame_needed = 1, uses_anonymous_args = 0
 2209              		@ link register save eliminated.
 2210 0d20 80B4     		push	{r7}
 2211              	.LCFI85:
 2212              		.cfi_def_cfa_offset 4
 2213              		.cfi_offset 7, -4
 2214 0d22 83B0     		sub	sp, sp, #12
 2215              	.LCFI86:
 2216              		.cfi_def_cfa_offset 16
 2217 0d24 00AF     		add	r7, sp, #0
 2218              	.LCFI87:
 2219              		.cfi_def_cfa_register 7
 2220 0d26 7860     		str	r0, [r7, #4]
 2221 0d28 0B46     		mov	r3, r1
 2222 0d2a FB70     		strb	r3, [r7, #3]
1406:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1407:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
1408:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1409:../src/stm32f30x_rcc.c **** 
1410:../src/stm32f30x_rcc.c ****   if (NewState != DISABLE)
 2223              		.loc 1 1410 0
 2224 0d2c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2225 0d2e 002B     		cmp	r3, #0
 2226 0d30 0CD0     		beq	.L94
1411:../src/stm32f30x_rcc.c ****   {
1412:../src/stm32f30x_rcc.c ****     RCC->APB2ENR |= RCC_APB2Periph;
 2227              		.loc 1 1412 0
 2228 0d32 4FF48053 		mov	r3, #4096
 2229 0d36 C4F20203 		movt	r3, 16386
 2230 0d3a 4FF48052 		mov	r2, #4096
 2231 0d3e C4F20202 		movt	r2, 16386
 2232 0d42 9169     		ldr	r1, [r2, #24]
 2233 0d44 7A68     		ldr	r2, [r7, #4]
 2234 0d46 0A43     		orrs	r2, r2, r1
 2235 0d48 9A61     		str	r2, [r3, #24]
 2236 0d4a 0DE0     		b	.L93
 2237              	.L94:
1413:../src/stm32f30x_rcc.c ****   }
1414:../src/stm32f30x_rcc.c ****   else
1415:../src/stm32f30x_rcc.c ****   {
1416:../src/stm32f30x_rcc.c ****     RCC->APB2ENR &= ~RCC_APB2Periph;
 2238              		.loc 1 1416 0
 2239 0d4c 4FF48053 		mov	r3, #4096
 2240 0d50 C4F20203 		movt	r3, 16386
 2241 0d54 4FF48052 		mov	r2, #4096
 2242 0d58 C4F20202 		movt	r2, 16386
 2243 0d5c 9169     		ldr	r1, [r2, #24]
 2244 0d5e 7A68     		ldr	r2, [r7, #4]
 2245 0d60 6FEA0202 		mvn	r2, r2
 2246 0d64 0A40     		ands	r2, r2, r1
 2247 0d66 9A61     		str	r2, [r3, #24]
 2248              	.L93:
1417:../src/stm32f30x_rcc.c ****   }
1418:../src/stm32f30x_rcc.c **** }
 2249              		.loc 1 1418 0
 2250 0d68 07F10C07 		add	r7, r7, #12
 2251 0d6c BD46     		mov	sp, r7
 2252 0d6e 80BC     		pop	{r7}
 2253 0d70 7047     		bx	lr
 2254              		.cfi_endproc
 2255              	.LFE140:
 2257 0d72 00BF     		.align	2
 2258              		.global	RCC_APB1PeriphClockCmd
 2259              		.thumb
 2260              		.thumb_func
 2262              	RCC_APB1PeriphClockCmd:
 2263              	.LFB141:
1419:../src/stm32f30x_rcc.c **** 
1420:../src/stm32f30x_rcc.c **** /**
1421:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
1422:../src/stm32f30x_rcc.c ****   * @note   After reset, the peripheral clock (used for registers read/write access)
1423:../src/stm32f30x_rcc.c ****   *         is disabled and the application software has to enable this clock before 
1424:../src/stm32f30x_rcc.c ****   *         using it.
1425:../src/stm32f30x_rcc.c ****   * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
1426:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1427:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM2
1428:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM3
1429:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM4
1430:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM6
1431:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM7
1432:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_WWDG
1433:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_SPI2
1434:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_SPI3  
1435:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_USART2
1436:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_USART3
1437:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_UART4 
1438:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_UART5     
1439:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_I2C1
1440:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_I2C2
1441:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_USB
1442:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_CAN1
1443:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_PWR
1444:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_DAC
1445:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the specified peripheral clock.
1446:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1447:../src/stm32f30x_rcc.c ****   * @retval None
1448:../src/stm32f30x_rcc.c ****   */
1449:../src/stm32f30x_rcc.c **** void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
1450:../src/stm32f30x_rcc.c **** {
 2264              		.loc 1 1450 0
 2265              		.cfi_startproc
 2266              		@ args = 0, pretend = 0, frame = 8
 2267              		@ frame_needed = 1, uses_anonymous_args = 0
 2268              		@ link register save eliminated.
 2269 0d74 80B4     		push	{r7}
 2270              	.LCFI88:
 2271              		.cfi_def_cfa_offset 4
 2272              		.cfi_offset 7, -4
 2273 0d76 83B0     		sub	sp, sp, #12
 2274              	.LCFI89:
 2275              		.cfi_def_cfa_offset 16
 2276 0d78 00AF     		add	r7, sp, #0
 2277              	.LCFI90:
 2278              		.cfi_def_cfa_register 7
 2279 0d7a 7860     		str	r0, [r7, #4]
 2280 0d7c 0B46     		mov	r3, r1
 2281 0d7e FB70     		strb	r3, [r7, #3]
1451:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1452:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
1453:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1454:../src/stm32f30x_rcc.c **** 
1455:../src/stm32f30x_rcc.c ****   if (NewState != DISABLE)
 2282              		.loc 1 1455 0
 2283 0d80 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2284 0d82 002B     		cmp	r3, #0
 2285 0d84 0CD0     		beq	.L97
1456:../src/stm32f30x_rcc.c ****   {
1457:../src/stm32f30x_rcc.c ****     RCC->APB1ENR |= RCC_APB1Periph;
 2286              		.loc 1 1457 0
 2287 0d86 4FF48053 		mov	r3, #4096
 2288 0d8a C4F20203 		movt	r3, 16386
 2289 0d8e 4FF48052 		mov	r2, #4096
 2290 0d92 C4F20202 		movt	r2, 16386
 2291 0d96 D169     		ldr	r1, [r2, #28]
 2292 0d98 7A68     		ldr	r2, [r7, #4]
 2293 0d9a 0A43     		orrs	r2, r2, r1
 2294 0d9c DA61     		str	r2, [r3, #28]
 2295 0d9e 0DE0     		b	.L96
 2296              	.L97:
1458:../src/stm32f30x_rcc.c ****   }
1459:../src/stm32f30x_rcc.c ****   else
1460:../src/stm32f30x_rcc.c ****   {
1461:../src/stm32f30x_rcc.c ****     RCC->APB1ENR &= ~RCC_APB1Periph;
 2297              		.loc 1 1461 0
 2298 0da0 4FF48053 		mov	r3, #4096
 2299 0da4 C4F20203 		movt	r3, 16386
 2300 0da8 4FF48052 		mov	r2, #4096
 2301 0dac C4F20202 		movt	r2, 16386
 2302 0db0 D169     		ldr	r1, [r2, #28]
 2303 0db2 7A68     		ldr	r2, [r7, #4]
 2304 0db4 6FEA0202 		mvn	r2, r2
 2305 0db8 0A40     		ands	r2, r2, r1
 2306 0dba DA61     		str	r2, [r3, #28]
 2307              	.L96:
1462:../src/stm32f30x_rcc.c ****   }
1463:../src/stm32f30x_rcc.c **** }
 2308              		.loc 1 1463 0
 2309 0dbc 07F10C07 		add	r7, r7, #12
 2310 0dc0 BD46     		mov	sp, r7
 2311 0dc2 80BC     		pop	{r7}
 2312 0dc4 7047     		bx	lr
 2313              		.cfi_endproc
 2314              	.LFE141:
 2316 0dc6 00BF     		.align	2
 2317              		.global	RCC_AHBPeriphResetCmd
 2318              		.thumb
 2319              		.thumb_func
 2321              	RCC_AHBPeriphResetCmd:
 2322              	.LFB142:
1464:../src/stm32f30x_rcc.c **** 
1465:../src/stm32f30x_rcc.c **** /**
1466:../src/stm32f30x_rcc.c ****   * @brief  Forces or releases AHB peripheral reset.
1467:../src/stm32f30x_rcc.c ****   * @param  RCC_AHBPeriph: specifies the AHB peripheral to reset.
1468:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1469:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOA
1470:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOB
1471:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOC  
1472:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOD
1473:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOE  
1474:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_GPIOF
1475:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_TS
1476:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_ADC34
1477:../src/stm32f30x_rcc.c ****   *     @arg RCC_AHBPeriph_ADC12    
1478:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the specified peripheral reset.
1479:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1480:../src/stm32f30x_rcc.c ****   * @retval None
1481:../src/stm32f30x_rcc.c ****   */
1482:../src/stm32f30x_rcc.c **** void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
1483:../src/stm32f30x_rcc.c **** {
 2323              		.loc 1 1483 0
 2324              		.cfi_startproc
 2325              		@ args = 0, pretend = 0, frame = 8
 2326              		@ frame_needed = 1, uses_anonymous_args = 0
 2327              		@ link register save eliminated.
 2328 0dc8 80B4     		push	{r7}
 2329              	.LCFI91:
 2330              		.cfi_def_cfa_offset 4
 2331              		.cfi_offset 7, -4
 2332 0dca 83B0     		sub	sp, sp, #12
 2333              	.LCFI92:
 2334              		.cfi_def_cfa_offset 16
 2335 0dcc 00AF     		add	r7, sp, #0
 2336              	.LCFI93:
 2337              		.cfi_def_cfa_register 7
 2338 0dce 7860     		str	r0, [r7, #4]
 2339 0dd0 0B46     		mov	r3, r1
 2340 0dd2 FB70     		strb	r3, [r7, #3]
1484:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1485:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
1486:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1487:../src/stm32f30x_rcc.c **** 
1488:../src/stm32f30x_rcc.c ****   if (NewState != DISABLE)
 2341              		.loc 1 1488 0
 2342 0dd4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2343 0dd6 002B     		cmp	r3, #0
 2344 0dd8 0CD0     		beq	.L100
1489:../src/stm32f30x_rcc.c ****   {
1490:../src/stm32f30x_rcc.c ****     RCC->AHBRSTR |= RCC_AHBPeriph;
 2345              		.loc 1 1490 0
 2346 0dda 4FF48053 		mov	r3, #4096
 2347 0dde C4F20203 		movt	r3, 16386
 2348 0de2 4FF48052 		mov	r2, #4096
 2349 0de6 C4F20202 		movt	r2, 16386
 2350 0dea 916A     		ldr	r1, [r2, #40]
 2351 0dec 7A68     		ldr	r2, [r7, #4]
 2352 0dee 0A43     		orrs	r2, r2, r1
 2353 0df0 9A62     		str	r2, [r3, #40]
 2354 0df2 0DE0     		b	.L99
 2355              	.L100:
1491:../src/stm32f30x_rcc.c ****   }
1492:../src/stm32f30x_rcc.c ****   else
1493:../src/stm32f30x_rcc.c ****   {
1494:../src/stm32f30x_rcc.c ****     RCC->AHBRSTR &= ~RCC_AHBPeriph;
 2356              		.loc 1 1494 0
 2357 0df4 4FF48053 		mov	r3, #4096
 2358 0df8 C4F20203 		movt	r3, 16386
 2359 0dfc 4FF48052 		mov	r2, #4096
 2360 0e00 C4F20202 		movt	r2, 16386
 2361 0e04 916A     		ldr	r1, [r2, #40]
 2362 0e06 7A68     		ldr	r2, [r7, #4]
 2363 0e08 6FEA0202 		mvn	r2, r2
 2364 0e0c 0A40     		ands	r2, r2, r1
 2365 0e0e 9A62     		str	r2, [r3, #40]
 2366              	.L99:
1495:../src/stm32f30x_rcc.c ****   }
1496:../src/stm32f30x_rcc.c **** }
 2367              		.loc 1 1496 0
 2368 0e10 07F10C07 		add	r7, r7, #12
 2369 0e14 BD46     		mov	sp, r7
 2370 0e16 80BC     		pop	{r7}
 2371 0e18 7047     		bx	lr
 2372              		.cfi_endproc
 2373              	.LFE142:
 2375 0e1a 00BF     		.align	2
 2376              		.global	RCC_APB2PeriphResetCmd
 2377              		.thumb
 2378              		.thumb_func
 2380              	RCC_APB2PeriphResetCmd:
 2381              	.LFB143:
1497:../src/stm32f30x_rcc.c **** 
1498:../src/stm32f30x_rcc.c **** /**
1499:../src/stm32f30x_rcc.c ****   * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
1500:../src/stm32f30x_rcc.c ****   * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
1501:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1502:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_SYSCFG
1503:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_SPI1
1504:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_USART1
1505:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM15
1506:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM16
1507:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM17
1508:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM1       
1509:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB2Periph_TIM8  
1510:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the specified peripheral reset.
1511:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1512:../src/stm32f30x_rcc.c ****   * @retval None
1513:../src/stm32f30x_rcc.c ****   */
1514:../src/stm32f30x_rcc.c **** void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
1515:../src/stm32f30x_rcc.c **** {
 2382              		.loc 1 1515 0
 2383              		.cfi_startproc
 2384              		@ args = 0, pretend = 0, frame = 8
 2385              		@ frame_needed = 1, uses_anonymous_args = 0
 2386              		@ link register save eliminated.
 2387 0e1c 80B4     		push	{r7}
 2388              	.LCFI94:
 2389              		.cfi_def_cfa_offset 4
 2390              		.cfi_offset 7, -4
 2391 0e1e 83B0     		sub	sp, sp, #12
 2392              	.LCFI95:
 2393              		.cfi_def_cfa_offset 16
 2394 0e20 00AF     		add	r7, sp, #0
 2395              	.LCFI96:
 2396              		.cfi_def_cfa_register 7
 2397 0e22 7860     		str	r0, [r7, #4]
 2398 0e24 0B46     		mov	r3, r1
 2399 0e26 FB70     		strb	r3, [r7, #3]
1516:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1517:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
1518:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1519:../src/stm32f30x_rcc.c **** 
1520:../src/stm32f30x_rcc.c ****   if (NewState != DISABLE)
 2400              		.loc 1 1520 0
 2401 0e28 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2402 0e2a 002B     		cmp	r3, #0
 2403 0e2c 0CD0     		beq	.L103
1521:../src/stm32f30x_rcc.c ****   {
1522:../src/stm32f30x_rcc.c ****     RCC->APB2RSTR |= RCC_APB2Periph;
 2404              		.loc 1 1522 0
 2405 0e2e 4FF48053 		mov	r3, #4096
 2406 0e32 C4F20203 		movt	r3, 16386
 2407 0e36 4FF48052 		mov	r2, #4096
 2408 0e3a C4F20202 		movt	r2, 16386
 2409 0e3e D168     		ldr	r1, [r2, #12]
 2410 0e40 7A68     		ldr	r2, [r7, #4]
 2411 0e42 0A43     		orrs	r2, r2, r1
 2412 0e44 DA60     		str	r2, [r3, #12]
 2413 0e46 0DE0     		b	.L102
 2414              	.L103:
1523:../src/stm32f30x_rcc.c ****   }
1524:../src/stm32f30x_rcc.c ****   else
1525:../src/stm32f30x_rcc.c ****   {
1526:../src/stm32f30x_rcc.c ****     RCC->APB2RSTR &= ~RCC_APB2Periph;
 2415              		.loc 1 1526 0
 2416 0e48 4FF48053 		mov	r3, #4096
 2417 0e4c C4F20203 		movt	r3, 16386
 2418 0e50 4FF48052 		mov	r2, #4096
 2419 0e54 C4F20202 		movt	r2, 16386
 2420 0e58 D168     		ldr	r1, [r2, #12]
 2421 0e5a 7A68     		ldr	r2, [r7, #4]
 2422 0e5c 6FEA0202 		mvn	r2, r2
 2423 0e60 0A40     		ands	r2, r2, r1
 2424 0e62 DA60     		str	r2, [r3, #12]
 2425              	.L102:
1527:../src/stm32f30x_rcc.c ****   }
1528:../src/stm32f30x_rcc.c **** }
 2426              		.loc 1 1528 0
 2427 0e64 07F10C07 		add	r7, r7, #12
 2428 0e68 BD46     		mov	sp, r7
 2429 0e6a 80BC     		pop	{r7}
 2430 0e6c 7047     		bx	lr
 2431              		.cfi_endproc
 2432              	.LFE143:
 2434 0e6e 00BF     		.align	2
 2435              		.global	RCC_APB1PeriphResetCmd
 2436              		.thumb
 2437              		.thumb_func
 2439              	RCC_APB1PeriphResetCmd:
 2440              	.LFB144:
1529:../src/stm32f30x_rcc.c **** 
1530:../src/stm32f30x_rcc.c **** /**
1531:../src/stm32f30x_rcc.c ****   * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
1532:../src/stm32f30x_rcc.c ****   * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
1533:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1534:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM2
1535:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM3
1536:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM4
1537:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM6
1538:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_TIM7
1539:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_WWDG
1540:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_SPI2
1541:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_SPI3  
1542:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_USART2
1543:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_USART3
1544:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_UART4
1545:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_UART5      
1546:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_I2C1
1547:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_I2C2
1548:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_USB
1549:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_CAN1
1550:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_PWR
1551:../src/stm32f30x_rcc.c ****   *     @arg RCC_APB1Periph_DAC
1552:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the specified peripheral clock.
1553:../src/stm32f30x_rcc.c ****   *         This parameter can be: ENABLE or DISABLE.
1554:../src/stm32f30x_rcc.c ****   * @retval None
1555:../src/stm32f30x_rcc.c ****   */
1556:../src/stm32f30x_rcc.c **** void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
1557:../src/stm32f30x_rcc.c **** {
 2441              		.loc 1 1557 0
 2442              		.cfi_startproc
 2443              		@ args = 0, pretend = 0, frame = 8
 2444              		@ frame_needed = 1, uses_anonymous_args = 0
 2445              		@ link register save eliminated.
 2446 0e70 80B4     		push	{r7}
 2447              	.LCFI97:
 2448              		.cfi_def_cfa_offset 4
 2449              		.cfi_offset 7, -4
 2450 0e72 83B0     		sub	sp, sp, #12
 2451              	.LCFI98:
 2452              		.cfi_def_cfa_offset 16
 2453 0e74 00AF     		add	r7, sp, #0
 2454              	.LCFI99:
 2455              		.cfi_def_cfa_register 7
 2456 0e76 7860     		str	r0, [r7, #4]
 2457 0e78 0B46     		mov	r3, r1
 2458 0e7a FB70     		strb	r3, [r7, #3]
1558:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1559:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
1560:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1561:../src/stm32f30x_rcc.c **** 
1562:../src/stm32f30x_rcc.c ****   if (NewState != DISABLE)
 2459              		.loc 1 1562 0
 2460 0e7c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2461 0e7e 002B     		cmp	r3, #0
 2462 0e80 0CD0     		beq	.L106
1563:../src/stm32f30x_rcc.c ****   {
1564:../src/stm32f30x_rcc.c ****     RCC->APB1RSTR |= RCC_APB1Periph;
 2463              		.loc 1 1564 0
 2464 0e82 4FF48053 		mov	r3, #4096
 2465 0e86 C4F20203 		movt	r3, 16386
 2466 0e8a 4FF48052 		mov	r2, #4096
 2467 0e8e C4F20202 		movt	r2, 16386
 2468 0e92 1169     		ldr	r1, [r2, #16]
 2469 0e94 7A68     		ldr	r2, [r7, #4]
 2470 0e96 0A43     		orrs	r2, r2, r1
 2471 0e98 1A61     		str	r2, [r3, #16]
 2472 0e9a 0DE0     		b	.L105
 2473              	.L106:
1565:../src/stm32f30x_rcc.c ****   }
1566:../src/stm32f30x_rcc.c ****   else
1567:../src/stm32f30x_rcc.c ****   {
1568:../src/stm32f30x_rcc.c ****     RCC->APB1RSTR &= ~RCC_APB1Periph;
 2474              		.loc 1 1568 0
 2475 0e9c 4FF48053 		mov	r3, #4096
 2476 0ea0 C4F20203 		movt	r3, 16386
 2477 0ea4 4FF48052 		mov	r2, #4096
 2478 0ea8 C4F20202 		movt	r2, 16386
 2479 0eac 1169     		ldr	r1, [r2, #16]
 2480 0eae 7A68     		ldr	r2, [r7, #4]
 2481 0eb0 6FEA0202 		mvn	r2, r2
 2482 0eb4 0A40     		ands	r2, r2, r1
 2483 0eb6 1A61     		str	r2, [r3, #16]
 2484              	.L105:
1569:../src/stm32f30x_rcc.c ****   }
1570:../src/stm32f30x_rcc.c **** }
 2485              		.loc 1 1570 0
 2486 0eb8 07F10C07 		add	r7, r7, #12
 2487 0ebc BD46     		mov	sp, r7
 2488 0ebe 80BC     		pop	{r7}
 2489 0ec0 7047     		bx	lr
 2490              		.cfi_endproc
 2491              	.LFE144:
 2493 0ec2 00BF     		.align	2
 2494              		.global	RCC_ITConfig
 2495              		.thumb
 2496              		.thumb_func
 2498              	RCC_ITConfig:
 2499              	.LFB145:
1571:../src/stm32f30x_rcc.c **** 
1572:../src/stm32f30x_rcc.c **** /**
1573:../src/stm32f30x_rcc.c ****   * @}
1574:../src/stm32f30x_rcc.c ****   */
1575:../src/stm32f30x_rcc.c **** 
1576:../src/stm32f30x_rcc.c **** /** @defgroup RCC_Group4 Interrupts and flags management functions
1577:../src/stm32f30x_rcc.c ****  *  @brief   Interrupts and flags management functions 
1578:../src/stm32f30x_rcc.c ****  *
1579:../src/stm32f30x_rcc.c **** @verbatim   
1580:../src/stm32f30x_rcc.c ****  ===============================================================================
1581:../src/stm32f30x_rcc.c ****             ##### Interrupts and flags management functions #####
1582:../src/stm32f30x_rcc.c ****  ===============================================================================  
1583:../src/stm32f30x_rcc.c **** 
1584:../src/stm32f30x_rcc.c **** @endverbatim
1585:../src/stm32f30x_rcc.c ****   * @{
1586:../src/stm32f30x_rcc.c ****   */
1587:../src/stm32f30x_rcc.c **** 
1588:../src/stm32f30x_rcc.c **** /**
1589:../src/stm32f30x_rcc.c ****   * @brief  Enables or disables the specified RCC interrupts.
1590:../src/stm32f30x_rcc.c ****   * @note   The CSS interrupt doesn't have an enable bit; once the CSS is enabled
1591:../src/stm32f30x_rcc.c ****   *         and if the HSE clock fails, the CSS interrupt occurs and an NMI is
1592:../src/stm32f30x_rcc.c ****   *         automatically generated. The NMI will be executed indefinitely, and 
1593:../src/stm32f30x_rcc.c ****   *         since NMI has higher priority than any other IRQ (and main program)
1594:../src/stm32f30x_rcc.c ****   *         the application will be stacked in the NMI ISR unless the CSS interrupt
1595:../src/stm32f30x_rcc.c ****   *         pending bit is cleared.
1596:../src/stm32f30x_rcc.c ****   * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
1597:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1598:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_LSIRDY: LSI ready interrupt
1599:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_LSERDY: LSE ready interrupt
1600:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_HSIRDY: HSI ready interrupt
1601:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_HSERDY: HSE ready interrupt
1602:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_PLLRDY: PLL ready interrupt
1603:../src/stm32f30x_rcc.c ****   * @param  NewState: new state of the specified RCC interrupts.
1604:../src/stm32f30x_rcc.c ****   *   This parameter can be: ENABLE or DISABLE.
1605:../src/stm32f30x_rcc.c ****   * @retval None
1606:../src/stm32f30x_rcc.c ****   */
1607:../src/stm32f30x_rcc.c **** void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
1608:../src/stm32f30x_rcc.c **** {
 2500              		.loc 1 1608 0
 2501              		.cfi_startproc
 2502              		@ args = 0, pretend = 0, frame = 8
 2503              		@ frame_needed = 1, uses_anonymous_args = 0
 2504              		@ link register save eliminated.
 2505 0ec4 80B4     		push	{r7}
 2506              	.LCFI100:
 2507              		.cfi_def_cfa_offset 4
 2508              		.cfi_offset 7, -4
 2509 0ec6 83B0     		sub	sp, sp, #12
 2510              	.LCFI101:
 2511              		.cfi_def_cfa_offset 16
 2512 0ec8 00AF     		add	r7, sp, #0
 2513              	.LCFI102:
 2514              		.cfi_def_cfa_register 7
 2515 0eca 0246     		mov	r2, r0
 2516 0ecc 0B46     		mov	r3, r1
 2517 0ece FA71     		strb	r2, [r7, #7]
 2518 0ed0 BB71     		strb	r3, [r7, #6]
1609:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1610:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_IT(RCC_IT));
1611:../src/stm32f30x_rcc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1612:../src/stm32f30x_rcc.c ****   
1613:../src/stm32f30x_rcc.c ****   if (NewState != DISABLE)
 2519              		.loc 1 1613 0
 2520 0ed2 BB79     		ldrb	r3, [r7, #6]	@ zero_extendqisi2
 2521 0ed4 002B     		cmp	r3, #0
 2522 0ed6 0ED0     		beq	.L109
1614:../src/stm32f30x_rcc.c ****   {
1615:../src/stm32f30x_rcc.c ****     /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
1616:../src/stm32f30x_rcc.c ****     *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 2523              		.loc 1 1616 0
 2524 0ed8 41F20903 		movw	r3, #4105
 2525 0edc C4F20203 		movt	r3, 16386
 2526 0ee0 41F20902 		movw	r2, #4105
 2527 0ee4 C4F20202 		movt	r2, 16386
 2528 0ee8 1278     		ldrb	r2, [r2, #0]
 2529 0eea D1B2     		uxtb	r1, r2
 2530 0eec FA79     		ldrb	r2, [r7, #7]
 2531 0eee 0A43     		orrs	r2, r2, r1
 2532 0ef0 D2B2     		uxtb	r2, r2
 2533 0ef2 1A70     		strb	r2, [r3, #0]
 2534 0ef4 10E0     		b	.L108
 2535              	.L109:
1617:../src/stm32f30x_rcc.c ****   }
1618:../src/stm32f30x_rcc.c ****   else
1619:../src/stm32f30x_rcc.c ****   {
1620:../src/stm32f30x_rcc.c ****     /* Perform Byte access to RCC_CIR[13:8] bits to disable the selected interrupts */
1621:../src/stm32f30x_rcc.c ****     *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 2536              		.loc 1 1621 0
 2537 0ef6 41F20903 		movw	r3, #4105
 2538 0efa C4F20203 		movt	r3, 16386
 2539 0efe 41F20902 		movw	r2, #4105
 2540 0f02 C4F20202 		movt	r2, 16386
 2541 0f06 1278     		ldrb	r2, [r2, #0]
 2542 0f08 D1B2     		uxtb	r1, r2
 2543 0f0a FA79     		ldrb	r2, [r7, #7]
 2544 0f0c 6FEA0202 		mvn	r2, r2
 2545 0f10 D2B2     		uxtb	r2, r2
 2546 0f12 0A40     		ands	r2, r2, r1
 2547 0f14 D2B2     		uxtb	r2, r2
 2548 0f16 1A70     		strb	r2, [r3, #0]
 2549              	.L108:
1622:../src/stm32f30x_rcc.c ****   }
1623:../src/stm32f30x_rcc.c **** }
 2550              		.loc 1 1623 0
 2551 0f18 07F10C07 		add	r7, r7, #12
 2552 0f1c BD46     		mov	sp, r7
 2553 0f1e 80BC     		pop	{r7}
 2554 0f20 7047     		bx	lr
 2555              		.cfi_endproc
 2556              	.LFE145:
 2558 0f22 00BF     		.align	2
 2559              		.global	RCC_GetFlagStatus
 2560              		.thumb
 2561              		.thumb_func
 2563              	RCC_GetFlagStatus:
 2564              	.LFB146:
1624:../src/stm32f30x_rcc.c **** 
1625:../src/stm32f30x_rcc.c **** /**
1626:../src/stm32f30x_rcc.c ****   * @brief  Checks whether the specified RCC flag is set or not.
1627:../src/stm32f30x_rcc.c ****   * @param  RCC_FLAG: specifies the flag to check.
1628:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1629:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready  
1630:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
1631:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_PLLRDY: PLL clock ready
1632:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_MCOF: MCO Flag  
1633:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
1634:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
1635:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_OBLRST: Option Byte Loader (OBL) reset 
1636:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_PINRST: Pin reset
1637:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_PORRST: POR/PDR reset
1638:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_SFTRST: Software reset
1639:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
1640:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
1641:../src/stm32f30x_rcc.c ****   *     @arg RCC_FLAG_LPWRRST: Low Power reset
1642:../src/stm32f30x_rcc.c ****   * @retval The new state of RCC_FLAG (SET or RESET).
1643:../src/stm32f30x_rcc.c ****   */
1644:../src/stm32f30x_rcc.c **** FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
1645:../src/stm32f30x_rcc.c **** {
 2565              		.loc 1 1645 0
 2566              		.cfi_startproc
 2567              		@ args = 0, pretend = 0, frame = 24
 2568              		@ frame_needed = 1, uses_anonymous_args = 0
 2569              		@ link register save eliminated.
 2570 0f24 80B4     		push	{r7}
 2571              	.LCFI103:
 2572              		.cfi_def_cfa_offset 4
 2573              		.cfi_offset 7, -4
 2574 0f26 87B0     		sub	sp, sp, #28
 2575              	.LCFI104:
 2576              		.cfi_def_cfa_offset 32
 2577 0f28 00AF     		add	r7, sp, #0
 2578              	.LCFI105:
 2579              		.cfi_def_cfa_register 7
 2580 0f2a 0346     		mov	r3, r0
 2581 0f2c FB71     		strb	r3, [r7, #7]
1646:../src/stm32f30x_rcc.c ****   uint32_t tmp = 0;
 2582              		.loc 1 1646 0
 2583 0f2e 4FF00003 		mov	r3, #0
 2584 0f32 FB60     		str	r3, [r7, #12]
1647:../src/stm32f30x_rcc.c ****   uint32_t statusreg = 0;
 2585              		.loc 1 1647 0
 2586 0f34 4FF00003 		mov	r3, #0
 2587 0f38 7B61     		str	r3, [r7, #20]
1648:../src/stm32f30x_rcc.c ****   FlagStatus bitstatus = RESET;
 2588              		.loc 1 1648 0
 2589 0f3a 4FF00003 		mov	r3, #0
 2590 0f3e FB74     		strb	r3, [r7, #19]
1649:../src/stm32f30x_rcc.c **** 
1650:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1651:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_FLAG(RCC_FLAG));
1652:../src/stm32f30x_rcc.c **** 
1653:../src/stm32f30x_rcc.c ****   /* Get the RCC register index */
1654:../src/stm32f30x_rcc.c ****   tmp = RCC_FLAG >> 5;
 2591              		.loc 1 1654 0
 2592 0f40 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2593 0f42 4FEA5313 		lsr	r3, r3, #5
 2594 0f46 DBB2     		uxtb	r3, r3
 2595 0f48 FB60     		str	r3, [r7, #12]
1655:../src/stm32f30x_rcc.c **** 
1656:../src/stm32f30x_rcc.c ****    if (tmp == 0)               /* The flag to check is in CR register */
 2596              		.loc 1 1656 0
 2597 0f4a FB68     		ldr	r3, [r7, #12]
 2598 0f4c 002B     		cmp	r3, #0
 2599 0f4e 06D1     		bne	.L112
1657:../src/stm32f30x_rcc.c ****   {
1658:../src/stm32f30x_rcc.c ****     statusreg = RCC->CR;
 2600              		.loc 1 1658 0
 2601 0f50 4FF48053 		mov	r3, #4096
 2602 0f54 C4F20203 		movt	r3, 16386
 2603 0f58 1B68     		ldr	r3, [r3, #0]
 2604 0f5a 7B61     		str	r3, [r7, #20]
 2605 0f5c 19E0     		b	.L113
 2606              	.L112:
1659:../src/stm32f30x_rcc.c ****   }
1660:../src/stm32f30x_rcc.c ****   else if (tmp == 1)          /* The flag to check is in BDCR register */
 2607              		.loc 1 1660 0
 2608 0f5e FB68     		ldr	r3, [r7, #12]
 2609 0f60 012B     		cmp	r3, #1
 2610 0f62 06D1     		bne	.L114
1661:../src/stm32f30x_rcc.c ****   {
1662:../src/stm32f30x_rcc.c ****     statusreg = RCC->BDCR;
 2611              		.loc 1 1662 0
 2612 0f64 4FF48053 		mov	r3, #4096
 2613 0f68 C4F20203 		movt	r3, 16386
 2614 0f6c 1B6A     		ldr	r3, [r3, #32]
 2615 0f6e 7B61     		str	r3, [r7, #20]
 2616 0f70 0FE0     		b	.L113
 2617              	.L114:
1663:../src/stm32f30x_rcc.c ****   }
1664:../src/stm32f30x_rcc.c ****   else if (tmp == 4)          /* The flag to check is in CFGR register */
 2618              		.loc 1 1664 0
 2619 0f72 FB68     		ldr	r3, [r7, #12]
 2620 0f74 042B     		cmp	r3, #4
 2621 0f76 06D1     		bne	.L115
1665:../src/stm32f30x_rcc.c ****   {
1666:../src/stm32f30x_rcc.c ****     statusreg = RCC->CFGR;
 2622              		.loc 1 1666 0
 2623 0f78 4FF48053 		mov	r3, #4096
 2624 0f7c C4F20203 		movt	r3, 16386
 2625 0f80 5B68     		ldr	r3, [r3, #4]
 2626 0f82 7B61     		str	r3, [r7, #20]
 2627 0f84 05E0     		b	.L113
 2628              	.L115:
1667:../src/stm32f30x_rcc.c ****   }
1668:../src/stm32f30x_rcc.c ****   else                       /* The flag to check is in CSR register */
1669:../src/stm32f30x_rcc.c ****   {
1670:../src/stm32f30x_rcc.c ****     statusreg = RCC->CSR;
 2629              		.loc 1 1670 0
 2630 0f86 4FF48053 		mov	r3, #4096
 2631 0f8a C4F20203 		movt	r3, 16386
 2632 0f8e 5B6A     		ldr	r3, [r3, #36]
 2633 0f90 7B61     		str	r3, [r7, #20]
 2634              	.L113:
1671:../src/stm32f30x_rcc.c ****   }
1672:../src/stm32f30x_rcc.c **** 
1673:../src/stm32f30x_rcc.c ****   /* Get the flag position */
1674:../src/stm32f30x_rcc.c ****   tmp = RCC_FLAG & FLAG_MASK;
 2635              		.loc 1 1674 0
 2636 0f92 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2637 0f94 03F01F03 		and	r3, r3, #31
 2638 0f98 FB60     		str	r3, [r7, #12]
1675:../src/stm32f30x_rcc.c **** 
1676:../src/stm32f30x_rcc.c ****   if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 2639              		.loc 1 1676 0
 2640 0f9a FB68     		ldr	r3, [r7, #12]
 2641 0f9c 7A69     		ldr	r2, [r7, #20]
 2642 0f9e 22FA03F3 		lsr	r3, r2, r3
 2643 0fa2 03F00103 		and	r3, r3, #1
 2644 0fa6 002B     		cmp	r3, #0
 2645 0fa8 03D0     		beq	.L116
1677:../src/stm32f30x_rcc.c ****   {
1678:../src/stm32f30x_rcc.c ****     bitstatus = SET;
 2646              		.loc 1 1678 0
 2647 0faa 4FF00103 		mov	r3, #1
 2648 0fae FB74     		strb	r3, [r7, #19]
 2649 0fb0 02E0     		b	.L117
 2650              	.L116:
1679:../src/stm32f30x_rcc.c ****   }
1680:../src/stm32f30x_rcc.c ****   else
1681:../src/stm32f30x_rcc.c ****   {
1682:../src/stm32f30x_rcc.c ****     bitstatus = RESET;
 2651              		.loc 1 1682 0
 2652 0fb2 4FF00003 		mov	r3, #0
 2653 0fb6 FB74     		strb	r3, [r7, #19]
 2654              	.L117:
1683:../src/stm32f30x_rcc.c ****   }
1684:../src/stm32f30x_rcc.c ****   /* Return the flag status */
1685:../src/stm32f30x_rcc.c ****   return bitstatus;
 2655              		.loc 1 1685 0
 2656 0fb8 FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
1686:../src/stm32f30x_rcc.c **** }
 2657              		.loc 1 1686 0
 2658 0fba 1846     		mov	r0, r3
 2659 0fbc 07F11C07 		add	r7, r7, #28
 2660 0fc0 BD46     		mov	sp, r7
 2661 0fc2 80BC     		pop	{r7}
 2662 0fc4 7047     		bx	lr
 2663              		.cfi_endproc
 2664              	.LFE146:
 2666 0fc6 00BF     		.align	2
 2667              		.global	RCC_ClearFlag
 2668              		.thumb
 2669              		.thumb_func
 2671              	RCC_ClearFlag:
 2672              	.LFB147:
1687:../src/stm32f30x_rcc.c **** 
1688:../src/stm32f30x_rcc.c **** /**
1689:../src/stm32f30x_rcc.c ****   * @brief  Clears the RCC reset flags.
1690:../src/stm32f30x_rcc.c ****   *         The reset flags are: RCC_FLAG_OBLRST, RCC_FLAG_PINRST, RCC_FLAG_PORRST, 
1691:../src/stm32f30x_rcc.c ****   *         RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST.
1692:../src/stm32f30x_rcc.c ****   * @param  None
1693:../src/stm32f30x_rcc.c ****   * @retval None
1694:../src/stm32f30x_rcc.c ****   */
1695:../src/stm32f30x_rcc.c **** void RCC_ClearFlag(void)
1696:../src/stm32f30x_rcc.c **** {
 2673              		.loc 1 1696 0
 2674              		.cfi_startproc
 2675              		@ args = 0, pretend = 0, frame = 0
 2676              		@ frame_needed = 1, uses_anonymous_args = 0
 2677              		@ link register save eliminated.
 2678 0fc8 80B4     		push	{r7}
 2679              	.LCFI106:
 2680              		.cfi_def_cfa_offset 4
 2681              		.cfi_offset 7, -4
 2682 0fca 00AF     		add	r7, sp, #0
 2683              	.LCFI107:
 2684              		.cfi_def_cfa_register 7
1697:../src/stm32f30x_rcc.c ****   /* Set RMVF bit to clear the reset flags */
1698:../src/stm32f30x_rcc.c ****   RCC->CSR |= RCC_CSR_RMVF;
 2685              		.loc 1 1698 0
 2686 0fcc 4FF48053 		mov	r3, #4096
 2687 0fd0 C4F20203 		movt	r3, 16386
 2688 0fd4 4FF48052 		mov	r2, #4096
 2689 0fd8 C4F20202 		movt	r2, 16386
 2690 0fdc 526A     		ldr	r2, [r2, #36]
 2691 0fde 42F08072 		orr	r2, r2, #16777216
 2692 0fe2 5A62     		str	r2, [r3, #36]
1699:../src/stm32f30x_rcc.c **** }
 2693              		.loc 1 1699 0
 2694 0fe4 BD46     		mov	sp, r7
 2695 0fe6 80BC     		pop	{r7}
 2696 0fe8 7047     		bx	lr
 2697              		.cfi_endproc
 2698              	.LFE147:
 2700 0fea 00BF     		.align	2
 2701              		.global	RCC_GetITStatus
 2702              		.thumb
 2703              		.thumb_func
 2705              	RCC_GetITStatus:
 2706              	.LFB148:
1700:../src/stm32f30x_rcc.c **** 
1701:../src/stm32f30x_rcc.c **** /**
1702:../src/stm32f30x_rcc.c ****   * @brief  Checks whether the specified RCC interrupt has occurred or not.
1703:../src/stm32f30x_rcc.c ****   * @param  RCC_IT: specifies the RCC interrupt source to check.
1704:../src/stm32f30x_rcc.c ****   *   This parameter can be one of the following values:
1705:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_LSIRDY: LSI ready interrupt
1706:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_LSERDY: LSE ready interrupt
1707:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_HSIRDY: HSI ready interrupt
1708:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_HSERDY: HSE ready interrupt
1709:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_PLLRDY: PLL ready interrupt
1710:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_CSS: Clock Security System interrupt
1711:../src/stm32f30x_rcc.c ****   * @retval The new state of RCC_IT (SET or RESET).
1712:../src/stm32f30x_rcc.c ****   */
1713:../src/stm32f30x_rcc.c **** ITStatus RCC_GetITStatus(uint8_t RCC_IT)
1714:../src/stm32f30x_rcc.c **** {
 2707              		.loc 1 1714 0
 2708              		.cfi_startproc
 2709              		@ args = 0, pretend = 0, frame = 16
 2710              		@ frame_needed = 1, uses_anonymous_args = 0
 2711              		@ link register save eliminated.
 2712 0fec 80B4     		push	{r7}
 2713              	.LCFI108:
 2714              		.cfi_def_cfa_offset 4
 2715              		.cfi_offset 7, -4
 2716 0fee 85B0     		sub	sp, sp, #20
 2717              	.LCFI109:
 2718              		.cfi_def_cfa_offset 24
 2719 0ff0 00AF     		add	r7, sp, #0
 2720              	.LCFI110:
 2721              		.cfi_def_cfa_register 7
 2722 0ff2 0346     		mov	r3, r0
 2723 0ff4 FB71     		strb	r3, [r7, #7]
1715:../src/stm32f30x_rcc.c ****   ITStatus bitstatus = RESET;
 2724              		.loc 1 1715 0
 2725 0ff6 4FF00003 		mov	r3, #0
 2726 0ffa FB73     		strb	r3, [r7, #15]
1716:../src/stm32f30x_rcc.c ****   
1717:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1718:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_GET_IT(RCC_IT));
1719:../src/stm32f30x_rcc.c ****   
1720:../src/stm32f30x_rcc.c ****   /* Check the status of the specified RCC interrupt */
1721:../src/stm32f30x_rcc.c ****   if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 2727              		.loc 1 1721 0
 2728 0ffc 4FF48053 		mov	r3, #4096
 2729 1000 C4F20203 		movt	r3, 16386
 2730 1004 9A68     		ldr	r2, [r3, #8]
 2731 1006 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2732 1008 1340     		ands	r3, r3, r2
 2733 100a 002B     		cmp	r3, #0
 2734 100c 03D0     		beq	.L121
1722:../src/stm32f30x_rcc.c ****   {
1723:../src/stm32f30x_rcc.c ****     bitstatus = SET;
 2735              		.loc 1 1723 0
 2736 100e 4FF00103 		mov	r3, #1
 2737 1012 FB73     		strb	r3, [r7, #15]
 2738 1014 02E0     		b	.L122
 2739              	.L121:
1724:../src/stm32f30x_rcc.c ****   }
1725:../src/stm32f30x_rcc.c ****   else
1726:../src/stm32f30x_rcc.c ****   {
1727:../src/stm32f30x_rcc.c ****     bitstatus = RESET;
 2740              		.loc 1 1727 0
 2741 1016 4FF00003 		mov	r3, #0
 2742 101a FB73     		strb	r3, [r7, #15]
 2743              	.L122:
1728:../src/stm32f30x_rcc.c ****   }
1729:../src/stm32f30x_rcc.c ****   /* Return the RCC_IT status */
1730:../src/stm32f30x_rcc.c ****   return  bitstatus;
 2744              		.loc 1 1730 0
 2745 101c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1731:../src/stm32f30x_rcc.c **** }
 2746              		.loc 1 1731 0
 2747 101e 1846     		mov	r0, r3
 2748 1020 07F11407 		add	r7, r7, #20
 2749 1024 BD46     		mov	sp, r7
 2750 1026 80BC     		pop	{r7}
 2751 1028 7047     		bx	lr
 2752              		.cfi_endproc
 2753              	.LFE148:
 2755 102a 00BF     		.align	2
 2756              		.global	RCC_ClearITPendingBit
 2757              		.thumb
 2758              		.thumb_func
 2760              	RCC_ClearITPendingBit:
 2761              	.LFB149:
1732:../src/stm32f30x_rcc.c **** 
1733:../src/stm32f30x_rcc.c **** /**
1734:../src/stm32f30x_rcc.c ****   * @brief  Clears the RCC's interrupt pending bits.
1735:../src/stm32f30x_rcc.c ****   * @param  RCC_IT: specifies the interrupt pending bit to clear.
1736:../src/stm32f30x_rcc.c ****   *   This parameter can be any combination of the following values:
1737:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_LSIRDY: LSI ready interrupt
1738:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_LSERDY: LSE ready interrupt
1739:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_HSIRDY: HSI ready interrupt
1740:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_HSERDY: HSE ready interrupt
1741:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_PLLRDY: PLL ready interrupt
1742:../src/stm32f30x_rcc.c ****   *     @arg RCC_IT_CSS: Clock Security System interrupt
1743:../src/stm32f30x_rcc.c ****   * @retval None
1744:../src/stm32f30x_rcc.c ****   */
1745:../src/stm32f30x_rcc.c **** void RCC_ClearITPendingBit(uint8_t RCC_IT)
1746:../src/stm32f30x_rcc.c **** {
 2762              		.loc 1 1746 0
 2763              		.cfi_startproc
 2764              		@ args = 0, pretend = 0, frame = 8
 2765              		@ frame_needed = 1, uses_anonymous_args = 0
 2766              		@ link register save eliminated.
 2767 102c 80B4     		push	{r7}
 2768              	.LCFI111:
 2769              		.cfi_def_cfa_offset 4
 2770              		.cfi_offset 7, -4
 2771 102e 83B0     		sub	sp, sp, #12
 2772              	.LCFI112:
 2773              		.cfi_def_cfa_offset 16
 2774 1030 00AF     		add	r7, sp, #0
 2775              	.LCFI113:
 2776              		.cfi_def_cfa_register 7
 2777 1032 0346     		mov	r3, r0
 2778 1034 FB71     		strb	r3, [r7, #7]
1747:../src/stm32f30x_rcc.c ****   /* Check the parameters */
1748:../src/stm32f30x_rcc.c ****   assert_param(IS_RCC_CLEAR_IT(RCC_IT));
1749:../src/stm32f30x_rcc.c ****   
1750:../src/stm32f30x_rcc.c ****   /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
1751:../src/stm32f30x_rcc.c ****      pending bits */
1752:../src/stm32f30x_rcc.c ****   *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 2779              		.loc 1 1752 0
 2780 1036 41F20A03 		movw	r3, #4106
 2781 103a C4F20203 		movt	r3, 16386
 2782 103e FA79     		ldrb	r2, [r7, #7]
 2783 1040 1A70     		strb	r2, [r3, #0]
1753:../src/stm32f30x_rcc.c **** }
 2784              		.loc 1 1753 0
 2785 1042 07F10C07 		add	r7, r7, #12
 2786 1046 BD46     		mov	sp, r7
 2787 1048 80BC     		pop	{r7}
 2788 104a 7047     		bx	lr
 2789              		.cfi_endproc
 2790              	.LFE149:
 2792              	.Letext0:
 2793              		.file 2 "/home/aghosh01/gcc-arm-none-eabi-4_7-2012q4/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../.
 2794              		.file 3 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x.h"
 2795              		.file 4 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x_rcc.h"
 2796              		.file 5 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f30x_rcc.c
     /tmp/cc6obxTX.s:21     .data:00000000 $d
     /tmp/cc6obxTX.s:24     .data:00000000 APBAHBPrescTable
     /tmp/cc6obxTX.s:44     .data:00000010 ADCPrescTable
     /tmp/cc6obxTX.s:59     .text:00000000 $t
     /tmp/cc6obxTX.s:64     .text:00000000 RCC_DeInit
     /tmp/cc6obxTX.s:158    .text:000000d4 RCC_HSEConfig
     /tmp/cc6obxTX.s:200    .text:00000104 RCC_WaitForHSEStartUp
     /tmp/cc6obxTX.s:2563   .text:00000f24 RCC_GetFlagStatus
     /tmp/cc6obxTX.s:274    .text:00000168 RCC_AdjustHSICalibrationValue
     /tmp/cc6obxTX.s:329    .text:000001b0 RCC_HSICmd
     /tmp/cc6obxTX.s:366    .text:000001d0 RCC_LSEConfig
     /tmp/cc6obxTX.s:422    .text:0000022c RCC_LSEDriveConfig
     /tmp/cc6obxTX.s:470    .text:00000270 RCC_LSICmd
     /tmp/cc6obxTX.s:507    .text:00000290 RCC_PLLConfig
     /tmp/cc6obxTX.s:558    .text:000002d8 RCC_PLLCmd
     /tmp/cc6obxTX.s:595    .text:000002f8 RCC_PREDIV1Config
     /tmp/cc6obxTX.s:648    .text:00000338 RCC_ClockSecuritySystemCmd
     /tmp/cc6obxTX.s:685    .text:00000358 RCC_MCOConfig
     /tmp/cc6obxTX.s:722    .text:00000378 RCC_SYSCLKConfig
     /tmp/cc6obxTX.s:775    .text:000003b8 RCC_GetSYSCLKSource
     /tmp/cc6obxTX.s:809    .text:000003d8 RCC_HCLKConfig
     /tmp/cc6obxTX.s:862    .text:00000418 RCC_PCLK1Config
     /tmp/cc6obxTX.s:915    .text:00000458 RCC_PCLK2Config
     /tmp/cc6obxTX.s:969    .text:0000049c RCC_GetClocksFreq
     /tmp/cc6obxTX.s:1628   .text:000009ec RCC_ADCCLKConfig
     /tmp/cc6obxTX.s:1698   .text:00000a5c RCC_I2CCLKConfig
     /tmp/cc6obxTX.s:1768   .text:00000acc RCC_TIMCLKConfig
     /tmp/cc6obxTX.s:1838   .text:00000b3c RCC_USARTCLKConfig
     /tmp/cc6obxTX.s:1872   .text:00000b64 $d
     /tmp/cc6obxTX.s:1879   .text:00000b78 $t
     /tmp/cc6obxTX.s:1958   .text:00000c20 RCC_USBCLKConfig
     /tmp/cc6obxTX.s:1994   .text:00000c40 RCC_RTCCLKConfig
     /tmp/cc6obxTX.s:2034   .text:00000c6c RCC_I2SCLKConfig
     /tmp/cc6obxTX.s:2070   .text:00000c8c RCC_RTCCLKCmd
     /tmp/cc6obxTX.s:2107   .text:00000cac RCC_BackupResetCmd
     /tmp/cc6obxTX.s:2144   .text:00000ccc RCC_AHBPeriphClockCmd
     /tmp/cc6obxTX.s:2203   .text:00000d20 RCC_APB2PeriphClockCmd
     /tmp/cc6obxTX.s:2262   .text:00000d74 RCC_APB1PeriphClockCmd
     /tmp/cc6obxTX.s:2321   .text:00000dc8 RCC_AHBPeriphResetCmd
     /tmp/cc6obxTX.s:2380   .text:00000e1c RCC_APB2PeriphResetCmd
     /tmp/cc6obxTX.s:2439   .text:00000e70 RCC_APB1PeriphResetCmd
     /tmp/cc6obxTX.s:2498   .text:00000ec4 RCC_ITConfig
     /tmp/cc6obxTX.s:2671   .text:00000fc8 RCC_ClearFlag
     /tmp/cc6obxTX.s:2705   .text:00000fec RCC_GetITStatus
     /tmp/cc6obxTX.s:2760   .text:0000102c RCC_ClearITPendingBit
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.743cd71370ebc432b539c5dba7924ecc
                           .group:00000000 wm4.stm32f30x.h.56.6f19c65e98e3319a61449cb2b2455af5
                           .group:00000000 wm4.core_cm4.h.32.1434cd257ff5806b1b03cd32ab0641e9
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.core_cmInstr.h.25.d8165482ef3061013a2fc83e2d85f3d9
                           .group:00000000 wm4.core_cm4_simd.h.29.013e5bcf58dba2d27c60184174208e07
                           .group:00000000 wm4.core_cm4.h.155.cf7c793e178943e1bbf613f1b21cd51a
                           .group:00000000 wm4.stm32f30x.h.294.d8a54360eca16e4157694b52a095202d
                           .group:00000000 wm4.stm32f30x_adc.h.130.cbebad91f78fb87381fe0860eea6104e
                           .group:00000000 wm4.stm32f30x_can.h.50.8b8f5d301152c422a6e50622b33ef620
                           .group:00000000 wm4.stm32f30x_crc.h.54.66d4c5e565e18566aebd9abfd4bcd4b0
                           .group:00000000 wm4.stm32f30x_comp.h.91.06ae44150aaaa82c077b71df8db3541a
                           .group:00000000 wm4.stm32f30x_dac.h.49.b1b5b26e4ca241dbe67fa16dc86a615f
                           .group:00000000 wm4.stm32f30x_dbgmcu.h.53.b238a263ce6a2cc83f610cc35302a38b
                           .group:00000000 wm4.stm32f30x_dma.h.96.d7a2ddd10023e12781aa8ff5ac15d212
                           .group:00000000 wm4.stm32f30x_exti.h.60.8ca0809491a21dec6fc69cf7471e2bab
                           .group:00000000 wm4.stm32f30x_flash.h.70.32613455dfe7328932f786a224daac23
                           .group:00000000 wm4.stm32f30x_gpio.h.50.408e1f6250246e4cc28221970909d34c
                           .group:00000000 wm4.stm32f30x_syscfg.h.58.4cadeb4ec8e47d36b972bbb6b96b7161
                           .group:00000000 wm4.stm32f30x_i2c.h.86.3d51d4edc0e3b9ee9aae045ccbb7739a
                           .group:00000000 wm4.stm32f30x_iwdg.h.59.467d704fb073a015941f19b50fa6470a
                           .group:00000000 wm4.stm32f30x_opamp.h.75.704e2e5e2aab039de307aaa2dcc99fa5
                           .group:00000000 wm4.stm32f30x_pwr.h.59.5c85acff2a3e3c5085b2140c06025cfc
                           .group:00000000 wm4.stm32f30x_rtc.h.133.d184e08ff40bda44db4bed94f9633384
                           .group:00000000 wm4.stm32f30x_spi.h.119.4d21ec94ec14f3553a127e61c0a9874f
                           .group:00000000 wm4.stm32f30x_tim.h.175.d4a93cff2e7924577147254e501271b6
                           .group:00000000 wm4.stm32f30x_usart.h.110.c89016273702821ff4f9fe43881f70b5
                           .group:00000000 wm4.stm32f30x_wwdg.h.58.4688eee61a2709866472b4b4c07d9275
                           .group:00000000 wm4.stm32f30x_misc.h.113.6a52e4fe7c3825a3ab05990f30dddf92
                           .group:00000000 wm4.stm32f30x_rcc.h.79.5ba7cac1e74879861a72556c25322aa4

NO UNDEFINED SYMBOLS
