   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"stm32f30x_i2c.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.align	2
  20              		.global	I2C_DeInit
  21              		.thumb
  22              		.thumb_func
  24              	I2C_DeInit:
  25              	.LFB111:
  26              		.file 1 "../src/stm32f30x_i2c.c"
   1:../src/stm32f30x_i2c.c **** /**
   2:../src/stm32f30x_i2c.c ****   ******************************************************************************
   3:../src/stm32f30x_i2c.c ****   * @file    stm32f30x_i2c.c
   4:../src/stm32f30x_i2c.c ****   * @author  MCD Application Team
   5:../src/stm32f30x_i2c.c ****   * @version V1.0.1
   6:../src/stm32f30x_i2c.c ****   * @date    23-October-2012
   7:../src/stm32f30x_i2c.c ****   * @brief   This file provides firmware functions to manage the following 
   8:../src/stm32f30x_i2c.c ****   *          functionalities of the Inter-Integrated circuit (I2C):
   9:../src/stm32f30x_i2c.c ****   *           + Initialization and Configuration
  10:../src/stm32f30x_i2c.c ****   *           + Communications handling
  11:../src/stm32f30x_i2c.c ****   *           + SMBUS management
  12:../src/stm32f30x_i2c.c ****   *           + I2C registers management
  13:../src/stm32f30x_i2c.c ****   *           + Data transfers management
  14:../src/stm32f30x_i2c.c ****   *           + DMA transfers management
  15:../src/stm32f30x_i2c.c ****   *           + Interrupts and flags management
  16:../src/stm32f30x_i2c.c ****   *
  17:../src/stm32f30x_i2c.c ****   *  @verbatim
  18:../src/stm32f30x_i2c.c ****  ============================================================================
  19:../src/stm32f30x_i2c.c ****                      ##### How to use this driver #####
  20:../src/stm32f30x_i2c.c ****  ============================================================================
  21:../src/stm32f30x_i2c.c ****    [..]
  22:../src/stm32f30x_i2c.c ****    (#) Enable peripheral clock using RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2Cx, ENABLE)
  23:../src/stm32f30x_i2c.c ****        function for I2C1 or I2C2.
  24:../src/stm32f30x_i2c.c ****    (#) Enable SDA, SCL  and SMBA (when used) GPIO clocks using 
  25:../src/stm32f30x_i2c.c ****        RCC_AHBPeriphClockCmd() function. 
  26:../src/stm32f30x_i2c.c ****    (#) Peripherals alternate function: 
  27:../src/stm32f30x_i2c.c ****        (++) Connect the pin to the desired peripherals' Alternate 
  28:../src/stm32f30x_i2c.c ****             Function (AF) using GPIO_PinAFConfig() function.
  29:../src/stm32f30x_i2c.c ****        (++) Configure the desired pin in alternate function by:
  30:../src/stm32f30x_i2c.c ****             GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
  31:../src/stm32f30x_i2c.c ****        (++) Select the type, OpenDrain and speed via 
  32:../src/stm32f30x_i2c.c ****             GPIO_PuPd, GPIO_OType and GPIO_Speed members
  33:../src/stm32f30x_i2c.c ****        (++) Call GPIO_Init() function.
  34:../src/stm32f30x_i2c.c ****    (#) Program the Mode, Timing , Own address, Ack and Acknowledged Address 
  35:../src/stm32f30x_i2c.c ****        using the I2C_Init() function.
  36:../src/stm32f30x_i2c.c ****    (#) Optionally you can enable/configure the following parameters without
  37:../src/stm32f30x_i2c.c ****        re-initialization (i.e there is no need to call again I2C_Init() function):
  38:../src/stm32f30x_i2c.c ****        (++) Enable the acknowledge feature using I2C_AcknowledgeConfig() function.
  39:../src/stm32f30x_i2c.c ****        (++) Enable the dual addressing mode using I2C_DualAddressCmd() function.
  40:../src/stm32f30x_i2c.c ****        (++) Enable the general call using the I2C_GeneralCallCmd() function.
  41:../src/stm32f30x_i2c.c ****        (++) Enable the clock stretching using I2C_StretchClockCmd() function.
  42:../src/stm32f30x_i2c.c ****        (++) Enable the PEC Calculation using I2C_CalculatePEC() function.
  43:../src/stm32f30x_i2c.c ****        (++) For SMBus Mode: 
  44:../src/stm32f30x_i2c.c ****             (+++) Enable the SMBusAlert pin using I2C_SMBusAlertCmd() function.
  45:../src/stm32f30x_i2c.c ****    (#) Enable the NVIC and the corresponding interrupt using the function
  46:../src/stm32f30x_i2c.c ****        I2C_ITConfig() if you need to use interrupt mode.
  47:../src/stm32f30x_i2c.c ****    (#) When using the DMA mode 
  48:../src/stm32f30x_i2c.c ****       (++) Configure the DMA using DMA_Init() function.
  49:../src/stm32f30x_i2c.c ****       (++) Active the needed channel Request using I2C_DMACmd() function.
  50:../src/stm32f30x_i2c.c ****    (#) Enable the I2C using the I2C_Cmd() function.
  51:../src/stm32f30x_i2c.c ****    (#) Enable the DMA using the DMA_Cmd() function when using DMA mode in the 
  52:../src/stm32f30x_i2c.c ****        transfers.
  53:../src/stm32f30x_i2c.c ****    [..]        
  54:../src/stm32f30x_i2c.c ****    (@) When using I2C in Fast Mode Plus, SCL and SDA pin 20mA current drive capability
  55:../src/stm32f30x_i2c.c ****        must be enabled by setting the driving capability control bit in SYSCFG.
  56:../src/stm32f30x_i2c.c ****        
  57:../src/stm32f30x_i2c.c ****     @endverbatim
  58:../src/stm32f30x_i2c.c ****   ******************************************************************************
  59:../src/stm32f30x_i2c.c ****   * @attention
  60:../src/stm32f30x_i2c.c ****   *
  61:../src/stm32f30x_i2c.c ****   * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
  62:../src/stm32f30x_i2c.c ****   *
  63:../src/stm32f30x_i2c.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  64:../src/stm32f30x_i2c.c ****   * You may not use this file except in compliance with the License.
  65:../src/stm32f30x_i2c.c ****   * You may obtain a copy of the License at:
  66:../src/stm32f30x_i2c.c ****   *
  67:../src/stm32f30x_i2c.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  68:../src/stm32f30x_i2c.c ****   *
  69:../src/stm32f30x_i2c.c ****   * Unless required by applicable law or agreed to in writing, software 
  70:../src/stm32f30x_i2c.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  71:../src/stm32f30x_i2c.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  72:../src/stm32f30x_i2c.c ****   * See the License for the specific language governing permissions and
  73:../src/stm32f30x_i2c.c ****   * limitations under the License.
  74:../src/stm32f30x_i2c.c ****   *
  75:../src/stm32f30x_i2c.c ****   ******************************************************************************
  76:../src/stm32f30x_i2c.c ****   */
  77:../src/stm32f30x_i2c.c **** 
  78:../src/stm32f30x_i2c.c **** /* Includes ------------------------------------------------------------------*/
  79:../src/stm32f30x_i2c.c **** #include "stm32f30x_i2c.h"
  80:../src/stm32f30x_i2c.c **** #include "stm32f30x_rcc.h"
  81:../src/stm32f30x_i2c.c **** 
  82:../src/stm32f30x_i2c.c **** /** @addtogroup STM32F30x_StdPeriph_Driver
  83:../src/stm32f30x_i2c.c ****   * @{
  84:../src/stm32f30x_i2c.c ****   */
  85:../src/stm32f30x_i2c.c **** 
  86:../src/stm32f30x_i2c.c **** /** @defgroup I2C 
  87:../src/stm32f30x_i2c.c ****   * @brief I2C driver modules
  88:../src/stm32f30x_i2c.c ****   * @{
  89:../src/stm32f30x_i2c.c ****   */
  90:../src/stm32f30x_i2c.c **** 
  91:../src/stm32f30x_i2c.c **** /* Private typedef -----------------------------------------------------------*/
  92:../src/stm32f30x_i2c.c **** /* Private define ------------------------------------------------------------*/
  93:../src/stm32f30x_i2c.c **** 
  94:../src/stm32f30x_i2c.c **** #define CR1_CLEAR_MASK          ((uint32_t)0x00CFE0FF)  /*<! I2C CR1 clear register Mask */
  95:../src/stm32f30x_i2c.c **** #define CR2_CLEAR_MASK          ((uint32_t)0x07FF7FFF)  /*<! I2C CR2 clear register Mask */
  96:../src/stm32f30x_i2c.c **** #define TIMING_CLEAR_MASK       ((uint32_t)0xF0FFFFFF)  /*<! I2C TIMING clear register Mask */
  97:../src/stm32f30x_i2c.c **** #define ERROR_IT_MASK           ((uint32_t)0x00003F00)  /*<! I2C Error interrupt register Mask */
  98:../src/stm32f30x_i2c.c **** #define TC_IT_MASK              ((uint32_t)0x000000C0)  /*<! I2C TC interrupt register Mask */
  99:../src/stm32f30x_i2c.c **** 
 100:../src/stm32f30x_i2c.c **** /* Private macro -------------------------------------------------------------*/
 101:../src/stm32f30x_i2c.c **** /* Private variables ---------------------------------------------------------*/
 102:../src/stm32f30x_i2c.c **** /* Private function prototypes -----------------------------------------------*/
 103:../src/stm32f30x_i2c.c **** /* Private functions ---------------------------------------------------------*/
 104:../src/stm32f30x_i2c.c **** 
 105:../src/stm32f30x_i2c.c **** /** @defgroup I2C_Private_Functions
 106:../src/stm32f30x_i2c.c ****   * @{
 107:../src/stm32f30x_i2c.c ****   */
 108:../src/stm32f30x_i2c.c **** 
 109:../src/stm32f30x_i2c.c **** 
 110:../src/stm32f30x_i2c.c **** /** @defgroup I2C_Group1 Initialization and Configuration functions
 111:../src/stm32f30x_i2c.c ****  *  @brief   Initialization and Configuration functions 
 112:../src/stm32f30x_i2c.c ****  *
 113:../src/stm32f30x_i2c.c **** @verbatim   
 114:../src/stm32f30x_i2c.c ****  ===============================================================================
 115:../src/stm32f30x_i2c.c ****            ##### Initialization and Configuration functions #####
 116:../src/stm32f30x_i2c.c ****  ===============================================================================
 117:../src/stm32f30x_i2c.c ****     [..] This section provides a set of functions allowing to initialize the I2C Mode,
 118:../src/stm32f30x_i2c.c ****          I2C Timing, I2C filters, I2C Addressing mode, I2C OwnAddress1.
 119:../src/stm32f30x_i2c.c **** 
 120:../src/stm32f30x_i2c.c ****     [..] The I2C_Init() function follows the I2C configuration procedures (these procedures 
 121:../src/stm32f30x_i2c.c ****          are available in reference manual).
 122:../src/stm32f30x_i2c.c ****          
 123:../src/stm32f30x_i2c.c ****     [..] When the Software Reset is performed using I2C_SoftwareResetCmd() function, the internal
 124:../src/stm32f30x_i2c.c ****          states machines are reset and communication control bits, as well as status bits come 
 125:../src/stm32f30x_i2c.c ****          back to their reset value.
 126:../src/stm32f30x_i2c.c ****          
 127:../src/stm32f30x_i2c.c ****     [..] Before enabling Stop mode using I2C_StopModeCmd() I2C Clock source must be set to
 128:../src/stm32f30x_i2c.c ****          HSI and Digital filters must be disabled.
 129:../src/stm32f30x_i2c.c ****          
 130:../src/stm32f30x_i2c.c ****     [..] Before enabling Own Address 2 via I2C_DualAddressCmd() function, OA2 and mask should be
 131:../src/stm32f30x_i2c.c ****          configured using I2C_OwnAddress2Config() function.
 132:../src/stm32f30x_i2c.c ****          
 133:../src/stm32f30x_i2c.c ****     [..] I2C_SlaveByteControlCmd() enable Slave byte control that allow user to get control of 
 134:../src/stm32f30x_i2c.c ****          each byte in slave mode when NBYTES is set to 0x01. 
 135:../src/stm32f30x_i2c.c ****              
 136:../src/stm32f30x_i2c.c **** @endverbatim
 137:../src/stm32f30x_i2c.c ****   * @{
 138:../src/stm32f30x_i2c.c ****   */
 139:../src/stm32f30x_i2c.c **** 
 140:../src/stm32f30x_i2c.c **** /**
 141:../src/stm32f30x_i2c.c ****   * @brief  Deinitializes the I2Cx peripheral registers to their default reset values.
 142:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 143:../src/stm32f30x_i2c.c ****   * @retval None
 144:../src/stm32f30x_i2c.c ****   */
 145:../src/stm32f30x_i2c.c **** void I2C_DeInit(I2C_TypeDef* I2Cx)
 146:../src/stm32f30x_i2c.c **** {
  27              		.loc 1 146 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31 0000 80B5     		push	{r7, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  36 0002 82B0     		sub	sp, sp, #8
  37              	.LCFI1:
  38              		.cfi_def_cfa_offset 16
  39 0004 00AF     		add	r7, sp, #0
  40              	.LCFI2:
  41              		.cfi_def_cfa_register 7
  42 0006 7860     		str	r0, [r7, #4]
 147:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 148:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 149:../src/stm32f30x_i2c.c **** 
 150:../src/stm32f30x_i2c.c ****   if (I2Cx == I2C1)
  43              		.loc 1 150 0
  44 0008 7A68     		ldr	r2, [r7, #4]
  45 000a 4FF4A843 		mov	r3, #21504
  46 000e C4F20003 		movt	r3, 16384
  47 0012 9A42     		cmp	r2, r3
  48 0014 0CD1     		bne	.L2
 151:../src/stm32f30x_i2c.c ****   {
 152:../src/stm32f30x_i2c.c ****     /* Enable I2C1 reset state */
 153:../src/stm32f30x_i2c.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
  49              		.loc 1 153 0
  50 0016 4FF40010 		mov	r0, #2097152
  51 001a 4FF00101 		mov	r1, #1
  52 001e FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 154:../src/stm32f30x_i2c.c ****     /* Release I2C1 from reset state */
 155:../src/stm32f30x_i2c.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
  53              		.loc 1 155 0
  54 0022 4FF40010 		mov	r0, #2097152
  55 0026 4FF00001 		mov	r1, #0
  56 002a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  57 002e 0BE0     		b	.L1
  58              	.L2:
 156:../src/stm32f30x_i2c.c ****   }
 157:../src/stm32f30x_i2c.c ****   else
 158:../src/stm32f30x_i2c.c ****   {
 159:../src/stm32f30x_i2c.c ****     /* Enable I2C2 reset state */
 160:../src/stm32f30x_i2c.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
  59              		.loc 1 160 0
  60 0030 4FF48000 		mov	r0, #4194304
  61 0034 4FF00101 		mov	r1, #1
  62 0038 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 161:../src/stm32f30x_i2c.c ****     /* Release I2C2 from reset state */
 162:../src/stm32f30x_i2c.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
  63              		.loc 1 162 0
  64 003c 4FF48000 		mov	r0, #4194304
  65 0040 4FF00001 		mov	r1, #0
  66 0044 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  67              	.L1:
 163:../src/stm32f30x_i2c.c ****   }
 164:../src/stm32f30x_i2c.c **** }
  68              		.loc 1 164 0
  69 0048 07F10807 		add	r7, r7, #8
  70 004c BD46     		mov	sp, r7
  71 004e 80BD     		pop	{r7, pc}
  72              		.cfi_endproc
  73              	.LFE111:
  75              		.align	2
  76              		.global	I2C_Init
  77              		.thumb
  78              		.thumb_func
  80              	I2C_Init:
  81              	.LFB112:
 165:../src/stm32f30x_i2c.c **** 
 166:../src/stm32f30x_i2c.c **** /**
 167:../src/stm32f30x_i2c.c ****   * @brief  Initializes the I2Cx peripheral according to the specified
 168:../src/stm32f30x_i2c.c ****   *         parameters in the I2C_InitStruct.
 169:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 170:../src/stm32f30x_i2c.c ****   * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
 171:../src/stm32f30x_i2c.c ****   *         contains the configuration information for the specified I2C peripheral.
 172:../src/stm32f30x_i2c.c ****   * @retval None
 173:../src/stm32f30x_i2c.c ****   */
 174:../src/stm32f30x_i2c.c **** void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
 175:../src/stm32f30x_i2c.c **** {
  82              		.loc 1 175 0
  83              		.cfi_startproc
  84              		@ args = 0, pretend = 0, frame = 16
  85              		@ frame_needed = 1, uses_anonymous_args = 0
  86              		@ link register save eliminated.
  87 0050 80B4     		push	{r7}
  88              	.LCFI3:
  89              		.cfi_def_cfa_offset 4
  90              		.cfi_offset 7, -4
  91 0052 85B0     		sub	sp, sp, #20
  92              	.LCFI4:
  93              		.cfi_def_cfa_offset 24
  94 0054 00AF     		add	r7, sp, #0
  95              	.LCFI5:
  96              		.cfi_def_cfa_register 7
  97 0056 7860     		str	r0, [r7, #4]
  98 0058 3960     		str	r1, [r7, #0]
 176:../src/stm32f30x_i2c.c ****   uint32_t tmpreg = 0;
  99              		.loc 1 176 0
 100 005a 4FF00003 		mov	r3, #0
 101 005e FB60     		str	r3, [r7, #12]
 177:../src/stm32f30x_i2c.c **** 
 178:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 179:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 180:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ANALOG_FILTER(I2C_InitStruct->I2C_AnalogFilter));
 181:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_DIGITAL_FILTER(I2C_InitStruct->I2C_DigitalFilter));
 182:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
 183:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
 184:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ACK(I2C_InitStruct->I2C_Ack));
 185:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
 186:../src/stm32f30x_i2c.c **** 
 187:../src/stm32f30x_i2c.c ****   /* Disable I2Cx Peripheral */
 188:../src/stm32f30x_i2c.c ****   I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
 102              		.loc 1 188 0
 103 0060 7B68     		ldr	r3, [r7, #4]
 104 0062 1B68     		ldr	r3, [r3, #0]
 105 0064 23F00102 		bic	r2, r3, #1
 106 0068 7B68     		ldr	r3, [r7, #4]
 107 006a 1A60     		str	r2, [r3, #0]
 189:../src/stm32f30x_i2c.c **** 
 190:../src/stm32f30x_i2c.c ****   /*---------------------------- I2Cx FILTERS Configuration ------------------*/
 191:../src/stm32f30x_i2c.c ****   /* Get the I2Cx CR1 value */
 192:../src/stm32f30x_i2c.c ****   tmpreg = I2Cx->CR1;
 108              		.loc 1 192 0
 109 006c 7B68     		ldr	r3, [r7, #4]
 110 006e 1B68     		ldr	r3, [r3, #0]
 111 0070 FB60     		str	r3, [r7, #12]
 193:../src/stm32f30x_i2c.c ****   /* Clear I2Cx CR1 register */
 194:../src/stm32f30x_i2c.c ****   tmpreg &= CR1_CLEAR_MASK;
 112              		.loc 1 194 0
 113 0072 FA68     		ldr	r2, [r7, #12]
 114 0074 4EF2FF03 		movw	r3, #57599
 115 0078 C0F2CF03 		movt	r3, 207
 116 007c 1340     		ands	r3, r3, r2
 117 007e FB60     		str	r3, [r7, #12]
 195:../src/stm32f30x_i2c.c ****   /* Configure I2Cx: analog and digital filter */
 196:../src/stm32f30x_i2c.c ****   /* Set ANFOFF bit according to I2C_AnalogFilter value */
 197:../src/stm32f30x_i2c.c ****   /* Set DFN bits according to I2C_DigitalFilter value */
 198:../src/stm32f30x_i2c.c ****   tmpreg |= (uint32_t)I2C_InitStruct->I2C_AnalogFilter |(I2C_InitStruct->I2C_DigitalFilter << 8);
 118              		.loc 1 198 0
 119 0080 3B68     		ldr	r3, [r7, #0]
 120 0082 5A68     		ldr	r2, [r3, #4]
 121 0084 3B68     		ldr	r3, [r7, #0]
 122 0086 9B68     		ldr	r3, [r3, #8]
 123 0088 4FEA0323 		lsl	r3, r3, #8
 124 008c 1343     		orrs	r3, r3, r2
 125 008e FA68     		ldr	r2, [r7, #12]
 126 0090 1343     		orrs	r3, r3, r2
 127 0092 FB60     		str	r3, [r7, #12]
 199:../src/stm32f30x_i2c.c ****   
 200:../src/stm32f30x_i2c.c ****   /* Write to I2Cx CR1 */
 201:../src/stm32f30x_i2c.c ****   I2Cx->CR1 = tmpreg;
 128              		.loc 1 201 0
 129 0094 7B68     		ldr	r3, [r7, #4]
 130 0096 FA68     		ldr	r2, [r7, #12]
 131 0098 1A60     		str	r2, [r3, #0]
 202:../src/stm32f30x_i2c.c **** 
 203:../src/stm32f30x_i2c.c ****   /*---------------------------- I2Cx TIMING Configuration -------------------*/
 204:../src/stm32f30x_i2c.c ****   /* Configure I2Cx: Timing */
 205:../src/stm32f30x_i2c.c ****   /* Set TIMINGR bits according to I2C_Timing */
 206:../src/stm32f30x_i2c.c ****   /* Write to I2Cx TIMING */
 207:../src/stm32f30x_i2c.c ****   I2Cx->TIMINGR = I2C_InitStruct->I2C_Timing & TIMING_CLEAR_MASK;
 132              		.loc 1 207 0
 133 009a 3B68     		ldr	r3, [r7, #0]
 134 009c 1B68     		ldr	r3, [r3, #0]
 135 009e 23F07062 		bic	r2, r3, #251658240
 136 00a2 7B68     		ldr	r3, [r7, #4]
 137 00a4 1A61     		str	r2, [r3, #16]
 208:../src/stm32f30x_i2c.c **** 
 209:../src/stm32f30x_i2c.c ****   /* Enable I2Cx Peripheral */
 210:../src/stm32f30x_i2c.c ****   I2Cx->CR1 |= I2C_CR1_PE;
 138              		.loc 1 210 0
 139 00a6 7B68     		ldr	r3, [r7, #4]
 140 00a8 1B68     		ldr	r3, [r3, #0]
 141 00aa 43F00102 		orr	r2, r3, #1
 142 00ae 7B68     		ldr	r3, [r7, #4]
 143 00b0 1A60     		str	r2, [r3, #0]
 211:../src/stm32f30x_i2c.c **** 
 212:../src/stm32f30x_i2c.c ****   /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
 213:../src/stm32f30x_i2c.c ****   /* Clear tmpreg local variable */
 214:../src/stm32f30x_i2c.c ****   tmpreg = 0;
 144              		.loc 1 214 0
 145 00b2 4FF00003 		mov	r3, #0
 146 00b6 FB60     		str	r3, [r7, #12]
 215:../src/stm32f30x_i2c.c ****   /* Clear OAR1 register */
 216:../src/stm32f30x_i2c.c ****   I2Cx->OAR1 = (uint32_t)tmpreg;
 147              		.loc 1 216 0
 148 00b8 7B68     		ldr	r3, [r7, #4]
 149 00ba FA68     		ldr	r2, [r7, #12]
 150 00bc 9A60     		str	r2, [r3, #8]
 217:../src/stm32f30x_i2c.c ****   /* Clear OAR2 register */
 218:../src/stm32f30x_i2c.c ****   I2Cx->OAR2 = (uint32_t)tmpreg;
 151              		.loc 1 218 0
 152 00be 7B68     		ldr	r3, [r7, #4]
 153 00c0 FA68     		ldr	r2, [r7, #12]
 154 00c2 DA60     		str	r2, [r3, #12]
 219:../src/stm32f30x_i2c.c ****   /* Configure I2Cx: Own Address1 and acknowledged address */
 220:../src/stm32f30x_i2c.c ****   /* Set OA1MODE bit according to I2C_AcknowledgedAddress value */
 221:../src/stm32f30x_i2c.c ****   /* Set OA1 bits according to I2C_OwnAddress1 value */
 222:../src/stm32f30x_i2c.c ****   tmpreg = (uint32_t)((uint32_t)I2C_InitStruct->I2C_AcknowledgedAddress | \
 155              		.loc 1 222 0
 156 00c4 3B68     		ldr	r3, [r7, #0]
 157 00c6 9A69     		ldr	r2, [r3, #24]
 223:../src/stm32f30x_i2c.c ****                       (uint32_t)I2C_InitStruct->I2C_OwnAddress1);
 158              		.loc 1 223 0
 159 00c8 3B68     		ldr	r3, [r7, #0]
 160 00ca 1B69     		ldr	r3, [r3, #16]
 222:../src/stm32f30x_i2c.c ****   tmpreg = (uint32_t)((uint32_t)I2C_InitStruct->I2C_AcknowledgedAddress | \
 161              		.loc 1 222 0
 162 00cc 1343     		orrs	r3, r3, r2
 163 00ce FB60     		str	r3, [r7, #12]
 224:../src/stm32f30x_i2c.c ****   /* Write to I2Cx OAR1 */
 225:../src/stm32f30x_i2c.c ****   I2Cx->OAR1 = tmpreg;
 164              		.loc 1 225 0
 165 00d0 7B68     		ldr	r3, [r7, #4]
 166 00d2 FA68     		ldr	r2, [r7, #12]
 167 00d4 9A60     		str	r2, [r3, #8]
 226:../src/stm32f30x_i2c.c ****   /* Enable Own Address1 acknowledgement */
 227:../src/stm32f30x_i2c.c ****   I2Cx->OAR1 |= I2C_OAR1_OA1EN;
 168              		.loc 1 227 0
 169 00d6 7B68     		ldr	r3, [r7, #4]
 170 00d8 9B68     		ldr	r3, [r3, #8]
 171 00da 43F40042 		orr	r2, r3, #32768
 172 00de 7B68     		ldr	r3, [r7, #4]
 173 00e0 9A60     		str	r2, [r3, #8]
 228:../src/stm32f30x_i2c.c **** 
 229:../src/stm32f30x_i2c.c ****   /*---------------------------- I2Cx MODE Configuration ---------------------*/
 230:../src/stm32f30x_i2c.c ****   /* Configure I2Cx: mode */
 231:../src/stm32f30x_i2c.c ****   /* Set SMBDEN and SMBHEN bits according to I2C_Mode value */
 232:../src/stm32f30x_i2c.c ****   tmpreg = I2C_InitStruct->I2C_Mode;
 174              		.loc 1 232 0
 175 00e2 3B68     		ldr	r3, [r7, #0]
 176 00e4 DB68     		ldr	r3, [r3, #12]
 177 00e6 FB60     		str	r3, [r7, #12]
 233:../src/stm32f30x_i2c.c ****   /* Write to I2Cx CR1 */
 234:../src/stm32f30x_i2c.c ****   I2Cx->CR1 |= tmpreg;
 178              		.loc 1 234 0
 179 00e8 7B68     		ldr	r3, [r7, #4]
 180 00ea 1A68     		ldr	r2, [r3, #0]
 181 00ec FB68     		ldr	r3, [r7, #12]
 182 00ee 1A43     		orrs	r2, r2, r3
 183 00f0 7B68     		ldr	r3, [r7, #4]
 184 00f2 1A60     		str	r2, [r3, #0]
 235:../src/stm32f30x_i2c.c **** 
 236:../src/stm32f30x_i2c.c ****   /*---------------------------- I2Cx ACK Configuration ----------------------*/
 237:../src/stm32f30x_i2c.c ****   /* Get the I2Cx CR2 value */
 238:../src/stm32f30x_i2c.c ****   tmpreg = I2Cx->CR2;
 185              		.loc 1 238 0
 186 00f4 7B68     		ldr	r3, [r7, #4]
 187 00f6 5B68     		ldr	r3, [r3, #4]
 188 00f8 FB60     		str	r3, [r7, #12]
 239:../src/stm32f30x_i2c.c ****   /* Clear I2Cx CR2 register */
 240:../src/stm32f30x_i2c.c ****   tmpreg &= CR2_CLEAR_MASK;
 189              		.loc 1 240 0
 190 00fa FB68     		ldr	r3, [r7, #12]
 191 00fc 23F07843 		bic	r3, r3, #-134217728
 192 0100 23F40043 		bic	r3, r3, #32768
 193 0104 FB60     		str	r3, [r7, #12]
 241:../src/stm32f30x_i2c.c ****   /* Configure I2Cx: acknowledgement */
 242:../src/stm32f30x_i2c.c ****   /* Set NACK bit according to I2C_Ack value */
 243:../src/stm32f30x_i2c.c ****   tmpreg |= I2C_InitStruct->I2C_Ack;
 194              		.loc 1 243 0
 195 0106 3B68     		ldr	r3, [r7, #0]
 196 0108 5B69     		ldr	r3, [r3, #20]
 197 010a FA68     		ldr	r2, [r7, #12]
 198 010c 1343     		orrs	r3, r3, r2
 199 010e FB60     		str	r3, [r7, #12]
 244:../src/stm32f30x_i2c.c ****   /* Write to I2Cx CR2 */
 245:../src/stm32f30x_i2c.c ****   I2Cx->CR2 = tmpreg;
 200              		.loc 1 245 0
 201 0110 7B68     		ldr	r3, [r7, #4]
 202 0112 FA68     		ldr	r2, [r7, #12]
 203 0114 5A60     		str	r2, [r3, #4]
 246:../src/stm32f30x_i2c.c **** }
 204              		.loc 1 246 0
 205 0116 07F11407 		add	r7, r7, #20
 206 011a BD46     		mov	sp, r7
 207 011c 80BC     		pop	{r7}
 208 011e 7047     		bx	lr
 209              		.cfi_endproc
 210              	.LFE112:
 212              		.align	2
 213              		.global	I2C_StructInit
 214              		.thumb
 215              		.thumb_func
 217              	I2C_StructInit:
 218              	.LFB113:
 247:../src/stm32f30x_i2c.c **** 
 248:../src/stm32f30x_i2c.c **** /**
 249:../src/stm32f30x_i2c.c ****   * @brief  Fills each I2C_InitStruct member with its default value.
 250:../src/stm32f30x_i2c.c ****   * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
 251:../src/stm32f30x_i2c.c ****   * @retval None
 252:../src/stm32f30x_i2c.c ****   */
 253:../src/stm32f30x_i2c.c **** void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
 254:../src/stm32f30x_i2c.c **** {
 219              		.loc 1 254 0
 220              		.cfi_startproc
 221              		@ args = 0, pretend = 0, frame = 8
 222              		@ frame_needed = 1, uses_anonymous_args = 0
 223              		@ link register save eliminated.
 224 0120 80B4     		push	{r7}
 225              	.LCFI6:
 226              		.cfi_def_cfa_offset 4
 227              		.cfi_offset 7, -4
 228 0122 83B0     		sub	sp, sp, #12
 229              	.LCFI7:
 230              		.cfi_def_cfa_offset 16
 231 0124 00AF     		add	r7, sp, #0
 232              	.LCFI8:
 233              		.cfi_def_cfa_register 7
 234 0126 7860     		str	r0, [r7, #4]
 255:../src/stm32f30x_i2c.c ****   /*---------------- Reset I2C init structure parameters values --------------*/
 256:../src/stm32f30x_i2c.c ****   /* Initialize the I2C_Timing member */
 257:../src/stm32f30x_i2c.c ****   I2C_InitStruct->I2C_Timing = 0;
 235              		.loc 1 257 0
 236 0128 7B68     		ldr	r3, [r7, #4]
 237 012a 4FF00002 		mov	r2, #0
 238 012e 1A60     		str	r2, [r3, #0]
 258:../src/stm32f30x_i2c.c ****   /* Initialize the I2C_AnalogFilter member */
 259:../src/stm32f30x_i2c.c ****   I2C_InitStruct->I2C_AnalogFilter = I2C_AnalogFilter_Enable;
 239              		.loc 1 259 0
 240 0130 7B68     		ldr	r3, [r7, #4]
 241 0132 4FF00002 		mov	r2, #0
 242 0136 5A60     		str	r2, [r3, #4]
 260:../src/stm32f30x_i2c.c ****   /* Initialize the I2C_DigitalFilter member */
 261:../src/stm32f30x_i2c.c ****   I2C_InitStruct->I2C_DigitalFilter = 0;
 243              		.loc 1 261 0
 244 0138 7B68     		ldr	r3, [r7, #4]
 245 013a 4FF00002 		mov	r2, #0
 246 013e 9A60     		str	r2, [r3, #8]
 262:../src/stm32f30x_i2c.c ****   /* Initialize the I2C_Mode member */
 263:../src/stm32f30x_i2c.c ****   I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
 247              		.loc 1 263 0
 248 0140 7B68     		ldr	r3, [r7, #4]
 249 0142 4FF00002 		mov	r2, #0
 250 0146 DA60     		str	r2, [r3, #12]
 264:../src/stm32f30x_i2c.c ****   /* Initialize the I2C_OwnAddress1 member */
 265:../src/stm32f30x_i2c.c ****   I2C_InitStruct->I2C_OwnAddress1 = 0;
 251              		.loc 1 265 0
 252 0148 7B68     		ldr	r3, [r7, #4]
 253 014a 4FF00002 		mov	r2, #0
 254 014e 1A61     		str	r2, [r3, #16]
 266:../src/stm32f30x_i2c.c ****   /* Initialize the I2C_Ack member */
 267:../src/stm32f30x_i2c.c ****   I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
 255              		.loc 1 267 0
 256 0150 7B68     		ldr	r3, [r7, #4]
 257 0152 4FF40042 		mov	r2, #32768
 258 0156 5A61     		str	r2, [r3, #20]
 268:../src/stm32f30x_i2c.c ****   /* Initialize the I2C_AcknowledgedAddress member */
 269:../src/stm32f30x_i2c.c ****   I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 259              		.loc 1 269 0
 260 0158 7B68     		ldr	r3, [r7, #4]
 261 015a 4FF00002 		mov	r2, #0
 262 015e 9A61     		str	r2, [r3, #24]
 270:../src/stm32f30x_i2c.c **** }
 263              		.loc 1 270 0
 264 0160 07F10C07 		add	r7, r7, #12
 265 0164 BD46     		mov	sp, r7
 266 0166 80BC     		pop	{r7}
 267 0168 7047     		bx	lr
 268              		.cfi_endproc
 269              	.LFE113:
 271 016a 00BF     		.align	2
 272              		.global	I2C_Cmd
 273              		.thumb
 274              		.thumb_func
 276              	I2C_Cmd:
 277              	.LFB114:
 271:../src/stm32f30x_i2c.c **** 
 272:../src/stm32f30x_i2c.c **** /**
 273:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables the specified I2C peripheral.
 274:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 275:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2Cx peripheral. 
 276:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
 277:../src/stm32f30x_i2c.c ****   * @retval None
 278:../src/stm32f30x_i2c.c ****   */
 279:../src/stm32f30x_i2c.c **** void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
 280:../src/stm32f30x_i2c.c **** {
 278              		.loc 1 280 0
 279              		.cfi_startproc
 280              		@ args = 0, pretend = 0, frame = 8
 281              		@ frame_needed = 1, uses_anonymous_args = 0
 282              		@ link register save eliminated.
 283 016c 80B4     		push	{r7}
 284              	.LCFI9:
 285              		.cfi_def_cfa_offset 4
 286              		.cfi_offset 7, -4
 287 016e 83B0     		sub	sp, sp, #12
 288              	.LCFI10:
 289              		.cfi_def_cfa_offset 16
 290 0170 00AF     		add	r7, sp, #0
 291              	.LCFI11:
 292              		.cfi_def_cfa_register 7
 293 0172 7860     		str	r0, [r7, #4]
 294 0174 0B46     		mov	r3, r1
 295 0176 FB70     		strb	r3, [r7, #3]
 281:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 282:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 283:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 284:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 296              		.loc 1 284 0
 297 0178 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 298 017a 002B     		cmp	r3, #0
 299 017c 06D0     		beq	.L7
 285:../src/stm32f30x_i2c.c ****   {
 286:../src/stm32f30x_i2c.c ****     /* Enable the selected I2C peripheral */
 287:../src/stm32f30x_i2c.c ****     I2Cx->CR1 |= I2C_CR1_PE;
 300              		.loc 1 287 0
 301 017e 7B68     		ldr	r3, [r7, #4]
 302 0180 1B68     		ldr	r3, [r3, #0]
 303 0182 43F00102 		orr	r2, r3, #1
 304 0186 7B68     		ldr	r3, [r7, #4]
 305 0188 1A60     		str	r2, [r3, #0]
 306 018a 05E0     		b	.L6
 307              	.L7:
 288:../src/stm32f30x_i2c.c ****   }
 289:../src/stm32f30x_i2c.c ****   else
 290:../src/stm32f30x_i2c.c ****   {
 291:../src/stm32f30x_i2c.c ****     /* Disable the selected I2C peripheral */
 292:../src/stm32f30x_i2c.c ****     I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
 308              		.loc 1 292 0
 309 018c 7B68     		ldr	r3, [r7, #4]
 310 018e 1B68     		ldr	r3, [r3, #0]
 311 0190 23F00102 		bic	r2, r3, #1
 312 0194 7B68     		ldr	r3, [r7, #4]
 313 0196 1A60     		str	r2, [r3, #0]
 314              	.L6:
 293:../src/stm32f30x_i2c.c ****   }
 294:../src/stm32f30x_i2c.c **** }
 315              		.loc 1 294 0
 316 0198 07F10C07 		add	r7, r7, #12
 317 019c BD46     		mov	sp, r7
 318 019e 80BC     		pop	{r7}
 319 01a0 7047     		bx	lr
 320              		.cfi_endproc
 321              	.LFE114:
 323 01a2 00BF     		.align	2
 324              		.global	I2C_SoftwareResetCmd
 325              		.thumb
 326              		.thumb_func
 328              	I2C_SoftwareResetCmd:
 329              	.LFB115:
 295:../src/stm32f30x_i2c.c **** 
 296:../src/stm32f30x_i2c.c **** 
 297:../src/stm32f30x_i2c.c **** /**
 298:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables the specified I2C software reset.
 299:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 300:../src/stm32f30x_i2c.c ****   * @retval None
 301:../src/stm32f30x_i2c.c ****   */
 302:../src/stm32f30x_i2c.c **** void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx)
 303:../src/stm32f30x_i2c.c **** {
 330              		.loc 1 303 0
 331              		.cfi_startproc
 332              		@ args = 0, pretend = 0, frame = 8
 333              		@ frame_needed = 1, uses_anonymous_args = 0
 334              		@ link register save eliminated.
 335 01a4 80B4     		push	{r7}
 336              	.LCFI12:
 337              		.cfi_def_cfa_offset 4
 338              		.cfi_offset 7, -4
 339 01a6 83B0     		sub	sp, sp, #12
 340              	.LCFI13:
 341              		.cfi_def_cfa_offset 16
 342 01a8 00AF     		add	r7, sp, #0
 343              	.LCFI14:
 344              		.cfi_def_cfa_register 7
 345 01aa 7860     		str	r0, [r7, #4]
 304:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 305:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 306:../src/stm32f30x_i2c.c **** 
 307:../src/stm32f30x_i2c.c ****   /* Disable peripheral */
 308:../src/stm32f30x_i2c.c ****   I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
 346              		.loc 1 308 0
 347 01ac 7B68     		ldr	r3, [r7, #4]
 348 01ae 1B68     		ldr	r3, [r3, #0]
 349 01b0 23F00102 		bic	r2, r3, #1
 350 01b4 7B68     		ldr	r3, [r7, #4]
 351 01b6 1A60     		str	r2, [r3, #0]
 309:../src/stm32f30x_i2c.c **** 
 310:../src/stm32f30x_i2c.c ****   /* Perform a dummy read to delay the disable of peripheral for minimum
 311:../src/stm32f30x_i2c.c ****      3 APB clock cycles to perform the software reset functionality */
 312:../src/stm32f30x_i2c.c ****   *(__IO uint32_t *)(uint32_t)I2Cx; 
 352              		.loc 1 312 0
 353 01b8 7B68     		ldr	r3, [r7, #4]
 354 01ba 1B68     		ldr	r3, [r3, #0]
 313:../src/stm32f30x_i2c.c **** 
 314:../src/stm32f30x_i2c.c ****   /* Enable peripheral */
 315:../src/stm32f30x_i2c.c ****   I2Cx->CR1 |= I2C_CR1_PE;
 355              		.loc 1 315 0
 356 01bc 7B68     		ldr	r3, [r7, #4]
 357 01be 1B68     		ldr	r3, [r3, #0]
 358 01c0 43F00102 		orr	r2, r3, #1
 359 01c4 7B68     		ldr	r3, [r7, #4]
 360 01c6 1A60     		str	r2, [r3, #0]
 316:../src/stm32f30x_i2c.c **** }
 361              		.loc 1 316 0
 362 01c8 07F10C07 		add	r7, r7, #12
 363 01cc BD46     		mov	sp, r7
 364 01ce 80BC     		pop	{r7}
 365 01d0 7047     		bx	lr
 366              		.cfi_endproc
 367              	.LFE115:
 369 01d2 00BF     		.align	2
 370              		.global	I2C_ITConfig
 371              		.thumb
 372              		.thumb_func
 374              	I2C_ITConfig:
 375              	.LFB116:
 317:../src/stm32f30x_i2c.c **** 
 318:../src/stm32f30x_i2c.c **** /**
 319:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables the specified I2C interrupts.
 320:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 321:../src/stm32f30x_i2c.c ****   * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled. 
 322:../src/stm32f30x_i2c.c ****   *   This parameter can be any combination of the following values:
 323:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_ERRI: Error interrupt mask
 324:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_TCI: Transfer Complete interrupt mask
 325:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_STOPI: Stop Detection interrupt mask
 326:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_NACKI: Not Acknowledge received interrupt mask
 327:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_ADDRI: Address Match interrupt mask  
 328:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_RXI: RX interrupt mask
 329:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_TXI: TX interrupt mask
 330:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the specified I2C interrupts.
 331:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
 332:../src/stm32f30x_i2c.c ****   * @retval None
 333:../src/stm32f30x_i2c.c ****   */
 334:../src/stm32f30x_i2c.c **** void I2C_ITConfig(I2C_TypeDef* I2Cx, uint32_t I2C_IT, FunctionalState NewState)
 335:../src/stm32f30x_i2c.c **** {
 376              		.loc 1 335 0
 377              		.cfi_startproc
 378              		@ args = 0, pretend = 0, frame = 16
 379              		@ frame_needed = 1, uses_anonymous_args = 0
 380              		@ link register save eliminated.
 381 01d4 80B4     		push	{r7}
 382              	.LCFI15:
 383              		.cfi_def_cfa_offset 4
 384              		.cfi_offset 7, -4
 385 01d6 85B0     		sub	sp, sp, #20
 386              	.LCFI16:
 387              		.cfi_def_cfa_offset 24
 388 01d8 00AF     		add	r7, sp, #0
 389              	.LCFI17:
 390              		.cfi_def_cfa_register 7
 391 01da F860     		str	r0, [r7, #12]
 392 01dc B960     		str	r1, [r7, #8]
 393 01de 1346     		mov	r3, r2
 394 01e0 FB71     		strb	r3, [r7, #7]
 336:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 337:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 338:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 339:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_CONFIG_IT(I2C_IT));
 340:../src/stm32f30x_i2c.c ****   
 341:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 395              		.loc 1 341 0
 396 01e2 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 397 01e4 002B     		cmp	r3, #0
 398 01e6 06D0     		beq	.L11
 342:../src/stm32f30x_i2c.c ****   {
 343:../src/stm32f30x_i2c.c ****     /* Enable the selected I2C interrupts */
 344:../src/stm32f30x_i2c.c ****     I2Cx->CR1 |= I2C_IT;
 399              		.loc 1 344 0
 400 01e8 FB68     		ldr	r3, [r7, #12]
 401 01ea 1A68     		ldr	r2, [r3, #0]
 402 01ec BB68     		ldr	r3, [r7, #8]
 403 01ee 1A43     		orrs	r2, r2, r3
 404 01f0 FB68     		ldr	r3, [r7, #12]
 405 01f2 1A60     		str	r2, [r3, #0]
 406 01f4 07E0     		b	.L10
 407              	.L11:
 345:../src/stm32f30x_i2c.c ****   }
 346:../src/stm32f30x_i2c.c ****   else
 347:../src/stm32f30x_i2c.c ****   {
 348:../src/stm32f30x_i2c.c ****     /* Disable the selected I2C interrupts */
 349:../src/stm32f30x_i2c.c ****     I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_IT);
 408              		.loc 1 349 0
 409 01f6 FB68     		ldr	r3, [r7, #12]
 410 01f8 1A68     		ldr	r2, [r3, #0]
 411 01fa BB68     		ldr	r3, [r7, #8]
 412 01fc 6FEA0303 		mvn	r3, r3
 413 0200 1A40     		ands	r2, r2, r3
 414 0202 FB68     		ldr	r3, [r7, #12]
 415 0204 1A60     		str	r2, [r3, #0]
 416              	.L10:
 350:../src/stm32f30x_i2c.c ****   }
 351:../src/stm32f30x_i2c.c **** }
 417              		.loc 1 351 0
 418 0206 07F11407 		add	r7, r7, #20
 419 020a BD46     		mov	sp, r7
 420 020c 80BC     		pop	{r7}
 421 020e 7047     		bx	lr
 422              		.cfi_endproc
 423              	.LFE116:
 425              		.align	2
 426              		.global	I2C_StretchClockCmd
 427              		.thumb
 428              		.thumb_func
 430              	I2C_StretchClockCmd:
 431              	.LFB117:
 352:../src/stm32f30x_i2c.c **** 
 353:../src/stm32f30x_i2c.c **** /**
 354:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables the I2C Clock stretching.
 355:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 356:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2Cx Clock stretching.
 357:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
 358:../src/stm32f30x_i2c.c ****   * @retval None
 359:../src/stm32f30x_i2c.c ****   */
 360:../src/stm32f30x_i2c.c **** void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
 361:../src/stm32f30x_i2c.c **** {
 432              		.loc 1 361 0
 433              		.cfi_startproc
 434              		@ args = 0, pretend = 0, frame = 8
 435              		@ frame_needed = 1, uses_anonymous_args = 0
 436              		@ link register save eliminated.
 437 0210 80B4     		push	{r7}
 438              	.LCFI18:
 439              		.cfi_def_cfa_offset 4
 440              		.cfi_offset 7, -4
 441 0212 83B0     		sub	sp, sp, #12
 442              	.LCFI19:
 443              		.cfi_def_cfa_offset 16
 444 0214 00AF     		add	r7, sp, #0
 445              	.LCFI20:
 446              		.cfi_def_cfa_register 7
 447 0216 7860     		str	r0, [r7, #4]
 448 0218 0B46     		mov	r3, r1
 449 021a FB70     		strb	r3, [r7, #3]
 362:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 363:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 364:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 365:../src/stm32f30x_i2c.c ****   
 366:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 450              		.loc 1 366 0
 451 021c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 452 021e 002B     		cmp	r3, #0
 453 0220 06D0     		beq	.L14
 367:../src/stm32f30x_i2c.c ****   {
 368:../src/stm32f30x_i2c.c ****     /* Enable clock stretching */
 369:../src/stm32f30x_i2c.c ****     I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_NOSTRETCH);    
 454              		.loc 1 369 0
 455 0222 7B68     		ldr	r3, [r7, #4]
 456 0224 1B68     		ldr	r3, [r3, #0]
 457 0226 23F40032 		bic	r2, r3, #131072
 458 022a 7B68     		ldr	r3, [r7, #4]
 459 022c 1A60     		str	r2, [r3, #0]
 460 022e 05E0     		b	.L13
 461              	.L14:
 370:../src/stm32f30x_i2c.c ****   }
 371:../src/stm32f30x_i2c.c ****   else
 372:../src/stm32f30x_i2c.c ****   {
 373:../src/stm32f30x_i2c.c ****     /* Disable clock stretching  */
 374:../src/stm32f30x_i2c.c ****     I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
 462              		.loc 1 374 0
 463 0230 7B68     		ldr	r3, [r7, #4]
 464 0232 1B68     		ldr	r3, [r3, #0]
 465 0234 43F40032 		orr	r2, r3, #131072
 466 0238 7B68     		ldr	r3, [r7, #4]
 467 023a 1A60     		str	r2, [r3, #0]
 468              	.L13:
 375:../src/stm32f30x_i2c.c ****   }
 376:../src/stm32f30x_i2c.c **** }
 469              		.loc 1 376 0
 470 023c 07F10C07 		add	r7, r7, #12
 471 0240 BD46     		mov	sp, r7
 472 0242 80BC     		pop	{r7}
 473 0244 7047     		bx	lr
 474              		.cfi_endproc
 475              	.LFE117:
 477 0246 00BF     		.align	2
 478              		.global	I2C_StopModeCmd
 479              		.thumb
 480              		.thumb_func
 482              	I2C_StopModeCmd:
 483              	.LFB118:
 377:../src/stm32f30x_i2c.c **** 
 378:../src/stm32f30x_i2c.c **** /**
 379:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables I2C wakeup from stop mode.
 380:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 381:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2Cx stop mode.
 382:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
 383:../src/stm32f30x_i2c.c ****   * @retval None
 384:../src/stm32f30x_i2c.c ****   */
 385:../src/stm32f30x_i2c.c **** void I2C_StopModeCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
 386:../src/stm32f30x_i2c.c **** {
 484              		.loc 1 386 0
 485              		.cfi_startproc
 486              		@ args = 0, pretend = 0, frame = 8
 487              		@ frame_needed = 1, uses_anonymous_args = 0
 488              		@ link register save eliminated.
 489 0248 80B4     		push	{r7}
 490              	.LCFI21:
 491              		.cfi_def_cfa_offset 4
 492              		.cfi_offset 7, -4
 493 024a 83B0     		sub	sp, sp, #12
 494              	.LCFI22:
 495              		.cfi_def_cfa_offset 16
 496 024c 00AF     		add	r7, sp, #0
 497              	.LCFI23:
 498              		.cfi_def_cfa_register 7
 499 024e 7860     		str	r0, [r7, #4]
 500 0250 0B46     		mov	r3, r1
 501 0252 FB70     		strb	r3, [r7, #3]
 387:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 388:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 389:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 390:../src/stm32f30x_i2c.c ****   
 391:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 502              		.loc 1 391 0
 503 0254 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 504 0256 002B     		cmp	r3, #0
 505 0258 06D0     		beq	.L17
 392:../src/stm32f30x_i2c.c ****   {
 393:../src/stm32f30x_i2c.c ****     /* Enable wakeup from stop mode */
 394:../src/stm32f30x_i2c.c ****     I2Cx->CR1 |= I2C_CR1_WUPEN;   
 506              		.loc 1 394 0
 507 025a 7B68     		ldr	r3, [r7, #4]
 508 025c 1B68     		ldr	r3, [r3, #0]
 509 025e 43F48022 		orr	r2, r3, #262144
 510 0262 7B68     		ldr	r3, [r7, #4]
 511 0264 1A60     		str	r2, [r3, #0]
 512 0266 05E0     		b	.L16
 513              	.L17:
 395:../src/stm32f30x_i2c.c ****   }
 396:../src/stm32f30x_i2c.c ****   else
 397:../src/stm32f30x_i2c.c ****   {
 398:../src/stm32f30x_i2c.c ****     /* Disable wakeup from stop mode */    
 399:../src/stm32f30x_i2c.c ****     I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_WUPEN); 
 514              		.loc 1 399 0
 515 0268 7B68     		ldr	r3, [r7, #4]
 516 026a 1B68     		ldr	r3, [r3, #0]
 517 026c 23F48022 		bic	r2, r3, #262144
 518 0270 7B68     		ldr	r3, [r7, #4]
 519 0272 1A60     		str	r2, [r3, #0]
 520              	.L16:
 400:../src/stm32f30x_i2c.c ****   }
 401:../src/stm32f30x_i2c.c **** }
 521              		.loc 1 401 0
 522 0274 07F10C07 		add	r7, r7, #12
 523 0278 BD46     		mov	sp, r7
 524 027a 80BC     		pop	{r7}
 525 027c 7047     		bx	lr
 526              		.cfi_endproc
 527              	.LFE118:
 529 027e 00BF     		.align	2
 530              		.global	I2C_DualAddressCmd
 531              		.thumb
 532              		.thumb_func
 534              	I2C_DualAddressCmd:
 535              	.LFB119:
 402:../src/stm32f30x_i2c.c **** 
 403:../src/stm32f30x_i2c.c **** /**
 404:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables the I2C own address 2.
 405:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 406:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2C own address 2.
 407:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.  
 408:../src/stm32f30x_i2c.c ****   * @retval None
 409:../src/stm32f30x_i2c.c ****   */
 410:../src/stm32f30x_i2c.c **** void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
 411:../src/stm32f30x_i2c.c **** {
 536              		.loc 1 411 0
 537              		.cfi_startproc
 538              		@ args = 0, pretend = 0, frame = 8
 539              		@ frame_needed = 1, uses_anonymous_args = 0
 540              		@ link register save eliminated.
 541 0280 80B4     		push	{r7}
 542              	.LCFI24:
 543              		.cfi_def_cfa_offset 4
 544              		.cfi_offset 7, -4
 545 0282 83B0     		sub	sp, sp, #12
 546              	.LCFI25:
 547              		.cfi_def_cfa_offset 16
 548 0284 00AF     		add	r7, sp, #0
 549              	.LCFI26:
 550              		.cfi_def_cfa_register 7
 551 0286 7860     		str	r0, [r7, #4]
 552 0288 0B46     		mov	r3, r1
 553 028a FB70     		strb	r3, [r7, #3]
 412:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 413:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 414:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 415:../src/stm32f30x_i2c.c ****   
 416:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 554              		.loc 1 416 0
 555 028c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 556 028e 002B     		cmp	r3, #0
 557 0290 06D0     		beq	.L20
 417:../src/stm32f30x_i2c.c ****   {
 418:../src/stm32f30x_i2c.c ****     /* Enable own address 2 */
 419:../src/stm32f30x_i2c.c ****     I2Cx->OAR2 |= I2C_OAR2_OA2EN;
 558              		.loc 1 419 0
 559 0292 7B68     		ldr	r3, [r7, #4]
 560 0294 DB68     		ldr	r3, [r3, #12]
 561 0296 43F40042 		orr	r2, r3, #32768
 562 029a 7B68     		ldr	r3, [r7, #4]
 563 029c DA60     		str	r2, [r3, #12]
 564 029e 05E0     		b	.L19
 565              	.L20:
 420:../src/stm32f30x_i2c.c ****   }
 421:../src/stm32f30x_i2c.c ****   else
 422:../src/stm32f30x_i2c.c ****   {
 423:../src/stm32f30x_i2c.c ****     /* Disable own address 2 */
 424:../src/stm32f30x_i2c.c ****     I2Cx->OAR2 &= (uint32_t)~((uint32_t)I2C_OAR2_OA2EN);
 566              		.loc 1 424 0
 567 02a0 7B68     		ldr	r3, [r7, #4]
 568 02a2 DB68     		ldr	r3, [r3, #12]
 569 02a4 23F40042 		bic	r2, r3, #32768
 570 02a8 7B68     		ldr	r3, [r7, #4]
 571 02aa DA60     		str	r2, [r3, #12]
 572              	.L19:
 425:../src/stm32f30x_i2c.c ****   }
 426:../src/stm32f30x_i2c.c **** }    
 573              		.loc 1 426 0
 574 02ac 07F10C07 		add	r7, r7, #12
 575 02b0 BD46     		mov	sp, r7
 576 02b2 80BC     		pop	{r7}
 577 02b4 7047     		bx	lr
 578              		.cfi_endproc
 579              	.LFE119:
 581 02b6 00BF     		.align	2
 582              		.global	I2C_OwnAddress2Config
 583              		.thumb
 584              		.thumb_func
 586              	I2C_OwnAddress2Config:
 587              	.LFB120:
 427:../src/stm32f30x_i2c.c **** 
 428:../src/stm32f30x_i2c.c **** /**
 429:../src/stm32f30x_i2c.c ****   * @brief  Configures the I2C slave own address 2 and mask.
 430:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 431:../src/stm32f30x_i2c.c ****   * @param  Address: specifies the slave address to be programmed.
 432:../src/stm32f30x_i2c.c ****   * @param  Mask: specifies own address 2 mask to be programmed.
 433:../src/stm32f30x_i2c.c ****   *   This parameter can be one of the following values:
 434:../src/stm32f30x_i2c.c ****   *     @arg I2C_OA2_NoMask: no mask.
 435:../src/stm32f30x_i2c.c ****   *     @arg I2C_OA2_Mask01: OA2[1] is masked and don't care.
 436:../src/stm32f30x_i2c.c ****   *     @arg I2C_OA2_Mask02: OA2[2:1] are masked and don't care.
 437:../src/stm32f30x_i2c.c ****   *     @arg I2C_OA2_Mask03: OA2[3:1] are masked and don't care.
 438:../src/stm32f30x_i2c.c ****   *     @arg I2C_OA2_Mask04: OA2[4:1] are masked and don't care.
 439:../src/stm32f30x_i2c.c ****   *     @arg I2C_OA2_Mask05: OA2[5:1] are masked and don't care.
 440:../src/stm32f30x_i2c.c ****   *     @arg I2C_OA2_Mask06: OA2[6:1] are masked and don't care.
 441:../src/stm32f30x_i2c.c ****   *     @arg I2C_OA2_Mask07: OA2[7:1] are masked and don't care.
 442:../src/stm32f30x_i2c.c ****   * @retval None
 443:../src/stm32f30x_i2c.c ****   */
 444:../src/stm32f30x_i2c.c **** void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Mask)
 445:../src/stm32f30x_i2c.c **** {
 588              		.loc 1 445 0
 589              		.cfi_startproc
 590              		@ args = 0, pretend = 0, frame = 16
 591              		@ frame_needed = 1, uses_anonymous_args = 0
 592              		@ link register save eliminated.
 593 02b8 80B4     		push	{r7}
 594              	.LCFI27:
 595              		.cfi_def_cfa_offset 4
 596              		.cfi_offset 7, -4
 597 02ba 85B0     		sub	sp, sp, #20
 598              	.LCFI28:
 599              		.cfi_def_cfa_offset 24
 600 02bc 00AF     		add	r7, sp, #0
 601              	.LCFI29:
 602              		.cfi_def_cfa_register 7
 603 02be 7860     		str	r0, [r7, #4]
 604 02c0 1346     		mov	r3, r2
 605 02c2 0A46     		mov	r2, r1	@ movhi
 606 02c4 7A80     		strh	r2, [r7, #2]	@ movhi
 607 02c6 7B70     		strb	r3, [r7, #1]
 446:../src/stm32f30x_i2c.c ****   uint32_t tmpreg = 0;
 608              		.loc 1 446 0
 609 02c8 4FF00003 		mov	r3, #0
 610 02cc FB60     		str	r3, [r7, #12]
 447:../src/stm32f30x_i2c.c **** 
 448:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 449:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 450:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_OWN_ADDRESS2(Address));
 451:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_OWN_ADDRESS2_MASK(Mask));
 452:../src/stm32f30x_i2c.c ****   
 453:../src/stm32f30x_i2c.c ****   /* Get the old register value */
 454:../src/stm32f30x_i2c.c ****   tmpreg = I2Cx->OAR2;
 611              		.loc 1 454 0
 612 02ce 7B68     		ldr	r3, [r7, #4]
 613 02d0 DB68     		ldr	r3, [r3, #12]
 614 02d2 FB60     		str	r3, [r7, #12]
 455:../src/stm32f30x_i2c.c **** 
 456:../src/stm32f30x_i2c.c ****   /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
 457:../src/stm32f30x_i2c.c ****   tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));
 615              		.loc 1 457 0
 616 02d4 FB68     		ldr	r3, [r7, #12]
 617 02d6 23F4FF63 		bic	r3, r3, #2040
 618 02da 23F00603 		bic	r3, r3, #6
 619 02de FB60     		str	r3, [r7, #12]
 458:../src/stm32f30x_i2c.c **** 
 459:../src/stm32f30x_i2c.c ****   /* Set I2Cx SADD */
 460:../src/stm32f30x_i2c.c ****   tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
 620              		.loc 1 460 0
 621 02e0 7B88     		ldrh	r3, [r7, #2]
 622 02e2 03F0FE02 		and	r2, r3, #254
 461:../src/stm32f30x_i2c.c ****             (((uint32_t)Mask << 8) & I2C_OAR2_OA2MSK)) ;
 623              		.loc 1 461 0
 624 02e6 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 625 02e8 4FEA0323 		lsl	r3, r3, #8
 626 02ec 03F4E063 		and	r3, r3, #1792
 460:../src/stm32f30x_i2c.c ****   tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
 627              		.loc 1 460 0
 628 02f0 1343     		orrs	r3, r3, r2
 629 02f2 FA68     		ldr	r2, [r7, #12]
 630 02f4 1343     		orrs	r3, r3, r2
 631 02f6 FB60     		str	r3, [r7, #12]
 462:../src/stm32f30x_i2c.c **** 
 463:../src/stm32f30x_i2c.c ****   /* Store the new register value */
 464:../src/stm32f30x_i2c.c ****   I2Cx->OAR2 = tmpreg;
 632              		.loc 1 464 0
 633 02f8 7B68     		ldr	r3, [r7, #4]
 634 02fa FA68     		ldr	r2, [r7, #12]
 635 02fc DA60     		str	r2, [r3, #12]
 465:../src/stm32f30x_i2c.c **** }
 636              		.loc 1 465 0
 637 02fe 07F11407 		add	r7, r7, #20
 638 0302 BD46     		mov	sp, r7
 639 0304 80BC     		pop	{r7}
 640 0306 7047     		bx	lr
 641              		.cfi_endproc
 642              	.LFE120:
 644              		.align	2
 645              		.global	I2C_GeneralCallCmd
 646              		.thumb
 647              		.thumb_func
 649              	I2C_GeneralCallCmd:
 650              	.LFB121:
 466:../src/stm32f30x_i2c.c **** 
 467:../src/stm32f30x_i2c.c **** /**
 468:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables the I2C general call mode.
 469:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 470:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2C general call mode.
 471:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.  
 472:../src/stm32f30x_i2c.c ****   * @retval None
 473:../src/stm32f30x_i2c.c ****   */
 474:../src/stm32f30x_i2c.c **** void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
 475:../src/stm32f30x_i2c.c **** {
 651              		.loc 1 475 0
 652              		.cfi_startproc
 653              		@ args = 0, pretend = 0, frame = 8
 654              		@ frame_needed = 1, uses_anonymous_args = 0
 655              		@ link register save eliminated.
 656 0308 80B4     		push	{r7}
 657              	.LCFI30:
 658              		.cfi_def_cfa_offset 4
 659              		.cfi_offset 7, -4
 660 030a 83B0     		sub	sp, sp, #12
 661              	.LCFI31:
 662              		.cfi_def_cfa_offset 16
 663 030c 00AF     		add	r7, sp, #0
 664              	.LCFI32:
 665              		.cfi_def_cfa_register 7
 666 030e 7860     		str	r0, [r7, #4]
 667 0310 0B46     		mov	r3, r1
 668 0312 FB70     		strb	r3, [r7, #3]
 476:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 477:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 478:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 479:../src/stm32f30x_i2c.c ****   
 480:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 669              		.loc 1 480 0
 670 0314 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 671 0316 002B     		cmp	r3, #0
 672 0318 06D0     		beq	.L24
 481:../src/stm32f30x_i2c.c ****   {
 482:../src/stm32f30x_i2c.c ****     /* Enable general call mode */
 483:../src/stm32f30x_i2c.c ****     I2Cx->CR1 |= I2C_CR1_GCEN;
 673              		.loc 1 483 0
 674 031a 7B68     		ldr	r3, [r7, #4]
 675 031c 1B68     		ldr	r3, [r3, #0]
 676 031e 43F40022 		orr	r2, r3, #524288
 677 0322 7B68     		ldr	r3, [r7, #4]
 678 0324 1A60     		str	r2, [r3, #0]
 679 0326 05E0     		b	.L23
 680              	.L24:
 484:../src/stm32f30x_i2c.c ****   }
 485:../src/stm32f30x_i2c.c ****   else
 486:../src/stm32f30x_i2c.c ****   {
 487:../src/stm32f30x_i2c.c ****     /* Disable general call mode */
 488:../src/stm32f30x_i2c.c ****     I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_GCEN);
 681              		.loc 1 488 0
 682 0328 7B68     		ldr	r3, [r7, #4]
 683 032a 1B68     		ldr	r3, [r3, #0]
 684 032c 23F40022 		bic	r2, r3, #524288
 685 0330 7B68     		ldr	r3, [r7, #4]
 686 0332 1A60     		str	r2, [r3, #0]
 687              	.L23:
 489:../src/stm32f30x_i2c.c ****   }
 490:../src/stm32f30x_i2c.c **** } 
 688              		.loc 1 490 0
 689 0334 07F10C07 		add	r7, r7, #12
 690 0338 BD46     		mov	sp, r7
 691 033a 80BC     		pop	{r7}
 692 033c 7047     		bx	lr
 693              		.cfi_endproc
 694              	.LFE121:
 696 033e 00BF     		.align	2
 697              		.global	I2C_SlaveByteControlCmd
 698              		.thumb
 699              		.thumb_func
 701              	I2C_SlaveByteControlCmd:
 702              	.LFB122:
 491:../src/stm32f30x_i2c.c **** 
 492:../src/stm32f30x_i2c.c **** /**
 493:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables the I2C slave byte control.
 494:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 495:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2C slave byte control.
 496:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.  
 497:../src/stm32f30x_i2c.c ****   * @retval None
 498:../src/stm32f30x_i2c.c ****   */
 499:../src/stm32f30x_i2c.c **** void I2C_SlaveByteControlCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
 500:../src/stm32f30x_i2c.c **** {
 703              		.loc 1 500 0
 704              		.cfi_startproc
 705              		@ args = 0, pretend = 0, frame = 8
 706              		@ frame_needed = 1, uses_anonymous_args = 0
 707              		@ link register save eliminated.
 708 0340 80B4     		push	{r7}
 709              	.LCFI33:
 710              		.cfi_def_cfa_offset 4
 711              		.cfi_offset 7, -4
 712 0342 83B0     		sub	sp, sp, #12
 713              	.LCFI34:
 714              		.cfi_def_cfa_offset 16
 715 0344 00AF     		add	r7, sp, #0
 716              	.LCFI35:
 717              		.cfi_def_cfa_register 7
 718 0346 7860     		str	r0, [r7, #4]
 719 0348 0B46     		mov	r3, r1
 720 034a FB70     		strb	r3, [r7, #3]
 501:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 502:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 503:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 504:../src/stm32f30x_i2c.c ****   
 505:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 721              		.loc 1 505 0
 722 034c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 723 034e 002B     		cmp	r3, #0
 724 0350 06D0     		beq	.L27
 506:../src/stm32f30x_i2c.c ****   {
 507:../src/stm32f30x_i2c.c ****     /* Enable slave byte control */
 508:../src/stm32f30x_i2c.c ****     I2Cx->CR1 |= I2C_CR1_SBC;
 725              		.loc 1 508 0
 726 0352 7B68     		ldr	r3, [r7, #4]
 727 0354 1B68     		ldr	r3, [r3, #0]
 728 0356 43F48032 		orr	r2, r3, #65536
 729 035a 7B68     		ldr	r3, [r7, #4]
 730 035c 1A60     		str	r2, [r3, #0]
 731 035e 05E0     		b	.L26
 732              	.L27:
 509:../src/stm32f30x_i2c.c ****   }
 510:../src/stm32f30x_i2c.c ****   else
 511:../src/stm32f30x_i2c.c ****   {
 512:../src/stm32f30x_i2c.c ****     /* Disable slave byte control */
 513:../src/stm32f30x_i2c.c ****     I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_SBC);
 733              		.loc 1 513 0
 734 0360 7B68     		ldr	r3, [r7, #4]
 735 0362 1B68     		ldr	r3, [r3, #0]
 736 0364 23F48032 		bic	r2, r3, #65536
 737 0368 7B68     		ldr	r3, [r7, #4]
 738 036a 1A60     		str	r2, [r3, #0]
 739              	.L26:
 514:../src/stm32f30x_i2c.c ****   }
 515:../src/stm32f30x_i2c.c **** }
 740              		.loc 1 515 0
 741 036c 07F10C07 		add	r7, r7, #12
 742 0370 BD46     		mov	sp, r7
 743 0372 80BC     		pop	{r7}
 744 0374 7047     		bx	lr
 745              		.cfi_endproc
 746              	.LFE122:
 748 0376 00BF     		.align	2
 749              		.global	I2C_SlaveAddressConfig
 750              		.thumb
 751              		.thumb_func
 753              	I2C_SlaveAddressConfig:
 754              	.LFB123:
 516:../src/stm32f30x_i2c.c **** 
 517:../src/stm32f30x_i2c.c **** /**
 518:../src/stm32f30x_i2c.c ****   * @brief  Configures the slave address to be transmitted after start generation.
 519:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 520:../src/stm32f30x_i2c.c ****   * @param  Address: specifies the slave address to be programmed.
 521:../src/stm32f30x_i2c.c ****   * @note   This function should be called before generating start condition.  
 522:../src/stm32f30x_i2c.c ****   * @retval None
 523:../src/stm32f30x_i2c.c ****   */
 524:../src/stm32f30x_i2c.c **** void I2C_SlaveAddressConfig(I2C_TypeDef* I2Cx, uint16_t Address)
 525:../src/stm32f30x_i2c.c **** {
 755              		.loc 1 525 0
 756              		.cfi_startproc
 757              		@ args = 0, pretend = 0, frame = 16
 758              		@ frame_needed = 1, uses_anonymous_args = 0
 759              		@ link register save eliminated.
 760 0378 80B4     		push	{r7}
 761              	.LCFI36:
 762              		.cfi_def_cfa_offset 4
 763              		.cfi_offset 7, -4
 764 037a 85B0     		sub	sp, sp, #20
 765              	.LCFI37:
 766              		.cfi_def_cfa_offset 24
 767 037c 00AF     		add	r7, sp, #0
 768              	.LCFI38:
 769              		.cfi_def_cfa_register 7
 770 037e 7860     		str	r0, [r7, #4]
 771 0380 0B46     		mov	r3, r1
 772 0382 7B80     		strh	r3, [r7, #2]	@ movhi
 526:../src/stm32f30x_i2c.c ****   uint32_t tmpreg = 0;
 773              		.loc 1 526 0
 774 0384 4FF00003 		mov	r3, #0
 775 0388 FB60     		str	r3, [r7, #12]
 527:../src/stm32f30x_i2c.c **** 
 528:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 529:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 530:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_SLAVE_ADDRESS(Address));
 531:../src/stm32f30x_i2c.c ****                
 532:../src/stm32f30x_i2c.c ****   /* Get the old register value */
 533:../src/stm32f30x_i2c.c ****   tmpreg = I2Cx->CR2;
 776              		.loc 1 533 0
 777 038a 7B68     		ldr	r3, [r7, #4]
 778 038c 5B68     		ldr	r3, [r3, #4]
 779 038e FB60     		str	r3, [r7, #12]
 534:../src/stm32f30x_i2c.c **** 
 535:../src/stm32f30x_i2c.c ****   /* Reset I2Cx SADD bit [9:0] */
 536:../src/stm32f30x_i2c.c ****   tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_SADD);
 780              		.loc 1 536 0
 781 0390 FB68     		ldr	r3, [r7, #12]
 782 0392 23F47F73 		bic	r3, r3, #1020
 783 0396 23F00303 		bic	r3, r3, #3
 784 039a FB60     		str	r3, [r7, #12]
 537:../src/stm32f30x_i2c.c **** 
 538:../src/stm32f30x_i2c.c ****   /* Set I2Cx SADD */
 539:../src/stm32f30x_i2c.c ****   tmpreg |= (uint32_t)((uint32_t)Address & I2C_CR2_SADD);
 785              		.loc 1 539 0
 786 039c 7B88     		ldrh	r3, [r7, #2]
 787 039e 4FEA8353 		lsl	r3, r3, #22
 788 03a2 4FEA9353 		lsr	r3, r3, #22
 789 03a6 FA68     		ldr	r2, [r7, #12]
 790 03a8 1343     		orrs	r3, r3, r2
 791 03aa FB60     		str	r3, [r7, #12]
 540:../src/stm32f30x_i2c.c **** 
 541:../src/stm32f30x_i2c.c ****   /* Store the new register value */
 542:../src/stm32f30x_i2c.c ****   I2Cx->CR2 = tmpreg;
 792              		.loc 1 542 0
 793 03ac 7B68     		ldr	r3, [r7, #4]
 794 03ae FA68     		ldr	r2, [r7, #12]
 795 03b0 5A60     		str	r2, [r3, #4]
 543:../src/stm32f30x_i2c.c **** }
 796              		.loc 1 543 0
 797 03b2 07F11407 		add	r7, r7, #20
 798 03b6 BD46     		mov	sp, r7
 799 03b8 80BC     		pop	{r7}
 800 03ba 7047     		bx	lr
 801              		.cfi_endproc
 802              	.LFE123:
 804              		.align	2
 805              		.global	I2C_10BitAddressingModeCmd
 806              		.thumb
 807              		.thumb_func
 809              	I2C_10BitAddressingModeCmd:
 810              	.LFB124:
 544:../src/stm32f30x_i2c.c ****   
 545:../src/stm32f30x_i2c.c **** /**
 546:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables the I2C 10-bit addressing mode for the master.
 547:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 548:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2C 10-bit addressing mode.
 549:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
 550:../src/stm32f30x_i2c.c ****   * @note   This function should be called before generating start condition.  
 551:../src/stm32f30x_i2c.c ****   * @retval None
 552:../src/stm32f30x_i2c.c ****   */
 553:../src/stm32f30x_i2c.c **** void I2C_10BitAddressingModeCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
 554:../src/stm32f30x_i2c.c **** {
 811              		.loc 1 554 0
 812              		.cfi_startproc
 813              		@ args = 0, pretend = 0, frame = 8
 814              		@ frame_needed = 1, uses_anonymous_args = 0
 815              		@ link register save eliminated.
 816 03bc 80B4     		push	{r7}
 817              	.LCFI39:
 818              		.cfi_def_cfa_offset 4
 819              		.cfi_offset 7, -4
 820 03be 83B0     		sub	sp, sp, #12
 821              	.LCFI40:
 822              		.cfi_def_cfa_offset 16
 823 03c0 00AF     		add	r7, sp, #0
 824              	.LCFI41:
 825              		.cfi_def_cfa_register 7
 826 03c2 7860     		str	r0, [r7, #4]
 827 03c4 0B46     		mov	r3, r1
 828 03c6 FB70     		strb	r3, [r7, #3]
 555:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 556:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 557:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 558:../src/stm32f30x_i2c.c ****   
 559:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 829              		.loc 1 559 0
 830 03c8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 831 03ca 002B     		cmp	r3, #0
 832 03cc 06D0     		beq	.L31
 560:../src/stm32f30x_i2c.c ****   {
 561:../src/stm32f30x_i2c.c ****     /* Enable 10-bit addressing mode */
 562:../src/stm32f30x_i2c.c ****     I2Cx->CR2 |= I2C_CR2_ADD10;
 833              		.loc 1 562 0
 834 03ce 7B68     		ldr	r3, [r7, #4]
 835 03d0 5B68     		ldr	r3, [r3, #4]
 836 03d2 43F40062 		orr	r2, r3, #2048
 837 03d6 7B68     		ldr	r3, [r7, #4]
 838 03d8 5A60     		str	r2, [r3, #4]
 839 03da 05E0     		b	.L30
 840              	.L31:
 563:../src/stm32f30x_i2c.c ****   }
 564:../src/stm32f30x_i2c.c ****   else
 565:../src/stm32f30x_i2c.c ****   {
 566:../src/stm32f30x_i2c.c ****     /* Disable 10-bit addressing mode */
 567:../src/stm32f30x_i2c.c ****     I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_ADD10);
 841              		.loc 1 567 0
 842 03dc 7B68     		ldr	r3, [r7, #4]
 843 03de 5B68     		ldr	r3, [r3, #4]
 844 03e0 23F40062 		bic	r2, r3, #2048
 845 03e4 7B68     		ldr	r3, [r7, #4]
 846 03e6 5A60     		str	r2, [r3, #4]
 847              	.L30:
 568:../src/stm32f30x_i2c.c ****   }
 569:../src/stm32f30x_i2c.c **** } 
 848              		.loc 1 569 0
 849 03e8 07F10C07 		add	r7, r7, #12
 850 03ec BD46     		mov	sp, r7
 851 03ee 80BC     		pop	{r7}
 852 03f0 7047     		bx	lr
 853              		.cfi_endproc
 854              	.LFE124:
 856 03f2 00BF     		.align	2
 857              		.global	I2C_AutoEndCmd
 858              		.thumb
 859              		.thumb_func
 861              	I2C_AutoEndCmd:
 862              	.LFB125:
 570:../src/stm32f30x_i2c.c **** 
 571:../src/stm32f30x_i2c.c **** /**
 572:../src/stm32f30x_i2c.c ****   * @}
 573:../src/stm32f30x_i2c.c ****   */
 574:../src/stm32f30x_i2c.c **** 
 575:../src/stm32f30x_i2c.c **** 
 576:../src/stm32f30x_i2c.c **** /** @defgroup I2C_Group2 Communications handling functions
 577:../src/stm32f30x_i2c.c ****  *  @brief   Communications handling functions 
 578:../src/stm32f30x_i2c.c ****  *
 579:../src/stm32f30x_i2c.c **** @verbatim
 580:../src/stm32f30x_i2c.c ****  ===============================================================================
 581:../src/stm32f30x_i2c.c ****                   ##### Communications handling functions #####
 582:../src/stm32f30x_i2c.c ****  ===============================================================================  
 583:../src/stm32f30x_i2c.c ****     [..] This section provides a set of functions that handles I2C communication.
 584:../src/stm32f30x_i2c.c ****     
 585:../src/stm32f30x_i2c.c ****     [..] Automatic End mode is enabled using I2C_AutoEndCmd() function. When Reload
 586:../src/stm32f30x_i2c.c ****          mode is enabled via I2C_ReloadCmd() AutoEnd bit has no effect.
 587:../src/stm32f30x_i2c.c ****          
 588:../src/stm32f30x_i2c.c ****     [..] I2C_NumberOfBytesConfig() function set the number of bytes to be transferred,
 589:../src/stm32f30x_i2c.c ****          this configuration should be done before generating start condition in master 
 590:../src/stm32f30x_i2c.c ****          mode.
 591:../src/stm32f30x_i2c.c ****          
 592:../src/stm32f30x_i2c.c ****     [..] When switching from master write operation to read operation in 10Bit addressing
 593:../src/stm32f30x_i2c.c ****          mode, master can only sends the 1st 7 bits of the 10 bit address, followed by 
 594:../src/stm32f30x_i2c.c ****          Read direction by enabling HEADR bit using I2C_10BitAddressHeader() function.        
 595:../src/stm32f30x_i2c.c ****          
 596:../src/stm32f30x_i2c.c ****     [..] In master mode, when transferring more than 255 bytes Reload mode should be used
 597:../src/stm32f30x_i2c.c ****          to handle communication. In the first phase of transfer, Nbytes should be set to 
 598:../src/stm32f30x_i2c.c ****          255. After transferring these bytes TCR flag is set and I2C_TransferHandling()
 599:../src/stm32f30x_i2c.c ****          function should be called to handle remaining communication.
 600:../src/stm32f30x_i2c.c ****          
 601:../src/stm32f30x_i2c.c ****     [..] In master mode, when software end mode is selected when all data is transferred
 602:../src/stm32f30x_i2c.c ****          TC flag is set I2C_TransferHandling() function should be called to generate STOP
 603:../src/stm32f30x_i2c.c ****          or generate ReStart.                      
 604:../src/stm32f30x_i2c.c ****              
 605:../src/stm32f30x_i2c.c **** @endverbatim
 606:../src/stm32f30x_i2c.c ****   * @{
 607:../src/stm32f30x_i2c.c ****   */
 608:../src/stm32f30x_i2c.c ****   
 609:../src/stm32f30x_i2c.c **** /**
 610:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables the I2C automatic end mode (stop condition is 
 611:../src/stm32f30x_i2c.c ****   *         automatically sent when nbytes data are transferred).
 612:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 613:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2C automatic end mode.
 614:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
 615:../src/stm32f30x_i2c.c ****   * @note   This function has effect if Reload mode is disabled.   
 616:../src/stm32f30x_i2c.c ****   * @retval None
 617:../src/stm32f30x_i2c.c ****   */
 618:../src/stm32f30x_i2c.c **** void I2C_AutoEndCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
 619:../src/stm32f30x_i2c.c **** {
 863              		.loc 1 619 0
 864              		.cfi_startproc
 865              		@ args = 0, pretend = 0, frame = 8
 866              		@ frame_needed = 1, uses_anonymous_args = 0
 867              		@ link register save eliminated.
 868 03f4 80B4     		push	{r7}
 869              	.LCFI42:
 870              		.cfi_def_cfa_offset 4
 871              		.cfi_offset 7, -4
 872 03f6 83B0     		sub	sp, sp, #12
 873              	.LCFI43:
 874              		.cfi_def_cfa_offset 16
 875 03f8 00AF     		add	r7, sp, #0
 876              	.LCFI44:
 877              		.cfi_def_cfa_register 7
 878 03fa 7860     		str	r0, [r7, #4]
 879 03fc 0B46     		mov	r3, r1
 880 03fe FB70     		strb	r3, [r7, #3]
 620:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 621:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 622:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 623:../src/stm32f30x_i2c.c ****   
 624:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 881              		.loc 1 624 0
 882 0400 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 883 0402 002B     		cmp	r3, #0
 884 0404 06D0     		beq	.L34
 625:../src/stm32f30x_i2c.c ****   {
 626:../src/stm32f30x_i2c.c ****     /* Enable Auto end mode */
 627:../src/stm32f30x_i2c.c ****     I2Cx->CR2 |= I2C_CR2_AUTOEND;
 885              		.loc 1 627 0
 886 0406 7B68     		ldr	r3, [r7, #4]
 887 0408 5B68     		ldr	r3, [r3, #4]
 888 040a 43F00072 		orr	r2, r3, #33554432
 889 040e 7B68     		ldr	r3, [r7, #4]
 890 0410 5A60     		str	r2, [r3, #4]
 891 0412 05E0     		b	.L33
 892              	.L34:
 628:../src/stm32f30x_i2c.c ****   }
 629:../src/stm32f30x_i2c.c ****   else
 630:../src/stm32f30x_i2c.c ****   {
 631:../src/stm32f30x_i2c.c ****     /* Disable Auto end mode */
 632:../src/stm32f30x_i2c.c ****     I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_AUTOEND);
 893              		.loc 1 632 0
 894 0414 7B68     		ldr	r3, [r7, #4]
 895 0416 5B68     		ldr	r3, [r3, #4]
 896 0418 23F00072 		bic	r2, r3, #33554432
 897 041c 7B68     		ldr	r3, [r7, #4]
 898 041e 5A60     		str	r2, [r3, #4]
 899              	.L33:
 633:../src/stm32f30x_i2c.c ****   }
 634:../src/stm32f30x_i2c.c **** } 
 900              		.loc 1 634 0
 901 0420 07F10C07 		add	r7, r7, #12
 902 0424 BD46     		mov	sp, r7
 903 0426 80BC     		pop	{r7}
 904 0428 7047     		bx	lr
 905              		.cfi_endproc
 906              	.LFE125:
 908 042a 00BF     		.align	2
 909              		.global	I2C_ReloadCmd
 910              		.thumb
 911              		.thumb_func
 913              	I2C_ReloadCmd:
 914              	.LFB126:
 635:../src/stm32f30x_i2c.c **** 
 636:../src/stm32f30x_i2c.c **** /**
 637:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables the I2C nbytes reload mode.
 638:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 639:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the nbytes reload mode.
 640:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
 641:../src/stm32f30x_i2c.c ****   * @retval None
 642:../src/stm32f30x_i2c.c ****   */
 643:../src/stm32f30x_i2c.c **** void I2C_ReloadCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
 644:../src/stm32f30x_i2c.c **** {
 915              		.loc 1 644 0
 916              		.cfi_startproc
 917              		@ args = 0, pretend = 0, frame = 8
 918              		@ frame_needed = 1, uses_anonymous_args = 0
 919              		@ link register save eliminated.
 920 042c 80B4     		push	{r7}
 921              	.LCFI45:
 922              		.cfi_def_cfa_offset 4
 923              		.cfi_offset 7, -4
 924 042e 83B0     		sub	sp, sp, #12
 925              	.LCFI46:
 926              		.cfi_def_cfa_offset 16
 927 0430 00AF     		add	r7, sp, #0
 928              	.LCFI47:
 929              		.cfi_def_cfa_register 7
 930 0432 7860     		str	r0, [r7, #4]
 931 0434 0B46     		mov	r3, r1
 932 0436 FB70     		strb	r3, [r7, #3]
 645:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 646:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 647:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 648:../src/stm32f30x_i2c.c ****   
 649:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 933              		.loc 1 649 0
 934 0438 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 935 043a 002B     		cmp	r3, #0
 936 043c 06D0     		beq	.L37
 650:../src/stm32f30x_i2c.c ****   {
 651:../src/stm32f30x_i2c.c ****     /* Enable Auto Reload mode */
 652:../src/stm32f30x_i2c.c ****     I2Cx->CR2 |= I2C_CR2_RELOAD;
 937              		.loc 1 652 0
 938 043e 7B68     		ldr	r3, [r7, #4]
 939 0440 5B68     		ldr	r3, [r3, #4]
 940 0442 43F08072 		orr	r2, r3, #16777216
 941 0446 7B68     		ldr	r3, [r7, #4]
 942 0448 5A60     		str	r2, [r3, #4]
 943 044a 05E0     		b	.L36
 944              	.L37:
 653:../src/stm32f30x_i2c.c ****   }
 654:../src/stm32f30x_i2c.c ****   else
 655:../src/stm32f30x_i2c.c ****   {
 656:../src/stm32f30x_i2c.c ****     /* Disable Auto Reload mode */
 657:../src/stm32f30x_i2c.c ****     I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RELOAD);
 945              		.loc 1 657 0
 946 044c 7B68     		ldr	r3, [r7, #4]
 947 044e 5B68     		ldr	r3, [r3, #4]
 948 0450 23F08072 		bic	r2, r3, #16777216
 949 0454 7B68     		ldr	r3, [r7, #4]
 950 0456 5A60     		str	r2, [r3, #4]
 951              	.L36:
 658:../src/stm32f30x_i2c.c ****   }
 659:../src/stm32f30x_i2c.c **** }
 952              		.loc 1 659 0
 953 0458 07F10C07 		add	r7, r7, #12
 954 045c BD46     		mov	sp, r7
 955 045e 80BC     		pop	{r7}
 956 0460 7047     		bx	lr
 957              		.cfi_endproc
 958              	.LFE126:
 960 0462 00BF     		.align	2
 961              		.global	I2C_NumberOfBytesConfig
 962              		.thumb
 963              		.thumb_func
 965              	I2C_NumberOfBytesConfig:
 966              	.LFB127:
 660:../src/stm32f30x_i2c.c **** 
 661:../src/stm32f30x_i2c.c **** /**
 662:../src/stm32f30x_i2c.c ****   * @brief  Configures the number of bytes to be transmitted/received.
 663:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 664:../src/stm32f30x_i2c.c ****   * @param  Number_Bytes: specifies the number of bytes to be programmed.
 665:../src/stm32f30x_i2c.c ****   * @retval None
 666:../src/stm32f30x_i2c.c ****   */
 667:../src/stm32f30x_i2c.c **** void I2C_NumberOfBytesConfig(I2C_TypeDef* I2Cx, uint8_t Number_Bytes)
 668:../src/stm32f30x_i2c.c **** {
 967              		.loc 1 668 0
 968              		.cfi_startproc
 969              		@ args = 0, pretend = 0, frame = 16
 970              		@ frame_needed = 1, uses_anonymous_args = 0
 971              		@ link register save eliminated.
 972 0464 80B4     		push	{r7}
 973              	.LCFI48:
 974              		.cfi_def_cfa_offset 4
 975              		.cfi_offset 7, -4
 976 0466 85B0     		sub	sp, sp, #20
 977              	.LCFI49:
 978              		.cfi_def_cfa_offset 24
 979 0468 00AF     		add	r7, sp, #0
 980              	.LCFI50:
 981              		.cfi_def_cfa_register 7
 982 046a 7860     		str	r0, [r7, #4]
 983 046c 0B46     		mov	r3, r1
 984 046e FB70     		strb	r3, [r7, #3]
 669:../src/stm32f30x_i2c.c ****   uint32_t tmpreg = 0;
 985              		.loc 1 669 0
 986 0470 4FF00003 		mov	r3, #0
 987 0474 FB60     		str	r3, [r7, #12]
 670:../src/stm32f30x_i2c.c **** 
 671:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 672:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 673:../src/stm32f30x_i2c.c **** 
 674:../src/stm32f30x_i2c.c ****   /* Get the old register value */
 675:../src/stm32f30x_i2c.c ****   tmpreg = I2Cx->CR2;
 988              		.loc 1 675 0
 989 0476 7B68     		ldr	r3, [r7, #4]
 990 0478 5B68     		ldr	r3, [r3, #4]
 991 047a FB60     		str	r3, [r7, #12]
 676:../src/stm32f30x_i2c.c **** 
 677:../src/stm32f30x_i2c.c ****   /* Reset I2Cx Nbytes bit [7:0] */
 678:../src/stm32f30x_i2c.c ****   tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_NBYTES);
 992              		.loc 1 678 0
 993 047c FB68     		ldr	r3, [r7, #12]
 994 047e 23F47F03 		bic	r3, r3, #16711680
 995 0482 FB60     		str	r3, [r7, #12]
 679:../src/stm32f30x_i2c.c **** 
 680:../src/stm32f30x_i2c.c ****   /* Set I2Cx Nbytes */
 681:../src/stm32f30x_i2c.c ****   tmpreg |= (uint32_t)(((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES);
 996              		.loc 1 681 0
 997 0484 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 998 0486 4FEA0343 		lsl	r3, r3, #16
 999 048a 03F47F03 		and	r3, r3, #16711680
 1000 048e FA68     		ldr	r2, [r7, #12]
 1001 0490 1343     		orrs	r3, r3, r2
 1002 0492 FB60     		str	r3, [r7, #12]
 682:../src/stm32f30x_i2c.c **** 
 683:../src/stm32f30x_i2c.c ****   /* Store the new register value */
 684:../src/stm32f30x_i2c.c ****   I2Cx->CR2 = tmpreg;
 1003              		.loc 1 684 0
 1004 0494 7B68     		ldr	r3, [r7, #4]
 1005 0496 FA68     		ldr	r2, [r7, #12]
 1006 0498 5A60     		str	r2, [r3, #4]
 685:../src/stm32f30x_i2c.c **** }  
 1007              		.loc 1 685 0
 1008 049a 07F11407 		add	r7, r7, #20
 1009 049e BD46     		mov	sp, r7
 1010 04a0 80BC     		pop	{r7}
 1011 04a2 7047     		bx	lr
 1012              		.cfi_endproc
 1013              	.LFE127:
 1015              		.align	2
 1016              		.global	I2C_MasterRequestConfig
 1017              		.thumb
 1018              		.thumb_func
 1020              	I2C_MasterRequestConfig:
 1021              	.LFB128:
 686:../src/stm32f30x_i2c.c ****   
 687:../src/stm32f30x_i2c.c **** /**
 688:../src/stm32f30x_i2c.c ****   * @brief  Configures the type of transfer request for the master.
 689:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 690:../src/stm32f30x_i2c.c ****   * @param  I2C_Direction: specifies the transfer request direction to be programmed.
 691:../src/stm32f30x_i2c.c ****   *    This parameter can be one of the following values:
 692:../src/stm32f30x_i2c.c ****   *     @arg I2C_Direction_Transmitter: Master request a write transfer
 693:../src/stm32f30x_i2c.c ****   *     @arg I2C_Direction_Receiver: Master request a read transfer 
 694:../src/stm32f30x_i2c.c ****   * @retval None
 695:../src/stm32f30x_i2c.c ****   */
 696:../src/stm32f30x_i2c.c **** void I2C_MasterRequestConfig(I2C_TypeDef* I2Cx, uint16_t I2C_Direction)
 697:../src/stm32f30x_i2c.c **** {
 1022              		.loc 1 697 0
 1023              		.cfi_startproc
 1024              		@ args = 0, pretend = 0, frame = 8
 1025              		@ frame_needed = 1, uses_anonymous_args = 0
 1026              		@ link register save eliminated.
 1027 04a4 80B4     		push	{r7}
 1028              	.LCFI51:
 1029              		.cfi_def_cfa_offset 4
 1030              		.cfi_offset 7, -4
 1031 04a6 83B0     		sub	sp, sp, #12
 1032              	.LCFI52:
 1033              		.cfi_def_cfa_offset 16
 1034 04a8 00AF     		add	r7, sp, #0
 1035              	.LCFI53:
 1036              		.cfi_def_cfa_register 7
 1037 04aa 7860     		str	r0, [r7, #4]
 1038 04ac 0B46     		mov	r3, r1
 1039 04ae 7B80     		strh	r3, [r7, #2]	@ movhi
 698:../src/stm32f30x_i2c.c **** /* Check the parameters */
 699:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 700:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_DIRECTION(I2C_Direction));
 701:../src/stm32f30x_i2c.c ****   
 702:../src/stm32f30x_i2c.c ****   /* Test on the direction to set/reset the read/write bit */
 703:../src/stm32f30x_i2c.c ****   if (I2C_Direction == I2C_Direction_Transmitter)
 1040              		.loc 1 703 0
 1041 04b0 7B88     		ldrh	r3, [r7, #2]
 1042 04b2 002B     		cmp	r3, #0
 1043 04b4 06D1     		bne	.L41
 704:../src/stm32f30x_i2c.c ****   {
 705:../src/stm32f30x_i2c.c ****     /* Request a write Transfer */
 706:../src/stm32f30x_i2c.c ****     I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RD_WRN);
 1044              		.loc 1 706 0
 1045 04b6 7B68     		ldr	r3, [r7, #4]
 1046 04b8 5B68     		ldr	r3, [r3, #4]
 1047 04ba 23F48062 		bic	r2, r3, #1024
 1048 04be 7B68     		ldr	r3, [r7, #4]
 1049 04c0 5A60     		str	r2, [r3, #4]
 1050 04c2 05E0     		b	.L40
 1051              	.L41:
 707:../src/stm32f30x_i2c.c ****   }
 708:../src/stm32f30x_i2c.c ****   else
 709:../src/stm32f30x_i2c.c ****   {
 710:../src/stm32f30x_i2c.c ****     /* Request a read Transfer */
 711:../src/stm32f30x_i2c.c ****     I2Cx->CR2 |= I2C_CR2_RD_WRN;
 1052              		.loc 1 711 0
 1053 04c4 7B68     		ldr	r3, [r7, #4]
 1054 04c6 5B68     		ldr	r3, [r3, #4]
 1055 04c8 43F48062 		orr	r2, r3, #1024
 1056 04cc 7B68     		ldr	r3, [r7, #4]
 1057 04ce 5A60     		str	r2, [r3, #4]
 1058              	.L40:
 712:../src/stm32f30x_i2c.c ****   }
 713:../src/stm32f30x_i2c.c **** }  
 1059              		.loc 1 713 0
 1060 04d0 07F10C07 		add	r7, r7, #12
 1061 04d4 BD46     		mov	sp, r7
 1062 04d6 80BC     		pop	{r7}
 1063 04d8 7047     		bx	lr
 1064              		.cfi_endproc
 1065              	.LFE128:
 1067 04da 00BF     		.align	2
 1068              		.global	I2C_GenerateSTART
 1069              		.thumb
 1070              		.thumb_func
 1072              	I2C_GenerateSTART:
 1073              	.LFB129:
 714:../src/stm32f30x_i2c.c ****   
 715:../src/stm32f30x_i2c.c **** /**
 716:../src/stm32f30x_i2c.c ****   * @brief  Generates I2Cx communication START condition.
 717:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 718:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2C START condition generation.
 719:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
 720:../src/stm32f30x_i2c.c ****   * @retval None
 721:../src/stm32f30x_i2c.c ****   */
 722:../src/stm32f30x_i2c.c **** void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
 723:../src/stm32f30x_i2c.c **** {
 1074              		.loc 1 723 0
 1075              		.cfi_startproc
 1076              		@ args = 0, pretend = 0, frame = 8
 1077              		@ frame_needed = 1, uses_anonymous_args = 0
 1078              		@ link register save eliminated.
 1079 04dc 80B4     		push	{r7}
 1080              	.LCFI54:
 1081              		.cfi_def_cfa_offset 4
 1082              		.cfi_offset 7, -4
 1083 04de 83B0     		sub	sp, sp, #12
 1084              	.LCFI55:
 1085              		.cfi_def_cfa_offset 16
 1086 04e0 00AF     		add	r7, sp, #0
 1087              	.LCFI56:
 1088              		.cfi_def_cfa_register 7
 1089 04e2 7860     		str	r0, [r7, #4]
 1090 04e4 0B46     		mov	r3, r1
 1091 04e6 FB70     		strb	r3, [r7, #3]
 724:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 725:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 726:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 727:../src/stm32f30x_i2c.c ****   
 728:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 1092              		.loc 1 728 0
 1093 04e8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1094 04ea 002B     		cmp	r3, #0
 1095 04ec 06D0     		beq	.L44
 729:../src/stm32f30x_i2c.c ****   {
 730:../src/stm32f30x_i2c.c ****     /* Generate a START condition */
 731:../src/stm32f30x_i2c.c ****     I2Cx->CR2 |= I2C_CR2_START;
 1096              		.loc 1 731 0
 1097 04ee 7B68     		ldr	r3, [r7, #4]
 1098 04f0 5B68     		ldr	r3, [r3, #4]
 1099 04f2 43F40052 		orr	r2, r3, #8192
 1100 04f6 7B68     		ldr	r3, [r7, #4]
 1101 04f8 5A60     		str	r2, [r3, #4]
 1102 04fa 05E0     		b	.L43
 1103              	.L44:
 732:../src/stm32f30x_i2c.c ****   }
 733:../src/stm32f30x_i2c.c ****   else
 734:../src/stm32f30x_i2c.c ****   {
 735:../src/stm32f30x_i2c.c ****     /* Disable the START condition generation */
 736:../src/stm32f30x_i2c.c ****     I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_START);
 1104              		.loc 1 736 0
 1105 04fc 7B68     		ldr	r3, [r7, #4]
 1106 04fe 5B68     		ldr	r3, [r3, #4]
 1107 0500 23F40052 		bic	r2, r3, #8192
 1108 0504 7B68     		ldr	r3, [r7, #4]
 1109 0506 5A60     		str	r2, [r3, #4]
 1110              	.L43:
 737:../src/stm32f30x_i2c.c ****   }
 738:../src/stm32f30x_i2c.c **** }  
 1111              		.loc 1 738 0
 1112 0508 07F10C07 		add	r7, r7, #12
 1113 050c BD46     		mov	sp, r7
 1114 050e 80BC     		pop	{r7}
 1115 0510 7047     		bx	lr
 1116              		.cfi_endproc
 1117              	.LFE129:
 1119 0512 00BF     		.align	2
 1120              		.global	I2C_GenerateSTOP
 1121              		.thumb
 1122              		.thumb_func
 1124              	I2C_GenerateSTOP:
 1125              	.LFB130:
 739:../src/stm32f30x_i2c.c ****   
 740:../src/stm32f30x_i2c.c **** /**
 741:../src/stm32f30x_i2c.c ****   * @brief  Generates I2Cx communication STOP condition.
 742:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 743:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2C STOP condition generation.
 744:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
 745:../src/stm32f30x_i2c.c ****   * @retval None
 746:../src/stm32f30x_i2c.c ****   */
 747:../src/stm32f30x_i2c.c **** void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
 748:../src/stm32f30x_i2c.c **** {
 1126              		.loc 1 748 0
 1127              		.cfi_startproc
 1128              		@ args = 0, pretend = 0, frame = 8
 1129              		@ frame_needed = 1, uses_anonymous_args = 0
 1130              		@ link register save eliminated.
 1131 0514 80B4     		push	{r7}
 1132              	.LCFI57:
 1133              		.cfi_def_cfa_offset 4
 1134              		.cfi_offset 7, -4
 1135 0516 83B0     		sub	sp, sp, #12
 1136              	.LCFI58:
 1137              		.cfi_def_cfa_offset 16
 1138 0518 00AF     		add	r7, sp, #0
 1139              	.LCFI59:
 1140              		.cfi_def_cfa_register 7
 1141 051a 7860     		str	r0, [r7, #4]
 1142 051c 0B46     		mov	r3, r1
 1143 051e FB70     		strb	r3, [r7, #3]
 749:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 750:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 751:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 752:../src/stm32f30x_i2c.c ****   
 753:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 1144              		.loc 1 753 0
 1145 0520 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1146 0522 002B     		cmp	r3, #0
 1147 0524 06D0     		beq	.L47
 754:../src/stm32f30x_i2c.c ****   {
 755:../src/stm32f30x_i2c.c ****     /* Generate a STOP condition */
 756:../src/stm32f30x_i2c.c ****     I2Cx->CR2 |= I2C_CR2_STOP;
 1148              		.loc 1 756 0
 1149 0526 7B68     		ldr	r3, [r7, #4]
 1150 0528 5B68     		ldr	r3, [r3, #4]
 1151 052a 43F48042 		orr	r2, r3, #16384
 1152 052e 7B68     		ldr	r3, [r7, #4]
 1153 0530 5A60     		str	r2, [r3, #4]
 1154 0532 05E0     		b	.L46
 1155              	.L47:
 757:../src/stm32f30x_i2c.c ****   }
 758:../src/stm32f30x_i2c.c ****   else
 759:../src/stm32f30x_i2c.c ****   {
 760:../src/stm32f30x_i2c.c ****     /* Disable the STOP condition generation */
 761:../src/stm32f30x_i2c.c ****     I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_STOP);
 1156              		.loc 1 761 0
 1157 0534 7B68     		ldr	r3, [r7, #4]
 1158 0536 5B68     		ldr	r3, [r3, #4]
 1159 0538 23F48042 		bic	r2, r3, #16384
 1160 053c 7B68     		ldr	r3, [r7, #4]
 1161 053e 5A60     		str	r2, [r3, #4]
 1162              	.L46:
 762:../src/stm32f30x_i2c.c ****   }
 763:../src/stm32f30x_i2c.c **** }  
 1163              		.loc 1 763 0
 1164 0540 07F10C07 		add	r7, r7, #12
 1165 0544 BD46     		mov	sp, r7
 1166 0546 80BC     		pop	{r7}
 1167 0548 7047     		bx	lr
 1168              		.cfi_endproc
 1169              	.LFE130:
 1171 054a 00BF     		.align	2
 1172              		.global	I2C_10BitAddressHeaderCmd
 1173              		.thumb
 1174              		.thumb_func
 1176              	I2C_10BitAddressHeaderCmd:
 1177              	.LFB131:
 764:../src/stm32f30x_i2c.c **** 
 765:../src/stm32f30x_i2c.c **** /**
 766:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables the I2C 10-bit header only mode with read direction.
 767:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 768:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2C 10-bit header only mode.
 769:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
 770:../src/stm32f30x_i2c.c ****   * @note   This mode can be used only when switching from master transmitter mode 
 771:../src/stm32f30x_i2c.c ****   *         to master receiver mode.        
 772:../src/stm32f30x_i2c.c ****   * @retval None
 773:../src/stm32f30x_i2c.c ****   */
 774:../src/stm32f30x_i2c.c **** void I2C_10BitAddressHeaderCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
 775:../src/stm32f30x_i2c.c **** {
 1178              		.loc 1 775 0
 1179              		.cfi_startproc
 1180              		@ args = 0, pretend = 0, frame = 8
 1181              		@ frame_needed = 1, uses_anonymous_args = 0
 1182              		@ link register save eliminated.
 1183 054c 80B4     		push	{r7}
 1184              	.LCFI60:
 1185              		.cfi_def_cfa_offset 4
 1186              		.cfi_offset 7, -4
 1187 054e 83B0     		sub	sp, sp, #12
 1188              	.LCFI61:
 1189              		.cfi_def_cfa_offset 16
 1190 0550 00AF     		add	r7, sp, #0
 1191              	.LCFI62:
 1192              		.cfi_def_cfa_register 7
 1193 0552 7860     		str	r0, [r7, #4]
 1194 0554 0B46     		mov	r3, r1
 1195 0556 FB70     		strb	r3, [r7, #3]
 776:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 777:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 778:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 779:../src/stm32f30x_i2c.c ****   
 780:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 1196              		.loc 1 780 0
 1197 0558 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1198 055a 002B     		cmp	r3, #0
 1199 055c 06D0     		beq	.L50
 781:../src/stm32f30x_i2c.c ****   {
 782:../src/stm32f30x_i2c.c ****     /* Enable 10-bit header only mode */
 783:../src/stm32f30x_i2c.c ****     I2Cx->CR2 |= I2C_CR2_HEAD10R;
 1200              		.loc 1 783 0
 1201 055e 7B68     		ldr	r3, [r7, #4]
 1202 0560 5B68     		ldr	r3, [r3, #4]
 1203 0562 43F48052 		orr	r2, r3, #4096
 1204 0566 7B68     		ldr	r3, [r7, #4]
 1205 0568 5A60     		str	r2, [r3, #4]
 1206 056a 05E0     		b	.L49
 1207              	.L50:
 784:../src/stm32f30x_i2c.c ****   }
 785:../src/stm32f30x_i2c.c ****   else
 786:../src/stm32f30x_i2c.c ****   {
 787:../src/stm32f30x_i2c.c ****     /* Disable 10-bit header only mode */
 788:../src/stm32f30x_i2c.c ****     I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_HEAD10R);
 1208              		.loc 1 788 0
 1209 056c 7B68     		ldr	r3, [r7, #4]
 1210 056e 5B68     		ldr	r3, [r3, #4]
 1211 0570 23F48052 		bic	r2, r3, #4096
 1212 0574 7B68     		ldr	r3, [r7, #4]
 1213 0576 5A60     		str	r2, [r3, #4]
 1214              	.L49:
 789:../src/stm32f30x_i2c.c ****   }
 790:../src/stm32f30x_i2c.c **** }    
 1215              		.loc 1 790 0
 1216 0578 07F10C07 		add	r7, r7, #12
 1217 057c BD46     		mov	sp, r7
 1218 057e 80BC     		pop	{r7}
 1219 0580 7047     		bx	lr
 1220              		.cfi_endproc
 1221              	.LFE131:
 1223 0582 00BF     		.align	2
 1224              		.global	I2C_AcknowledgeConfig
 1225              		.thumb
 1226              		.thumb_func
 1228              	I2C_AcknowledgeConfig:
 1229              	.LFB132:
 791:../src/stm32f30x_i2c.c **** 
 792:../src/stm32f30x_i2c.c **** /**
 793:../src/stm32f30x_i2c.c ****   * @brief  Generates I2C communication Acknowledge.
 794:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 795:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the Acknowledge.
 796:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.  
 797:../src/stm32f30x_i2c.c ****   * @retval None
 798:../src/stm32f30x_i2c.c ****   */
 799:../src/stm32f30x_i2c.c **** void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
 800:../src/stm32f30x_i2c.c **** {
 1230              		.loc 1 800 0
 1231              		.cfi_startproc
 1232              		@ args = 0, pretend = 0, frame = 8
 1233              		@ frame_needed = 1, uses_anonymous_args = 0
 1234              		@ link register save eliminated.
 1235 0584 80B4     		push	{r7}
 1236              	.LCFI63:
 1237              		.cfi_def_cfa_offset 4
 1238              		.cfi_offset 7, -4
 1239 0586 83B0     		sub	sp, sp, #12
 1240              	.LCFI64:
 1241              		.cfi_def_cfa_offset 16
 1242 0588 00AF     		add	r7, sp, #0
 1243              	.LCFI65:
 1244              		.cfi_def_cfa_register 7
 1245 058a 7860     		str	r0, [r7, #4]
 1246 058c 0B46     		mov	r3, r1
 1247 058e FB70     		strb	r3, [r7, #3]
 801:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 802:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 803:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 804:../src/stm32f30x_i2c.c ****   
 805:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 1248              		.loc 1 805 0
 1249 0590 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1250 0592 002B     		cmp	r3, #0
 1251 0594 06D0     		beq	.L53
 806:../src/stm32f30x_i2c.c ****   {
 807:../src/stm32f30x_i2c.c ****     /* Enable ACK generation */
 808:../src/stm32f30x_i2c.c ****     I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_NACK);    
 1252              		.loc 1 808 0
 1253 0596 7B68     		ldr	r3, [r7, #4]
 1254 0598 5B68     		ldr	r3, [r3, #4]
 1255 059a 23F40042 		bic	r2, r3, #32768
 1256 059e 7B68     		ldr	r3, [r7, #4]
 1257 05a0 5A60     		str	r2, [r3, #4]
 1258 05a2 05E0     		b	.L52
 1259              	.L53:
 809:../src/stm32f30x_i2c.c ****   }
 810:../src/stm32f30x_i2c.c ****   else
 811:../src/stm32f30x_i2c.c ****   {
 812:../src/stm32f30x_i2c.c ****     /* Enable NACK generation */
 813:../src/stm32f30x_i2c.c ****     I2Cx->CR2 |= I2C_CR2_NACK;
 1260              		.loc 1 813 0
 1261 05a4 7B68     		ldr	r3, [r7, #4]
 1262 05a6 5B68     		ldr	r3, [r3, #4]
 1263 05a8 43F40042 		orr	r2, r3, #32768
 1264 05ac 7B68     		ldr	r3, [r7, #4]
 1265 05ae 5A60     		str	r2, [r3, #4]
 1266              	.L52:
 814:../src/stm32f30x_i2c.c ****   }
 815:../src/stm32f30x_i2c.c **** }
 1267              		.loc 1 815 0
 1268 05b0 07F10C07 		add	r7, r7, #12
 1269 05b4 BD46     		mov	sp, r7
 1270 05b6 80BC     		pop	{r7}
 1271 05b8 7047     		bx	lr
 1272              		.cfi_endproc
 1273              	.LFE132:
 1275 05ba 00BF     		.align	2
 1276              		.global	I2C_GetAddressMatched
 1277              		.thumb
 1278              		.thumb_func
 1280              	I2C_GetAddressMatched:
 1281              	.LFB133:
 816:../src/stm32f30x_i2c.c **** 
 817:../src/stm32f30x_i2c.c **** /**
 818:../src/stm32f30x_i2c.c ****   * @brief  Returns the I2C slave matched address .
 819:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 820:../src/stm32f30x_i2c.c ****   * @retval The value of the slave matched address .
 821:../src/stm32f30x_i2c.c ****   */
 822:../src/stm32f30x_i2c.c **** uint8_t I2C_GetAddressMatched(I2C_TypeDef* I2Cx)
 823:../src/stm32f30x_i2c.c **** {
 1282              		.loc 1 823 0
 1283              		.cfi_startproc
 1284              		@ args = 0, pretend = 0, frame = 8
 1285              		@ frame_needed = 1, uses_anonymous_args = 0
 1286              		@ link register save eliminated.
 1287 05bc 80B4     		push	{r7}
 1288              	.LCFI66:
 1289              		.cfi_def_cfa_offset 4
 1290              		.cfi_offset 7, -4
 1291 05be 83B0     		sub	sp, sp, #12
 1292              	.LCFI67:
 1293              		.cfi_def_cfa_offset 16
 1294 05c0 00AF     		add	r7, sp, #0
 1295              	.LCFI68:
 1296              		.cfi_def_cfa_register 7
 1297 05c2 7860     		str	r0, [r7, #4]
 824:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 825:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 826:../src/stm32f30x_i2c.c ****   
 827:../src/stm32f30x_i2c.c ****   /* Return the slave matched address in the SR1 register */
 828:../src/stm32f30x_i2c.c ****   return (uint8_t)(((uint32_t)I2Cx->ISR & I2C_ISR_ADDCODE) >> 16) ;
 1298              		.loc 1 828 0
 1299 05c4 7B68     		ldr	r3, [r7, #4]
 1300 05c6 9B69     		ldr	r3, [r3, #24]
 1301 05c8 03F47E03 		and	r3, r3, #16646144
 1302 05cc 4FEA1343 		lsr	r3, r3, #16
 1303 05d0 DBB2     		uxtb	r3, r3
 829:../src/stm32f30x_i2c.c **** }
 1304              		.loc 1 829 0
 1305 05d2 1846     		mov	r0, r3
 1306 05d4 07F10C07 		add	r7, r7, #12
 1307 05d8 BD46     		mov	sp, r7
 1308 05da 80BC     		pop	{r7}
 1309 05dc 7047     		bx	lr
 1310              		.cfi_endproc
 1311              	.LFE133:
 1313 05de 00BF     		.align	2
 1314              		.global	I2C_GetTransferDirection
 1315              		.thumb
 1316              		.thumb_func
 1318              	I2C_GetTransferDirection:
 1319              	.LFB134:
 830:../src/stm32f30x_i2c.c **** 
 831:../src/stm32f30x_i2c.c **** /**
 832:../src/stm32f30x_i2c.c ****   * @brief  Returns the I2C slave received request.
 833:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 834:../src/stm32f30x_i2c.c ****   * @retval The value of the received request.
 835:../src/stm32f30x_i2c.c ****   */
 836:../src/stm32f30x_i2c.c **** uint16_t I2C_GetTransferDirection(I2C_TypeDef* I2Cx)
 837:../src/stm32f30x_i2c.c **** {
 1320              		.loc 1 837 0
 1321              		.cfi_startproc
 1322              		@ args = 0, pretend = 0, frame = 16
 1323              		@ frame_needed = 1, uses_anonymous_args = 0
 1324              		@ link register save eliminated.
 1325 05e0 80B4     		push	{r7}
 1326              	.LCFI69:
 1327              		.cfi_def_cfa_offset 4
 1328              		.cfi_offset 7, -4
 1329 05e2 85B0     		sub	sp, sp, #20
 1330              	.LCFI70:
 1331              		.cfi_def_cfa_offset 24
 1332 05e4 00AF     		add	r7, sp, #0
 1333              	.LCFI71:
 1334              		.cfi_def_cfa_register 7
 1335 05e6 7860     		str	r0, [r7, #4]
 838:../src/stm32f30x_i2c.c ****   uint32_t tmpreg = 0;
 1336              		.loc 1 838 0
 1337 05e8 4FF00003 		mov	r3, #0
 1338 05ec BB60     		str	r3, [r7, #8]
 839:../src/stm32f30x_i2c.c ****   uint16_t direction = 0;
 1339              		.loc 1 839 0
 1340 05ee 4FF00003 		mov	r3, #0
 1341 05f2 FB81     		strh	r3, [r7, #14]	@ movhi
 840:../src/stm32f30x_i2c.c ****   
 841:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 842:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 843:../src/stm32f30x_i2c.c ****   
 844:../src/stm32f30x_i2c.c ****   /* Return the slave matched address in the SR1 register */
 845:../src/stm32f30x_i2c.c ****   tmpreg = (uint32_t)(I2Cx->ISR & I2C_ISR_DIR);
 1342              		.loc 1 845 0
 1343 05f4 7B68     		ldr	r3, [r7, #4]
 1344 05f6 9B69     		ldr	r3, [r3, #24]
 1345 05f8 03F48033 		and	r3, r3, #65536
 1346 05fc BB60     		str	r3, [r7, #8]
 846:../src/stm32f30x_i2c.c ****   
 847:../src/stm32f30x_i2c.c ****   /* If write transfer is requested */
 848:../src/stm32f30x_i2c.c ****   if (tmpreg == 0)
 1347              		.loc 1 848 0
 1348 05fe BB68     		ldr	r3, [r7, #8]
 1349 0600 002B     		cmp	r3, #0
 1350 0602 03D1     		bne	.L58
 849:../src/stm32f30x_i2c.c ****   {
 850:../src/stm32f30x_i2c.c ****     /* write transfer is requested */
 851:../src/stm32f30x_i2c.c ****     direction = I2C_Direction_Transmitter;
 1351              		.loc 1 851 0
 1352 0604 4FF00003 		mov	r3, #0
 1353 0608 FB81     		strh	r3, [r7, #14]	@ movhi
 1354 060a 02E0     		b	.L59
 1355              	.L58:
 852:../src/stm32f30x_i2c.c ****   }
 853:../src/stm32f30x_i2c.c ****   else
 854:../src/stm32f30x_i2c.c ****   {
 855:../src/stm32f30x_i2c.c ****     /* Read transfer is requested */
 856:../src/stm32f30x_i2c.c ****     direction = I2C_Direction_Receiver;
 1356              		.loc 1 856 0
 1357 060c 4FF48063 		mov	r3, #1024
 1358 0610 FB81     		strh	r3, [r7, #14]	@ movhi
 1359              	.L59:
 857:../src/stm32f30x_i2c.c ****   }  
 858:../src/stm32f30x_i2c.c ****   return direction;
 1360              		.loc 1 858 0
 1361 0612 FB89     		ldrh	r3, [r7, #14]
 859:../src/stm32f30x_i2c.c **** }
 1362              		.loc 1 859 0
 1363 0614 1846     		mov	r0, r3
 1364 0616 07F11407 		add	r7, r7, #20
 1365 061a BD46     		mov	sp, r7
 1366 061c 80BC     		pop	{r7}
 1367 061e 7047     		bx	lr
 1368              		.cfi_endproc
 1369              	.LFE134:
 1371              		.align	2
 1372              		.global	I2C_TransferHandling
 1373              		.thumb
 1374              		.thumb_func
 1376              	I2C_TransferHandling:
 1377              	.LFB135:
 860:../src/stm32f30x_i2c.c **** 
 861:../src/stm32f30x_i2c.c **** /**
 862:../src/stm32f30x_i2c.c ****   * @brief  Handles I2Cx communication when starting transfer or during transfer (TC or TCR flag ar
 863:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 864:../src/stm32f30x_i2c.c ****   * @param  Address: specifies the slave address to be programmed.
 865:../src/stm32f30x_i2c.c ****   * @param  Number_Bytes: specifies the number of bytes to be programmed.
 866:../src/stm32f30x_i2c.c ****   *   This parameter must be a value between 0 and 255.
 867:../src/stm32f30x_i2c.c ****   * @param  ReloadEndMode: new state of the I2C START condition generation.
 868:../src/stm32f30x_i2c.c ****   *   This parameter can be one of the following values:
 869:../src/stm32f30x_i2c.c ****   *     @arg I2C_Reload_Mode: Enable Reload mode .
 870:../src/stm32f30x_i2c.c ****   *     @arg I2C_AutoEnd_Mode: Enable Automatic end mode.
 871:../src/stm32f30x_i2c.c ****   *     @arg I2C_SoftEnd_Mode: Enable Software end mode.
 872:../src/stm32f30x_i2c.c ****   * @param  StartStopMode: new state of the I2C START condition generation.
 873:../src/stm32f30x_i2c.c ****   *   This parameter can be one of the following values:
 874:../src/stm32f30x_i2c.c ****   *     @arg I2C_No_StartStop: Don't Generate stop and start condition.
 875:../src/stm32f30x_i2c.c ****   *     @arg I2C_Generate_Stop: Generate stop condition (Number_Bytes should be set to 0).
 876:../src/stm32f30x_i2c.c ****   *     @arg I2C_Generate_Start_Read: Generate Restart for read request.
 877:../src/stm32f30x_i2c.c ****   *     @arg I2C_Generate_Start_Write: Generate Restart for write request.
 878:../src/stm32f30x_i2c.c ****   * @retval None
 879:../src/stm32f30x_i2c.c ****   */
 880:../src/stm32f30x_i2c.c **** void I2C_TransferHandling(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Number_Bytes, uint32_t Reloa
 881:../src/stm32f30x_i2c.c **** {
 1378              		.loc 1 881 0
 1379              		.cfi_startproc
 1380              		@ args = 4, pretend = 0, frame = 24
 1381              		@ frame_needed = 1, uses_anonymous_args = 0
 1382              		@ link register save eliminated.
 1383 0620 80B4     		push	{r7}
 1384              	.LCFI72:
 1385              		.cfi_def_cfa_offset 4
 1386              		.cfi_offset 7, -4
 1387 0622 87B0     		sub	sp, sp, #28
 1388              	.LCFI73:
 1389              		.cfi_def_cfa_offset 32
 1390 0624 00AF     		add	r7, sp, #0
 1391              	.LCFI74:
 1392              		.cfi_def_cfa_register 7
 1393 0626 F860     		str	r0, [r7, #12]
 1394 0628 7B60     		str	r3, [r7, #4]
 1395 062a 0B46     		mov	r3, r1	@ movhi
 1396 062c 7B81     		strh	r3, [r7, #10]	@ movhi
 1397 062e 1346     		mov	r3, r2
 1398 0630 7B72     		strb	r3, [r7, #9]
 882:../src/stm32f30x_i2c.c ****   uint32_t tmpreg = 0;
 1399              		.loc 1 882 0
 1400 0632 4FF00003 		mov	r3, #0
 1401 0636 7B61     		str	r3, [r7, #20]
 883:../src/stm32f30x_i2c.c ****   
 884:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 885:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 886:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_SLAVE_ADDRESS(Address));  
 887:../src/stm32f30x_i2c.c ****   assert_param(IS_RELOAD_END_MODE(ReloadEndMode));
 888:../src/stm32f30x_i2c.c ****   assert_param(IS_START_STOP_MODE(StartStopMode));
 889:../src/stm32f30x_i2c.c ****     
 890:../src/stm32f30x_i2c.c ****   /* Get the CR2 register value */
 891:../src/stm32f30x_i2c.c ****   tmpreg = I2Cx->CR2;
 1402              		.loc 1 891 0
 1403 0638 FB68     		ldr	r3, [r7, #12]
 1404 063a 5B68     		ldr	r3, [r3, #4]
 1405 063c 7B61     		str	r3, [r7, #20]
 892:../src/stm32f30x_i2c.c ****   
 893:../src/stm32f30x_i2c.c ****   /* clear tmpreg specific bits */
 894:../src/stm32f30x_i2c.c ****   tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND
 1406              		.loc 1 894 0
 1407 063e 7A69     		ldr	r2, [r7, #20]
 1408 0640 4FF41843 		mov	r3, #38912
 1409 0644 CFF60043 		movt	r3, 64512
 1410 0648 1340     		ands	r3, r3, r2
 1411 064a 7B61     		str	r3, [r7, #20]
 895:../src/stm32f30x_i2c.c ****   
 896:../src/stm32f30x_i2c.c ****   /* update tmpreg */
 897:../src/stm32f30x_i2c.c ****   tmpreg |= (uint32_t)(((uint32_t)Address & I2C_CR2_SADD) | (((uint32_t)Number_Bytes << 16 ) & I2C_
 1412              		.loc 1 897 0
 1413 064c 7B89     		ldrh	r3, [r7, #10]
 1414 064e 4FEA8353 		lsl	r3, r3, #22
 1415 0652 4FEA9353 		lsr	r3, r3, #22
 1416 0656 7A7A     		ldrb	r2, [r7, #9]	@ zero_extendqisi2
 1417 0658 4FEA0242 		lsl	r2, r2, #16
 1418 065c 02F47F02 		and	r2, r2, #16711680
 1419 0660 1A43     		orrs	r2, r2, r3
 1420 0662 7B68     		ldr	r3, [r7, #4]
 1421 0664 1A43     		orrs	r2, r2, r3
 1422 0666 3B6A     		ldr	r3, [r7, #32]
 1423 0668 1343     		orrs	r3, r3, r2
 1424 066a 7A69     		ldr	r2, [r7, #20]
 1425 066c 1343     		orrs	r3, r3, r2
 1426 066e 7B61     		str	r3, [r7, #20]
 898:../src/stm32f30x_i2c.c ****             (uint32_t)ReloadEndMode | (uint32_t)StartStopMode);
 899:../src/stm32f30x_i2c.c ****   
 900:../src/stm32f30x_i2c.c ****   /* update CR2 register */
 901:../src/stm32f30x_i2c.c ****   I2Cx->CR2 = tmpreg;  
 1427              		.loc 1 901 0
 1428 0670 FB68     		ldr	r3, [r7, #12]
 1429 0672 7A69     		ldr	r2, [r7, #20]
 1430 0674 5A60     		str	r2, [r3, #4]
 902:../src/stm32f30x_i2c.c **** }  
 1431              		.loc 1 902 0
 1432 0676 07F11C07 		add	r7, r7, #28
 1433 067a BD46     		mov	sp, r7
 1434 067c 80BC     		pop	{r7}
 1435 067e 7047     		bx	lr
 1436              		.cfi_endproc
 1437              	.LFE135:
 1439              		.align	2
 1440              		.global	I2C_SMBusAlertCmd
 1441              		.thumb
 1442              		.thumb_func
 1444              	I2C_SMBusAlertCmd:
 1445              	.LFB136:
 903:../src/stm32f30x_i2c.c **** 
 904:../src/stm32f30x_i2c.c **** /**
 905:../src/stm32f30x_i2c.c ****   * @}
 906:../src/stm32f30x_i2c.c ****   */
 907:../src/stm32f30x_i2c.c **** 
 908:../src/stm32f30x_i2c.c **** 
 909:../src/stm32f30x_i2c.c **** /** @defgroup I2C_Group3 SMBUS management functions
 910:../src/stm32f30x_i2c.c ****  *  @brief   SMBUS management functions 
 911:../src/stm32f30x_i2c.c ****  *
 912:../src/stm32f30x_i2c.c **** @verbatim
 913:../src/stm32f30x_i2c.c ****  ===============================================================================
 914:../src/stm32f30x_i2c.c ****                       ##### SMBUS management functions #####
 915:../src/stm32f30x_i2c.c ****  ===============================================================================   
 916:../src/stm32f30x_i2c.c ****     [..] This section provides a set of functions that handles SMBus communication
 917:../src/stm32f30x_i2c.c ****          and timeouts detection.
 918:../src/stm32f30x_i2c.c ****     
 919:../src/stm32f30x_i2c.c ****     [..] The SMBus Device default address (0b1100 001) is enabled by calling I2C_Init()
 920:../src/stm32f30x_i2c.c ****          function and setting I2C_Mode member of I2C_InitTypeDef() structure to 
 921:../src/stm32f30x_i2c.c ****          I2C_Mode_SMBusDevice.
 922:../src/stm32f30x_i2c.c ****          
 923:../src/stm32f30x_i2c.c ****     [..] The SMBus Host address (0b0001 000) is enabled by calling I2C_Init()
 924:../src/stm32f30x_i2c.c ****          function and setting I2C_Mode member of I2C_InitTypeDef() structure to 
 925:../src/stm32f30x_i2c.c ****          I2C_Mode_SMBusHost.         
 926:../src/stm32f30x_i2c.c ****          
 927:../src/stm32f30x_i2c.c ****     [..] The Alert Response Address (0b0001 100) is enabled using I2C_SMBusAlertCmd()
 928:../src/stm32f30x_i2c.c ****          function.
 929:../src/stm32f30x_i2c.c ****          
 930:../src/stm32f30x_i2c.c ****     [..] To detect cumulative SCL stretch in master and slave mode, TIMEOUTB should be 
 931:../src/stm32f30x_i2c.c ****          configured (in accordance to SMBus specification) using I2C_TimeoutBConfig() 
 932:../src/stm32f30x_i2c.c ****          function then I2C_ExtendedClockTimeoutCmd() function should be called to enable
 933:../src/stm32f30x_i2c.c ****          the detection.
 934:../src/stm32f30x_i2c.c ****          
 935:../src/stm32f30x_i2c.c ****     [..] SCL low timeout is detected by configuring TIMEOUTB using I2C_TimeoutBConfig()
 936:../src/stm32f30x_i2c.c ****          function followed by the call of I2C_ClockTimeoutCmd(). When adding to this 
 937:../src/stm32f30x_i2c.c ****          procedure the call of I2C_IdleClockTimeoutCmd() function, Bus Idle condition 
 938:../src/stm32f30x_i2c.c ****          (both SCL and SDA high) is detected also.                
 939:../src/stm32f30x_i2c.c ****                           
 940:../src/stm32f30x_i2c.c **** @endverbatim
 941:../src/stm32f30x_i2c.c ****   * @{
 942:../src/stm32f30x_i2c.c ****   */
 943:../src/stm32f30x_i2c.c **** 
 944:../src/stm32f30x_i2c.c **** /**
 945:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables I2C SMBus alert.
 946:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 947:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2Cx SMBus alert.
 948:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
 949:../src/stm32f30x_i2c.c ****   * @retval None
 950:../src/stm32f30x_i2c.c ****   */
 951:../src/stm32f30x_i2c.c **** void I2C_SMBusAlertCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
 952:../src/stm32f30x_i2c.c **** {
 1446              		.loc 1 952 0
 1447              		.cfi_startproc
 1448              		@ args = 0, pretend = 0, frame = 8
 1449              		@ frame_needed = 1, uses_anonymous_args = 0
 1450              		@ link register save eliminated.
 1451 0680 80B4     		push	{r7}
 1452              	.LCFI75:
 1453              		.cfi_def_cfa_offset 4
 1454              		.cfi_offset 7, -4
 1455 0682 83B0     		sub	sp, sp, #12
 1456              	.LCFI76:
 1457              		.cfi_def_cfa_offset 16
 1458 0684 00AF     		add	r7, sp, #0
 1459              	.LCFI77:
 1460              		.cfi_def_cfa_register 7
 1461 0686 7860     		str	r0, [r7, #4]
 1462 0688 0B46     		mov	r3, r1
 1463 068a FB70     		strb	r3, [r7, #3]
 953:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 954:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 955:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 956:../src/stm32f30x_i2c.c ****   
 957:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 1464              		.loc 1 957 0
 1465 068c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1466 068e 002B     		cmp	r3, #0
 1467 0690 06D0     		beq	.L63
 958:../src/stm32f30x_i2c.c ****   {
 959:../src/stm32f30x_i2c.c ****     /* Enable SMBus alert */
 960:../src/stm32f30x_i2c.c ****     I2Cx->CR1 |= I2C_CR1_ALERTEN;   
 1468              		.loc 1 960 0
 1469 0692 7B68     		ldr	r3, [r7, #4]
 1470 0694 1B68     		ldr	r3, [r3, #0]
 1471 0696 43F48002 		orr	r2, r3, #4194304
 1472 069a 7B68     		ldr	r3, [r7, #4]
 1473 069c 1A60     		str	r2, [r3, #0]
 1474 069e 05E0     		b	.L62
 1475              	.L63:
 961:../src/stm32f30x_i2c.c ****   }
 962:../src/stm32f30x_i2c.c ****   else
 963:../src/stm32f30x_i2c.c ****   {
 964:../src/stm32f30x_i2c.c ****     /* Disable SMBus alert */    
 965:../src/stm32f30x_i2c.c ****     I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_ALERTEN); 
 1476              		.loc 1 965 0
 1477 06a0 7B68     		ldr	r3, [r7, #4]
 1478 06a2 1B68     		ldr	r3, [r3, #0]
 1479 06a4 23F48002 		bic	r2, r3, #4194304
 1480 06a8 7B68     		ldr	r3, [r7, #4]
 1481 06aa 1A60     		str	r2, [r3, #0]
 1482              	.L62:
 966:../src/stm32f30x_i2c.c ****   }
 967:../src/stm32f30x_i2c.c **** }
 1483              		.loc 1 967 0
 1484 06ac 07F10C07 		add	r7, r7, #12
 1485 06b0 BD46     		mov	sp, r7
 1486 06b2 80BC     		pop	{r7}
 1487 06b4 7047     		bx	lr
 1488              		.cfi_endproc
 1489              	.LFE136:
 1491 06b6 00BF     		.align	2
 1492              		.global	I2C_ClockTimeoutCmd
 1493              		.thumb
 1494              		.thumb_func
 1496              	I2C_ClockTimeoutCmd:
 1497              	.LFB137:
 968:../src/stm32f30x_i2c.c **** 
 969:../src/stm32f30x_i2c.c **** /**
 970:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables I2C Clock Timeout (SCL Timeout detection).
 971:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 972:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2Cx clock Timeout.
 973:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
 974:../src/stm32f30x_i2c.c ****   * @retval None
 975:../src/stm32f30x_i2c.c ****   */
 976:../src/stm32f30x_i2c.c **** void I2C_ClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
 977:../src/stm32f30x_i2c.c **** {
 1498              		.loc 1 977 0
 1499              		.cfi_startproc
 1500              		@ args = 0, pretend = 0, frame = 8
 1501              		@ frame_needed = 1, uses_anonymous_args = 0
 1502              		@ link register save eliminated.
 1503 06b8 80B4     		push	{r7}
 1504              	.LCFI78:
 1505              		.cfi_def_cfa_offset 4
 1506              		.cfi_offset 7, -4
 1507 06ba 83B0     		sub	sp, sp, #12
 1508              	.LCFI79:
 1509              		.cfi_def_cfa_offset 16
 1510 06bc 00AF     		add	r7, sp, #0
 1511              	.LCFI80:
 1512              		.cfi_def_cfa_register 7
 1513 06be 7860     		str	r0, [r7, #4]
 1514 06c0 0B46     		mov	r3, r1
 1515 06c2 FB70     		strb	r3, [r7, #3]
 978:../src/stm32f30x_i2c.c ****   /* Check the parameters */
 979:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
 980:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 981:../src/stm32f30x_i2c.c ****   
 982:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 1516              		.loc 1 982 0
 1517 06c4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1518 06c6 002B     		cmp	r3, #0
 1519 06c8 06D0     		beq	.L66
 983:../src/stm32f30x_i2c.c ****   {
 984:../src/stm32f30x_i2c.c ****     /* Enable Clock Timeout */
 985:../src/stm32f30x_i2c.c ****     I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIMOUTEN;   
 1520              		.loc 1 985 0
 1521 06ca 7B68     		ldr	r3, [r7, #4]
 1522 06cc 5B69     		ldr	r3, [r3, #20]
 1523 06ce 43F40042 		orr	r2, r3, #32768
 1524 06d2 7B68     		ldr	r3, [r7, #4]
 1525 06d4 5A61     		str	r2, [r3, #20]
 1526 06d6 05E0     		b	.L65
 1527              	.L66:
 986:../src/stm32f30x_i2c.c ****   }
 987:../src/stm32f30x_i2c.c ****   else
 988:../src/stm32f30x_i2c.c ****   {
 989:../src/stm32f30x_i2c.c ****     /* Disable Clock Timeout */    
 990:../src/stm32f30x_i2c.c ****     I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMOUTEN); 
 1528              		.loc 1 990 0
 1529 06d8 7B68     		ldr	r3, [r7, #4]
 1530 06da 5B69     		ldr	r3, [r3, #20]
 1531 06dc 23F40042 		bic	r2, r3, #32768
 1532 06e0 7B68     		ldr	r3, [r7, #4]
 1533 06e2 5A61     		str	r2, [r3, #20]
 1534              	.L65:
 991:../src/stm32f30x_i2c.c ****   }
 992:../src/stm32f30x_i2c.c **** }
 1535              		.loc 1 992 0
 1536 06e4 07F10C07 		add	r7, r7, #12
 1537 06e8 BD46     		mov	sp, r7
 1538 06ea 80BC     		pop	{r7}
 1539 06ec 7047     		bx	lr
 1540              		.cfi_endproc
 1541              	.LFE137:
 1543 06ee 00BF     		.align	2
 1544              		.global	I2C_ExtendedClockTimeoutCmd
 1545              		.thumb
 1546              		.thumb_func
 1548              	I2C_ExtendedClockTimeoutCmd:
 1549              	.LFB138:
 993:../src/stm32f30x_i2c.c **** 
 994:../src/stm32f30x_i2c.c **** /**
 995:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables I2C Extended Clock Timeout (SCL cumulative Timeout detection).
 996:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
 997:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2Cx Extended clock Timeout.
 998:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
 999:../src/stm32f30x_i2c.c ****   * @retval None
1000:../src/stm32f30x_i2c.c ****   */
1001:../src/stm32f30x_i2c.c **** void I2C_ExtendedClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
1002:../src/stm32f30x_i2c.c **** {
 1550              		.loc 1 1002 0
 1551              		.cfi_startproc
 1552              		@ args = 0, pretend = 0, frame = 8
 1553              		@ frame_needed = 1, uses_anonymous_args = 0
 1554              		@ link register save eliminated.
 1555 06f0 80B4     		push	{r7}
 1556              	.LCFI81:
 1557              		.cfi_def_cfa_offset 4
 1558              		.cfi_offset 7, -4
 1559 06f2 83B0     		sub	sp, sp, #12
 1560              	.LCFI82:
 1561              		.cfi_def_cfa_offset 16
 1562 06f4 00AF     		add	r7, sp, #0
 1563              	.LCFI83:
 1564              		.cfi_def_cfa_register 7
 1565 06f6 7860     		str	r0, [r7, #4]
 1566 06f8 0B46     		mov	r3, r1
 1567 06fa FB70     		strb	r3, [r7, #3]
1003:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1004:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1005:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1006:../src/stm32f30x_i2c.c ****   
1007:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 1568              		.loc 1 1007 0
 1569 06fc FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1570 06fe 002B     		cmp	r3, #0
 1571 0700 06D0     		beq	.L69
1008:../src/stm32f30x_i2c.c ****   {
1009:../src/stm32f30x_i2c.c ****     /* Enable Clock Timeout */
1010:../src/stm32f30x_i2c.c ****     I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TEXTEN;   
 1572              		.loc 1 1010 0
 1573 0702 7B68     		ldr	r3, [r7, #4]
 1574 0704 5B69     		ldr	r3, [r3, #20]
 1575 0706 43F00042 		orr	r2, r3, #-2147483648
 1576 070a 7B68     		ldr	r3, [r7, #4]
 1577 070c 5A61     		str	r2, [r3, #20]
 1578 070e 05E0     		b	.L68
 1579              	.L69:
1011:../src/stm32f30x_i2c.c ****   }
1012:../src/stm32f30x_i2c.c ****   else
1013:../src/stm32f30x_i2c.c ****   {
1014:../src/stm32f30x_i2c.c ****     /* Disable Clock Timeout */    
1015:../src/stm32f30x_i2c.c ****     I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TEXTEN); 
 1580              		.loc 1 1015 0
 1581 0710 7B68     		ldr	r3, [r7, #4]
 1582 0712 5B69     		ldr	r3, [r3, #20]
 1583 0714 23F00042 		bic	r2, r3, #-2147483648
 1584 0718 7B68     		ldr	r3, [r7, #4]
 1585 071a 5A61     		str	r2, [r3, #20]
 1586              	.L68:
1016:../src/stm32f30x_i2c.c ****   }
1017:../src/stm32f30x_i2c.c **** }
 1587              		.loc 1 1017 0
 1588 071c 07F10C07 		add	r7, r7, #12
 1589 0720 BD46     		mov	sp, r7
 1590 0722 80BC     		pop	{r7}
 1591 0724 7047     		bx	lr
 1592              		.cfi_endproc
 1593              	.LFE138:
 1595 0726 00BF     		.align	2
 1596              		.global	I2C_IdleClockTimeoutCmd
 1597              		.thumb
 1598              		.thumb_func
 1600              	I2C_IdleClockTimeoutCmd:
 1601              	.LFB139:
1018:../src/stm32f30x_i2c.c **** 
1019:../src/stm32f30x_i2c.c **** /**
1020:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables I2C Idle Clock Timeout (Bus idle SCL and SDA 
1021:../src/stm32f30x_i2c.c ****   *         high detection).
1022:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
1023:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2Cx Idle clock Timeout.
1024:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
1025:../src/stm32f30x_i2c.c ****   * @retval None
1026:../src/stm32f30x_i2c.c ****   */
1027:../src/stm32f30x_i2c.c **** void I2C_IdleClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
1028:../src/stm32f30x_i2c.c **** {
 1602              		.loc 1 1028 0
 1603              		.cfi_startproc
 1604              		@ args = 0, pretend = 0, frame = 8
 1605              		@ frame_needed = 1, uses_anonymous_args = 0
 1606              		@ link register save eliminated.
 1607 0728 80B4     		push	{r7}
 1608              	.LCFI84:
 1609              		.cfi_def_cfa_offset 4
 1610              		.cfi_offset 7, -4
 1611 072a 83B0     		sub	sp, sp, #12
 1612              	.LCFI85:
 1613              		.cfi_def_cfa_offset 16
 1614 072c 00AF     		add	r7, sp, #0
 1615              	.LCFI86:
 1616              		.cfi_def_cfa_register 7
 1617 072e 7860     		str	r0, [r7, #4]
 1618 0730 0B46     		mov	r3, r1
 1619 0732 FB70     		strb	r3, [r7, #3]
1029:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1030:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1031:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1032:../src/stm32f30x_i2c.c ****   
1033:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 1620              		.loc 1 1033 0
 1621 0734 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1622 0736 002B     		cmp	r3, #0
 1623 0738 06D0     		beq	.L72
1034:../src/stm32f30x_i2c.c ****   {
1035:../src/stm32f30x_i2c.c ****     /* Enable Clock Timeout */
1036:../src/stm32f30x_i2c.c ****     I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIDLE;   
 1624              		.loc 1 1036 0
 1625 073a 7B68     		ldr	r3, [r7, #4]
 1626 073c 5B69     		ldr	r3, [r3, #20]
 1627 073e 43F48052 		orr	r2, r3, #4096
 1628 0742 7B68     		ldr	r3, [r7, #4]
 1629 0744 5A61     		str	r2, [r3, #20]
 1630 0746 05E0     		b	.L71
 1631              	.L72:
1037:../src/stm32f30x_i2c.c ****   }
1038:../src/stm32f30x_i2c.c ****   else
1039:../src/stm32f30x_i2c.c ****   {
1040:../src/stm32f30x_i2c.c ****     /* Disable Clock Timeout */    
1041:../src/stm32f30x_i2c.c ****     I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIDLE); 
 1632              		.loc 1 1041 0
 1633 0748 7B68     		ldr	r3, [r7, #4]
 1634 074a 5B69     		ldr	r3, [r3, #20]
 1635 074c 23F48052 		bic	r2, r3, #4096
 1636 0750 7B68     		ldr	r3, [r7, #4]
 1637 0752 5A61     		str	r2, [r3, #20]
 1638              	.L71:
1042:../src/stm32f30x_i2c.c ****   }
1043:../src/stm32f30x_i2c.c **** }
 1639              		.loc 1 1043 0
 1640 0754 07F10C07 		add	r7, r7, #12
 1641 0758 BD46     		mov	sp, r7
 1642 075a 80BC     		pop	{r7}
 1643 075c 7047     		bx	lr
 1644              		.cfi_endproc
 1645              	.LFE139:
 1647 075e 00BF     		.align	2
 1648              		.global	I2C_TimeoutAConfig
 1649              		.thumb
 1650              		.thumb_func
 1652              	I2C_TimeoutAConfig:
 1653              	.LFB140:
1044:../src/stm32f30x_i2c.c **** 
1045:../src/stm32f30x_i2c.c **** /**
1046:../src/stm32f30x_i2c.c ****   * @brief  Configures the I2C Bus Timeout A (SCL Timeout when TIDLE = 0 or Bus 
1047:../src/stm32f30x_i2c.c ****   *   idle SCL and SDA high when TIDLE = 1).
1048:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
1049:../src/stm32f30x_i2c.c ****   * @param  Timeout: specifies the TimeoutA to be programmed. 
1050:../src/stm32f30x_i2c.c ****   * @retval None
1051:../src/stm32f30x_i2c.c ****   */
1052:../src/stm32f30x_i2c.c **** void I2C_TimeoutAConfig(I2C_TypeDef* I2Cx, uint16_t Timeout)
1053:../src/stm32f30x_i2c.c **** {
 1654              		.loc 1 1053 0
 1655              		.cfi_startproc
 1656              		@ args = 0, pretend = 0, frame = 16
 1657              		@ frame_needed = 1, uses_anonymous_args = 0
 1658              		@ link register save eliminated.
 1659 0760 80B4     		push	{r7}
 1660              	.LCFI87:
 1661              		.cfi_def_cfa_offset 4
 1662              		.cfi_offset 7, -4
 1663 0762 85B0     		sub	sp, sp, #20
 1664              	.LCFI88:
 1665              		.cfi_def_cfa_offset 24
 1666 0764 00AF     		add	r7, sp, #0
 1667              	.LCFI89:
 1668              		.cfi_def_cfa_register 7
 1669 0766 7860     		str	r0, [r7, #4]
 1670 0768 0B46     		mov	r3, r1
 1671 076a 7B80     		strh	r3, [r7, #2]	@ movhi
1054:../src/stm32f30x_i2c.c ****   uint32_t tmpreg = 0;
 1672              		.loc 1 1054 0
 1673 076c 4FF00003 		mov	r3, #0
 1674 0770 FB60     		str	r3, [r7, #12]
1055:../src/stm32f30x_i2c.c **** 
1056:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1057:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1058:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_TIMEOUT(Timeout));
1059:../src/stm32f30x_i2c.c ****     
1060:../src/stm32f30x_i2c.c ****   /* Get the old register value */
1061:../src/stm32f30x_i2c.c ****   tmpreg = I2Cx->TIMEOUTR;
 1675              		.loc 1 1061 0
 1676 0772 7B68     		ldr	r3, [r7, #4]
 1677 0774 5B69     		ldr	r3, [r3, #20]
 1678 0776 FB60     		str	r3, [r7, #12]
1062:../src/stm32f30x_i2c.c **** 
1063:../src/stm32f30x_i2c.c ****   /* Reset I2Cx TIMEOUTA bit [11:0] */
1064:../src/stm32f30x_i2c.c ****   tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTA);
 1679              		.loc 1 1064 0
 1680 0778 FB68     		ldr	r3, [r7, #12]
 1681 077a 23F47F63 		bic	r3, r3, #4080
 1682 077e 23F00F03 		bic	r3, r3, #15
 1683 0782 FB60     		str	r3, [r7, #12]
1065:../src/stm32f30x_i2c.c **** 
1066:../src/stm32f30x_i2c.c ****   /* Set I2Cx TIMEOUTA */
1067:../src/stm32f30x_i2c.c ****   tmpreg |= (uint32_t)((uint32_t)Timeout & I2C_TIMEOUTR_TIMEOUTA) ;
 1684              		.loc 1 1067 0
 1685 0784 7B88     		ldrh	r3, [r7, #2]
 1686 0786 4FEA0353 		lsl	r3, r3, #20
 1687 078a 4FEA1353 		lsr	r3, r3, #20
 1688 078e FA68     		ldr	r2, [r7, #12]
 1689 0790 1343     		orrs	r3, r3, r2
 1690 0792 FB60     		str	r3, [r7, #12]
1068:../src/stm32f30x_i2c.c **** 
1069:../src/stm32f30x_i2c.c ****   /* Store the new register value */
1070:../src/stm32f30x_i2c.c ****   I2Cx->TIMEOUTR = tmpreg;
 1691              		.loc 1 1070 0
 1692 0794 7B68     		ldr	r3, [r7, #4]
 1693 0796 FA68     		ldr	r2, [r7, #12]
 1694 0798 5A61     		str	r2, [r3, #20]
1071:../src/stm32f30x_i2c.c **** }
 1695              		.loc 1 1071 0
 1696 079a 07F11407 		add	r7, r7, #20
 1697 079e BD46     		mov	sp, r7
 1698 07a0 80BC     		pop	{r7}
 1699 07a2 7047     		bx	lr
 1700              		.cfi_endproc
 1701              	.LFE140:
 1703              		.align	2
 1704              		.global	I2C_TimeoutBConfig
 1705              		.thumb
 1706              		.thumb_func
 1708              	I2C_TimeoutBConfig:
 1709              	.LFB141:
1072:../src/stm32f30x_i2c.c **** 
1073:../src/stm32f30x_i2c.c **** /**
1074:../src/stm32f30x_i2c.c ****   * @brief  Configures the I2C Bus Timeout B (SCL cumulative Timeout).
1075:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
1076:../src/stm32f30x_i2c.c ****   * @param  Timeout: specifies the TimeoutB to be programmed. 
1077:../src/stm32f30x_i2c.c ****   * @retval None
1078:../src/stm32f30x_i2c.c ****   */
1079:../src/stm32f30x_i2c.c **** void I2C_TimeoutBConfig(I2C_TypeDef* I2Cx, uint16_t Timeout)
1080:../src/stm32f30x_i2c.c **** {
 1710              		.loc 1 1080 0
 1711              		.cfi_startproc
 1712              		@ args = 0, pretend = 0, frame = 16
 1713              		@ frame_needed = 1, uses_anonymous_args = 0
 1714              		@ link register save eliminated.
 1715 07a4 80B4     		push	{r7}
 1716              	.LCFI90:
 1717              		.cfi_def_cfa_offset 4
 1718              		.cfi_offset 7, -4
 1719 07a6 85B0     		sub	sp, sp, #20
 1720              	.LCFI91:
 1721              		.cfi_def_cfa_offset 24
 1722 07a8 00AF     		add	r7, sp, #0
 1723              	.LCFI92:
 1724              		.cfi_def_cfa_register 7
 1725 07aa 7860     		str	r0, [r7, #4]
 1726 07ac 0B46     		mov	r3, r1
 1727 07ae 7B80     		strh	r3, [r7, #2]	@ movhi
1081:../src/stm32f30x_i2c.c ****   uint32_t tmpreg = 0;
 1728              		.loc 1 1081 0
 1729 07b0 4FF00003 		mov	r3, #0
 1730 07b4 FB60     		str	r3, [r7, #12]
1082:../src/stm32f30x_i2c.c **** 
1083:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1084:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1085:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_TIMEOUT(Timeout));
1086:../src/stm32f30x_i2c.c **** 
1087:../src/stm32f30x_i2c.c ****   /* Get the old register value */
1088:../src/stm32f30x_i2c.c ****   tmpreg = I2Cx->TIMEOUTR;
 1731              		.loc 1 1088 0
 1732 07b6 7B68     		ldr	r3, [r7, #4]
 1733 07b8 5B69     		ldr	r3, [r3, #20]
 1734 07ba FB60     		str	r3, [r7, #12]
1089:../src/stm32f30x_i2c.c **** 
1090:../src/stm32f30x_i2c.c ****   /* Reset I2Cx TIMEOUTB bit [11:0] */
1091:../src/stm32f30x_i2c.c ****   tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTB);
 1735              		.loc 1 1091 0
 1736 07bc FB68     		ldr	r3, [r7, #12]
 1737 07be 23F07F63 		bic	r3, r3, #267386880
 1738 07c2 23F47023 		bic	r3, r3, #983040
 1739 07c6 FB60     		str	r3, [r7, #12]
1092:../src/stm32f30x_i2c.c **** 
1093:../src/stm32f30x_i2c.c ****   /* Set I2Cx TIMEOUTB */
1094:../src/stm32f30x_i2c.c ****   tmpreg |= (uint32_t)(((uint32_t)Timeout << 16) & I2C_TIMEOUTR_TIMEOUTB) ;
 1740              		.loc 1 1094 0
 1741 07c8 7B88     		ldrh	r3, [r7, #2]
 1742 07ca 4FEA0342 		lsl	r2, r3, #16
 1743 07ce 4FF00003 		mov	r3, #0
 1744 07d2 C0F6FF73 		movt	r3, 4095
 1745 07d6 1340     		ands	r3, r3, r2
 1746 07d8 FA68     		ldr	r2, [r7, #12]
 1747 07da 1343     		orrs	r3, r3, r2
 1748 07dc FB60     		str	r3, [r7, #12]
1095:../src/stm32f30x_i2c.c **** 
1096:../src/stm32f30x_i2c.c ****   /* Store the new register value */
1097:../src/stm32f30x_i2c.c ****   I2Cx->TIMEOUTR = tmpreg;
 1749              		.loc 1 1097 0
 1750 07de 7B68     		ldr	r3, [r7, #4]
 1751 07e0 FA68     		ldr	r2, [r7, #12]
 1752 07e2 5A61     		str	r2, [r3, #20]
1098:../src/stm32f30x_i2c.c **** }
 1753              		.loc 1 1098 0
 1754 07e4 07F11407 		add	r7, r7, #20
 1755 07e8 BD46     		mov	sp, r7
 1756 07ea 80BC     		pop	{r7}
 1757 07ec 7047     		bx	lr
 1758              		.cfi_endproc
 1759              	.LFE141:
 1761 07ee 00BF     		.align	2
 1762              		.global	I2C_CalculatePEC
 1763              		.thumb
 1764              		.thumb_func
 1766              	I2C_CalculatePEC:
 1767              	.LFB142:
1099:../src/stm32f30x_i2c.c **** 
1100:../src/stm32f30x_i2c.c **** /**
1101:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables I2C PEC calculation.
1102:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
1103:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2Cx PEC calculation.
1104:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
1105:../src/stm32f30x_i2c.c ****   * @retval None
1106:../src/stm32f30x_i2c.c ****   */
1107:../src/stm32f30x_i2c.c **** void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
1108:../src/stm32f30x_i2c.c **** {
 1768              		.loc 1 1108 0
 1769              		.cfi_startproc
 1770              		@ args = 0, pretend = 0, frame = 8
 1771              		@ frame_needed = 1, uses_anonymous_args = 0
 1772              		@ link register save eliminated.
 1773 07f0 80B4     		push	{r7}
 1774              	.LCFI93:
 1775              		.cfi_def_cfa_offset 4
 1776              		.cfi_offset 7, -4
 1777 07f2 83B0     		sub	sp, sp, #12
 1778              	.LCFI94:
 1779              		.cfi_def_cfa_offset 16
 1780 07f4 00AF     		add	r7, sp, #0
 1781              	.LCFI95:
 1782              		.cfi_def_cfa_register 7
 1783 07f6 7860     		str	r0, [r7, #4]
 1784 07f8 0B46     		mov	r3, r1
 1785 07fa FB70     		strb	r3, [r7, #3]
1109:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1110:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1111:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1112:../src/stm32f30x_i2c.c ****   
1113:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 1786              		.loc 1 1113 0
 1787 07fc FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1788 07fe 002B     		cmp	r3, #0
 1789 0800 06D0     		beq	.L77
1114:../src/stm32f30x_i2c.c ****   {
1115:../src/stm32f30x_i2c.c ****     /* Enable PEC calculation */
1116:../src/stm32f30x_i2c.c ****     I2Cx->CR1 |= I2C_CR1_PECEN;   
 1790              		.loc 1 1116 0
 1791 0802 7B68     		ldr	r3, [r7, #4]
 1792 0804 1B68     		ldr	r3, [r3, #0]
 1793 0806 43F40002 		orr	r2, r3, #8388608
 1794 080a 7B68     		ldr	r3, [r7, #4]
 1795 080c 1A60     		str	r2, [r3, #0]
 1796 080e 05E0     		b	.L76
 1797              	.L77:
1117:../src/stm32f30x_i2c.c ****   }
1118:../src/stm32f30x_i2c.c ****   else
1119:../src/stm32f30x_i2c.c ****   {
1120:../src/stm32f30x_i2c.c ****     /* Disable PEC calculation */    
1121:../src/stm32f30x_i2c.c ****     I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PECEN); 
 1798              		.loc 1 1121 0
 1799 0810 7B68     		ldr	r3, [r7, #4]
 1800 0812 1B68     		ldr	r3, [r3, #0]
 1801 0814 23F40002 		bic	r2, r3, #8388608
 1802 0818 7B68     		ldr	r3, [r7, #4]
 1803 081a 1A60     		str	r2, [r3, #0]
 1804              	.L76:
1122:../src/stm32f30x_i2c.c ****   }
1123:../src/stm32f30x_i2c.c **** }
 1805              		.loc 1 1123 0
 1806 081c 07F10C07 		add	r7, r7, #12
 1807 0820 BD46     		mov	sp, r7
 1808 0822 80BC     		pop	{r7}
 1809 0824 7047     		bx	lr
 1810              		.cfi_endproc
 1811              	.LFE142:
 1813 0826 00BF     		.align	2
 1814              		.global	I2C_PECRequestCmd
 1815              		.thumb
 1816              		.thumb_func
 1818              	I2C_PECRequestCmd:
 1819              	.LFB143:
1124:../src/stm32f30x_i2c.c **** 
1125:../src/stm32f30x_i2c.c **** /**
1126:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables I2C PEC transmission/reception request.
1127:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
1128:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the I2Cx PEC request.
1129:../src/stm32f30x_i2c.c ****   *   This parameter can be: ENABLE or DISABLE.
1130:../src/stm32f30x_i2c.c ****   * @retval None
1131:../src/stm32f30x_i2c.c ****   */
1132:../src/stm32f30x_i2c.c **** void I2C_PECRequestCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
1133:../src/stm32f30x_i2c.c **** {
 1820              		.loc 1 1133 0
 1821              		.cfi_startproc
 1822              		@ args = 0, pretend = 0, frame = 8
 1823              		@ frame_needed = 1, uses_anonymous_args = 0
 1824              		@ link register save eliminated.
 1825 0828 80B4     		push	{r7}
 1826              	.LCFI96:
 1827              		.cfi_def_cfa_offset 4
 1828              		.cfi_offset 7, -4
 1829 082a 83B0     		sub	sp, sp, #12
 1830              	.LCFI97:
 1831              		.cfi_def_cfa_offset 16
 1832 082c 00AF     		add	r7, sp, #0
 1833              	.LCFI98:
 1834              		.cfi_def_cfa_register 7
 1835 082e 7860     		str	r0, [r7, #4]
 1836 0830 0B46     		mov	r3, r1
 1837 0832 FB70     		strb	r3, [r7, #3]
1134:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1135:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1136:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1137:../src/stm32f30x_i2c.c ****   
1138:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 1838              		.loc 1 1138 0
 1839 0834 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1840 0836 002B     		cmp	r3, #0
 1841 0838 06D0     		beq	.L80
1139:../src/stm32f30x_i2c.c ****   {
1140:../src/stm32f30x_i2c.c ****     /* Enable PEC transmission/reception request */
1141:../src/stm32f30x_i2c.c ****     I2Cx->CR1 |= I2C_CR2_PECBYTE;   
 1842              		.loc 1 1141 0
 1843 083a 7B68     		ldr	r3, [r7, #4]
 1844 083c 1B68     		ldr	r3, [r3, #0]
 1845 083e 43F08062 		orr	r2, r3, #67108864
 1846 0842 7B68     		ldr	r3, [r7, #4]
 1847 0844 1A60     		str	r2, [r3, #0]
 1848 0846 05E0     		b	.L79
 1849              	.L80:
1142:../src/stm32f30x_i2c.c ****   }
1143:../src/stm32f30x_i2c.c ****   else
1144:../src/stm32f30x_i2c.c ****   {
1145:../src/stm32f30x_i2c.c ****     /* Disable PEC transmission/reception request */    
1146:../src/stm32f30x_i2c.c ****     I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR2_PECBYTE); 
 1850              		.loc 1 1146 0
 1851 0848 7B68     		ldr	r3, [r7, #4]
 1852 084a 1B68     		ldr	r3, [r3, #0]
 1853 084c 23F08062 		bic	r2, r3, #67108864
 1854 0850 7B68     		ldr	r3, [r7, #4]
 1855 0852 1A60     		str	r2, [r3, #0]
 1856              	.L79:
1147:../src/stm32f30x_i2c.c ****   }
1148:../src/stm32f30x_i2c.c **** }
 1857              		.loc 1 1148 0
 1858 0854 07F10C07 		add	r7, r7, #12
 1859 0858 BD46     		mov	sp, r7
 1860 085a 80BC     		pop	{r7}
 1861 085c 7047     		bx	lr
 1862              		.cfi_endproc
 1863              	.LFE143:
 1865 085e 00BF     		.align	2
 1866              		.global	I2C_GetPEC
 1867              		.thumb
 1868              		.thumb_func
 1870              	I2C_GetPEC:
 1871              	.LFB144:
1149:../src/stm32f30x_i2c.c **** 
1150:../src/stm32f30x_i2c.c **** /**
1151:../src/stm32f30x_i2c.c ****   * @brief  Returns the I2C PEC.
1152:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
1153:../src/stm32f30x_i2c.c ****   * @retval The value of the PEC .
1154:../src/stm32f30x_i2c.c ****   */
1155:../src/stm32f30x_i2c.c **** uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
1156:../src/stm32f30x_i2c.c **** {
 1872              		.loc 1 1156 0
 1873              		.cfi_startproc
 1874              		@ args = 0, pretend = 0, frame = 8
 1875              		@ frame_needed = 1, uses_anonymous_args = 0
 1876              		@ link register save eliminated.
 1877 0860 80B4     		push	{r7}
 1878              	.LCFI99:
 1879              		.cfi_def_cfa_offset 4
 1880              		.cfi_offset 7, -4
 1881 0862 83B0     		sub	sp, sp, #12
 1882              	.LCFI100:
 1883              		.cfi_def_cfa_offset 16
 1884 0864 00AF     		add	r7, sp, #0
 1885              	.LCFI101:
 1886              		.cfi_def_cfa_register 7
 1887 0866 7860     		str	r0, [r7, #4]
1157:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1158:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1159:../src/stm32f30x_i2c.c ****   
1160:../src/stm32f30x_i2c.c ****   /* Return the slave matched address in the SR1 register */
1161:../src/stm32f30x_i2c.c ****   return (uint8_t)((uint32_t)I2Cx->PECR & I2C_PECR_PEC);
 1888              		.loc 1 1161 0
 1889 0868 7B68     		ldr	r3, [r7, #4]
 1890 086a 1B6A     		ldr	r3, [r3, #32]
 1891 086c DBB2     		uxtb	r3, r3
1162:../src/stm32f30x_i2c.c **** }
 1892              		.loc 1 1162 0
 1893 086e 1846     		mov	r0, r3
 1894 0870 07F10C07 		add	r7, r7, #12
 1895 0874 BD46     		mov	sp, r7
 1896 0876 80BC     		pop	{r7}
 1897 0878 7047     		bx	lr
 1898              		.cfi_endproc
 1899              	.LFE144:
 1901 087a 00BF     		.align	2
 1902              		.global	I2C_ReadRegister
 1903              		.thumb
 1904              		.thumb_func
 1906              	I2C_ReadRegister:
 1907              	.LFB145:
1163:../src/stm32f30x_i2c.c **** 
1164:../src/stm32f30x_i2c.c **** /**
1165:../src/stm32f30x_i2c.c ****   * @}
1166:../src/stm32f30x_i2c.c ****   */  
1167:../src/stm32f30x_i2c.c ****   
1168:../src/stm32f30x_i2c.c ****   
1169:../src/stm32f30x_i2c.c **** /** @defgroup I2C_Group4 I2C registers management functions
1170:../src/stm32f30x_i2c.c ****  *  @brief   I2C registers management functions 
1171:../src/stm32f30x_i2c.c ****  *
1172:../src/stm32f30x_i2c.c **** @verbatim
1173:../src/stm32f30x_i2c.c ****  ===============================================================================
1174:../src/stm32f30x_i2c.c ****                 ##### I2C registers management functions #####
1175:../src/stm32f30x_i2c.c ****  ===============================================================================  
1176:../src/stm32f30x_i2c.c ****     [..] This section provides a functions that allow user the management of 
1177:../src/stm32f30x_i2c.c ****          I2C registers.
1178:../src/stm32f30x_i2c.c ****          
1179:../src/stm32f30x_i2c.c **** @endverbatim
1180:../src/stm32f30x_i2c.c ****   * @{
1181:../src/stm32f30x_i2c.c ****   */
1182:../src/stm32f30x_i2c.c **** 
1183:../src/stm32f30x_i2c.c ****   /**
1184:../src/stm32f30x_i2c.c ****   * @brief  Reads the specified I2C register and returns its value.
1185:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
1186:../src/stm32f30x_i2c.c ****   * @param  I2C_Register: specifies the register to read.
1187:../src/stm32f30x_i2c.c ****   *   This parameter can be one of the following values:
1188:../src/stm32f30x_i2c.c ****   *     @arg I2C_Register_CR1: CR1 register.
1189:../src/stm32f30x_i2c.c ****   *     @arg I2C_Register_CR2: CR2 register.
1190:../src/stm32f30x_i2c.c ****   *     @arg I2C_Register_OAR1: OAR1 register.
1191:../src/stm32f30x_i2c.c ****   *     @arg I2C_Register_OAR2: OAR2 register.
1192:../src/stm32f30x_i2c.c ****   *     @arg I2C_Register_TIMINGR: TIMING register.
1193:../src/stm32f30x_i2c.c ****   *     @arg I2C_Register_TIMEOUTR: TIMEOUTR register.
1194:../src/stm32f30x_i2c.c ****   *     @arg I2C_Register_ISR: ISR register.
1195:../src/stm32f30x_i2c.c ****   *     @arg I2C_Register_ICR: ICR register.
1196:../src/stm32f30x_i2c.c ****   *     @arg I2C_Register_PECR: PECR register.
1197:../src/stm32f30x_i2c.c ****   *     @arg I2C_Register_RXDR: RXDR register.
1198:../src/stm32f30x_i2c.c ****   *     @arg I2C_Register_TXDR: TXDR register.
1199:../src/stm32f30x_i2c.c ****   * @retval The value of the read register.
1200:../src/stm32f30x_i2c.c ****   */
1201:../src/stm32f30x_i2c.c **** uint32_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
1202:../src/stm32f30x_i2c.c **** {
 1908              		.loc 1 1202 0
 1909              		.cfi_startproc
 1910              		@ args = 0, pretend = 0, frame = 16
 1911              		@ frame_needed = 1, uses_anonymous_args = 0
 1912              		@ link register save eliminated.
 1913 087c 80B4     		push	{r7}
 1914              	.LCFI102:
 1915              		.cfi_def_cfa_offset 4
 1916              		.cfi_offset 7, -4
 1917 087e 85B0     		sub	sp, sp, #20
 1918              	.LCFI103:
 1919              		.cfi_def_cfa_offset 24
 1920 0880 00AF     		add	r7, sp, #0
 1921              	.LCFI104:
 1922              		.cfi_def_cfa_register 7
 1923 0882 7860     		str	r0, [r7, #4]
 1924 0884 0B46     		mov	r3, r1
 1925 0886 FB70     		strb	r3, [r7, #3]
1203:../src/stm32f30x_i2c.c ****   __IO uint32_t tmp = 0;
 1926              		.loc 1 1203 0
 1927 0888 4FF00003 		mov	r3, #0
 1928 088c FB60     		str	r3, [r7, #12]
1204:../src/stm32f30x_i2c.c **** 
1205:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1206:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1207:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_REGISTER(I2C_Register));
1208:../src/stm32f30x_i2c.c **** 
1209:../src/stm32f30x_i2c.c ****   tmp = (uint32_t)I2Cx;
 1929              		.loc 1 1209 0
 1930 088e 7B68     		ldr	r3, [r7, #4]
 1931 0890 FB60     		str	r3, [r7, #12]
1210:../src/stm32f30x_i2c.c ****   tmp += I2C_Register;
 1932              		.loc 1 1210 0
 1933 0892 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 1934 0894 FB68     		ldr	r3, [r7, #12]
 1935 0896 D318     		adds	r3, r2, r3
 1936 0898 FB60     		str	r3, [r7, #12]
1211:../src/stm32f30x_i2c.c **** 
1212:../src/stm32f30x_i2c.c ****   /* Return the selected register value */
1213:../src/stm32f30x_i2c.c ****   return (*(__IO uint32_t *) tmp);
 1937              		.loc 1 1213 0
 1938 089a FB68     		ldr	r3, [r7, #12]
 1939 089c 1B68     		ldr	r3, [r3, #0]
1214:../src/stm32f30x_i2c.c **** }
 1940              		.loc 1 1214 0
 1941 089e 1846     		mov	r0, r3
 1942 08a0 07F11407 		add	r7, r7, #20
 1943 08a4 BD46     		mov	sp, r7
 1944 08a6 80BC     		pop	{r7}
 1945 08a8 7047     		bx	lr
 1946              		.cfi_endproc
 1947              	.LFE145:
 1949 08aa 00BF     		.align	2
 1950              		.global	I2C_SendData
 1951              		.thumb
 1952              		.thumb_func
 1954              	I2C_SendData:
 1955              	.LFB146:
1215:../src/stm32f30x_i2c.c **** 
1216:../src/stm32f30x_i2c.c **** /**
1217:../src/stm32f30x_i2c.c ****   * @}
1218:../src/stm32f30x_i2c.c ****   */  
1219:../src/stm32f30x_i2c.c ****   
1220:../src/stm32f30x_i2c.c **** /** @defgroup I2C_Group5 Data transfers management functions
1221:../src/stm32f30x_i2c.c ****  *  @brief   Data transfers management functions 
1222:../src/stm32f30x_i2c.c ****  *
1223:../src/stm32f30x_i2c.c **** @verbatim
1224:../src/stm32f30x_i2c.c ****  ===============================================================================
1225:../src/stm32f30x_i2c.c ****                 ##### Data transfers management functions #####
1226:../src/stm32f30x_i2c.c ****  =============================================================================== 
1227:../src/stm32f30x_i2c.c ****     [..] This subsection provides a set of functions allowing to manage 
1228:../src/stm32f30x_i2c.c ****          the I2C data transfers.
1229:../src/stm32f30x_i2c.c ****          
1230:../src/stm32f30x_i2c.c ****     [..] The read access of the I2C_RXDR register can be done using 
1231:../src/stm32f30x_i2c.c ****          the I2C_ReceiveData() function and returns the received value.
1232:../src/stm32f30x_i2c.c ****          Whereas a write access to the I2C_TXDR can be done using I2C_SendData()
1233:../src/stm32f30x_i2c.c ****          function and stores the written data into TXDR.
1234:../src/stm32f30x_i2c.c **** @endverbatim
1235:../src/stm32f30x_i2c.c ****   * @{
1236:../src/stm32f30x_i2c.c ****   */  
1237:../src/stm32f30x_i2c.c ****   
1238:../src/stm32f30x_i2c.c **** /**
1239:../src/stm32f30x_i2c.c ****   * @brief  Sends a data byte through the I2Cx peripheral.
1240:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
1241:../src/stm32f30x_i2c.c ****   * @param  Data: Byte to be transmitted..
1242:../src/stm32f30x_i2c.c ****   * @retval None
1243:../src/stm32f30x_i2c.c ****   */
1244:../src/stm32f30x_i2c.c **** void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
1245:../src/stm32f30x_i2c.c **** {
 1956              		.loc 1 1245 0
 1957              		.cfi_startproc
 1958              		@ args = 0, pretend = 0, frame = 8
 1959              		@ frame_needed = 1, uses_anonymous_args = 0
 1960              		@ link register save eliminated.
 1961 08ac 80B4     		push	{r7}
 1962              	.LCFI105:
 1963              		.cfi_def_cfa_offset 4
 1964              		.cfi_offset 7, -4
 1965 08ae 83B0     		sub	sp, sp, #12
 1966              	.LCFI106:
 1967              		.cfi_def_cfa_offset 16
 1968 08b0 00AF     		add	r7, sp, #0
 1969              	.LCFI107:
 1970              		.cfi_def_cfa_register 7
 1971 08b2 7860     		str	r0, [r7, #4]
 1972 08b4 0B46     		mov	r3, r1
 1973 08b6 FB70     		strb	r3, [r7, #3]
1246:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1247:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1248:../src/stm32f30x_i2c.c ****   
1249:../src/stm32f30x_i2c.c ****   /* Write in the DR register the data to be sent */
1250:../src/stm32f30x_i2c.c ****   I2Cx->TXDR = (uint8_t)Data;
 1974              		.loc 1 1250 0
 1975 08b8 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 1976 08ba 7B68     		ldr	r3, [r7, #4]
 1977 08bc 9A62     		str	r2, [r3, #40]
1251:../src/stm32f30x_i2c.c **** }
 1978              		.loc 1 1251 0
 1979 08be 07F10C07 		add	r7, r7, #12
 1980 08c2 BD46     		mov	sp, r7
 1981 08c4 80BC     		pop	{r7}
 1982 08c6 7047     		bx	lr
 1983              		.cfi_endproc
 1984              	.LFE146:
 1986              		.align	2
 1987              		.global	I2C_ReceiveData
 1988              		.thumb
 1989              		.thumb_func
 1991              	I2C_ReceiveData:
 1992              	.LFB147:
1252:../src/stm32f30x_i2c.c **** 
1253:../src/stm32f30x_i2c.c **** /**
1254:../src/stm32f30x_i2c.c ****   * @brief  Returns the most recent received data by the I2Cx peripheral.
1255:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
1256:../src/stm32f30x_i2c.c ****   * @retval The value of the received data.
1257:../src/stm32f30x_i2c.c ****   */
1258:../src/stm32f30x_i2c.c **** uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
1259:../src/stm32f30x_i2c.c **** {
 1993              		.loc 1 1259 0
 1994              		.cfi_startproc
 1995              		@ args = 0, pretend = 0, frame = 8
 1996              		@ frame_needed = 1, uses_anonymous_args = 0
 1997              		@ link register save eliminated.
 1998 08c8 80B4     		push	{r7}
 1999              	.LCFI108:
 2000              		.cfi_def_cfa_offset 4
 2001              		.cfi_offset 7, -4
 2002 08ca 83B0     		sub	sp, sp, #12
 2003              	.LCFI109:
 2004              		.cfi_def_cfa_offset 16
 2005 08cc 00AF     		add	r7, sp, #0
 2006              	.LCFI110:
 2007              		.cfi_def_cfa_register 7
 2008 08ce 7860     		str	r0, [r7, #4]
1260:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1261:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1262:../src/stm32f30x_i2c.c ****   
1263:../src/stm32f30x_i2c.c ****   /* Return the data in the DR register */
1264:../src/stm32f30x_i2c.c ****   return (uint8_t)I2Cx->RXDR;
 2009              		.loc 1 1264 0
 2010 08d0 7B68     		ldr	r3, [r7, #4]
 2011 08d2 5B6A     		ldr	r3, [r3, #36]
 2012 08d4 DBB2     		uxtb	r3, r3
1265:../src/stm32f30x_i2c.c **** }  
 2013              		.loc 1 1265 0
 2014 08d6 1846     		mov	r0, r3
 2015 08d8 07F10C07 		add	r7, r7, #12
 2016 08dc BD46     		mov	sp, r7
 2017 08de 80BC     		pop	{r7}
 2018 08e0 7047     		bx	lr
 2019              		.cfi_endproc
 2020              	.LFE147:
 2022 08e2 00BF     		.align	2
 2023              		.global	I2C_DMACmd
 2024              		.thumb
 2025              		.thumb_func
 2027              	I2C_DMACmd:
 2028              	.LFB148:
1266:../src/stm32f30x_i2c.c **** 
1267:../src/stm32f30x_i2c.c **** /**
1268:../src/stm32f30x_i2c.c ****   * @}
1269:../src/stm32f30x_i2c.c ****   */ 
1270:../src/stm32f30x_i2c.c ****   
1271:../src/stm32f30x_i2c.c ****   
1272:../src/stm32f30x_i2c.c **** /** @defgroup I2C_Group6 DMA transfers management functions
1273:../src/stm32f30x_i2c.c ****  *  @brief   DMA transfers management functions 
1274:../src/stm32f30x_i2c.c ****  *
1275:../src/stm32f30x_i2c.c **** @verbatim
1276:../src/stm32f30x_i2c.c ****  ===============================================================================
1277:../src/stm32f30x_i2c.c ****                ##### DMA transfers management functions #####
1278:../src/stm32f30x_i2c.c ****  ===============================================================================  
1279:../src/stm32f30x_i2c.c ****     [..] This section provides two functions that can be used only in DMA mode.
1280:../src/stm32f30x_i2c.c ****     [..] In DMA Mode, the I2C communication can be managed by 2 DMA Channel 
1281:../src/stm32f30x_i2c.c ****          requests:
1282:../src/stm32f30x_i2c.c ****          (#) I2C_DMAReq_Tx: specifies the Tx buffer DMA transfer request.
1283:../src/stm32f30x_i2c.c ****          (#) I2C_DMAReq_Rx: specifies the Rx buffer DMA transfer request.
1284:../src/stm32f30x_i2c.c ****     [..] In this Mode it is advised to use the following function:
1285:../src/stm32f30x_i2c.c ****          (+) I2C_DMACmd(I2C_TypeDef* I2Cx, uint32_t I2C_DMAReq, FunctionalState NewState);
1286:../src/stm32f30x_i2c.c **** @endverbatim
1287:../src/stm32f30x_i2c.c ****   * @{
1288:../src/stm32f30x_i2c.c ****   */  
1289:../src/stm32f30x_i2c.c ****     
1290:../src/stm32f30x_i2c.c **** /**
1291:../src/stm32f30x_i2c.c ****   * @brief  Enables or disables the I2C DMA interface.
1292:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
1293:../src/stm32f30x_i2c.c ****   * @param  I2C_DMAReq: specifies the I2C DMA transfer request to be enabled or disabled. 
1294:../src/stm32f30x_i2c.c ****   *   This parameter can be any combination of the following values:
1295:../src/stm32f30x_i2c.c ****   *     @arg I2C_DMAReq_Tx: Tx DMA transfer request
1296:../src/stm32f30x_i2c.c ****   *     @arg I2C_DMAReq_Rx: Rx DMA transfer request
1297:../src/stm32f30x_i2c.c ****   * @param  NewState: new state of the selected I2C DMA transfer request.
1298:../src/stm32f30x_i2c.c ****   *         This parameter can be: ENABLE or DISABLE.
1299:../src/stm32f30x_i2c.c ****   * @retval None
1300:../src/stm32f30x_i2c.c ****   */
1301:../src/stm32f30x_i2c.c **** void I2C_DMACmd(I2C_TypeDef* I2Cx, uint32_t I2C_DMAReq, FunctionalState NewState)
1302:../src/stm32f30x_i2c.c **** {
 2029              		.loc 1 1302 0
 2030              		.cfi_startproc
 2031              		@ args = 0, pretend = 0, frame = 16
 2032              		@ frame_needed = 1, uses_anonymous_args = 0
 2033              		@ link register save eliminated.
 2034 08e4 80B4     		push	{r7}
 2035              	.LCFI111:
 2036              		.cfi_def_cfa_offset 4
 2037              		.cfi_offset 7, -4
 2038 08e6 85B0     		sub	sp, sp, #20
 2039              	.LCFI112:
 2040              		.cfi_def_cfa_offset 24
 2041 08e8 00AF     		add	r7, sp, #0
 2042              	.LCFI113:
 2043              		.cfi_def_cfa_register 7
 2044 08ea F860     		str	r0, [r7, #12]
 2045 08ec B960     		str	r1, [r7, #8]
 2046 08ee 1346     		mov	r3, r2
 2047 08f0 FB71     		strb	r3, [r7, #7]
1303:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1304:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1305:../src/stm32f30x_i2c.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1306:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_DMA_REQ(I2C_DMAReq));
1307:../src/stm32f30x_i2c.c **** 
1308:../src/stm32f30x_i2c.c ****   if (NewState != DISABLE)
 2048              		.loc 1 1308 0
 2049 08f2 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2050 08f4 002B     		cmp	r3, #0
 2051 08f6 06D0     		beq	.L90
1309:../src/stm32f30x_i2c.c ****   {
1310:../src/stm32f30x_i2c.c ****     /* Enable the selected I2C DMA requests */
1311:../src/stm32f30x_i2c.c ****     I2Cx->CR1 |= I2C_DMAReq;
 2052              		.loc 1 1311 0
 2053 08f8 FB68     		ldr	r3, [r7, #12]
 2054 08fa 1A68     		ldr	r2, [r3, #0]
 2055 08fc BB68     		ldr	r3, [r7, #8]
 2056 08fe 1A43     		orrs	r2, r2, r3
 2057 0900 FB68     		ldr	r3, [r7, #12]
 2058 0902 1A60     		str	r2, [r3, #0]
 2059 0904 07E0     		b	.L89
 2060              	.L90:
1312:../src/stm32f30x_i2c.c ****   }
1313:../src/stm32f30x_i2c.c ****   else
1314:../src/stm32f30x_i2c.c ****   {
1315:../src/stm32f30x_i2c.c ****     /* Disable the selected I2C DMA requests */
1316:../src/stm32f30x_i2c.c ****     I2Cx->CR1 &= (uint32_t)~I2C_DMAReq;
 2061              		.loc 1 1316 0
 2062 0906 FB68     		ldr	r3, [r7, #12]
 2063 0908 1A68     		ldr	r2, [r3, #0]
 2064 090a BB68     		ldr	r3, [r7, #8]
 2065 090c 6FEA0303 		mvn	r3, r3
 2066 0910 1A40     		ands	r2, r2, r3
 2067 0912 FB68     		ldr	r3, [r7, #12]
 2068 0914 1A60     		str	r2, [r3, #0]
 2069              	.L89:
1317:../src/stm32f30x_i2c.c ****   }
1318:../src/stm32f30x_i2c.c **** }
 2070              		.loc 1 1318 0
 2071 0916 07F11407 		add	r7, r7, #20
 2072 091a BD46     		mov	sp, r7
 2073 091c 80BC     		pop	{r7}
 2074 091e 7047     		bx	lr
 2075              		.cfi_endproc
 2076              	.LFE148:
 2078              		.align	2
 2079              		.global	I2C_GetFlagStatus
 2080              		.thumb
 2081              		.thumb_func
 2083              	I2C_GetFlagStatus:
 2084              	.LFB149:
1319:../src/stm32f30x_i2c.c **** /**
1320:../src/stm32f30x_i2c.c ****   * @}
1321:../src/stm32f30x_i2c.c ****   */  
1322:../src/stm32f30x_i2c.c **** 
1323:../src/stm32f30x_i2c.c **** 
1324:../src/stm32f30x_i2c.c **** /** @defgroup I2C_Group7 Interrupts and flags management functions
1325:../src/stm32f30x_i2c.c ****  *  @brief   Interrupts and flags management functions 
1326:../src/stm32f30x_i2c.c ****  *
1327:../src/stm32f30x_i2c.c **** @verbatim
1328:../src/stm32f30x_i2c.c ****  ===============================================================================
1329:../src/stm32f30x_i2c.c ****              ##### Interrupts and flags management functions  #####
1330:../src/stm32f30x_i2c.c ****  =============================================================================== 
1331:../src/stm32f30x_i2c.c ****     [..] This section provides functions allowing to configure the I2C Interrupts 
1332:../src/stm32f30x_i2c.c ****          sources and check or clear the flags or pending bits status.
1333:../src/stm32f30x_i2c.c ****          The user should identify which mode will be used in his application to manage 
1334:../src/stm32f30x_i2c.c ****          the communication: Polling mode, Interrupt mode or DMA mode(refer I2C_Group6) .
1335:../src/stm32f30x_i2c.c **** 
1336:../src/stm32f30x_i2c.c ****   *** Polling Mode ***
1337:../src/stm32f30x_i2c.c ****   ====================
1338:../src/stm32f30x_i2c.c ****     [..] In Polling Mode, the I2C communication can be managed by 15 flags:
1339:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_TXE: to indicate the status of Transmit data register empty flag.
1340:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_TXIS: to indicate the status of Transmit interrupt status flag .
1341:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_RXNE: to indicate the status of Receive data register not empty flag.
1342:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_ADDR: to indicate the status of Address matched flag (slave mode).
1343:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_NACKF: to indicate the status of NACK received flag.
1344:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_STOPF: to indicate the status of STOP detection flag.
1345:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_TC: to indicate the status of Transfer complete flag(master mode).
1346:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_TCR: to indicate the status of Transfer complete reload flag.
1347:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_BERR: to indicate the status of Bus error flag.
1348:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_ARLO: to indicate the status of Arbitration lost flag.
1349:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_OVR: to indicate the status of Overrun/Underrun flag.
1350:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_PECERR: to indicate the status of PEC error in reception flag.
1351:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_TIMEOUT: to indicate the status of Timeout or Tlow detection flag.
1352:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_ALERT: to indicate the status of SMBus Alert flag.
1353:../src/stm32f30x_i2c.c ****         (#) I2C_FLAG_BUSY: to indicate the status of Bus busy flag.
1354:../src/stm32f30x_i2c.c **** 
1355:../src/stm32f30x_i2c.c ****     [..] In this Mode it is advised to use the following functions:
1356:../src/stm32f30x_i2c.c ****         (+) FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
1357:../src/stm32f30x_i2c.c ****         (+) void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
1358:../src/stm32f30x_i2c.c **** 
1359:../src/stm32f30x_i2c.c ****     [..]
1360:../src/stm32f30x_i2c.c ****         (@)Do not use the BUSY flag to handle each data transmission or reception.It is 
1361:../src/stm32f30x_i2c.c ****            better to use the TXIS and RXNE flags instead.
1362:../src/stm32f30x_i2c.c **** 
1363:../src/stm32f30x_i2c.c ****   *** Interrupt Mode ***
1364:../src/stm32f30x_i2c.c ****   ======================
1365:../src/stm32f30x_i2c.c ****     [..] In Interrupt Mode, the I2C communication can be managed by 7 interrupt sources
1366:../src/stm32f30x_i2c.c ****          and 15 pending bits: 
1367:../src/stm32f30x_i2c.c ****     [..] Interrupt Source:
1368:../src/stm32f30x_i2c.c ****         (#) I2C_IT_ERRI: specifies the interrupt source for the Error interrupt.
1369:../src/stm32f30x_i2c.c ****         (#) I2C_IT_TCI: specifies the interrupt source for the Transfer Complete interrupt.
1370:../src/stm32f30x_i2c.c ****         (#) I2C_IT_STOPI: specifies the interrupt source for the Stop Detection interrupt.
1371:../src/stm32f30x_i2c.c ****         (#) I2C_IT_NACKI: specifies the interrupt source for the Not Acknowledge received interrupt
1372:../src/stm32f30x_i2c.c ****         (#) I2C_IT_ADDRI: specifies the interrupt source for the Address Match interrupt.  
1373:../src/stm32f30x_i2c.c ****         (#) I2C_IT_RXI: specifies the interrupt source for the RX interrupt.
1374:../src/stm32f30x_i2c.c ****         (#) I2C_IT_TXI: specifies the interrupt source for the TX interrupt.
1375:../src/stm32f30x_i2c.c **** 
1376:../src/stm32f30x_i2c.c ****     [..] Pending Bits:
1377:../src/stm32f30x_i2c.c ****         (#) I2C_IT_TXIS: to indicate the status of Transmit interrupt status flag.
1378:../src/stm32f30x_i2c.c ****         (#) I2C_IT_RXNE: to indicate the status of Receive data register not empty flag.
1379:../src/stm32f30x_i2c.c ****         (#) I2C_IT_ADDR: to indicate the status of Address matched flag (slave mode).
1380:../src/stm32f30x_i2c.c ****         (#) I2C_IT_NACKF: to indicate the status of NACK received flag.
1381:../src/stm32f30x_i2c.c ****         (#) I2C_IT_STOPF: to indicate the status of STOP detection flag.
1382:../src/stm32f30x_i2c.c ****         (#) I2C_IT_TC: to indicate the status of Transfer complete flag (master mode).
1383:../src/stm32f30x_i2c.c ****         (#) I2C_IT_TCR: to indicate the status of Transfer complete reload flag.
1384:../src/stm32f30x_i2c.c ****         (#) I2C_IT_BERR: to indicate the status of Bus error flag.
1385:../src/stm32f30x_i2c.c ****         (#) I2C_IT_ARLO: to indicate the status of Arbitration lost flag.
1386:../src/stm32f30x_i2c.c ****         (#) I2C_IT_OVR: to indicate the status of Overrun/Underrun flag.
1387:../src/stm32f30x_i2c.c ****         (#) I2C_IT_PECERR: to indicate the status of PEC error in reception flag.
1388:../src/stm32f30x_i2c.c ****         (#) I2C_IT_TIMEOUT: to indicate the status of Timeout or Tlow detection flag.
1389:../src/stm32f30x_i2c.c ****         (#) I2C_IT_ALERT: to indicate the status of SMBus Alert flag.
1390:../src/stm32f30x_i2c.c **** 
1391:../src/stm32f30x_i2c.c ****     [..] In this Mode it is advised to use the following functions:
1392:../src/stm32f30x_i2c.c ****          (+) void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
1393:../src/stm32f30x_i2c.c ****          (+) ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
1394:../src/stm32f30x_i2c.c **** 
1395:../src/stm32f30x_i2c.c **** @endverbatim
1396:../src/stm32f30x_i2c.c ****   * @{
1397:../src/stm32f30x_i2c.c ****   */  
1398:../src/stm32f30x_i2c.c **** 
1399:../src/stm32f30x_i2c.c **** /**
1400:../src/stm32f30x_i2c.c ****   * @brief  Checks whether the specified I2C flag is set or not.
1401:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
1402:../src/stm32f30x_i2c.c ****   * @param  I2C_FLAG: specifies the flag to check. 
1403:../src/stm32f30x_i2c.c ****   *   This parameter can be one of the following values:
1404:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_TXE: Transmit data register empty
1405:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_TXIS: Transmit interrupt status
1406:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_RXNE: Receive data register not empty
1407:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_ADDR: Address matched (slave mode)
1408:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_NACKF: NACK received flag
1409:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_STOPF: STOP detection flag
1410:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_TC: Transfer complete (master mode)
1411:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_TCR: Transfer complete reload
1412:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_BERR: Bus error
1413:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_ARLO: Arbitration lost
1414:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_OVR: Overrun/Underrun
1415:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_PECERR: PEC error in reception
1416:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow detection flag
1417:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_ALERT: SMBus Alert
1418:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_BUSY: Bus busy
1419:../src/stm32f30x_i2c.c ****   * @retval The new state of I2C_FLAG (SET or RESET).
1420:../src/stm32f30x_i2c.c ****   */
1421:../src/stm32f30x_i2c.c **** FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
1422:../src/stm32f30x_i2c.c **** {
 2085              		.loc 1 1422 0
 2086              		.cfi_startproc
 2087              		@ args = 0, pretend = 0, frame = 16
 2088              		@ frame_needed = 1, uses_anonymous_args = 0
 2089              		@ link register save eliminated.
 2090 0920 80B4     		push	{r7}
 2091              	.LCFI114:
 2092              		.cfi_def_cfa_offset 4
 2093              		.cfi_offset 7, -4
 2094 0922 85B0     		sub	sp, sp, #20
 2095              	.LCFI115:
 2096              		.cfi_def_cfa_offset 24
 2097 0924 00AF     		add	r7, sp, #0
 2098              	.LCFI116:
 2099              		.cfi_def_cfa_register 7
 2100 0926 7860     		str	r0, [r7, #4]
 2101 0928 3960     		str	r1, [r7, #0]
1423:../src/stm32f30x_i2c.c ****   uint32_t tmpreg = 0;
 2102              		.loc 1 1423 0
 2103 092a 4FF00003 		mov	r3, #0
 2104 092e BB60     		str	r3, [r7, #8]
1424:../src/stm32f30x_i2c.c ****   FlagStatus bitstatus = RESET;
 2105              		.loc 1 1424 0
 2106 0930 4FF00003 		mov	r3, #0
 2107 0934 FB73     		strb	r3, [r7, #15]
1425:../src/stm32f30x_i2c.c ****   
1426:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1427:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1428:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
1429:../src/stm32f30x_i2c.c ****   
1430:../src/stm32f30x_i2c.c ****   /* Get the ISR register value */
1431:../src/stm32f30x_i2c.c ****   tmpreg = I2Cx->ISR;
 2108              		.loc 1 1431 0
 2109 0936 7B68     		ldr	r3, [r7, #4]
 2110 0938 9B69     		ldr	r3, [r3, #24]
 2111 093a BB60     		str	r3, [r7, #8]
1432:../src/stm32f30x_i2c.c ****   
1433:../src/stm32f30x_i2c.c ****   /* Get flag status */
1434:../src/stm32f30x_i2c.c ****   tmpreg &= I2C_FLAG;
 2112              		.loc 1 1434 0
 2113 093c BA68     		ldr	r2, [r7, #8]
 2114 093e 3B68     		ldr	r3, [r7, #0]
 2115 0940 1340     		ands	r3, r3, r2
 2116 0942 BB60     		str	r3, [r7, #8]
1435:../src/stm32f30x_i2c.c ****   
1436:../src/stm32f30x_i2c.c ****   if(tmpreg != 0)
 2117              		.loc 1 1436 0
 2118 0944 BB68     		ldr	r3, [r7, #8]
 2119 0946 002B     		cmp	r3, #0
 2120 0948 03D0     		beq	.L93
1437:../src/stm32f30x_i2c.c ****   {
1438:../src/stm32f30x_i2c.c ****     /* I2C_FLAG is set */
1439:../src/stm32f30x_i2c.c ****     bitstatus = SET;
 2121              		.loc 1 1439 0
 2122 094a 4FF00103 		mov	r3, #1
 2123 094e FB73     		strb	r3, [r7, #15]
 2124 0950 02E0     		b	.L94
 2125              	.L93:
1440:../src/stm32f30x_i2c.c ****   }
1441:../src/stm32f30x_i2c.c ****   else
1442:../src/stm32f30x_i2c.c ****   {
1443:../src/stm32f30x_i2c.c ****     /* I2C_FLAG is reset */
1444:../src/stm32f30x_i2c.c ****     bitstatus = RESET;
 2126              		.loc 1 1444 0
 2127 0952 4FF00003 		mov	r3, #0
 2128 0956 FB73     		strb	r3, [r7, #15]
 2129              	.L94:
1445:../src/stm32f30x_i2c.c ****   }
1446:../src/stm32f30x_i2c.c ****   return bitstatus;
 2130              		.loc 1 1446 0
 2131 0958 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1447:../src/stm32f30x_i2c.c **** }  
 2132              		.loc 1 1447 0
 2133 095a 1846     		mov	r0, r3
 2134 095c 07F11407 		add	r7, r7, #20
 2135 0960 BD46     		mov	sp, r7
 2136 0962 80BC     		pop	{r7}
 2137 0964 7047     		bx	lr
 2138              		.cfi_endproc
 2139              	.LFE149:
 2141 0966 00BF     		.align	2
 2142              		.global	I2C_ClearFlag
 2143              		.thumb
 2144              		.thumb_func
 2146              	I2C_ClearFlag:
 2147              	.LFB150:
1448:../src/stm32f30x_i2c.c ****   
1449:../src/stm32f30x_i2c.c **** /**
1450:../src/stm32f30x_i2c.c ****   * @brief  Clears the I2Cx's pending flags.
1451:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
1452:../src/stm32f30x_i2c.c ****   * @param  I2C_FLAG: specifies the flag to clear. 
1453:../src/stm32f30x_i2c.c ****   *   This parameter can be any combination of the following values:
1454:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_ADDR: Address matched (slave mode)
1455:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_NACKF: NACK received flag
1456:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_STOPF: STOP detection flag
1457:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_BERR: Bus error
1458:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_ARLO: Arbitration lost
1459:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_OVR: Overrun/Underrun
1460:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_PECERR: PEC error in reception
1461:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow detection flag
1462:../src/stm32f30x_i2c.c ****   *     @arg I2C_FLAG_ALERT: SMBus Alert
1463:../src/stm32f30x_i2c.c ****   * @retval The new state of I2C_FLAG (SET or RESET).
1464:../src/stm32f30x_i2c.c ****   */
1465:../src/stm32f30x_i2c.c **** void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
1466:../src/stm32f30x_i2c.c **** { 
 2148              		.loc 1 1466 0
 2149              		.cfi_startproc
 2150              		@ args = 0, pretend = 0, frame = 8
 2151              		@ frame_needed = 1, uses_anonymous_args = 0
 2152              		@ link register save eliminated.
 2153 0968 80B4     		push	{r7}
 2154              	.LCFI117:
 2155              		.cfi_def_cfa_offset 4
 2156              		.cfi_offset 7, -4
 2157 096a 83B0     		sub	sp, sp, #12
 2158              	.LCFI118:
 2159              		.cfi_def_cfa_offset 16
 2160 096c 00AF     		add	r7, sp, #0
 2161              	.LCFI119:
 2162              		.cfi_def_cfa_register 7
 2163 096e 7860     		str	r0, [r7, #4]
 2164 0970 3960     		str	r1, [r7, #0]
1467:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1468:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1469:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
1470:../src/stm32f30x_i2c.c **** 
1471:../src/stm32f30x_i2c.c ****   /* Clear the selected flag */
1472:../src/stm32f30x_i2c.c ****   I2Cx->ICR = I2C_FLAG;
 2165              		.loc 1 1472 0
 2166 0972 7B68     		ldr	r3, [r7, #4]
 2167 0974 3A68     		ldr	r2, [r7, #0]
 2168 0976 DA61     		str	r2, [r3, #28]
1473:../src/stm32f30x_i2c.c ****   }
 2169              		.loc 1 1473 0
 2170 0978 07F10C07 		add	r7, r7, #12
 2171 097c BD46     		mov	sp, r7
 2172 097e 80BC     		pop	{r7}
 2173 0980 7047     		bx	lr
 2174              		.cfi_endproc
 2175              	.LFE150:
 2177 0982 00BF     		.align	2
 2178              		.global	I2C_GetITStatus
 2179              		.thumb
 2180              		.thumb_func
 2182              	I2C_GetITStatus:
 2183              	.LFB151:
1474:../src/stm32f30x_i2c.c **** 
1475:../src/stm32f30x_i2c.c **** /**
1476:../src/stm32f30x_i2c.c ****   * @brief  Checks whether the specified I2C interrupt has occurred or not.
1477:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
1478:../src/stm32f30x_i2c.c ****   * @param  I2C_IT: specifies the interrupt source to check.
1479:../src/stm32f30x_i2c.c ****   *   This parameter can be one of the following values:
1480:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_TXIS: Transmit interrupt status
1481:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_RXNE: Receive data register not empty
1482:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_ADDR: Address matched (slave mode)
1483:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_NACKF: NACK received flag
1484:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_STOPF: STOP detection flag
1485:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_TC: Transfer complete (master mode)
1486:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_TCR: Transfer complete reload
1487:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_BERR: Bus error
1488:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_ARLO: Arbitration lost
1489:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_OVR: Overrun/Underrun
1490:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_PECERR: PEC error in reception
1491:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_TIMEOUT: Timeout or Tlow detection flag
1492:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_ALERT: SMBus Alert
1493:../src/stm32f30x_i2c.c ****   * @retval The new state of I2C_IT (SET or RESET).
1494:../src/stm32f30x_i2c.c ****   */
1495:../src/stm32f30x_i2c.c **** ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
1496:../src/stm32f30x_i2c.c **** {
 2184              		.loc 1 1496 0
 2185              		.cfi_startproc
 2186              		@ args = 0, pretend = 0, frame = 24
 2187              		@ frame_needed = 1, uses_anonymous_args = 0
 2188              		@ link register save eliminated.
 2189 0984 80B4     		push	{r7}
 2190              	.LCFI120:
 2191              		.cfi_def_cfa_offset 4
 2192              		.cfi_offset 7, -4
 2193 0986 87B0     		sub	sp, sp, #28
 2194              	.LCFI121:
 2195              		.cfi_def_cfa_offset 32
 2196 0988 00AF     		add	r7, sp, #0
 2197              	.LCFI122:
 2198              		.cfi_def_cfa_register 7
 2199 098a 7860     		str	r0, [r7, #4]
 2200 098c 3960     		str	r1, [r7, #0]
1497:../src/stm32f30x_i2c.c ****   uint32_t tmpreg = 0;
 2201              		.loc 1 1497 0
 2202 098e 4FF00003 		mov	r3, #0
 2203 0992 FB60     		str	r3, [r7, #12]
1498:../src/stm32f30x_i2c.c ****   ITStatus bitstatus = RESET;
 2204              		.loc 1 1498 0
 2205 0994 4FF00003 		mov	r3, #0
 2206 0998 FB75     		strb	r3, [r7, #23]
1499:../src/stm32f30x_i2c.c ****   uint32_t enablestatus = 0;
 2207              		.loc 1 1499 0
 2208 099a 4FF00003 		mov	r3, #0
 2209 099e 3B61     		str	r3, [r7, #16]
1500:../src/stm32f30x_i2c.c **** 
1501:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1502:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1503:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_GET_IT(I2C_IT));
1504:../src/stm32f30x_i2c.c **** 
1505:../src/stm32f30x_i2c.c ****   /* Check if the interrupt source is enabled or not */
1506:../src/stm32f30x_i2c.c ****   /* If Error interrupt */
1507:../src/stm32f30x_i2c.c ****   if((uint32_t)(I2C_IT & ERROR_IT_MASK))
 2210              		.loc 1 1507 0
 2211 09a0 3B68     		ldr	r3, [r7, #0]
 2212 09a2 03F47C53 		and	r3, r3, #16128
 2213 09a6 002B     		cmp	r3, #0
 2214 09a8 05D0     		beq	.L98
1508:../src/stm32f30x_i2c.c ****   {
1509:../src/stm32f30x_i2c.c ****     enablestatus = (uint32_t)((I2C_CR1_ERRIE) & (I2Cx->CR1));
 2215              		.loc 1 1509 0
 2216 09aa 7B68     		ldr	r3, [r7, #4]
 2217 09ac 1B68     		ldr	r3, [r3, #0]
 2218 09ae 03F08003 		and	r3, r3, #128
 2219 09b2 3B61     		str	r3, [r7, #16]
 2220 09b4 0FE0     		b	.L99
 2221              	.L98:
1510:../src/stm32f30x_i2c.c ****   }
1511:../src/stm32f30x_i2c.c ****   /* If TC interrupt */
1512:../src/stm32f30x_i2c.c ****   else if((uint32_t)(I2C_IT & TC_IT_MASK))
 2222              		.loc 1 1512 0
 2223 09b6 3B68     		ldr	r3, [r7, #0]
 2224 09b8 03F0C003 		and	r3, r3, #192
 2225 09bc 002B     		cmp	r3, #0
 2226 09be 05D0     		beq	.L100
1513:../src/stm32f30x_i2c.c ****   {
1514:../src/stm32f30x_i2c.c ****     enablestatus = (uint32_t)((I2C_CR1_TCIE) & (I2Cx->CR1));
 2227              		.loc 1 1514 0
 2228 09c0 7B68     		ldr	r3, [r7, #4]
 2229 09c2 1B68     		ldr	r3, [r3, #0]
 2230 09c4 03F04003 		and	r3, r3, #64
 2231 09c8 3B61     		str	r3, [r7, #16]
 2232 09ca 04E0     		b	.L99
 2233              	.L100:
1515:../src/stm32f30x_i2c.c ****   }
1516:../src/stm32f30x_i2c.c ****   else
1517:../src/stm32f30x_i2c.c ****   {
1518:../src/stm32f30x_i2c.c ****     enablestatus = (uint32_t)((I2C_IT) & (I2Cx->CR1));
 2234              		.loc 1 1518 0
 2235 09cc 7B68     		ldr	r3, [r7, #4]
 2236 09ce 1A68     		ldr	r2, [r3, #0]
 2237 09d0 3B68     		ldr	r3, [r7, #0]
 2238 09d2 1340     		ands	r3, r3, r2
 2239 09d4 3B61     		str	r3, [r7, #16]
 2240              	.L99:
1519:../src/stm32f30x_i2c.c ****   }
1520:../src/stm32f30x_i2c.c ****   
1521:../src/stm32f30x_i2c.c ****   /* Get the ISR register value */
1522:../src/stm32f30x_i2c.c ****   tmpreg = I2Cx->ISR;
 2241              		.loc 1 1522 0
 2242 09d6 7B68     		ldr	r3, [r7, #4]
 2243 09d8 9B69     		ldr	r3, [r3, #24]
 2244 09da FB60     		str	r3, [r7, #12]
1523:../src/stm32f30x_i2c.c **** 
1524:../src/stm32f30x_i2c.c ****   /* Get flag status */
1525:../src/stm32f30x_i2c.c ****   tmpreg &= I2C_IT;
 2245              		.loc 1 1525 0
 2246 09dc FA68     		ldr	r2, [r7, #12]
 2247 09de 3B68     		ldr	r3, [r7, #0]
 2248 09e0 1340     		ands	r3, r3, r2
 2249 09e2 FB60     		str	r3, [r7, #12]
1526:../src/stm32f30x_i2c.c **** 
1527:../src/stm32f30x_i2c.c ****   /* Check the status of the specified I2C flag */
1528:../src/stm32f30x_i2c.c ****   if((tmpreg != RESET) && enablestatus)
 2250              		.loc 1 1528 0
 2251 09e4 FB68     		ldr	r3, [r7, #12]
 2252 09e6 002B     		cmp	r3, #0
 2253 09e8 06D0     		beq	.L101
 2254              		.loc 1 1528 0 is_stmt 0 discriminator 1
 2255 09ea 3B69     		ldr	r3, [r7, #16]
 2256 09ec 002B     		cmp	r3, #0
 2257 09ee 03D0     		beq	.L101
1529:../src/stm32f30x_i2c.c ****   {
1530:../src/stm32f30x_i2c.c ****     /* I2C_IT is set */
1531:../src/stm32f30x_i2c.c ****     bitstatus = SET;
 2258              		.loc 1 1531 0 is_stmt 1
 2259 09f0 4FF00103 		mov	r3, #1
 2260 09f4 FB75     		strb	r3, [r7, #23]
 2261 09f6 02E0     		b	.L102
 2262              	.L101:
1532:../src/stm32f30x_i2c.c ****   }
1533:../src/stm32f30x_i2c.c ****   else
1534:../src/stm32f30x_i2c.c ****   {
1535:../src/stm32f30x_i2c.c ****     /* I2C_IT is reset */
1536:../src/stm32f30x_i2c.c ****     bitstatus = RESET;
 2263              		.loc 1 1536 0
 2264 09f8 4FF00003 		mov	r3, #0
 2265 09fc FB75     		strb	r3, [r7, #23]
 2266              	.L102:
1537:../src/stm32f30x_i2c.c ****   }
1538:../src/stm32f30x_i2c.c **** 
1539:../src/stm32f30x_i2c.c ****   /* Return the I2C_IT status */
1540:../src/stm32f30x_i2c.c ****   return bitstatus;
 2267              		.loc 1 1540 0
 2268 09fe FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1541:../src/stm32f30x_i2c.c **** }
 2269              		.loc 1 1541 0
 2270 0a00 1846     		mov	r0, r3
 2271 0a02 07F11C07 		add	r7, r7, #28
 2272 0a06 BD46     		mov	sp, r7
 2273 0a08 80BC     		pop	{r7}
 2274 0a0a 7047     		bx	lr
 2275              		.cfi_endproc
 2276              	.LFE151:
 2278              		.align	2
 2279              		.global	I2C_ClearITPendingBit
 2280              		.thumb
 2281              		.thumb_func
 2283              	I2C_ClearITPendingBit:
 2284              	.LFB152:
1542:../src/stm32f30x_i2c.c ****   
1543:../src/stm32f30x_i2c.c **** /**
1544:../src/stm32f30x_i2c.c ****   * @brief  Clears the I2Cx's interrupt pending bits.
1545:../src/stm32f30x_i2c.c ****   * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
1546:../src/stm32f30x_i2c.c ****   * @param  I2C_IT: specifies the interrupt pending bit to clear.
1547:../src/stm32f30x_i2c.c ****   *   This parameter can be any combination of the following values:
1548:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_ADDR: Address matched (slave mode)
1549:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_NACKF: NACK received flag
1550:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_STOPF: STOP detection flag
1551:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_BERR: Bus error
1552:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_ARLO: Arbitration lost
1553:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_OVR: Overrun/Underrun
1554:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_PECERR: PEC error in reception
1555:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_TIMEOUT: Timeout or Tlow detection flag
1556:../src/stm32f30x_i2c.c ****   *     @arg I2C_IT_ALERT: SMBus Alert
1557:../src/stm32f30x_i2c.c ****   * @retval The new state of I2C_IT (SET or RESET).
1558:../src/stm32f30x_i2c.c ****   */
1559:../src/stm32f30x_i2c.c **** void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
1560:../src/stm32f30x_i2c.c **** {
 2285              		.loc 1 1560 0
 2286              		.cfi_startproc
 2287              		@ args = 0, pretend = 0, frame = 8
 2288              		@ frame_needed = 1, uses_anonymous_args = 0
 2289              		@ link register save eliminated.
 2290 0a0c 80B4     		push	{r7}
 2291              	.LCFI123:
 2292              		.cfi_def_cfa_offset 4
 2293              		.cfi_offset 7, -4
 2294 0a0e 83B0     		sub	sp, sp, #12
 2295              	.LCFI124:
 2296              		.cfi_def_cfa_offset 16
 2297 0a10 00AF     		add	r7, sp, #0
 2298              	.LCFI125:
 2299              		.cfi_def_cfa_register 7
 2300 0a12 7860     		str	r0, [r7, #4]
 2301 0a14 3960     		str	r1, [r7, #0]
1561:../src/stm32f30x_i2c.c ****   /* Check the parameters */
1562:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_ALL_PERIPH(I2Cx));
1563:../src/stm32f30x_i2c.c ****   assert_param(IS_I2C_CLEAR_IT(I2C_IT));
1564:../src/stm32f30x_i2c.c **** 
1565:../src/stm32f30x_i2c.c ****   /* Clear the selected flag */
1566:../src/stm32f30x_i2c.c ****   I2Cx->ICR = I2C_IT;
 2302              		.loc 1 1566 0
 2303 0a16 7B68     		ldr	r3, [r7, #4]
 2304 0a18 3A68     		ldr	r2, [r7, #0]
 2305 0a1a DA61     		str	r2, [r3, #28]
1567:../src/stm32f30x_i2c.c **** }
 2306              		.loc 1 1567 0
 2307 0a1c 07F10C07 		add	r7, r7, #12
 2308 0a20 BD46     		mov	sp, r7
 2309 0a22 80BC     		pop	{r7}
 2310 0a24 7047     		bx	lr
 2311              		.cfi_endproc
 2312              	.LFE152:
 2314              	.Letext0:
 2315              		.file 2 "/home/aghosh01/gcc-arm-none-eabi-4_7-2012q4/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../.
 2316              		.file 3 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x.h"
 2317              		.file 4 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x_i2c.h"
 2318              		.file 5 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f30x_i2c.c
     /tmp/ccTqSRUF.s:19     .text:00000000 $t
     /tmp/ccTqSRUF.s:24     .text:00000000 I2C_DeInit
     /tmp/ccTqSRUF.s:80     .text:00000050 I2C_Init
     /tmp/ccTqSRUF.s:217    .text:00000120 I2C_StructInit
     /tmp/ccTqSRUF.s:276    .text:0000016c I2C_Cmd
     /tmp/ccTqSRUF.s:328    .text:000001a4 I2C_SoftwareResetCmd
     /tmp/ccTqSRUF.s:374    .text:000001d4 I2C_ITConfig
     /tmp/ccTqSRUF.s:430    .text:00000210 I2C_StretchClockCmd
     /tmp/ccTqSRUF.s:482    .text:00000248 I2C_StopModeCmd
     /tmp/ccTqSRUF.s:534    .text:00000280 I2C_DualAddressCmd
     /tmp/ccTqSRUF.s:586    .text:000002b8 I2C_OwnAddress2Config
     /tmp/ccTqSRUF.s:649    .text:00000308 I2C_GeneralCallCmd
     /tmp/ccTqSRUF.s:701    .text:00000340 I2C_SlaveByteControlCmd
     /tmp/ccTqSRUF.s:753    .text:00000378 I2C_SlaveAddressConfig
     /tmp/ccTqSRUF.s:809    .text:000003bc I2C_10BitAddressingModeCmd
     /tmp/ccTqSRUF.s:861    .text:000003f4 I2C_AutoEndCmd
     /tmp/ccTqSRUF.s:913    .text:0000042c I2C_ReloadCmd
     /tmp/ccTqSRUF.s:965    .text:00000464 I2C_NumberOfBytesConfig
     /tmp/ccTqSRUF.s:1020   .text:000004a4 I2C_MasterRequestConfig
     /tmp/ccTqSRUF.s:1072   .text:000004dc I2C_GenerateSTART
     /tmp/ccTqSRUF.s:1124   .text:00000514 I2C_GenerateSTOP
     /tmp/ccTqSRUF.s:1176   .text:0000054c I2C_10BitAddressHeaderCmd
     /tmp/ccTqSRUF.s:1228   .text:00000584 I2C_AcknowledgeConfig
     /tmp/ccTqSRUF.s:1280   .text:000005bc I2C_GetAddressMatched
     /tmp/ccTqSRUF.s:1318   .text:000005e0 I2C_GetTransferDirection
     /tmp/ccTqSRUF.s:1376   .text:00000620 I2C_TransferHandling
     /tmp/ccTqSRUF.s:1444   .text:00000680 I2C_SMBusAlertCmd
     /tmp/ccTqSRUF.s:1496   .text:000006b8 I2C_ClockTimeoutCmd
     /tmp/ccTqSRUF.s:1548   .text:000006f0 I2C_ExtendedClockTimeoutCmd
     /tmp/ccTqSRUF.s:1600   .text:00000728 I2C_IdleClockTimeoutCmd
     /tmp/ccTqSRUF.s:1652   .text:00000760 I2C_TimeoutAConfig
     /tmp/ccTqSRUF.s:1708   .text:000007a4 I2C_TimeoutBConfig
     /tmp/ccTqSRUF.s:1766   .text:000007f0 I2C_CalculatePEC
     /tmp/ccTqSRUF.s:1818   .text:00000828 I2C_PECRequestCmd
     /tmp/ccTqSRUF.s:1870   .text:00000860 I2C_GetPEC
     /tmp/ccTqSRUF.s:1906   .text:0000087c I2C_ReadRegister
     /tmp/ccTqSRUF.s:1954   .text:000008ac I2C_SendData
     /tmp/ccTqSRUF.s:1991   .text:000008c8 I2C_ReceiveData
     /tmp/ccTqSRUF.s:2027   .text:000008e4 I2C_DMACmd
     /tmp/ccTqSRUF.s:2083   .text:00000920 I2C_GetFlagStatus
     /tmp/ccTqSRUF.s:2146   .text:00000968 I2C_ClearFlag
     /tmp/ccTqSRUF.s:2182   .text:00000984 I2C_GetITStatus
     /tmp/ccTqSRUF.s:2283   .text:00000a0c I2C_ClearITPendingBit
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.323dce8664331a0daf4a2675e107c70c
                           .group:00000000 wm4.stm32f30x.h.56.6f19c65e98e3319a61449cb2b2455af5
                           .group:00000000 wm4.core_cm4.h.32.1434cd257ff5806b1b03cd32ab0641e9
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.core_cmInstr.h.25.d8165482ef3061013a2fc83e2d85f3d9
                           .group:00000000 wm4.core_cm4_simd.h.29.013e5bcf58dba2d27c60184174208e07
                           .group:00000000 wm4.core_cm4.h.155.cf7c793e178943e1bbf613f1b21cd51a
                           .group:00000000 wm4.stm32f30x.h.294.d8a54360eca16e4157694b52a095202d
                           .group:00000000 wm4.stm32f30x_adc.h.130.cbebad91f78fb87381fe0860eea6104e
                           .group:00000000 wm4.stm32f30x_can.h.50.8b8f5d301152c422a6e50622b33ef620
                           .group:00000000 wm4.stm32f30x_crc.h.54.66d4c5e565e18566aebd9abfd4bcd4b0
                           .group:00000000 wm4.stm32f30x_comp.h.91.06ae44150aaaa82c077b71df8db3541a
                           .group:00000000 wm4.stm32f30x_dac.h.49.b1b5b26e4ca241dbe67fa16dc86a615f
                           .group:00000000 wm4.stm32f30x_dbgmcu.h.53.b238a263ce6a2cc83f610cc35302a38b
                           .group:00000000 wm4.stm32f30x_dma.h.96.d7a2ddd10023e12781aa8ff5ac15d212
                           .group:00000000 wm4.stm32f30x_exti.h.60.8ca0809491a21dec6fc69cf7471e2bab
                           .group:00000000 wm4.stm32f30x_flash.h.70.32613455dfe7328932f786a224daac23
                           .group:00000000 wm4.stm32f30x_gpio.h.50.408e1f6250246e4cc28221970909d34c
                           .group:00000000 wm4.stm32f30x_syscfg.h.58.4cadeb4ec8e47d36b972bbb6b96b7161
                           .group:00000000 wm4.stm32f30x_iwdg.h.59.467d704fb073a015941f19b50fa6470a
                           .group:00000000 wm4.stm32f30x_opamp.h.75.704e2e5e2aab039de307aaa2dcc99fa5
                           .group:00000000 wm4.stm32f30x_pwr.h.59.5c85acff2a3e3c5085b2140c06025cfc
                           .group:00000000 wm4.stm32f30x_rcc.h.79.5ba7cac1e74879861a72556c25322aa4
                           .group:00000000 wm4.stm32f30x_rtc.h.133.d184e08ff40bda44db4bed94f9633384
                           .group:00000000 wm4.stm32f30x_spi.h.119.4d21ec94ec14f3553a127e61c0a9874f
                           .group:00000000 wm4.stm32f30x_tim.h.175.d4a93cff2e7924577147254e501271b6
                           .group:00000000 wm4.stm32f30x_usart.h.110.c89016273702821ff4f9fe43881f70b5
                           .group:00000000 wm4.stm32f30x_wwdg.h.58.4688eee61a2709866472b4b4c07d9275
                           .group:00000000 wm4.stm32f30x_misc.h.113.6a52e4fe7c3825a3ab05990f30dddf92
                           .group:00000000 wm4.stm32f30x_i2c.h.86.3d51d4edc0e3b9ee9aae045ccbb7739a

UNDEFINED SYMBOLS
RCC_APB1PeriphResetCmd
