   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 6
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"stm32f30x_usart.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.align	2
  21              		.global	USART_DeInit
  22              		.thumb
  23              		.thumb_func
  25              	USART_DeInit:
  26              	.LFB111:
  27              		.file 1 "../src/stm32f30x_usart.c"
   1:../src/stm32f30x_usart.c **** /**
   2:../src/stm32f30x_usart.c ****   ******************************************************************************
   3:../src/stm32f30x_usart.c ****   * @file    stm32f30x_usart.c
   4:../src/stm32f30x_usart.c ****   * @author  MCD Application Team
   5:../src/stm32f30x_usart.c ****   * @version V1.0.1
   6:../src/stm32f30x_usart.c ****   * @date    23-October-2012
   7:../src/stm32f30x_usart.c ****   * @brief   This file provides firmware functions to manage the following
   8:../src/stm32f30x_usart.c ****   *          functionalities of the Universal synchronous asynchronous receiver
   9:../src/stm32f30x_usart.c ****   *          transmitter (USART):
  10:../src/stm32f30x_usart.c ****   *           + Initialization and Configuration
  11:../src/stm32f30x_usart.c ****   *           + STOP Mode
  12:../src/stm32f30x_usart.c ****   *           + AutoBaudRate
  13:../src/stm32f30x_usart.c ****   *           + Data transfers
  14:../src/stm32f30x_usart.c ****   *           + Multi-Processor Communication
  15:../src/stm32f30x_usart.c ****   *           + LIN mode
  16:../src/stm32f30x_usart.c ****   *           + Half-duplex mode
  17:../src/stm32f30x_usart.c ****   *           + Smartcard mode
  18:../src/stm32f30x_usart.c ****   *           + IrDA mode
  19:../src/stm32f30x_usart.c ****   *           + RS485 mode  
  20:../src/stm32f30x_usart.c ****   *           + DMA transfers management
  21:../src/stm32f30x_usart.c ****   *           + Interrupts and flags management
  22:../src/stm32f30x_usart.c ****   *           
  23:../src/stm32f30x_usart.c ****   *  @verbatim  
  24:../src/stm32f30x_usart.c ****  ===============================================================================
  25:../src/stm32f30x_usart.c ****                       ##### How to use this driver #####
  26:../src/stm32f30x_usart.c ****  ===============================================================================
  27:../src/stm32f30x_usart.c ****       [..]
  28:../src/stm32f30x_usart.c ****           (#) Enable peripheral clock using RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE)
  29:../src/stm32f30x_usart.c ****              function for USART1 or using RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE)
  30:../src/stm32f30x_usart.c ****              function for USART2, USART3, UART4 and UART5.
  31:../src/stm32f30x_usart.c ****           (#)  According to the USART mode, enable the GPIO clocks using
  32:../src/stm32f30x_usart.c ****               RCC_AHBPeriphClockCmd() function. (The I/O can be TX, RX, CTS,
  33:../src/stm32f30x_usart.c ****               or and SCLK).
  34:../src/stm32f30x_usart.c ****           (#) Peripheral's alternate function:
  35:../src/stm32f30x_usart.c ****               (++) Connect the pin to the desired peripherals' Alternate
  36:../src/stm32f30x_usart.c ****                    Function (AF) using GPIO_PinAFConfig() function.
  37:../src/stm32f30x_usart.c ****               (++) Configure the desired pin in alternate function by:
  38:../src/stm32f30x_usart.c ****                    GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF.
  39:../src/stm32f30x_usart.c ****               (++) Select the type, pull-up/pull-down and output speed via
  40:../src/stm32f30x_usart.c ****                    GPIO_PuPd, GPIO_OType and GPIO_Speed members.
  41:../src/stm32f30x_usart.c ****               (++) Call GPIO_Init() function.
  42:../src/stm32f30x_usart.c ****           (#) Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware
  43:../src/stm32f30x_usart.c ****              flow control and Mode(Receiver/Transmitter) using the SPI_Init()
  44:../src/stm32f30x_usart.c ****              function.
  45:../src/stm32f30x_usart.c ****           (#) For synchronous mode, enable the clock and program the polarity,
  46:../src/stm32f30x_usart.c ****              phase and last bit using the USART_ClockInit() function.
  47:../src/stm32f30x_usart.c ****           (#) Enable the NVIC and the corresponding interrupt using the function
  48:../src/stm32f30x_usart.c ****              USART_ITConfig() if you need to use interrupt mode.
  49:../src/stm32f30x_usart.c ****           (#) When using the DMA mode:
  50:../src/stm32f30x_usart.c ****               (++) Configure the DMA using DMA_Init() function.
  51:../src/stm32f30x_usart.c ****               (++) Active the needed channel Request using USART_DMACmd() function.
  52:../src/stm32f30x_usart.c ****           (#) Enable the USART using the USART_Cmd() function.
  53:../src/stm32f30x_usart.c ****           (#) Enable the DMA using the DMA_Cmd() function, when using DMA mode.
  54:../src/stm32f30x_usart.c ****       [..]
  55:../src/stm32f30x_usart.c ****               Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
  56:../src/stm32f30x_usart.c ****               for more details.
  57:../src/stm32f30x_usart.c **** 
  58:../src/stm32f30x_usart.c ****    @endverbatim
  59:../src/stm32f30x_usart.c **** 
  60:../src/stm32f30x_usart.c ****   ******************************************************************************
  61:../src/stm32f30x_usart.c ****   * @attention
  62:../src/stm32f30x_usart.c ****   *
  63:../src/stm32f30x_usart.c ****   * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
  64:../src/stm32f30x_usart.c ****   *
  65:../src/stm32f30x_usart.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  66:../src/stm32f30x_usart.c ****   * You may not use this file except in compliance with the License.
  67:../src/stm32f30x_usart.c ****   * You may obtain a copy of the License at:
  68:../src/stm32f30x_usart.c ****   *
  69:../src/stm32f30x_usart.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  70:../src/stm32f30x_usart.c ****   *
  71:../src/stm32f30x_usart.c ****   * Unless required by applicable law or agreed to in writing, software 
  72:../src/stm32f30x_usart.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  73:../src/stm32f30x_usart.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  74:../src/stm32f30x_usart.c ****   * See the License for the specific language governing permissions and
  75:../src/stm32f30x_usart.c ****   * limitations under the License.
  76:../src/stm32f30x_usart.c ****   *
  77:../src/stm32f30x_usart.c ****   ******************************************************************************
  78:../src/stm32f30x_usart.c ****   */
  79:../src/stm32f30x_usart.c **** 
  80:../src/stm32f30x_usart.c **** /* Includes ------------------------------------------------------------------*/
  81:../src/stm32f30x_usart.c **** #include "stm32f30x_usart.h"
  82:../src/stm32f30x_usart.c **** #include "stm32f30x_rcc.h"
  83:../src/stm32f30x_usart.c **** 
  84:../src/stm32f30x_usart.c **** /** @addtogroup STM32F30x_StdPeriph_Driver
  85:../src/stm32f30x_usart.c ****   * @{
  86:../src/stm32f30x_usart.c ****   */
  87:../src/stm32f30x_usart.c **** 
  88:../src/stm32f30x_usart.c **** /** @defgroup USART 
  89:../src/stm32f30x_usart.c ****   * @brief USART driver modules
  90:../src/stm32f30x_usart.c ****   * @{
  91:../src/stm32f30x_usart.c ****   */
  92:../src/stm32f30x_usart.c **** 
  93:../src/stm32f30x_usart.c **** /* Private typedef -----------------------------------------------------------*/
  94:../src/stm32f30x_usart.c **** /* Private define ------------------------------------------------------------*/
  95:../src/stm32f30x_usart.c **** 
  96:../src/stm32f30x_usart.c **** /*!< USART CR1 register clear Mask ((~(uint32_t)0xFFFFE6F3)) */
  97:../src/stm32f30x_usart.c **** #define CR1_CLEAR_MASK            ((uint32_t)(USART_CR1_M | USART_CR1_PCE | \
  98:../src/stm32f30x_usart.c ****                                               USART_CR1_PS | USART_CR1_TE | \
  99:../src/stm32f30x_usart.c ****                                               USART_CR1_RE))
 100:../src/stm32f30x_usart.c **** 
 101:../src/stm32f30x_usart.c **** /*!< USART CR2 register clock bits clear Mask ((~(uint32_t)0xFFFFF0FF)) */
 102:../src/stm32f30x_usart.c **** #define CR2_CLOCK_CLEAR_MASK      ((uint32_t)(USART_CR2_CLKEN | USART_CR2_CPOL | \
 103:../src/stm32f30x_usart.c ****                                               USART_CR2_CPHA | USART_CR2_LBCL))
 104:../src/stm32f30x_usart.c **** 
 105:../src/stm32f30x_usart.c **** /*!< USART CR3 register clear Mask ((~(uint32_t)0xFFFFFCFF)) */
 106:../src/stm32f30x_usart.c **** #define CR3_CLEAR_MASK            ((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE))
 107:../src/stm32f30x_usart.c **** 
 108:../src/stm32f30x_usart.c **** /*!< USART Interrupts mask */
 109:../src/stm32f30x_usart.c **** #define IT_MASK                   ((uint32_t)0x000000FF)
 110:../src/stm32f30x_usart.c **** 
 111:../src/stm32f30x_usart.c **** /* Private macro -------------------------------------------------------------*/
 112:../src/stm32f30x_usart.c **** /* Private variables ---------------------------------------------------------*/
 113:../src/stm32f30x_usart.c **** /* Private function prototypes -----------------------------------------------*/
 114:../src/stm32f30x_usart.c **** /* Private functions ---------------------------------------------------------*/
 115:../src/stm32f30x_usart.c **** 
 116:../src/stm32f30x_usart.c **** /** @defgroup USART_Private_Functions
 117:../src/stm32f30x_usart.c ****   * @{
 118:../src/stm32f30x_usart.c ****   */
 119:../src/stm32f30x_usart.c **** 
 120:../src/stm32f30x_usart.c **** /** @defgroup USART_Group1 Initialization and Configuration functions
 121:../src/stm32f30x_usart.c ****  *  @brief   Initialization and Configuration functions 
 122:../src/stm32f30x_usart.c ****  *
 123:../src/stm32f30x_usart.c **** @verbatim 
 124:../src/stm32f30x_usart.c ****  ===============================================================================
 125:../src/stm32f30x_usart.c ****            ##### Initialization and Configuration functions #####
 126:../src/stm32f30x_usart.c ****  ===============================================================================  
 127:../src/stm32f30x_usart.c ****   [..]
 128:../src/stm32f30x_usart.c ****       This subsection provides a set of functions allowing to initialize the USART 
 129:../src/stm32f30x_usart.c ****       in asynchronous and in synchronous modes.
 130:../src/stm32f30x_usart.c ****        (+) For the asynchronous mode only these parameters can be configured: 
 131:../src/stm32f30x_usart.c ****             (++) Baud Rate.
 132:../src/stm32f30x_usart.c ****             (++) Word Length. 
 133:../src/stm32f30x_usart.c ****             (++) Stop Bit.
 134:../src/stm32f30x_usart.c ****             (++) Parity: If the parity is enabled, then the MSB bit of the data written
 135:../src/stm32f30x_usart.c ****                  in the data register is transmitted but is changed by the parity bit.
 136:../src/stm32f30x_usart.c ****                  Depending on the frame length defined by the M bit (8-bits or 9-bits),
 137:../src/stm32f30x_usart.c ****                  the possible USART frame formats are as listed in the following table:
 138:../src/stm32f30x_usart.c ****     [..]
 139:../src/stm32f30x_usart.c ****    +-------------------------------------------------------------+     
 140:../src/stm32f30x_usart.c ****    |   M bit |  PCE bit  |            USART frame                |
 141:../src/stm32f30x_usart.c ****    |---------------------|---------------------------------------|             
 142:../src/stm32f30x_usart.c ****    |    0    |    0      |    | SB | 8 bit data | STB |          |
 143:../src/stm32f30x_usart.c ****    |---------|-----------|---------------------------------------|  
 144:../src/stm32f30x_usart.c ****    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
 145:../src/stm32f30x_usart.c ****    |---------|-----------|---------------------------------------|  
 146:../src/stm32f30x_usart.c ****    |    1    |    0      |    | SB | 9 bit data | STB |          |
 147:../src/stm32f30x_usart.c ****    |---------|-----------|---------------------------------------|  
 148:../src/stm32f30x_usart.c ****    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
 149:../src/stm32f30x_usart.c ****    +-------------------------------------------------------------+            
 150:../src/stm32f30x_usart.c ****     [..]
 151:../src/stm32f30x_usart.c ****            (++) Hardware flow control.
 152:../src/stm32f30x_usart.c ****            (++) Receiver/transmitter modes.
 153:../src/stm32f30x_usart.c ****     [..] The USART_Init() function follows the USART  asynchronous configuration 
 154:../src/stm32f30x_usart.c ****          procedure(details for the procedure are available in reference manual.
 155:../src/stm32f30x_usart.c ****         (+) For the synchronous mode in addition to the asynchronous mode parameters
 156:../src/stm32f30x_usart.c ****             these parameters should be also configured:
 157:../src/stm32f30x_usart.c ****             (++) USART Clock Enabled.
 158:../src/stm32f30x_usart.c ****             (++) USART polarity.
 159:../src/stm32f30x_usart.c ****             (++) USART phase.
 160:../src/stm32f30x_usart.c ****             (++) USART LastBit.
 161:../src/stm32f30x_usart.c ****     [..] These parameters can be configured using the USART_ClockInit() function.
 162:../src/stm32f30x_usart.c **** 
 163:../src/stm32f30x_usart.c **** @endverbatim
 164:../src/stm32f30x_usart.c ****   * @{
 165:../src/stm32f30x_usart.c ****   */
 166:../src/stm32f30x_usart.c ****   
 167:../src/stm32f30x_usart.c **** /**
 168:../src/stm32f30x_usart.c ****   * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
 169:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 170:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 171:../src/stm32f30x_usart.c ****   * @retval None
 172:../src/stm32f30x_usart.c ****   */
 173:../src/stm32f30x_usart.c **** void USART_DeInit(USART_TypeDef* USARTx)
 174:../src/stm32f30x_usart.c **** {
  28              		.loc 1 174 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 8
  31              		@ frame_needed = 1, uses_anonymous_args = 0
  32 0000 80B5     		push	{r7, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 7, -8
  36              		.cfi_offset 14, -4
  37 0002 82B0     		sub	sp, sp, #8
  38              	.LCFI1:
  39              		.cfi_def_cfa_offset 16
  40 0004 00AF     		add	r7, sp, #0
  41              	.LCFI2:
  42              		.cfi_def_cfa_register 7
  43 0006 7860     		str	r0, [r7, #4]
 175:../src/stm32f30x_usart.c ****   /* Check the parameters */
 176:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 177:../src/stm32f30x_usart.c **** 
 178:../src/stm32f30x_usart.c ****   if (USARTx == USART1)
  44              		.loc 1 178 0
  45 0008 7A68     		ldr	r2, [r7, #4]
  46 000a 4FF46053 		mov	r3, #14336
  47 000e C4F20103 		movt	r3, 16385
  48 0012 9A42     		cmp	r2, r3
  49 0014 0CD1     		bne	.L2
 179:../src/stm32f30x_usart.c ****   {
 180:../src/stm32f30x_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
  50              		.loc 1 180 0
  51 0016 4FF48040 		mov	r0, #16384
  52 001a 4FF00101 		mov	r1, #1
  53 001e FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 181:../src/stm32f30x_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  54              		.loc 1 181 0
  55 0022 4FF48040 		mov	r0, #16384
  56 0026 4FF00001 		mov	r1, #0
  57 002a FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  58 002e 4EE0     		b	.L1
  59              	.L2:
 182:../src/stm32f30x_usart.c ****   }
 183:../src/stm32f30x_usart.c ****   else if (USARTx == USART2)
  60              		.loc 1 183 0
  61 0030 7A68     		ldr	r2, [r7, #4]
  62 0032 4FF48843 		mov	r3, #17408
  63 0036 C4F20003 		movt	r3, 16384
  64 003a 9A42     		cmp	r2, r3
  65 003c 0CD1     		bne	.L4
 184:../src/stm32f30x_usart.c ****   {
 185:../src/stm32f30x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
  66              		.loc 1 185 0
  67 003e 4FF40030 		mov	r0, #131072
  68 0042 4FF00101 		mov	r1, #1
  69 0046 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 186:../src/stm32f30x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  70              		.loc 1 186 0
  71 004a 4FF40030 		mov	r0, #131072
  72 004e 4FF00001 		mov	r1, #0
  73 0052 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  74 0056 3AE0     		b	.L1
  75              	.L4:
 187:../src/stm32f30x_usart.c ****   }
 188:../src/stm32f30x_usart.c ****   else if (USARTx == USART3)
  76              		.loc 1 188 0
  77 0058 7A68     		ldr	r2, [r7, #4]
  78 005a 4FF49043 		mov	r3, #18432
  79 005e C4F20003 		movt	r3, 16384
  80 0062 9A42     		cmp	r2, r3
  81 0064 0CD1     		bne	.L5
 189:../src/stm32f30x_usart.c ****   {
 190:../src/stm32f30x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
  82              		.loc 1 190 0
  83 0066 4FF48020 		mov	r0, #262144
  84 006a 4FF00101 		mov	r1, #1
  85 006e FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 191:../src/stm32f30x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  86              		.loc 1 191 0
  87 0072 4FF48020 		mov	r0, #262144
  88 0076 4FF00001 		mov	r1, #0
  89 007a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  90 007e 26E0     		b	.L1
  91              	.L5:
 192:../src/stm32f30x_usart.c ****   }
 193:../src/stm32f30x_usart.c ****   else if (USARTx == UART4)
  92              		.loc 1 193 0
  93 0080 7A68     		ldr	r2, [r7, #4]
  94 0082 4FF49843 		mov	r3, #19456
  95 0086 C4F20003 		movt	r3, 16384
  96 008a 9A42     		cmp	r2, r3
  97 008c 0CD1     		bne	.L6
 194:../src/stm32f30x_usart.c ****   {
 195:../src/stm32f30x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
  98              		.loc 1 195 0
  99 008e 4FF40020 		mov	r0, #524288
 100 0092 4FF00101 		mov	r1, #1
 101 0096 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 196:../src/stm32f30x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 102              		.loc 1 196 0
 103 009a 4FF40020 		mov	r0, #524288
 104 009e 4FF00001 		mov	r1, #0
 105 00a2 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 106 00a6 12E0     		b	.L1
 107              	.L6:
 197:../src/stm32f30x_usart.c ****   }
 198:../src/stm32f30x_usart.c ****   else
 199:../src/stm32f30x_usart.c ****   {
 200:../src/stm32f30x_usart.c ****     if  (USARTx == UART5)
 108              		.loc 1 200 0
 109 00a8 7A68     		ldr	r2, [r7, #4]
 110 00aa 4FF4A043 		mov	r3, #20480
 111 00ae C4F20003 		movt	r3, 16384
 112 00b2 9A42     		cmp	r2, r3
 113 00b4 0BD1     		bne	.L1
 201:../src/stm32f30x_usart.c ****     {
 202:../src/stm32f30x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 114              		.loc 1 202 0
 115 00b6 4FF48010 		mov	r0, #1048576
 116 00ba 4FF00101 		mov	r1, #1
 117 00be FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 203:../src/stm32f30x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 118              		.loc 1 203 0
 119 00c2 4FF48010 		mov	r0, #1048576
 120 00c6 4FF00001 		mov	r1, #0
 121 00ca FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 122              	.L1:
 204:../src/stm32f30x_usart.c ****     }
 205:../src/stm32f30x_usart.c ****   }
 206:../src/stm32f30x_usart.c **** }
 123              		.loc 1 206 0
 124 00ce 07F10807 		add	r7, r7, #8
 125 00d2 BD46     		mov	sp, r7
 126 00d4 80BD     		pop	{r7, pc}
 127              		.cfi_endproc
 128              	.LFE111:
 130 00d6 00BF     		.align	2
 131              		.global	USART_Init
 132              		.thumb
 133              		.thumb_func
 135              	USART_Init:
 136              	.LFB112:
 207:../src/stm32f30x_usart.c **** 
 208:../src/stm32f30x_usart.c **** /**
 209:../src/stm32f30x_usart.c ****   * @brief  Initializes the USARTx peripheral according to the specified
 210:../src/stm32f30x_usart.c ****   *         parameters in the USART_InitStruct .
 211:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 212:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 213:../src/stm32f30x_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
 214:../src/stm32f30x_usart.c ****   *         that contains the configuration information for the specified USART peripheral.
 215:../src/stm32f30x_usart.c ****   * @retval None
 216:../src/stm32f30x_usart.c ****   */
 217:../src/stm32f30x_usart.c **** void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
 218:../src/stm32f30x_usart.c **** {
 137              		.loc 1 218 0
 138              		.cfi_startproc
 139              		@ args = 0, pretend = 0, frame = 80
 140              		@ frame_needed = 1, uses_anonymous_args = 0
 141 00d8 80B5     		push	{r7, lr}
 142              	.LCFI3:
 143              		.cfi_def_cfa_offset 8
 144              		.cfi_offset 7, -8
 145              		.cfi_offset 14, -4
 146 00da 94B0     		sub	sp, sp, #80
 147              	.LCFI4:
 148              		.cfi_def_cfa_offset 88
 149 00dc 00AF     		add	r7, sp, #0
 150              	.LCFI5:
 151              		.cfi_def_cfa_register 7
 152 00de 7860     		str	r0, [r7, #4]
 153 00e0 3960     		str	r1, [r7, #0]
 219:../src/stm32f30x_usart.c ****   uint32_t divider = 0, apbclock = 0, tmpreg = 0;
 154              		.loc 1 219 0
 155 00e2 4FF00003 		mov	r3, #0
 156 00e6 FB64     		str	r3, [r7, #76]
 157 00e8 4FF00003 		mov	r3, #0
 158 00ec BB64     		str	r3, [r7, #72]
 159 00ee 4FF00003 		mov	r3, #0
 160 00f2 7B64     		str	r3, [r7, #68]
 220:../src/stm32f30x_usart.c ****   RCC_ClocksTypeDef RCC_ClocksStatus;
 221:../src/stm32f30x_usart.c ****   
 222:../src/stm32f30x_usart.c ****   /* Check the parameters */
 223:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 224:../src/stm32f30x_usart.c ****   assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));
 225:../src/stm32f30x_usart.c ****   assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
 226:../src/stm32f30x_usart.c ****   assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
 227:../src/stm32f30x_usart.c ****   assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
 228:../src/stm32f30x_usart.c ****   assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
 229:../src/stm32f30x_usart.c ****   assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
 230:../src/stm32f30x_usart.c ****   
 231:../src/stm32f30x_usart.c ****   /* Disable USART */
 232:../src/stm32f30x_usart.c ****   USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 161              		.loc 1 232 0
 162 00f4 7B68     		ldr	r3, [r7, #4]
 163 00f6 1B68     		ldr	r3, [r3, #0]
 164 00f8 23F00102 		bic	r2, r3, #1
 165 00fc 7B68     		ldr	r3, [r7, #4]
 166 00fe 1A60     		str	r2, [r3, #0]
 233:../src/stm32f30x_usart.c ****   
 234:../src/stm32f30x_usart.c ****   /*---------------------------- USART CR2 Configuration -----------------------*/
 235:../src/stm32f30x_usart.c ****   tmpreg = USARTx->CR2;
 167              		.loc 1 235 0
 168 0100 7B68     		ldr	r3, [r7, #4]
 169 0102 5B68     		ldr	r3, [r3, #4]
 170 0104 7B64     		str	r3, [r7, #68]
 236:../src/stm32f30x_usart.c ****   /* Clear STOP[13:12] bits */
 237:../src/stm32f30x_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 171              		.loc 1 237 0
 172 0106 7B6C     		ldr	r3, [r7, #68]
 173 0108 23F44053 		bic	r3, r3, #12288
 174 010c 7B64     		str	r3, [r7, #68]
 238:../src/stm32f30x_usart.c ****   
 239:../src/stm32f30x_usart.c ****   /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
 240:../src/stm32f30x_usart.c ****   /* Set STOP[13:12] bits according to USART_StopBits value */
 241:../src/stm32f30x_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 175              		.loc 1 241 0
 176 010e 3B68     		ldr	r3, [r7, #0]
 177 0110 9B68     		ldr	r3, [r3, #8]
 178 0112 7A6C     		ldr	r2, [r7, #68]
 179 0114 1343     		orrs	r3, r3, r2
 180 0116 7B64     		str	r3, [r7, #68]
 242:../src/stm32f30x_usart.c ****   
 243:../src/stm32f30x_usart.c ****   /* Write to USART CR2 */
 244:../src/stm32f30x_usart.c ****   USARTx->CR2 = tmpreg;
 181              		.loc 1 244 0
 182 0118 7B68     		ldr	r3, [r7, #4]
 183 011a 7A6C     		ldr	r2, [r7, #68]
 184 011c 5A60     		str	r2, [r3, #4]
 245:../src/stm32f30x_usart.c ****   
 246:../src/stm32f30x_usart.c ****   /*---------------------------- USART CR1 Configuration -----------------------*/
 247:../src/stm32f30x_usart.c ****   tmpreg = USARTx->CR1;
 185              		.loc 1 247 0
 186 011e 7B68     		ldr	r3, [r7, #4]
 187 0120 1B68     		ldr	r3, [r3, #0]
 188 0122 7B64     		str	r3, [r7, #68]
 248:../src/stm32f30x_usart.c ****   /* Clear M, PCE, PS, TE and RE bits */
 249:../src/stm32f30x_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 189              		.loc 1 249 0
 190 0124 7B6C     		ldr	r3, [r7, #68]
 191 0126 23F4B053 		bic	r3, r3, #5632
 192 012a 23F00C03 		bic	r3, r3, #12
 193 012e 7B64     		str	r3, [r7, #68]
 250:../src/stm32f30x_usart.c ****   
 251:../src/stm32f30x_usart.c ****   /* Configure the USART Word Length, Parity and mode ----------------------- */
 252:../src/stm32f30x_usart.c ****   /* Set the M bits according to USART_WordLength value */
 253:../src/stm32f30x_usart.c ****   /* Set PCE and PS bits according to USART_Parity value */
 254:../src/stm32f30x_usart.c ****   /* Set TE and RE bits according to USART_Mode value */
 255:../src/stm32f30x_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 194              		.loc 1 255 0
 195 0130 3B68     		ldr	r3, [r7, #0]
 196 0132 5A68     		ldr	r2, [r3, #4]
 197 0134 3B68     		ldr	r3, [r7, #0]
 198 0136 DB68     		ldr	r3, [r3, #12]
 199 0138 1A43     		orrs	r2, r2, r3
 256:../src/stm32f30x_usart.c ****     USART_InitStruct->USART_Mode;
 200              		.loc 1 256 0
 201 013a 3B68     		ldr	r3, [r7, #0]
 202 013c 1B69     		ldr	r3, [r3, #16]
 255:../src/stm32f30x_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 203              		.loc 1 255 0
 204 013e 1343     		orrs	r3, r3, r2
 205 0140 7A6C     		ldr	r2, [r7, #68]
 206 0142 1343     		orrs	r3, r3, r2
 207 0144 7B64     		str	r3, [r7, #68]
 257:../src/stm32f30x_usart.c ****   
 258:../src/stm32f30x_usart.c ****   /* Write to USART CR1 */
 259:../src/stm32f30x_usart.c ****   USARTx->CR1 = tmpreg;
 208              		.loc 1 259 0
 209 0146 7B68     		ldr	r3, [r7, #4]
 210 0148 7A6C     		ldr	r2, [r7, #68]
 211 014a 1A60     		str	r2, [r3, #0]
 260:../src/stm32f30x_usart.c ****   
 261:../src/stm32f30x_usart.c ****   /*---------------------------- USART CR3 Configuration -----------------------*/
 262:../src/stm32f30x_usart.c ****   tmpreg = USARTx->CR3;
 212              		.loc 1 262 0
 213 014c 7B68     		ldr	r3, [r7, #4]
 214 014e 9B68     		ldr	r3, [r3, #8]
 215 0150 7B64     		str	r3, [r7, #68]
 263:../src/stm32f30x_usart.c ****   /* Clear CTSE and RTSE bits */
 264:../src/stm32f30x_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 216              		.loc 1 264 0
 217 0152 7B6C     		ldr	r3, [r7, #68]
 218 0154 23F44073 		bic	r3, r3, #768
 219 0158 7B64     		str	r3, [r7, #68]
 265:../src/stm32f30x_usart.c ****   
 266:../src/stm32f30x_usart.c ****   /* Configure the USART HFC -------------------------------------------------*/
 267:../src/stm32f30x_usart.c ****   /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
 268:../src/stm32f30x_usart.c ****   tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 220              		.loc 1 268 0
 221 015a 3B68     		ldr	r3, [r7, #0]
 222 015c 5B69     		ldr	r3, [r3, #20]
 223 015e 7A6C     		ldr	r2, [r7, #68]
 224 0160 1343     		orrs	r3, r3, r2
 225 0162 7B64     		str	r3, [r7, #68]
 269:../src/stm32f30x_usart.c ****   
 270:../src/stm32f30x_usart.c ****   /* Write to USART CR3 */
 271:../src/stm32f30x_usart.c ****   USARTx->CR3 = tmpreg;
 226              		.loc 1 271 0
 227 0164 7B68     		ldr	r3, [r7, #4]
 228 0166 7A6C     		ldr	r2, [r7, #68]
 229 0168 9A60     		str	r2, [r3, #8]
 272:../src/stm32f30x_usart.c ****   
 273:../src/stm32f30x_usart.c ****   /*---------------------------- USART BRR Configuration -----------------------*/
 274:../src/stm32f30x_usart.c ****   /* Configure the USART Baud Rate -------------------------------------------*/
 275:../src/stm32f30x_usart.c ****   RCC_GetClocksFreq(&RCC_ClocksStatus);
 230              		.loc 1 275 0
 231 016a 07F10803 		add	r3, r7, #8
 232 016e 1846     		mov	r0, r3
 233 0170 FFF7FEFF 		bl	RCC_GetClocksFreq
 276:../src/stm32f30x_usart.c ****   
 277:../src/stm32f30x_usart.c ****   if (USARTx == USART1)
 234              		.loc 1 277 0
 235 0174 7A68     		ldr	r2, [r7, #4]
 236 0176 4FF46053 		mov	r3, #14336
 237 017a C4F20103 		movt	r3, 16385
 238 017e 9A42     		cmp	r2, r3
 239 0180 02D1     		bne	.L8
 278:../src/stm32f30x_usart.c ****   {
 279:../src/stm32f30x_usart.c ****     apbclock = RCC_ClocksStatus.USART1CLK_Frequency;
 240              		.loc 1 279 0
 241 0182 3B6B     		ldr	r3, [r7, #48]
 242 0184 BB64     		str	r3, [r7, #72]
 243 0186 1FE0     		b	.L9
 244              	.L8:
 280:../src/stm32f30x_usart.c ****   }
 281:../src/stm32f30x_usart.c ****   else if (USARTx == USART2)
 245              		.loc 1 281 0
 246 0188 7A68     		ldr	r2, [r7, #4]
 247 018a 4FF48843 		mov	r3, #17408
 248 018e C4F20003 		movt	r3, 16384
 249 0192 9A42     		cmp	r2, r3
 250 0194 02D1     		bne	.L10
 282:../src/stm32f30x_usart.c ****   {
 283:../src/stm32f30x_usart.c ****     apbclock = RCC_ClocksStatus.USART2CLK_Frequency;
 251              		.loc 1 283 0
 252 0196 7B6B     		ldr	r3, [r7, #52]
 253 0198 BB64     		str	r3, [r7, #72]
 254 019a 15E0     		b	.L9
 255              	.L10:
 284:../src/stm32f30x_usart.c ****   }
 285:../src/stm32f30x_usart.c ****   else if (USARTx == USART3)
 256              		.loc 1 285 0
 257 019c 7A68     		ldr	r2, [r7, #4]
 258 019e 4FF49043 		mov	r3, #18432
 259 01a2 C4F20003 		movt	r3, 16384
 260 01a6 9A42     		cmp	r2, r3
 261 01a8 02D1     		bne	.L11
 286:../src/stm32f30x_usart.c ****   {
 287:../src/stm32f30x_usart.c ****     apbclock = RCC_ClocksStatus.USART3CLK_Frequency;
 262              		.loc 1 287 0
 263 01aa BB6B     		ldr	r3, [r7, #56]
 264 01ac BB64     		str	r3, [r7, #72]
 265 01ae 0BE0     		b	.L9
 266              	.L11:
 288:../src/stm32f30x_usart.c ****   }
 289:../src/stm32f30x_usart.c ****   else if (USARTx == UART4)
 267              		.loc 1 289 0
 268 01b0 7A68     		ldr	r2, [r7, #4]
 269 01b2 4FF49843 		mov	r3, #19456
 270 01b6 C4F20003 		movt	r3, 16384
 271 01ba 9A42     		cmp	r2, r3
 272 01bc 02D1     		bne	.L12
 290:../src/stm32f30x_usart.c ****   {
 291:../src/stm32f30x_usart.c ****     apbclock = RCC_ClocksStatus.UART4CLK_Frequency;
 273              		.loc 1 291 0
 274 01be FB6B     		ldr	r3, [r7, #60]
 275 01c0 BB64     		str	r3, [r7, #72]
 276 01c2 01E0     		b	.L9
 277              	.L12:
 292:../src/stm32f30x_usart.c ****   }
 293:../src/stm32f30x_usart.c ****   else 
 294:../src/stm32f30x_usart.c ****   {
 295:../src/stm32f30x_usart.c ****     apbclock = RCC_ClocksStatus.UART5CLK_Frequency;
 278              		.loc 1 295 0
 279 01c4 3B6C     		ldr	r3, [r7, #64]
 280 01c6 BB64     		str	r3, [r7, #72]
 281              	.L9:
 296:../src/stm32f30x_usart.c ****   }  
 297:../src/stm32f30x_usart.c ****   
 298:../src/stm32f30x_usart.c ****   /* Determine the integer part */
 299:../src/stm32f30x_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 282              		.loc 1 299 0
 283 01c8 7B68     		ldr	r3, [r7, #4]
 284 01ca 1B68     		ldr	r3, [r3, #0]
 285 01cc 03F40043 		and	r3, r3, #32768
 286 01d0 002B     		cmp	r3, #0
 287 01d2 13D0     		beq	.L13
 300:../src/stm32f30x_usart.c ****   {
 301:../src/stm32f30x_usart.c ****     /* (divider * 10) computing in case Oversampling mode is 8 Samples */
 302:../src/stm32f30x_usart.c ****     divider = (uint32_t)((2 * apbclock) / (USART_InitStruct->USART_BaudRate));
 288              		.loc 1 302 0
 289 01d4 BB6C     		ldr	r3, [r7, #72]
 290 01d6 4FEA4302 		lsl	r2, r3, #1
 291 01da 3B68     		ldr	r3, [r7, #0]
 292 01dc 1B68     		ldr	r3, [r3, #0]
 293 01de B2FBF3F3 		udiv	r3, r2, r3
 294 01e2 FB64     		str	r3, [r7, #76]
 303:../src/stm32f30x_usart.c ****     tmpreg  = (uint32_t)((2 * apbclock) % (USART_InitStruct->USART_BaudRate));
 295              		.loc 1 303 0
 296 01e4 BB6C     		ldr	r3, [r7, #72]
 297 01e6 4FEA4303 		lsl	r3, r3, #1
 298 01ea 3A68     		ldr	r2, [r7, #0]
 299 01ec 1268     		ldr	r2, [r2, #0]
 300 01ee B3FBF2F1 		udiv	r1, r3, r2
 301 01f2 02FB01F2 		mul	r2, r2, r1
 302 01f6 9B1A     		subs	r3, r3, r2
 303 01f8 7B64     		str	r3, [r7, #68]
 304 01fa 0EE0     		b	.L14
 305              	.L13:
 304:../src/stm32f30x_usart.c ****   }
 305:../src/stm32f30x_usart.c ****   else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
 306:../src/stm32f30x_usart.c ****   {
 307:../src/stm32f30x_usart.c ****     /* (divider * 10) computing in case Oversampling mode is 16 Samples */
 308:../src/stm32f30x_usart.c ****     divider = (uint32_t)((apbclock) / (USART_InitStruct->USART_BaudRate));
 306              		.loc 1 308 0
 307 01fc 3B68     		ldr	r3, [r7, #0]
 308 01fe 1B68     		ldr	r3, [r3, #0]
 309 0200 BA6C     		ldr	r2, [r7, #72]
 310 0202 B2FBF3F3 		udiv	r3, r2, r3
 311 0206 FB64     		str	r3, [r7, #76]
 309:../src/stm32f30x_usart.c ****     tmpreg  = (uint32_t)((apbclock) % (USART_InitStruct->USART_BaudRate));
 312              		.loc 1 309 0
 313 0208 3B68     		ldr	r3, [r7, #0]
 314 020a 1A68     		ldr	r2, [r3, #0]
 315 020c BB6C     		ldr	r3, [r7, #72]
 316 020e B3FBF2F1 		udiv	r1, r3, r2
 317 0212 02FB01F2 		mul	r2, r2, r1
 318 0216 9B1A     		subs	r3, r3, r2
 319 0218 7B64     		str	r3, [r7, #68]
 320              	.L14:
 310:../src/stm32f30x_usart.c ****   }
 311:../src/stm32f30x_usart.c ****   
 312:../src/stm32f30x_usart.c ****   /* round the divider : if fractional part i greater than 0.5 increment divider */
 313:../src/stm32f30x_usart.c ****   if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
 321              		.loc 1 313 0
 322 021a 3B68     		ldr	r3, [r7, #0]
 323 021c 1B68     		ldr	r3, [r3, #0]
 324 021e 4FEA5302 		lsr	r2, r3, #1
 325 0222 7B6C     		ldr	r3, [r7, #68]
 326 0224 9A42     		cmp	r2, r3
 327 0226 03D8     		bhi	.L15
 314:../src/stm32f30x_usart.c ****   {
 315:../src/stm32f30x_usart.c ****     divider++;
 328              		.loc 1 315 0
 329 0228 FB6C     		ldr	r3, [r7, #76]
 330 022a 03F10103 		add	r3, r3, #1
 331 022e FB64     		str	r3, [r7, #76]
 332              	.L15:
 316:../src/stm32f30x_usart.c ****   } 
 317:../src/stm32f30x_usart.c ****   
 318:../src/stm32f30x_usart.c ****   /* Implement the divider in case Oversampling mode is 8 Samples */
 319:../src/stm32f30x_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 333              		.loc 1 319 0
 334 0230 7B68     		ldr	r3, [r7, #4]
 335 0232 1B68     		ldr	r3, [r3, #0]
 336 0234 03F40043 		and	r3, r3, #32768
 337 0238 002B     		cmp	r3, #0
 338 023a 0CD0     		beq	.L16
 320:../src/stm32f30x_usart.c ****   {
 321:../src/stm32f30x_usart.c ****     /* get the LSB of divider and shift it to the right by 1 bit */
 322:../src/stm32f30x_usart.c ****     tmpreg = (divider & (uint16_t)0x000F) >> 1;
 339              		.loc 1 322 0
 340 023c FB6C     		ldr	r3, [r7, #76]
 341 023e 03F00F03 		and	r3, r3, #15
 342 0242 4FEA5303 		lsr	r3, r3, #1
 343 0246 7B64     		str	r3, [r7, #68]
 323:../src/stm32f30x_usart.c ****     
 324:../src/stm32f30x_usart.c ****     /* update the divider value */
 325:../src/stm32f30x_usart.c ****     divider = (divider & (uint16_t)0xFFF0) | tmpreg;
 344              		.loc 1 325 0
 345 0248 FA6C     		ldr	r2, [r7, #76]
 346 024a 4FF6F073 		movw	r3, #65520
 347 024e 1340     		ands	r3, r3, r2
 348 0250 7A6C     		ldr	r2, [r7, #68]
 349 0252 1343     		orrs	r3, r3, r2
 350 0254 FB64     		str	r3, [r7, #76]
 351              	.L16:
 326:../src/stm32f30x_usart.c ****   }
 327:../src/stm32f30x_usart.c ****   
 328:../src/stm32f30x_usart.c ****   /* Write to USART BRR */
 329:../src/stm32f30x_usart.c ****   USARTx->BRR = (uint16_t)divider;
 352              		.loc 1 329 0
 353 0256 FB6C     		ldr	r3, [r7, #76]
 354 0258 9AB2     		uxth	r2, r3
 355 025a 7B68     		ldr	r3, [r7, #4]
 356 025c 9A81     		strh	r2, [r3, #12]	@ movhi
 330:../src/stm32f30x_usart.c **** }
 357              		.loc 1 330 0
 358 025e 07F15007 		add	r7, r7, #80
 359 0262 BD46     		mov	sp, r7
 360 0264 80BD     		pop	{r7, pc}
 361              		.cfi_endproc
 362              	.LFE112:
 364 0266 00BF     		.align	2
 365              		.global	USART_StructInit
 366              		.thumb
 367              		.thumb_func
 369              	USART_StructInit:
 370              	.LFB113:
 331:../src/stm32f30x_usart.c **** 
 332:../src/stm32f30x_usart.c **** /**
 333:../src/stm32f30x_usart.c ****   * @brief  Fills each USART_InitStruct member with its default value.
 334:../src/stm32f30x_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
 335:../src/stm32f30x_usart.c ****   *         which will be initialized.
 336:../src/stm32f30x_usart.c ****   * @retval None
 337:../src/stm32f30x_usart.c ****   */
 338:../src/stm32f30x_usart.c **** void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
 339:../src/stm32f30x_usart.c **** {
 371              		.loc 1 339 0
 372              		.cfi_startproc
 373              		@ args = 0, pretend = 0, frame = 8
 374              		@ frame_needed = 1, uses_anonymous_args = 0
 375              		@ link register save eliminated.
 376 0268 80B4     		push	{r7}
 377              	.LCFI6:
 378              		.cfi_def_cfa_offset 4
 379              		.cfi_offset 7, -4
 380 026a 83B0     		sub	sp, sp, #12
 381              	.LCFI7:
 382              		.cfi_def_cfa_offset 16
 383 026c 00AF     		add	r7, sp, #0
 384              	.LCFI8:
 385              		.cfi_def_cfa_register 7
 386 026e 7860     		str	r0, [r7, #4]
 340:../src/stm32f30x_usart.c ****   /* USART_InitStruct members default value */
 341:../src/stm32f30x_usart.c ****   USART_InitStruct->USART_BaudRate = 9600;
 387              		.loc 1 341 0
 388 0270 7B68     		ldr	r3, [r7, #4]
 389 0272 4FF41652 		mov	r2, #9600
 390 0276 1A60     		str	r2, [r3, #0]
 342:../src/stm32f30x_usart.c ****   USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 391              		.loc 1 342 0
 392 0278 7B68     		ldr	r3, [r7, #4]
 393 027a 4FF00002 		mov	r2, #0
 394 027e 5A60     		str	r2, [r3, #4]
 343:../src/stm32f30x_usart.c ****   USART_InitStruct->USART_StopBits = USART_StopBits_1;
 395              		.loc 1 343 0
 396 0280 7B68     		ldr	r3, [r7, #4]
 397 0282 4FF00002 		mov	r2, #0
 398 0286 9A60     		str	r2, [r3, #8]
 344:../src/stm32f30x_usart.c ****   USART_InitStruct->USART_Parity = USART_Parity_No ;
 399              		.loc 1 344 0
 400 0288 7B68     		ldr	r3, [r7, #4]
 401 028a 4FF00002 		mov	r2, #0
 402 028e DA60     		str	r2, [r3, #12]
 345:../src/stm32f30x_usart.c ****   USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 403              		.loc 1 345 0
 404 0290 7B68     		ldr	r3, [r7, #4]
 405 0292 4FF00C02 		mov	r2, #12
 406 0296 1A61     		str	r2, [r3, #16]
 346:../src/stm32f30x_usart.c ****   USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 407              		.loc 1 346 0
 408 0298 7B68     		ldr	r3, [r7, #4]
 409 029a 4FF00002 		mov	r2, #0
 410 029e 5A61     		str	r2, [r3, #20]
 347:../src/stm32f30x_usart.c **** }
 411              		.loc 1 347 0
 412 02a0 07F10C07 		add	r7, r7, #12
 413 02a4 BD46     		mov	sp, r7
 414 02a6 80BC     		pop	{r7}
 415 02a8 7047     		bx	lr
 416              		.cfi_endproc
 417              	.LFE113:
 419 02aa 00BF     		.align	2
 420              		.global	USART_ClockInit
 421              		.thumb
 422              		.thumb_func
 424              	USART_ClockInit:
 425              	.LFB114:
 348:../src/stm32f30x_usart.c **** 
 349:../src/stm32f30x_usart.c **** /**
 350:../src/stm32f30x_usart.c ****   * @brief  Initializes the USARTx peripheral Clock according to the
 351:../src/stm32f30x_usart.c ****   *         specified parameters in the USART_ClockInitStruct.
 352:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the
 353:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3.
 354:../src/stm32f30x_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
 355:../src/stm32f30x_usart.c ****   *         structure that contains the configuration information for the specified
 356:../src/stm32f30x_usart.c ****   *         USART peripheral.
 357:../src/stm32f30x_usart.c ****   * @retval None
 358:../src/stm32f30x_usart.c ****   */
 359:../src/stm32f30x_usart.c **** void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
 360:../src/stm32f30x_usart.c **** {
 426              		.loc 1 360 0
 427              		.cfi_startproc
 428              		@ args = 0, pretend = 0, frame = 16
 429              		@ frame_needed = 1, uses_anonymous_args = 0
 430              		@ link register save eliminated.
 431 02ac 80B4     		push	{r7}
 432              	.LCFI9:
 433              		.cfi_def_cfa_offset 4
 434              		.cfi_offset 7, -4
 435 02ae 85B0     		sub	sp, sp, #20
 436              	.LCFI10:
 437              		.cfi_def_cfa_offset 24
 438 02b0 00AF     		add	r7, sp, #0
 439              	.LCFI11:
 440              		.cfi_def_cfa_register 7
 441 02b2 7860     		str	r0, [r7, #4]
 442 02b4 3960     		str	r1, [r7, #0]
 361:../src/stm32f30x_usart.c ****   uint32_t tmpreg = 0;
 443              		.loc 1 361 0
 444 02b6 4FF00003 		mov	r3, #0
 445 02ba FB60     		str	r3, [r7, #12]
 362:../src/stm32f30x_usart.c ****   /* Check the parameters */
 363:../src/stm32f30x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 364:../src/stm32f30x_usart.c ****   assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
 365:../src/stm32f30x_usart.c ****   assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
 366:../src/stm32f30x_usart.c ****   assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
 367:../src/stm32f30x_usart.c ****   assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
 368:../src/stm32f30x_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 369:../src/stm32f30x_usart.c ****   tmpreg = USARTx->CR2;
 446              		.loc 1 369 0
 447 02bc 7B68     		ldr	r3, [r7, #4]
 448 02be 5B68     		ldr	r3, [r3, #4]
 449 02c0 FB60     		str	r3, [r7, #12]
 370:../src/stm32f30x_usart.c ****   /* Clear CLKEN, CPOL, CPHA, LBCL and SSM bits */
 371:../src/stm32f30x_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 450              		.loc 1 371 0
 451 02c2 FB68     		ldr	r3, [r7, #12]
 452 02c4 23F47063 		bic	r3, r3, #3840
 453 02c8 FB60     		str	r3, [r7, #12]
 372:../src/stm32f30x_usart.c ****   /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
 373:../src/stm32f30x_usart.c ****   /* Set CLKEN bit according to USART_Clock value */
 374:../src/stm32f30x_usart.c ****   /* Set CPOL bit according to USART_CPOL value */
 375:../src/stm32f30x_usart.c ****   /* Set CPHA bit according to USART_CPHA value */
 376:../src/stm32f30x_usart.c ****   /* Set LBCL bit according to USART_LastBit value */
 377:../src/stm32f30x_usart.c ****   tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 454              		.loc 1 377 0
 455 02ca 3B68     		ldr	r3, [r7, #0]
 456 02cc 1A68     		ldr	r2, [r3, #0]
 457 02ce 3B68     		ldr	r3, [r7, #0]
 458 02d0 5B68     		ldr	r3, [r3, #4]
 459 02d2 1A43     		orrs	r2, r2, r3
 378:../src/stm32f30x_usart.c ****                        USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit);
 460              		.loc 1 378 0
 461 02d4 3B68     		ldr	r3, [r7, #0]
 462 02d6 9B68     		ldr	r3, [r3, #8]
 377:../src/stm32f30x_usart.c ****   tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 463              		.loc 1 377 0
 464 02d8 1A43     		orrs	r2, r2, r3
 465              		.loc 1 378 0
 466 02da 3B68     		ldr	r3, [r7, #0]
 467 02dc DB68     		ldr	r3, [r3, #12]
 377:../src/stm32f30x_usart.c ****   tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 468              		.loc 1 377 0
 469 02de 1343     		orrs	r3, r3, r2
 470 02e0 FA68     		ldr	r2, [r7, #12]
 471 02e2 1343     		orrs	r3, r3, r2
 472 02e4 FB60     		str	r3, [r7, #12]
 379:../src/stm32f30x_usart.c ****   /* Write to USART CR2 */
 380:../src/stm32f30x_usart.c ****   USARTx->CR2 = tmpreg;
 473              		.loc 1 380 0
 474 02e6 7B68     		ldr	r3, [r7, #4]
 475 02e8 FA68     		ldr	r2, [r7, #12]
 476 02ea 5A60     		str	r2, [r3, #4]
 381:../src/stm32f30x_usart.c **** }
 477              		.loc 1 381 0
 478 02ec 07F11407 		add	r7, r7, #20
 479 02f0 BD46     		mov	sp, r7
 480 02f2 80BC     		pop	{r7}
 481 02f4 7047     		bx	lr
 482              		.cfi_endproc
 483              	.LFE114:
 485 02f6 00BF     		.align	2
 486              		.global	USART_ClockStructInit
 487              		.thumb
 488              		.thumb_func
 490              	USART_ClockStructInit:
 491              	.LFB115:
 382:../src/stm32f30x_usart.c **** 
 383:../src/stm32f30x_usart.c **** /**
 384:../src/stm32f30x_usart.c ****   * @brief  Fills each USART_ClockInitStruct member with its default value.
 385:../src/stm32f30x_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
 386:../src/stm32f30x_usart.c ****   *         structure which will be initialized.
 387:../src/stm32f30x_usart.c ****   * @retval None
 388:../src/stm32f30x_usart.c ****   */
 389:../src/stm32f30x_usart.c **** void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
 390:../src/stm32f30x_usart.c **** {
 492              		.loc 1 390 0
 493              		.cfi_startproc
 494              		@ args = 0, pretend = 0, frame = 8
 495              		@ frame_needed = 1, uses_anonymous_args = 0
 496              		@ link register save eliminated.
 497 02f8 80B4     		push	{r7}
 498              	.LCFI12:
 499              		.cfi_def_cfa_offset 4
 500              		.cfi_offset 7, -4
 501 02fa 83B0     		sub	sp, sp, #12
 502              	.LCFI13:
 503              		.cfi_def_cfa_offset 16
 504 02fc 00AF     		add	r7, sp, #0
 505              	.LCFI14:
 506              		.cfi_def_cfa_register 7
 507 02fe 7860     		str	r0, [r7, #4]
 391:../src/stm32f30x_usart.c ****   /* USART_ClockInitStruct members default value */
 392:../src/stm32f30x_usart.c ****   USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 508              		.loc 1 392 0
 509 0300 7B68     		ldr	r3, [r7, #4]
 510 0302 4FF00002 		mov	r2, #0
 511 0306 1A60     		str	r2, [r3, #0]
 393:../src/stm32f30x_usart.c ****   USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 512              		.loc 1 393 0
 513 0308 7B68     		ldr	r3, [r7, #4]
 514 030a 4FF00002 		mov	r2, #0
 515 030e 5A60     		str	r2, [r3, #4]
 394:../src/stm32f30x_usart.c ****   USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 516              		.loc 1 394 0
 517 0310 7B68     		ldr	r3, [r7, #4]
 518 0312 4FF00002 		mov	r2, #0
 519 0316 9A60     		str	r2, [r3, #8]
 395:../src/stm32f30x_usart.c ****   USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 520              		.loc 1 395 0
 521 0318 7B68     		ldr	r3, [r7, #4]
 522 031a 4FF00002 		mov	r2, #0
 523 031e DA60     		str	r2, [r3, #12]
 396:../src/stm32f30x_usart.c **** }
 524              		.loc 1 396 0
 525 0320 07F10C07 		add	r7, r7, #12
 526 0324 BD46     		mov	sp, r7
 527 0326 80BC     		pop	{r7}
 528 0328 7047     		bx	lr
 529              		.cfi_endproc
 530              	.LFE115:
 532 032a 00BF     		.align	2
 533              		.global	USART_Cmd
 534              		.thumb
 535              		.thumb_func
 537              	USART_Cmd:
 538              	.LFB116:
 397:../src/stm32f30x_usart.c **** 
 398:../src/stm32f30x_usart.c **** /**
 399:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the specified USART peripheral.
 400:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the
 401:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 402:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USARTx peripheral.
 403:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 404:../src/stm32f30x_usart.c ****   * @retval None
 405:../src/stm32f30x_usart.c ****   */
 406:../src/stm32f30x_usart.c **** void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 407:../src/stm32f30x_usart.c **** {
 539              		.loc 1 407 0
 540              		.cfi_startproc
 541              		@ args = 0, pretend = 0, frame = 8
 542              		@ frame_needed = 1, uses_anonymous_args = 0
 543              		@ link register save eliminated.
 544 032c 80B4     		push	{r7}
 545              	.LCFI15:
 546              		.cfi_def_cfa_offset 4
 547              		.cfi_offset 7, -4
 548 032e 83B0     		sub	sp, sp, #12
 549              	.LCFI16:
 550              		.cfi_def_cfa_offset 16
 551 0330 00AF     		add	r7, sp, #0
 552              	.LCFI17:
 553              		.cfi_def_cfa_register 7
 554 0332 7860     		str	r0, [r7, #4]
 555 0334 0B46     		mov	r3, r1
 556 0336 FB70     		strb	r3, [r7, #3]
 408:../src/stm32f30x_usart.c ****   /* Check the parameters */
 409:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 410:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 411:../src/stm32f30x_usart.c ****   
 412:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 557              		.loc 1 412 0
 558 0338 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 559 033a 002B     		cmp	r3, #0
 560 033c 06D0     		beq	.L21
 413:../src/stm32f30x_usart.c ****   {
 414:../src/stm32f30x_usart.c ****     /* Enable the selected USART by setting the UE bit in the CR1 register */
 415:../src/stm32f30x_usart.c ****     USARTx->CR1 |= USART_CR1_UE;
 561              		.loc 1 415 0
 562 033e 7B68     		ldr	r3, [r7, #4]
 563 0340 1B68     		ldr	r3, [r3, #0]
 564 0342 43F00102 		orr	r2, r3, #1
 565 0346 7B68     		ldr	r3, [r7, #4]
 566 0348 1A60     		str	r2, [r3, #0]
 567 034a 05E0     		b	.L20
 568              	.L21:
 416:../src/stm32f30x_usart.c ****   }
 417:../src/stm32f30x_usart.c ****   else
 418:../src/stm32f30x_usart.c ****   {
 419:../src/stm32f30x_usart.c ****     /* Disable the selected USART by clearing the UE bit in the CR1 register */
 420:../src/stm32f30x_usart.c ****     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 569              		.loc 1 420 0
 570 034c 7B68     		ldr	r3, [r7, #4]
 571 034e 1B68     		ldr	r3, [r3, #0]
 572 0350 23F00102 		bic	r2, r3, #1
 573 0354 7B68     		ldr	r3, [r7, #4]
 574 0356 1A60     		str	r2, [r3, #0]
 575              	.L20:
 421:../src/stm32f30x_usart.c ****   }
 422:../src/stm32f30x_usart.c **** }
 576              		.loc 1 422 0
 577 0358 07F10C07 		add	r7, r7, #12
 578 035c BD46     		mov	sp, r7
 579 035e 80BC     		pop	{r7}
 580 0360 7047     		bx	lr
 581              		.cfi_endproc
 582              	.LFE116:
 584 0362 00BF     		.align	2
 585              		.global	USART_DirectionModeCmd
 586              		.thumb
 587              		.thumb_func
 589              	USART_DirectionModeCmd:
 590              	.LFB117:
 423:../src/stm32f30x_usart.c **** 
 424:../src/stm32f30x_usart.c **** /**
 425:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's transmitter or receiver.
 426:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 427:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 428:../src/stm32f30x_usart.c ****   * @param  USART_Direction: specifies the USART direction.
 429:../src/stm32f30x_usart.c ****   *         This parameter can be any combination of the following values:
 430:../src/stm32f30x_usart.c ****   *         @arg USART_Mode_Tx: USART Transmitter
 431:../src/stm32f30x_usart.c ****   *         @arg USART_Mode_Rx: USART Receiver
 432:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USART transfer direction.
 433:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.  
 434:../src/stm32f30x_usart.c ****   * @retval None
 435:../src/stm32f30x_usart.c ****   */
 436:../src/stm32f30x_usart.c **** void USART_DirectionModeCmd(USART_TypeDef* USARTx, uint32_t USART_DirectionMode, FunctionalState Ne
 437:../src/stm32f30x_usart.c **** {
 591              		.loc 1 437 0
 592              		.cfi_startproc
 593              		@ args = 0, pretend = 0, frame = 16
 594              		@ frame_needed = 1, uses_anonymous_args = 0
 595              		@ link register save eliminated.
 596 0364 80B4     		push	{r7}
 597              	.LCFI18:
 598              		.cfi_def_cfa_offset 4
 599              		.cfi_offset 7, -4
 600 0366 85B0     		sub	sp, sp, #20
 601              	.LCFI19:
 602              		.cfi_def_cfa_offset 24
 603 0368 00AF     		add	r7, sp, #0
 604              	.LCFI20:
 605              		.cfi_def_cfa_register 7
 606 036a F860     		str	r0, [r7, #12]
 607 036c B960     		str	r1, [r7, #8]
 608 036e 1346     		mov	r3, r2
 609 0370 FB71     		strb	r3, [r7, #7]
 438:../src/stm32f30x_usart.c ****   /* Check the parameters */
 439:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 440:../src/stm32f30x_usart.c ****   assert_param(IS_USART_MODE(USART_DirectionMode));
 441:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 442:../src/stm32f30x_usart.c **** 
 443:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 610              		.loc 1 443 0
 611 0372 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 612 0374 002B     		cmp	r3, #0
 613 0376 06D0     		beq	.L24
 444:../src/stm32f30x_usart.c ****   {
 445:../src/stm32f30x_usart.c ****     /* Enable the USART's transfer interface by setting the TE and/or RE bits 
 446:../src/stm32f30x_usart.c ****        in the USART CR1 register */
 447:../src/stm32f30x_usart.c ****     USARTx->CR1 |= USART_DirectionMode;
 614              		.loc 1 447 0
 615 0378 FB68     		ldr	r3, [r7, #12]
 616 037a 1A68     		ldr	r2, [r3, #0]
 617 037c BB68     		ldr	r3, [r7, #8]
 618 037e 1A43     		orrs	r2, r2, r3
 619 0380 FB68     		ldr	r3, [r7, #12]
 620 0382 1A60     		str	r2, [r3, #0]
 621 0384 07E0     		b	.L23
 622              	.L24:
 448:../src/stm32f30x_usart.c ****   }
 449:../src/stm32f30x_usart.c ****   else
 450:../src/stm32f30x_usart.c ****   {
 451:../src/stm32f30x_usart.c ****     /* Disable the USART's transfer interface by clearing the TE and/or RE bits
 452:../src/stm32f30x_usart.c ****        in the USART CR3 register */
 453:../src/stm32f30x_usart.c ****     USARTx->CR1 &= (uint32_t)~USART_DirectionMode;
 623              		.loc 1 453 0
 624 0386 FB68     		ldr	r3, [r7, #12]
 625 0388 1A68     		ldr	r2, [r3, #0]
 626 038a BB68     		ldr	r3, [r7, #8]
 627 038c 6FEA0303 		mvn	r3, r3
 628 0390 1A40     		ands	r2, r2, r3
 629 0392 FB68     		ldr	r3, [r7, #12]
 630 0394 1A60     		str	r2, [r3, #0]
 631              	.L23:
 454:../src/stm32f30x_usart.c ****   }
 455:../src/stm32f30x_usart.c **** }
 632              		.loc 1 455 0
 633 0396 07F11407 		add	r7, r7, #20
 634 039a BD46     		mov	sp, r7
 635 039c 80BC     		pop	{r7}
 636 039e 7047     		bx	lr
 637              		.cfi_endproc
 638              	.LFE117:
 640              		.align	2
 641              		.global	USART_OverSampling8Cmd
 642              		.thumb
 643              		.thumb_func
 645              	USART_OverSampling8Cmd:
 646              	.LFB118:
 456:../src/stm32f30x_usart.c **** 
 457:../src/stm32f30x_usart.c **** /**
 458:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's 8x oversampling mode.
 459:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 460:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 461:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USART 8x oversampling mode.
 462:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 463:../src/stm32f30x_usart.c ****   * @note
 464:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Init()
 465:../src/stm32f30x_usart.c ****   *   function in order to have correct baudrate Divider value.
 466:../src/stm32f30x_usart.c ****   * @retval None
 467:../src/stm32f30x_usart.c ****   */
 468:../src/stm32f30x_usart.c **** void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 469:../src/stm32f30x_usart.c **** {
 647              		.loc 1 469 0
 648              		.cfi_startproc
 649              		@ args = 0, pretend = 0, frame = 8
 650              		@ frame_needed = 1, uses_anonymous_args = 0
 651              		@ link register save eliminated.
 652 03a0 80B4     		push	{r7}
 653              	.LCFI21:
 654              		.cfi_def_cfa_offset 4
 655              		.cfi_offset 7, -4
 656 03a2 83B0     		sub	sp, sp, #12
 657              	.LCFI22:
 658              		.cfi_def_cfa_offset 16
 659 03a4 00AF     		add	r7, sp, #0
 660              	.LCFI23:
 661              		.cfi_def_cfa_register 7
 662 03a6 7860     		str	r0, [r7, #4]
 663 03a8 0B46     		mov	r3, r1
 664 03aa FB70     		strb	r3, [r7, #3]
 470:../src/stm32f30x_usart.c ****   /* Check the parameters */
 471:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 472:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 473:../src/stm32f30x_usart.c ****   
 474:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 665              		.loc 1 474 0
 666 03ac FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 667 03ae 002B     		cmp	r3, #0
 668 03b0 06D0     		beq	.L27
 475:../src/stm32f30x_usart.c ****   {
 476:../src/stm32f30x_usart.c ****     /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
 477:../src/stm32f30x_usart.c ****     USARTx->CR1 |= USART_CR1_OVER8;
 669              		.loc 1 477 0
 670 03b2 7B68     		ldr	r3, [r7, #4]
 671 03b4 1B68     		ldr	r3, [r3, #0]
 672 03b6 43F40042 		orr	r2, r3, #32768
 673 03ba 7B68     		ldr	r3, [r7, #4]
 674 03bc 1A60     		str	r2, [r3, #0]
 675 03be 05E0     		b	.L26
 676              	.L27:
 478:../src/stm32f30x_usart.c ****   }
 479:../src/stm32f30x_usart.c ****   else
 480:../src/stm32f30x_usart.c ****   {
 481:../src/stm32f30x_usart.c ****     /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
 482:../src/stm32f30x_usart.c ****     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_OVER8);
 677              		.loc 1 482 0
 678 03c0 7B68     		ldr	r3, [r7, #4]
 679 03c2 1B68     		ldr	r3, [r3, #0]
 680 03c4 23F40042 		bic	r2, r3, #32768
 681 03c8 7B68     		ldr	r3, [r7, #4]
 682 03ca 1A60     		str	r2, [r3, #0]
 683              	.L26:
 483:../src/stm32f30x_usart.c ****   }
 484:../src/stm32f30x_usart.c **** }
 684              		.loc 1 484 0
 685 03cc 07F10C07 		add	r7, r7, #12
 686 03d0 BD46     		mov	sp, r7
 687 03d2 80BC     		pop	{r7}
 688 03d4 7047     		bx	lr
 689              		.cfi_endproc
 690              	.LFE118:
 692 03d6 00BF     		.align	2
 693              		.global	USART_OneBitMethodCmd
 694              		.thumb
 695              		.thumb_func
 697              	USART_OneBitMethodCmd:
 698              	.LFB119:
 485:../src/stm32f30x_usart.c **** 
 486:../src/stm32f30x_usart.c **** /**
 487:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's one bit sampling method.
 488:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the
 489:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 490:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USART one bit sampling method.
 491:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 492:../src/stm32f30x_usart.c ****   * @note
 493:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function.
 494:../src/stm32f30x_usart.c ****   * @retval None
 495:../src/stm32f30x_usart.c ****   */
 496:../src/stm32f30x_usart.c **** void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 497:../src/stm32f30x_usart.c **** {
 699              		.loc 1 497 0
 700              		.cfi_startproc
 701              		@ args = 0, pretend = 0, frame = 8
 702              		@ frame_needed = 1, uses_anonymous_args = 0
 703              		@ link register save eliminated.
 704 03d8 80B4     		push	{r7}
 705              	.LCFI24:
 706              		.cfi_def_cfa_offset 4
 707              		.cfi_offset 7, -4
 708 03da 83B0     		sub	sp, sp, #12
 709              	.LCFI25:
 710              		.cfi_def_cfa_offset 16
 711 03dc 00AF     		add	r7, sp, #0
 712              	.LCFI26:
 713              		.cfi_def_cfa_register 7
 714 03de 7860     		str	r0, [r7, #4]
 715 03e0 0B46     		mov	r3, r1
 716 03e2 FB70     		strb	r3, [r7, #3]
 498:../src/stm32f30x_usart.c ****   /* Check the parameters */
 499:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 500:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 501:../src/stm32f30x_usart.c **** 
 502:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 717              		.loc 1 502 0
 718 03e4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 719 03e6 002B     		cmp	r3, #0
 720 03e8 06D0     		beq	.L30
 503:../src/stm32f30x_usart.c ****   {
 504:../src/stm32f30x_usart.c ****     /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
 505:../src/stm32f30x_usart.c ****     USARTx->CR3 |= USART_CR3_ONEBIT;
 721              		.loc 1 505 0
 722 03ea 7B68     		ldr	r3, [r7, #4]
 723 03ec 9B68     		ldr	r3, [r3, #8]
 724 03ee 43F40062 		orr	r2, r3, #2048
 725 03f2 7B68     		ldr	r3, [r7, #4]
 726 03f4 9A60     		str	r2, [r3, #8]
 727 03f6 05E0     		b	.L29
 728              	.L30:
 506:../src/stm32f30x_usart.c ****   }
 507:../src/stm32f30x_usart.c ****   else
 508:../src/stm32f30x_usart.c ****   {
 509:../src/stm32f30x_usart.c ****     /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
 510:../src/stm32f30x_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_ONEBIT);
 729              		.loc 1 510 0
 730 03f8 7B68     		ldr	r3, [r7, #4]
 731 03fa 9B68     		ldr	r3, [r3, #8]
 732 03fc 23F40062 		bic	r2, r3, #2048
 733 0400 7B68     		ldr	r3, [r7, #4]
 734 0402 9A60     		str	r2, [r3, #8]
 735              	.L29:
 511:../src/stm32f30x_usart.c ****   }
 512:../src/stm32f30x_usart.c **** }
 736              		.loc 1 512 0
 737 0404 07F10C07 		add	r7, r7, #12
 738 0408 BD46     		mov	sp, r7
 739 040a 80BC     		pop	{r7}
 740 040c 7047     		bx	lr
 741              		.cfi_endproc
 742              	.LFE119:
 744 040e 00BF     		.align	2
 745              		.global	USART_MSBFirstCmd
 746              		.thumb
 747              		.thumb_func
 749              	USART_MSBFirstCmd:
 750              	.LFB120:
 513:../src/stm32f30x_usart.c **** 
 514:../src/stm32f30x_usart.c **** /**
 515:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's most significant bit first 
 516:../src/stm32f30x_usart.c ****   *         transmitted/received following the start bit.
 517:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the
 518:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 519:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USART most significant bit first
 520:../src/stm32f30x_usart.c ****   *         transmitted/received following the start bit.
 521:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 522:../src/stm32f30x_usart.c ****   * @note
 523:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function. 
 524:../src/stm32f30x_usart.c ****   * @retval None
 525:../src/stm32f30x_usart.c ****   */
 526:../src/stm32f30x_usart.c **** void USART_MSBFirstCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 527:../src/stm32f30x_usart.c **** {
 751              		.loc 1 527 0
 752              		.cfi_startproc
 753              		@ args = 0, pretend = 0, frame = 8
 754              		@ frame_needed = 1, uses_anonymous_args = 0
 755              		@ link register save eliminated.
 756 0410 80B4     		push	{r7}
 757              	.LCFI27:
 758              		.cfi_def_cfa_offset 4
 759              		.cfi_offset 7, -4
 760 0412 83B0     		sub	sp, sp, #12
 761              	.LCFI28:
 762              		.cfi_def_cfa_offset 16
 763 0414 00AF     		add	r7, sp, #0
 764              	.LCFI29:
 765              		.cfi_def_cfa_register 7
 766 0416 7860     		str	r0, [r7, #4]
 767 0418 0B46     		mov	r3, r1
 768 041a FB70     		strb	r3, [r7, #3]
 528:../src/stm32f30x_usart.c ****   /* Check the parameters */
 529:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 530:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 531:../src/stm32f30x_usart.c **** 
 532:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 769              		.loc 1 532 0
 770 041c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 771 041e 002B     		cmp	r3, #0
 772 0420 06D0     		beq	.L33
 533:../src/stm32f30x_usart.c ****   {
 534:../src/stm32f30x_usart.c ****     /* Enable the most significant bit first transmitted/received following the
 535:../src/stm32f30x_usart.c ****        start bit by setting the MSBFIRST bit in the CR2 register */
 536:../src/stm32f30x_usart.c ****     USARTx->CR2 |= USART_CR2_MSBFIRST;
 773              		.loc 1 536 0
 774 0422 7B68     		ldr	r3, [r7, #4]
 775 0424 5B68     		ldr	r3, [r3, #4]
 776 0426 43F40022 		orr	r2, r3, #524288
 777 042a 7B68     		ldr	r3, [r7, #4]
 778 042c 5A60     		str	r2, [r3, #4]
 779 042e 05E0     		b	.L32
 780              	.L33:
 537:../src/stm32f30x_usart.c ****   }
 538:../src/stm32f30x_usart.c ****   else
 539:../src/stm32f30x_usart.c ****   {
 540:../src/stm32f30x_usart.c ****     /* Disable the most significant bit first transmitted/received following the
 541:../src/stm32f30x_usart.c ****        start bit by clearing the MSBFIRST bit in the CR2 register */
 542:../src/stm32f30x_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_MSBFIRST);
 781              		.loc 1 542 0
 782 0430 7B68     		ldr	r3, [r7, #4]
 783 0432 5B68     		ldr	r3, [r3, #4]
 784 0434 23F40022 		bic	r2, r3, #524288
 785 0438 7B68     		ldr	r3, [r7, #4]
 786 043a 5A60     		str	r2, [r3, #4]
 787              	.L32:
 543:../src/stm32f30x_usart.c ****   }
 544:../src/stm32f30x_usart.c **** }
 788              		.loc 1 544 0
 789 043c 07F10C07 		add	r7, r7, #12
 790 0440 BD46     		mov	sp, r7
 791 0442 80BC     		pop	{r7}
 792 0444 7047     		bx	lr
 793              		.cfi_endproc
 794              	.LFE120:
 796 0446 00BF     		.align	2
 797              		.global	USART_DataInvCmd
 798              		.thumb
 799              		.thumb_func
 801              	USART_DataInvCmd:
 802              	.LFB121:
 545:../src/stm32f30x_usart.c **** 
 546:../src/stm32f30x_usart.c **** /**
 547:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the binary data inversion.
 548:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 549:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 550:../src/stm32f30x_usart.c ****   * @param  NewState: new defined levels for the USART data.
 551:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 552:../src/stm32f30x_usart.c ****   *   @arg  ENABLE: Logical data from the data register are send/received in negative
 553:../src/stm32f30x_usart.c ****   *         logic. (1=L, 0=H). The parity bit is also inverted.
 554:../src/stm32f30x_usart.c ****   *   @arg  DISABLE: Logical data from the data register are send/received in positive
 555:../src/stm32f30x_usart.c ****   *         logic. (1=H, 0=L) 
 556:../src/stm32f30x_usart.c ****   * @note
 557:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function. 
 558:../src/stm32f30x_usart.c ****   * @retval None
 559:../src/stm32f30x_usart.c ****   */
 560:../src/stm32f30x_usart.c **** void USART_DataInvCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 561:../src/stm32f30x_usart.c **** {
 803              		.loc 1 561 0
 804              		.cfi_startproc
 805              		@ args = 0, pretend = 0, frame = 8
 806              		@ frame_needed = 1, uses_anonymous_args = 0
 807              		@ link register save eliminated.
 808 0448 80B4     		push	{r7}
 809              	.LCFI30:
 810              		.cfi_def_cfa_offset 4
 811              		.cfi_offset 7, -4
 812 044a 83B0     		sub	sp, sp, #12
 813              	.LCFI31:
 814              		.cfi_def_cfa_offset 16
 815 044c 00AF     		add	r7, sp, #0
 816              	.LCFI32:
 817              		.cfi_def_cfa_register 7
 818 044e 7860     		str	r0, [r7, #4]
 819 0450 0B46     		mov	r3, r1
 820 0452 FB70     		strb	r3, [r7, #3]
 562:../src/stm32f30x_usart.c ****   /* Check the parameters */
 563:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 564:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 565:../src/stm32f30x_usart.c **** 
 566:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 821              		.loc 1 566 0
 822 0454 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 823 0456 002B     		cmp	r3, #0
 824 0458 06D0     		beq	.L36
 567:../src/stm32f30x_usart.c ****   {
 568:../src/stm32f30x_usart.c ****     /* Enable the binary data inversion feature by setting the DATAINV bit in
 569:../src/stm32f30x_usart.c ****        the CR2 register */
 570:../src/stm32f30x_usart.c ****     USARTx->CR2 |= USART_CR2_DATAINV;
 825              		.loc 1 570 0
 826 045a 7B68     		ldr	r3, [r7, #4]
 827 045c 5B68     		ldr	r3, [r3, #4]
 828 045e 43F48022 		orr	r2, r3, #262144
 829 0462 7B68     		ldr	r3, [r7, #4]
 830 0464 5A60     		str	r2, [r3, #4]
 831 0466 05E0     		b	.L35
 832              	.L36:
 571:../src/stm32f30x_usart.c ****   }
 572:../src/stm32f30x_usart.c ****   else
 573:../src/stm32f30x_usart.c ****   {
 574:../src/stm32f30x_usart.c ****     /* Disable the binary data inversion feature by clearing the DATAINV bit in
 575:../src/stm32f30x_usart.c ****        the CR2 register */
 576:../src/stm32f30x_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_DATAINV);
 833              		.loc 1 576 0
 834 0468 7B68     		ldr	r3, [r7, #4]
 835 046a 5B68     		ldr	r3, [r3, #4]
 836 046c 23F48022 		bic	r2, r3, #262144
 837 0470 7B68     		ldr	r3, [r7, #4]
 838 0472 5A60     		str	r2, [r3, #4]
 839              	.L35:
 577:../src/stm32f30x_usart.c ****   }
 578:../src/stm32f30x_usart.c **** }
 840              		.loc 1 578 0
 841 0474 07F10C07 		add	r7, r7, #12
 842 0478 BD46     		mov	sp, r7
 843 047a 80BC     		pop	{r7}
 844 047c 7047     		bx	lr
 845              		.cfi_endproc
 846              	.LFE121:
 848 047e 00BF     		.align	2
 849              		.global	USART_InvPinCmd
 850              		.thumb
 851              		.thumb_func
 853              	USART_InvPinCmd:
 854              	.LFB122:
 579:../src/stm32f30x_usart.c **** 
 580:../src/stm32f30x_usart.c **** /**
 581:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the Pin(s) active level inversion.
 582:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 583:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 584:../src/stm32f30x_usart.c ****   * @param  USART_InvPin: specifies the USART pin(s) to invert.
 585:../src/stm32f30x_usart.c ****   *         This parameter can be any combination of the following values:
 586:../src/stm32f30x_usart.c ****   *         @arg USART_InvPin_Tx: USART Tx pin active level inversion.
 587:../src/stm32f30x_usart.c ****   *         @arg USART_InvPin_Rx: USART Rx pin active level inversion.
 588:../src/stm32f30x_usart.c ****   * @param  NewState: new active level status for the USART pin(s).
 589:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 590:../src/stm32f30x_usart.c ****   *          - ENABLE: pin(s) signal values are inverted (Vdd =0, Gnd =1).
 591:../src/stm32f30x_usart.c ****   *          - DISABLE: pin(s) signal works using the standard logic levels (Vdd =1, Gnd =0).
 592:../src/stm32f30x_usart.c ****   * @note
 593:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function.  
 594:../src/stm32f30x_usart.c ****   * @retval None
 595:../src/stm32f30x_usart.c ****   */
 596:../src/stm32f30x_usart.c **** void USART_InvPinCmd(USART_TypeDef* USARTx, uint32_t USART_InvPin, FunctionalState NewState)
 597:../src/stm32f30x_usart.c **** {
 855              		.loc 1 597 0
 856              		.cfi_startproc
 857              		@ args = 0, pretend = 0, frame = 16
 858              		@ frame_needed = 1, uses_anonymous_args = 0
 859              		@ link register save eliminated.
 860 0480 80B4     		push	{r7}
 861              	.LCFI33:
 862              		.cfi_def_cfa_offset 4
 863              		.cfi_offset 7, -4
 864 0482 85B0     		sub	sp, sp, #20
 865              	.LCFI34:
 866              		.cfi_def_cfa_offset 24
 867 0484 00AF     		add	r7, sp, #0
 868              	.LCFI35:
 869              		.cfi_def_cfa_register 7
 870 0486 F860     		str	r0, [r7, #12]
 871 0488 B960     		str	r1, [r7, #8]
 872 048a 1346     		mov	r3, r2
 873 048c FB71     		strb	r3, [r7, #7]
 598:../src/stm32f30x_usart.c ****   /* Check the parameters */
 599:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 600:../src/stm32f30x_usart.c ****   assert_param(IS_USART_INVERSTION_PIN(USART_InvPin));
 601:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 602:../src/stm32f30x_usart.c **** 
 603:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 874              		.loc 1 603 0
 875 048e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 876 0490 002B     		cmp	r3, #0
 877 0492 06D0     		beq	.L39
 604:../src/stm32f30x_usart.c ****   {
 605:../src/stm32f30x_usart.c ****     /* Enable the active level inversion for selected pins by setting the TXINV 
 606:../src/stm32f30x_usart.c ****        and/or RXINV bits in the USART CR2 register */
 607:../src/stm32f30x_usart.c ****     USARTx->CR2 |= USART_InvPin;
 878              		.loc 1 607 0
 879 0494 FB68     		ldr	r3, [r7, #12]
 880 0496 5A68     		ldr	r2, [r3, #4]
 881 0498 BB68     		ldr	r3, [r7, #8]
 882 049a 1A43     		orrs	r2, r2, r3
 883 049c FB68     		ldr	r3, [r7, #12]
 884 049e 5A60     		str	r2, [r3, #4]
 885 04a0 07E0     		b	.L38
 886              	.L39:
 608:../src/stm32f30x_usart.c ****   }
 609:../src/stm32f30x_usart.c ****   else
 610:../src/stm32f30x_usart.c ****   {
 611:../src/stm32f30x_usart.c ****     /* Disable the active level inversion for selected requests by clearing the 
 612:../src/stm32f30x_usart.c ****        TXINV and/or RXINV bits in the USART CR2 register */
 613:../src/stm32f30x_usart.c ****     USARTx->CR2 &= (uint32_t)~USART_InvPin;
 887              		.loc 1 613 0
 888 04a2 FB68     		ldr	r3, [r7, #12]
 889 04a4 5A68     		ldr	r2, [r3, #4]
 890 04a6 BB68     		ldr	r3, [r7, #8]
 891 04a8 6FEA0303 		mvn	r3, r3
 892 04ac 1A40     		ands	r2, r2, r3
 893 04ae FB68     		ldr	r3, [r7, #12]
 894 04b0 5A60     		str	r2, [r3, #4]
 895              	.L38:
 614:../src/stm32f30x_usart.c ****   }
 615:../src/stm32f30x_usart.c **** }
 896              		.loc 1 615 0
 897 04b2 07F11407 		add	r7, r7, #20
 898 04b6 BD46     		mov	sp, r7
 899 04b8 80BC     		pop	{r7}
 900 04ba 7047     		bx	lr
 901              		.cfi_endproc
 902              	.LFE122:
 904              		.align	2
 905              		.global	USART_SWAPPinCmd
 906              		.thumb
 907              		.thumb_func
 909              	USART_SWAPPinCmd:
 910              	.LFB123:
 616:../src/stm32f30x_usart.c **** 
 617:../src/stm32f30x_usart.c **** /**
 618:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the swap Tx/Rx pins.
 619:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the
 620:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 621:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USARTx TX/RX pins pinout.
 622:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 623:../src/stm32f30x_usart.c ****   *         @arg ENABLE: The TX and RX pins functions are swapped.
 624:../src/stm32f30x_usart.c ****   *         @arg DISABLE: TX/RX pins are used as defined in standard pinout
 625:../src/stm32f30x_usart.c ****   * @note
 626:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function.
 627:../src/stm32f30x_usart.c ****   * @retval None
 628:../src/stm32f30x_usart.c ****   */
 629:../src/stm32f30x_usart.c **** void USART_SWAPPinCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 630:../src/stm32f30x_usart.c **** {
 911              		.loc 1 630 0
 912              		.cfi_startproc
 913              		@ args = 0, pretend = 0, frame = 8
 914              		@ frame_needed = 1, uses_anonymous_args = 0
 915              		@ link register save eliminated.
 916 04bc 80B4     		push	{r7}
 917              	.LCFI36:
 918              		.cfi_def_cfa_offset 4
 919              		.cfi_offset 7, -4
 920 04be 83B0     		sub	sp, sp, #12
 921              	.LCFI37:
 922              		.cfi_def_cfa_offset 16
 923 04c0 00AF     		add	r7, sp, #0
 924              	.LCFI38:
 925              		.cfi_def_cfa_register 7
 926 04c2 7860     		str	r0, [r7, #4]
 927 04c4 0B46     		mov	r3, r1
 928 04c6 FB70     		strb	r3, [r7, #3]
 631:../src/stm32f30x_usart.c ****   /* Check the parameters */
 632:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 633:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 634:../src/stm32f30x_usart.c **** 
 635:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 929              		.loc 1 635 0
 930 04c8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 931 04ca 002B     		cmp	r3, #0
 932 04cc 06D0     		beq	.L42
 636:../src/stm32f30x_usart.c ****   {
 637:../src/stm32f30x_usart.c ****     /* Enable the SWAP feature by setting the SWAP bit in the CR2 register */
 638:../src/stm32f30x_usart.c ****     USARTx->CR2 |= USART_CR2_SWAP;
 933              		.loc 1 638 0
 934 04ce 7B68     		ldr	r3, [r7, #4]
 935 04d0 5B68     		ldr	r3, [r3, #4]
 936 04d2 43F40042 		orr	r2, r3, #32768
 937 04d6 7B68     		ldr	r3, [r7, #4]
 938 04d8 5A60     		str	r2, [r3, #4]
 939 04da 05E0     		b	.L41
 940              	.L42:
 639:../src/stm32f30x_usart.c ****   }
 640:../src/stm32f30x_usart.c ****   else
 641:../src/stm32f30x_usart.c ****   {
 642:../src/stm32f30x_usart.c ****     /* Disable the SWAP feature by clearing the SWAP bit in the CR2 register */
 643:../src/stm32f30x_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_SWAP);
 941              		.loc 1 643 0
 942 04dc 7B68     		ldr	r3, [r7, #4]
 943 04de 5B68     		ldr	r3, [r3, #4]
 944 04e0 23F40042 		bic	r2, r3, #32768
 945 04e4 7B68     		ldr	r3, [r7, #4]
 946 04e6 5A60     		str	r2, [r3, #4]
 947              	.L41:
 644:../src/stm32f30x_usart.c ****   }
 645:../src/stm32f30x_usart.c **** }
 948              		.loc 1 645 0
 949 04e8 07F10C07 		add	r7, r7, #12
 950 04ec BD46     		mov	sp, r7
 951 04ee 80BC     		pop	{r7}
 952 04f0 7047     		bx	lr
 953              		.cfi_endproc
 954              	.LFE123:
 956 04f2 00BF     		.align	2
 957              		.global	USART_ReceiverTimeOutCmd
 958              		.thumb
 959              		.thumb_func
 961              	USART_ReceiverTimeOutCmd:
 962              	.LFB124:
 646:../src/stm32f30x_usart.c **** 
 647:../src/stm32f30x_usart.c **** /**
 648:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the receiver Time Out feature.
 649:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 650:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 651:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USARTx receiver Time Out.
 652:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 653:../src/stm32f30x_usart.c ****   * @retval None
 654:../src/stm32f30x_usart.c ****   */
 655:../src/stm32f30x_usart.c **** void USART_ReceiverTimeOutCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 656:../src/stm32f30x_usart.c **** {
 963              		.loc 1 656 0
 964              		.cfi_startproc
 965              		@ args = 0, pretend = 0, frame = 8
 966              		@ frame_needed = 1, uses_anonymous_args = 0
 967              		@ link register save eliminated.
 968 04f4 80B4     		push	{r7}
 969              	.LCFI39:
 970              		.cfi_def_cfa_offset 4
 971              		.cfi_offset 7, -4
 972 04f6 83B0     		sub	sp, sp, #12
 973              	.LCFI40:
 974              		.cfi_def_cfa_offset 16
 975 04f8 00AF     		add	r7, sp, #0
 976              	.LCFI41:
 977              		.cfi_def_cfa_register 7
 978 04fa 7860     		str	r0, [r7, #4]
 979 04fc 0B46     		mov	r3, r1
 980 04fe FB70     		strb	r3, [r7, #3]
 657:../src/stm32f30x_usart.c ****   /* Check the parameters */
 658:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 659:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 660:../src/stm32f30x_usart.c **** 
 661:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 981              		.loc 1 661 0
 982 0500 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 983 0502 002B     		cmp	r3, #0
 984 0504 06D0     		beq	.L45
 662:../src/stm32f30x_usart.c ****   {
 663:../src/stm32f30x_usart.c ****     /* Enable the receiver time out feature by setting the RTOEN bit in the CR2 
 664:../src/stm32f30x_usart.c ****        register */
 665:../src/stm32f30x_usart.c ****     USARTx->CR2 |= USART_CR2_RTOEN;
 985              		.loc 1 665 0
 986 0506 7B68     		ldr	r3, [r7, #4]
 987 0508 5B68     		ldr	r3, [r3, #4]
 988 050a 43F40002 		orr	r2, r3, #8388608
 989 050e 7B68     		ldr	r3, [r7, #4]
 990 0510 5A60     		str	r2, [r3, #4]
 991 0512 05E0     		b	.L44
 992              	.L45:
 666:../src/stm32f30x_usart.c ****   }
 667:../src/stm32f30x_usart.c ****   else
 668:../src/stm32f30x_usart.c ****   {
 669:../src/stm32f30x_usart.c ****     /* Disable the receiver time out feature by clearing the RTOEN bit in the CR2 
 670:../src/stm32f30x_usart.c ****        register */
 671:../src/stm32f30x_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_RTOEN);
 993              		.loc 1 671 0
 994 0514 7B68     		ldr	r3, [r7, #4]
 995 0516 5B68     		ldr	r3, [r3, #4]
 996 0518 23F40002 		bic	r2, r3, #8388608
 997 051c 7B68     		ldr	r3, [r7, #4]
 998 051e 5A60     		str	r2, [r3, #4]
 999              	.L44:
 672:../src/stm32f30x_usart.c ****   }
 673:../src/stm32f30x_usart.c **** }
 1000              		.loc 1 673 0
 1001 0520 07F10C07 		add	r7, r7, #12
 1002 0524 BD46     		mov	sp, r7
 1003 0526 80BC     		pop	{r7}
 1004 0528 7047     		bx	lr
 1005              		.cfi_endproc
 1006              	.LFE124:
 1008 052a 00BF     		.align	2
 1009              		.global	USART_SetReceiverTimeOut
 1010              		.thumb
 1011              		.thumb_func
 1013              	USART_SetReceiverTimeOut:
 1014              	.LFB125:
 674:../src/stm32f30x_usart.c **** 
 675:../src/stm32f30x_usart.c **** /**
 676:../src/stm32f30x_usart.c ****   * @brief  Sets the receiver Time Out value.
 677:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 678:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 679:../src/stm32f30x_usart.c ****   * @param  USART_ReceiverTimeOut: specifies the Receiver Time Out value.
 680:../src/stm32f30x_usart.c ****   * @retval None
 681:../src/stm32f30x_usart.c ****   */
 682:../src/stm32f30x_usart.c **** void USART_SetReceiverTimeOut(USART_TypeDef* USARTx, uint32_t USART_ReceiverTimeOut)
 683:../src/stm32f30x_usart.c **** {    
 1015              		.loc 1 683 0
 1016              		.cfi_startproc
 1017              		@ args = 0, pretend = 0, frame = 8
 1018              		@ frame_needed = 1, uses_anonymous_args = 0
 1019              		@ link register save eliminated.
 1020 052c 80B4     		push	{r7}
 1021              	.LCFI42:
 1022              		.cfi_def_cfa_offset 4
 1023              		.cfi_offset 7, -4
 1024 052e 83B0     		sub	sp, sp, #12
 1025              	.LCFI43:
 1026              		.cfi_def_cfa_offset 16
 1027 0530 00AF     		add	r7, sp, #0
 1028              	.LCFI44:
 1029              		.cfi_def_cfa_register 7
 1030 0532 7860     		str	r0, [r7, #4]
 1031 0534 3960     		str	r1, [r7, #0]
 684:../src/stm32f30x_usart.c ****   /* Check the parameters */
 685:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 686:../src/stm32f30x_usart.c ****   assert_param(IS_USART_TIMEOUT(USART_ReceiverTimeOut));
 687:../src/stm32f30x_usart.c **** 
 688:../src/stm32f30x_usart.c ****   /* Clear the receiver Time Out value by clearing the RTO[23:0] bits in the RTOR
 689:../src/stm32f30x_usart.c ****      register  */
 690:../src/stm32f30x_usart.c ****   USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_RTO);
 1032              		.loc 1 690 0
 1033 0536 7B68     		ldr	r3, [r7, #4]
 1034 0538 5B69     		ldr	r3, [r3, #20]
 1035 053a 03F07F42 		and	r2, r3, #-16777216
 1036 053e 7B68     		ldr	r3, [r7, #4]
 1037 0540 5A61     		str	r2, [r3, #20]
 691:../src/stm32f30x_usart.c ****   /* Set the receiver Time Out value by setting the RTO[23:0] bits in the RTOR
 692:../src/stm32f30x_usart.c ****      register  */
 693:../src/stm32f30x_usart.c ****   USARTx->RTOR |= USART_ReceiverTimeOut;
 1038              		.loc 1 693 0
 1039 0542 7B68     		ldr	r3, [r7, #4]
 1040 0544 5A69     		ldr	r2, [r3, #20]
 1041 0546 3B68     		ldr	r3, [r7, #0]
 1042 0548 1A43     		orrs	r2, r2, r3
 1043 054a 7B68     		ldr	r3, [r7, #4]
 1044 054c 5A61     		str	r2, [r3, #20]
 694:../src/stm32f30x_usart.c **** }
 1045              		.loc 1 694 0
 1046 054e 07F10C07 		add	r7, r7, #12
 1047 0552 BD46     		mov	sp, r7
 1048 0554 80BC     		pop	{r7}
 1049 0556 7047     		bx	lr
 1050              		.cfi_endproc
 1051              	.LFE125:
 1053              		.align	2
 1054              		.global	USART_SetPrescaler
 1055              		.thumb
 1056              		.thumb_func
 1058              	USART_SetPrescaler:
 1059              	.LFB126:
 695:../src/stm32f30x_usart.c **** 
 696:../src/stm32f30x_usart.c **** /**
 697:../src/stm32f30x_usart.c ****   * @brief  Sets the system clock prescaler.
 698:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the
 699:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 700:../src/stm32f30x_usart.c ****   * @param  USART_Prescaler: specifies the prescaler clock.  
 701:../src/stm32f30x_usart.c ****   * @note
 702:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function.  
 703:../src/stm32f30x_usart.c ****   * @retval None
 704:../src/stm32f30x_usart.c ****   */
 705:../src/stm32f30x_usart.c **** void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
 706:../src/stm32f30x_usart.c **** {
 1060              		.loc 1 706 0
 1061              		.cfi_startproc
 1062              		@ args = 0, pretend = 0, frame = 8
 1063              		@ frame_needed = 1, uses_anonymous_args = 0
 1064              		@ link register save eliminated.
 1065 0558 80B4     		push	{r7}
 1066              	.LCFI45:
 1067              		.cfi_def_cfa_offset 4
 1068              		.cfi_offset 7, -4
 1069 055a 83B0     		sub	sp, sp, #12
 1070              	.LCFI46:
 1071              		.cfi_def_cfa_offset 16
 1072 055c 00AF     		add	r7, sp, #0
 1073              	.LCFI47:
 1074              		.cfi_def_cfa_register 7
 1075 055e 7860     		str	r0, [r7, #4]
 1076 0560 0B46     		mov	r3, r1
 1077 0562 FB70     		strb	r3, [r7, #3]
 707:../src/stm32f30x_usart.c ****   /* Check the parameters */
 708:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 709:../src/stm32f30x_usart.c **** 
 710:../src/stm32f30x_usart.c ****   /* Clear the USART prescaler */
 711:../src/stm32f30x_usart.c ****   USARTx->GTPR &= USART_GTPR_GT;
 1078              		.loc 1 711 0
 1079 0564 7B68     		ldr	r3, [r7, #4]
 1080 0566 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1081 0568 9BB2     		uxth	r3, r3
 1082 056a 23F0FF03 		bic	r3, r3, #255
 1083 056e 9AB2     		uxth	r2, r3
 1084 0570 7B68     		ldr	r3, [r7, #4]
 1085 0572 1A82     		strh	r2, [r3, #16]	@ movhi
 712:../src/stm32f30x_usart.c ****   /* Set the USART prescaler */
 713:../src/stm32f30x_usart.c ****   USARTx->GTPR |= USART_Prescaler;
 1086              		.loc 1 713 0
 1087 0574 7B68     		ldr	r3, [r7, #4]
 1088 0576 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1089 0578 9AB2     		uxth	r2, r3
 1090 057a FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1091 057c 9BB2     		uxth	r3, r3
 1092 057e 1343     		orrs	r3, r3, r2
 1093 0580 9AB2     		uxth	r2, r3
 1094 0582 7B68     		ldr	r3, [r7, #4]
 1095 0584 1A82     		strh	r2, [r3, #16]	@ movhi
 714:../src/stm32f30x_usart.c **** }
 1096              		.loc 1 714 0
 1097 0586 07F10C07 		add	r7, r7, #12
 1098 058a BD46     		mov	sp, r7
 1099 058c 80BC     		pop	{r7}
 1100 058e 7047     		bx	lr
 1101              		.cfi_endproc
 1102              	.LFE126:
 1104              		.align	2
 1105              		.global	USART_STOPModeCmd
 1106              		.thumb
 1107              		.thumb_func
 1109              	USART_STOPModeCmd:
 1110              	.LFB127:
 715:../src/stm32f30x_usart.c **** 
 716:../src/stm32f30x_usart.c **** /**
 717:../src/stm32f30x_usart.c ****   * @}
 718:../src/stm32f30x_usart.c ****   */
 719:../src/stm32f30x_usart.c **** 
 720:../src/stm32f30x_usart.c **** 
 721:../src/stm32f30x_usart.c **** /** @defgroup USART_Group2 STOP Mode functions
 722:../src/stm32f30x_usart.c ****  *  @brief   STOP Mode functions
 723:../src/stm32f30x_usart.c ****  *
 724:../src/stm32f30x_usart.c **** @verbatim
 725:../src/stm32f30x_usart.c ****  ===============================================================================
 726:../src/stm32f30x_usart.c ****                         ##### STOP Mode functions #####
 727:../src/stm32f30x_usart.c ****  ===============================================================================
 728:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage 
 729:../src/stm32f30x_usart.c ****          WakeUp from STOP mode.
 730:../src/stm32f30x_usart.c **** 
 731:../src/stm32f30x_usart.c ****     [..] The USART is able to WakeUp from Stop Mode if USART clock is set to HSI
 732:../src/stm32f30x_usart.c ****          or LSI.
 733:../src/stm32f30x_usart.c ****          
 734:../src/stm32f30x_usart.c ****     [..] The WakeUp source is configured by calling USART_StopModeWakeUpSourceConfig()
 735:../src/stm32f30x_usart.c ****          function.
 736:../src/stm32f30x_usart.c ****          
 737:../src/stm32f30x_usart.c ****     [..] After configuring the source of WakeUp and before entering in Stop Mode 
 738:../src/stm32f30x_usart.c ****          USART_STOPModeCmd() function should be called to allow USART WakeUp.
 739:../src/stm32f30x_usart.c ****                            
 740:../src/stm32f30x_usart.c **** @endverbatim
 741:../src/stm32f30x_usart.c ****   * @{
 742:../src/stm32f30x_usart.c ****   */
 743:../src/stm32f30x_usart.c ****   
 744:../src/stm32f30x_usart.c **** /**
 745:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the specified USART peripheral in STOP Mode.
 746:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the
 747:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 748:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USARTx peripheral state in stop mode.
 749:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 750:../src/stm32f30x_usart.c ****   * @note
 751:../src/stm32f30x_usart.c ****   *   This function has to be called when USART clock is set to HSI or LSE.
 752:../src/stm32f30x_usart.c ****   * @retval None
 753:../src/stm32f30x_usart.c ****   */
 754:../src/stm32f30x_usart.c **** void USART_STOPModeCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 755:../src/stm32f30x_usart.c **** {
 1111              		.loc 1 755 0
 1112              		.cfi_startproc
 1113              		@ args = 0, pretend = 0, frame = 8
 1114              		@ frame_needed = 1, uses_anonymous_args = 0
 1115              		@ link register save eliminated.
 1116 0590 80B4     		push	{r7}
 1117              	.LCFI48:
 1118              		.cfi_def_cfa_offset 4
 1119              		.cfi_offset 7, -4
 1120 0592 83B0     		sub	sp, sp, #12
 1121              	.LCFI49:
 1122              		.cfi_def_cfa_offset 16
 1123 0594 00AF     		add	r7, sp, #0
 1124              	.LCFI50:
 1125              		.cfi_def_cfa_register 7
 1126 0596 7860     		str	r0, [r7, #4]
 1127 0598 0B46     		mov	r3, r1
 1128 059a FB70     		strb	r3, [r7, #3]
 756:../src/stm32f30x_usart.c ****   /* Check the parameters */
 757:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 758:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 759:../src/stm32f30x_usart.c ****   
 760:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 1129              		.loc 1 760 0
 1130 059c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1131 059e 002B     		cmp	r3, #0
 1132 05a0 06D0     		beq	.L50
 761:../src/stm32f30x_usart.c ****   {
 762:../src/stm32f30x_usart.c ****     /* Enable the selected USART in STOP mode by setting the UESM bit in the CR1
 763:../src/stm32f30x_usart.c ****        register */
 764:../src/stm32f30x_usart.c ****     USARTx->CR1 |= USART_CR1_UESM;
 1133              		.loc 1 764 0
 1134 05a2 7B68     		ldr	r3, [r7, #4]
 1135 05a4 1B68     		ldr	r3, [r3, #0]
 1136 05a6 43F00202 		orr	r2, r3, #2
 1137 05aa 7B68     		ldr	r3, [r7, #4]
 1138 05ac 1A60     		str	r2, [r3, #0]
 1139 05ae 05E0     		b	.L49
 1140              	.L50:
 765:../src/stm32f30x_usart.c ****   }
 766:../src/stm32f30x_usart.c ****   else
 767:../src/stm32f30x_usart.c ****   {
 768:../src/stm32f30x_usart.c ****     /* Disable the selected USART in STOP mode by clearing the UE bit in the CR1
 769:../src/stm32f30x_usart.c ****        register */
 770:../src/stm32f30x_usart.c ****     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UESM);
 1141              		.loc 1 770 0
 1142 05b0 7B68     		ldr	r3, [r7, #4]
 1143 05b2 1B68     		ldr	r3, [r3, #0]
 1144 05b4 23F00202 		bic	r2, r3, #2
 1145 05b8 7B68     		ldr	r3, [r7, #4]
 1146 05ba 1A60     		str	r2, [r3, #0]
 1147              	.L49:
 771:../src/stm32f30x_usart.c ****   }
 772:../src/stm32f30x_usart.c **** }
 1148              		.loc 1 772 0
 1149 05bc 07F10C07 		add	r7, r7, #12
 1150 05c0 BD46     		mov	sp, r7
 1151 05c2 80BC     		pop	{r7}
 1152 05c4 7047     		bx	lr
 1153              		.cfi_endproc
 1154              	.LFE127:
 1156 05c6 00BF     		.align	2
 1157              		.global	USART_StopModeWakeUpSourceConfig
 1158              		.thumb
 1159              		.thumb_func
 1161              	USART_StopModeWakeUpSourceConfig:
 1162              	.LFB128:
 773:../src/stm32f30x_usart.c **** 
 774:../src/stm32f30x_usart.c **** /**
 775:../src/stm32f30x_usart.c ****   * @brief  Selects the USART WakeUp method form stop mode.
 776:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 777:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 778:../src/stm32f30x_usart.c ****   * @param  USART_WakeUp: specifies the selected USART wakeup method.
 779:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
 780:../src/stm32f30x_usart.c ****   *         @arg USART_WakeUpSource_AddressMatch: WUF active on address match.
 781:../src/stm32f30x_usart.c ****   *         @arg USART_WakeUpSource_StartBit: WUF active on Start bit detection.
 782:../src/stm32f30x_usart.c ****   *         @arg USART_WakeUpSource_RXNE: WUF active on RXNE.
 783:../src/stm32f30x_usart.c ****   * @note
 784:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function.  
 785:../src/stm32f30x_usart.c ****   * @retval None
 786:../src/stm32f30x_usart.c ****   */
 787:../src/stm32f30x_usart.c **** void USART_StopModeWakeUpSourceConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUpSource)
 788:../src/stm32f30x_usart.c **** {
 1163              		.loc 1 788 0
 1164              		.cfi_startproc
 1165              		@ args = 0, pretend = 0, frame = 8
 1166              		@ frame_needed = 1, uses_anonymous_args = 0
 1167              		@ link register save eliminated.
 1168 05c8 80B4     		push	{r7}
 1169              	.LCFI51:
 1170              		.cfi_def_cfa_offset 4
 1171              		.cfi_offset 7, -4
 1172 05ca 83B0     		sub	sp, sp, #12
 1173              	.LCFI52:
 1174              		.cfi_def_cfa_offset 16
 1175 05cc 00AF     		add	r7, sp, #0
 1176              	.LCFI53:
 1177              		.cfi_def_cfa_register 7
 1178 05ce 7860     		str	r0, [r7, #4]
 1179 05d0 3960     		str	r1, [r7, #0]
 789:../src/stm32f30x_usart.c ****   /* Check the parameters */
 790:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 791:../src/stm32f30x_usart.c ****   assert_param(IS_USART_STOPMODE_WAKEUPSOURCE(USART_WakeUpSource));
 792:../src/stm32f30x_usart.c **** 
 793:../src/stm32f30x_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_WUS);
 1180              		.loc 1 793 0
 1181 05d2 7B68     		ldr	r3, [r7, #4]
 1182 05d4 9B68     		ldr	r3, [r3, #8]
 1183 05d6 23F44012 		bic	r2, r3, #3145728
 1184 05da 7B68     		ldr	r3, [r7, #4]
 1185 05dc 9A60     		str	r2, [r3, #8]
 794:../src/stm32f30x_usart.c ****   USARTx->CR3 |= USART_WakeUpSource;
 1186              		.loc 1 794 0
 1187 05de 7B68     		ldr	r3, [r7, #4]
 1188 05e0 9A68     		ldr	r2, [r3, #8]
 1189 05e2 3B68     		ldr	r3, [r7, #0]
 1190 05e4 1A43     		orrs	r2, r2, r3
 1191 05e6 7B68     		ldr	r3, [r7, #4]
 1192 05e8 9A60     		str	r2, [r3, #8]
 795:../src/stm32f30x_usart.c **** }
 1193              		.loc 1 795 0
 1194 05ea 07F10C07 		add	r7, r7, #12
 1195 05ee BD46     		mov	sp, r7
 1196 05f0 80BC     		pop	{r7}
 1197 05f2 7047     		bx	lr
 1198              		.cfi_endproc
 1199              	.LFE128:
 1201              		.align	2
 1202              		.global	USART_AutoBaudRateCmd
 1203              		.thumb
 1204              		.thumb_func
 1206              	USART_AutoBaudRateCmd:
 1207              	.LFB129:
 796:../src/stm32f30x_usart.c **** 
 797:../src/stm32f30x_usart.c **** /**
 798:../src/stm32f30x_usart.c ****   * @}
 799:../src/stm32f30x_usart.c ****   */
 800:../src/stm32f30x_usart.c **** 
 801:../src/stm32f30x_usart.c **** 
 802:../src/stm32f30x_usart.c **** /** @defgroup USART_Group3 AutoBaudRate functions
 803:../src/stm32f30x_usart.c ****  *  @brief   AutoBaudRate functions 
 804:../src/stm32f30x_usart.c ****  *
 805:../src/stm32f30x_usart.c **** @verbatim
 806:../src/stm32f30x_usart.c ****  ===============================================================================
 807:../src/stm32f30x_usart.c ****                        ##### AutoBaudRate functions #####
 808:../src/stm32f30x_usart.c ****  ===============================================================================
 809:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage 
 810:../src/stm32f30x_usart.c ****          the AutoBaudRate detections.
 811:../src/stm32f30x_usart.c ****          
 812:../src/stm32f30x_usart.c ****     [..] Before Enabling AutoBaudRate detection using USART_AutoBaudRateCmd ()
 813:../src/stm32f30x_usart.c ****          The character patterns used to calculate baudrate must be chosen by calling 
 814:../src/stm32f30x_usart.c ****          USART_AutoBaudRateConfig() function. These function take as parameter :
 815:../src/stm32f30x_usart.c ****         (#)USART_AutoBaudRate_StartBit : any character starting with a bit 1.
 816:../src/stm32f30x_usart.c ****         (#)USART_AutoBaudRate_FallingEdge : any character starting with a 10xx bit pattern. 
 817:../src/stm32f30x_usart.c ****                           
 818:../src/stm32f30x_usart.c ****     [..] At any later time, another request for AutoBaudRate detection can be performed
 819:../src/stm32f30x_usart.c ****          using USART_RequestCmd() function.
 820:../src/stm32f30x_usart.c ****          
 821:../src/stm32f30x_usart.c ****     [..] The AutoBaudRate detection is monitored by the status of ABRF flag which indicate
 822:../src/stm32f30x_usart.c ****          that the AutoBaudRate detection is completed. In addition to ABRF flag, the ABRE flag
 823:../src/stm32f30x_usart.c ****          indicate that this procedure is completed without success. USART_GetFlagStatus () 
 824:../src/stm32f30x_usart.c ****          function should be used to monitor the status of these flags.  
 825:../src/stm32f30x_usart.c ****              
 826:../src/stm32f30x_usart.c **** @endverbatim
 827:../src/stm32f30x_usart.c ****   * @{
 828:../src/stm32f30x_usart.c ****   */
 829:../src/stm32f30x_usart.c ****   
 830:../src/stm32f30x_usart.c **** /**
 831:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the Auto Baud Rate.
 832:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 833:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 834:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USARTx auto baud rate.
 835:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 836:../src/stm32f30x_usart.c ****   * @retval None
 837:../src/stm32f30x_usart.c ****   */
 838:../src/stm32f30x_usart.c **** void USART_AutoBaudRateCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 839:../src/stm32f30x_usart.c **** {
 1208              		.loc 1 839 0
 1209              		.cfi_startproc
 1210              		@ args = 0, pretend = 0, frame = 8
 1211              		@ frame_needed = 1, uses_anonymous_args = 0
 1212              		@ link register save eliminated.
 1213 05f4 80B4     		push	{r7}
 1214              	.LCFI54:
 1215              		.cfi_def_cfa_offset 4
 1216              		.cfi_offset 7, -4
 1217 05f6 83B0     		sub	sp, sp, #12
 1218              	.LCFI55:
 1219              		.cfi_def_cfa_offset 16
 1220 05f8 00AF     		add	r7, sp, #0
 1221              	.LCFI56:
 1222              		.cfi_def_cfa_register 7
 1223 05fa 7860     		str	r0, [r7, #4]
 1224 05fc 0B46     		mov	r3, r1
 1225 05fe FB70     		strb	r3, [r7, #3]
 840:../src/stm32f30x_usart.c ****   /* Check the parameters */
 841:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 842:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 843:../src/stm32f30x_usart.c **** 
 844:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 1226              		.loc 1 844 0
 1227 0600 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1228 0602 002B     		cmp	r3, #0
 1229 0604 06D0     		beq	.L54
 845:../src/stm32f30x_usart.c ****   {
 846:../src/stm32f30x_usart.c ****     /* Enable the auto baud rate feature by setting the ABREN bit in the CR2 
 847:../src/stm32f30x_usart.c ****        register */
 848:../src/stm32f30x_usart.c ****     USARTx->CR2 |= USART_CR2_ABREN;
 1230              		.loc 1 848 0
 1231 0606 7B68     		ldr	r3, [r7, #4]
 1232 0608 5B68     		ldr	r3, [r3, #4]
 1233 060a 43F48012 		orr	r2, r3, #1048576
 1234 060e 7B68     		ldr	r3, [r7, #4]
 1235 0610 5A60     		str	r2, [r3, #4]
 1236 0612 05E0     		b	.L53
 1237              	.L54:
 849:../src/stm32f30x_usart.c ****   }
 850:../src/stm32f30x_usart.c ****   else
 851:../src/stm32f30x_usart.c ****   {
 852:../src/stm32f30x_usart.c ****     /* Disable the auto baud rate feature by clearing the ABREN bit in the CR2 
 853:../src/stm32f30x_usart.c ****        register */
 854:../src/stm32f30x_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABREN);
 1238              		.loc 1 854 0
 1239 0614 7B68     		ldr	r3, [r7, #4]
 1240 0616 5B68     		ldr	r3, [r3, #4]
 1241 0618 23F48012 		bic	r2, r3, #1048576
 1242 061c 7B68     		ldr	r3, [r7, #4]
 1243 061e 5A60     		str	r2, [r3, #4]
 1244              	.L53:
 855:../src/stm32f30x_usart.c ****   }
 856:../src/stm32f30x_usart.c **** }
 1245              		.loc 1 856 0
 1246 0620 07F10C07 		add	r7, r7, #12
 1247 0624 BD46     		mov	sp, r7
 1248 0626 80BC     		pop	{r7}
 1249 0628 7047     		bx	lr
 1250              		.cfi_endproc
 1251              	.LFE129:
 1253 062a 00BF     		.align	2
 1254              		.global	USART_AutoBaudRateConfig
 1255              		.thumb
 1256              		.thumb_func
 1258              	USART_AutoBaudRateConfig:
 1259              	.LFB130:
 857:../src/stm32f30x_usart.c **** 
 858:../src/stm32f30x_usart.c **** /**
 859:../src/stm32f30x_usart.c ****   * @brief  Selects the USART auto baud rate method.
 860:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 861:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 862:../src/stm32f30x_usart.c ****   * @param  USART_AutoBaudRate: specifies the selected USART auto baud rate method.
 863:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
 864:../src/stm32f30x_usart.c ****   *         @arg USART_AutoBaudRate_StartBit: Start Bit duration measurement.
 865:../src/stm32f30x_usart.c ****   *         @arg USART_AutoBaudRate_FallingEdge: Falling edge to falling edge measurement.
 866:../src/stm32f30x_usart.c ****   *         @arg USART_AutoBaudRate_0x7FFrame: 0x7F frame.
 867:../src/stm32f30x_usart.c ****   *         @arg USART_AutoBaudRate_0x55Frame: 0x55 frame.
 868:../src/stm32f30x_usart.c ****   * @note
 869:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function. 
 870:../src/stm32f30x_usart.c ****   * @retval None
 871:../src/stm32f30x_usart.c ****   */
 872:../src/stm32f30x_usart.c **** void USART_AutoBaudRateConfig(USART_TypeDef* USARTx, uint32_t USART_AutoBaudRate)
 873:../src/stm32f30x_usart.c **** {
 1260              		.loc 1 873 0
 1261              		.cfi_startproc
 1262              		@ args = 0, pretend = 0, frame = 8
 1263              		@ frame_needed = 1, uses_anonymous_args = 0
 1264              		@ link register save eliminated.
 1265 062c 80B4     		push	{r7}
 1266              	.LCFI57:
 1267              		.cfi_def_cfa_offset 4
 1268              		.cfi_offset 7, -4
 1269 062e 83B0     		sub	sp, sp, #12
 1270              	.LCFI58:
 1271              		.cfi_def_cfa_offset 16
 1272 0630 00AF     		add	r7, sp, #0
 1273              	.LCFI59:
 1274              		.cfi_def_cfa_register 7
 1275 0632 7860     		str	r0, [r7, #4]
 1276 0634 3960     		str	r1, [r7, #0]
 874:../src/stm32f30x_usart.c ****   /* Check the parameters */
 875:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 876:../src/stm32f30x_usart.c ****   assert_param(IS_USART_AUTOBAUDRATE_MODE(USART_AutoBaudRate));
 877:../src/stm32f30x_usart.c **** 
 878:../src/stm32f30x_usart.c ****   USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABRMODE);
 1277              		.loc 1 878 0
 1278 0636 7B68     		ldr	r3, [r7, #4]
 1279 0638 5B68     		ldr	r3, [r3, #4]
 1280 063a 23F4C002 		bic	r2, r3, #6291456
 1281 063e 7B68     		ldr	r3, [r7, #4]
 1282 0640 5A60     		str	r2, [r3, #4]
 879:../src/stm32f30x_usart.c ****   USARTx->CR2 |= USART_AutoBaudRate;
 1283              		.loc 1 879 0
 1284 0642 7B68     		ldr	r3, [r7, #4]
 1285 0644 5A68     		ldr	r2, [r3, #4]
 1286 0646 3B68     		ldr	r3, [r7, #0]
 1287 0648 1A43     		orrs	r2, r2, r3
 1288 064a 7B68     		ldr	r3, [r7, #4]
 1289 064c 5A60     		str	r2, [r3, #4]
 880:../src/stm32f30x_usart.c **** }
 1290              		.loc 1 880 0
 1291 064e 07F10C07 		add	r7, r7, #12
 1292 0652 BD46     		mov	sp, r7
 1293 0654 80BC     		pop	{r7}
 1294 0656 7047     		bx	lr
 1295              		.cfi_endproc
 1296              	.LFE130:
 1298              		.align	2
 1299              		.global	USART_SendData
 1300              		.thumb
 1301              		.thumb_func
 1303              	USART_SendData:
 1304              	.LFB131:
 881:../src/stm32f30x_usart.c **** 
 882:../src/stm32f30x_usart.c **** /**
 883:../src/stm32f30x_usart.c ****   * @}
 884:../src/stm32f30x_usart.c ****   */
 885:../src/stm32f30x_usart.c **** 
 886:../src/stm32f30x_usart.c **** 
 887:../src/stm32f30x_usart.c **** /** @defgroup USART_Group4 Data transfers functions
 888:../src/stm32f30x_usart.c ****  *  @brief   Data transfers functions 
 889:../src/stm32f30x_usart.c ****  *
 890:../src/stm32f30x_usart.c **** @verbatim
 891:../src/stm32f30x_usart.c ****  ===============================================================================
 892:../src/stm32f30x_usart.c ****                     ##### Data transfers functions #####
 893:../src/stm32f30x_usart.c ****  ===============================================================================
 894:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage 
 895:../src/stm32f30x_usart.c ****          the USART data transfers.
 896:../src/stm32f30x_usart.c ****     [..] During an USART reception, data shifts in least significant bit first 
 897:../src/stm32f30x_usart.c ****          through the RX pin. When a transmission is taking place, a write instruction to 
 898:../src/stm32f30x_usart.c ****          the USART_TDR register stores the data in the shift register.
 899:../src/stm32f30x_usart.c ****     [..] The read access of the USART_RDR register can be done using 
 900:../src/stm32f30x_usart.c ****          the USART_ReceiveData() function and returns the RDR value.
 901:../src/stm32f30x_usart.c ****          Whereas a write access to the USART_TDR can be done using USART_SendData()
 902:../src/stm32f30x_usart.c ****          function and stores the written data into TDR.
 903:../src/stm32f30x_usart.c **** 
 904:../src/stm32f30x_usart.c **** @endverbatim
 905:../src/stm32f30x_usart.c ****   * @{
 906:../src/stm32f30x_usart.c ****   */
 907:../src/stm32f30x_usart.c **** 
 908:../src/stm32f30x_usart.c **** /**
 909:../src/stm32f30x_usart.c ****   * @brief  Transmits single data through the USARTx peripheral.
 910:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 911:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 912:../src/stm32f30x_usart.c ****   * @param  Data: the data to transmit.
 913:../src/stm32f30x_usart.c ****   * @retval None
 914:../src/stm32f30x_usart.c ****   */
 915:../src/stm32f30x_usart.c **** void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
 916:../src/stm32f30x_usart.c **** {
 1305              		.loc 1 916 0
 1306              		.cfi_startproc
 1307              		@ args = 0, pretend = 0, frame = 8
 1308              		@ frame_needed = 1, uses_anonymous_args = 0
 1309              		@ link register save eliminated.
 1310 0658 80B4     		push	{r7}
 1311              	.LCFI60:
 1312              		.cfi_def_cfa_offset 4
 1313              		.cfi_offset 7, -4
 1314 065a 83B0     		sub	sp, sp, #12
 1315              	.LCFI61:
 1316              		.cfi_def_cfa_offset 16
 1317 065c 00AF     		add	r7, sp, #0
 1318              	.LCFI62:
 1319              		.cfi_def_cfa_register 7
 1320 065e 7860     		str	r0, [r7, #4]
 1321 0660 0B46     		mov	r3, r1
 1322 0662 7B80     		strh	r3, [r7, #2]	@ movhi
 917:../src/stm32f30x_usart.c ****   /* Check the parameters */
 918:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 919:../src/stm32f30x_usart.c ****   assert_param(IS_USART_DATA(Data)); 
 920:../src/stm32f30x_usart.c **** 
 921:../src/stm32f30x_usart.c ****   /* Transmit Data */
 922:../src/stm32f30x_usart.c ****   USARTx->TDR = (Data & (uint16_t)0x01FF);
 1323              		.loc 1 922 0
 1324 0664 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1325 0666 4FEAC353 		lsl	r3, r3, #23
 1326 066a 4FEAD353 		lsr	r3, r3, #23
 1327 066e 9AB2     		uxth	r2, r3
 1328 0670 7B68     		ldr	r3, [r7, #4]
 1329 0672 1A85     		strh	r2, [r3, #40]	@ movhi
 923:../src/stm32f30x_usart.c **** }
 1330              		.loc 1 923 0
 1331 0674 07F10C07 		add	r7, r7, #12
 1332 0678 BD46     		mov	sp, r7
 1333 067a 80BC     		pop	{r7}
 1334 067c 7047     		bx	lr
 1335              		.cfi_endproc
 1336              	.LFE131:
 1338 067e 00BF     		.align	2
 1339              		.global	USART_ReceiveData
 1340              		.thumb
 1341              		.thumb_func
 1343              	USART_ReceiveData:
 1344              	.LFB132:
 924:../src/stm32f30x_usart.c **** 
 925:../src/stm32f30x_usart.c **** /**
 926:../src/stm32f30x_usart.c ****   * @brief  Returns the most recent received data by the USARTx peripheral.
 927:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 928:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 929:../src/stm32f30x_usart.c ****   * @retval The received data.
 930:../src/stm32f30x_usart.c ****   */
 931:../src/stm32f30x_usart.c **** uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
 932:../src/stm32f30x_usart.c **** {
 1345              		.loc 1 932 0
 1346              		.cfi_startproc
 1347              		@ args = 0, pretend = 0, frame = 8
 1348              		@ frame_needed = 1, uses_anonymous_args = 0
 1349              		@ link register save eliminated.
 1350 0680 80B4     		push	{r7}
 1351              	.LCFI63:
 1352              		.cfi_def_cfa_offset 4
 1353              		.cfi_offset 7, -4
 1354 0682 83B0     		sub	sp, sp, #12
 1355              	.LCFI64:
 1356              		.cfi_def_cfa_offset 16
 1357 0684 00AF     		add	r7, sp, #0
 1358              	.LCFI65:
 1359              		.cfi_def_cfa_register 7
 1360 0686 7860     		str	r0, [r7, #4]
 933:../src/stm32f30x_usart.c ****   /* Check the parameters */
 934:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 935:../src/stm32f30x_usart.c **** 
 936:../src/stm32f30x_usart.c ****   /* Receive Data */
 937:../src/stm32f30x_usart.c ****   return (uint16_t)(USARTx->RDR & (uint16_t)0x01FF);
 1361              		.loc 1 937 0
 1362 0688 7B68     		ldr	r3, [r7, #4]
 1363 068a 9B8C     		ldrh	r3, [r3, #36]	@ movhi
 1364 068c 9BB2     		uxth	r3, r3
 1365 068e 4FEAC353 		lsl	r3, r3, #23
 1366 0692 4FEAD353 		lsr	r3, r3, #23
 1367 0696 9BB2     		uxth	r3, r3
 938:../src/stm32f30x_usart.c **** }
 1368              		.loc 1 938 0
 1369 0698 1846     		mov	r0, r3
 1370 069a 07F10C07 		add	r7, r7, #12
 1371 069e BD46     		mov	sp, r7
 1372 06a0 80BC     		pop	{r7}
 1373 06a2 7047     		bx	lr
 1374              		.cfi_endproc
 1375              	.LFE132:
 1377              		.align	2
 1378              		.global	USART_SetAddress
 1379              		.thumb
 1380              		.thumb_func
 1382              	USART_SetAddress:
 1383              	.LFB133:
 939:../src/stm32f30x_usart.c **** 
 940:../src/stm32f30x_usart.c **** /**
 941:../src/stm32f30x_usart.c ****   * @}
 942:../src/stm32f30x_usart.c ****   */
 943:../src/stm32f30x_usart.c **** 
 944:../src/stm32f30x_usart.c **** /** @defgroup USART_Group5 MultiProcessor Communication functions
 945:../src/stm32f30x_usart.c ****  *  @brief   Multi-Processor Communication functions 
 946:../src/stm32f30x_usart.c ****  *
 947:../src/stm32f30x_usart.c **** @verbatim   
 948:../src/stm32f30x_usart.c ****  ===============================================================================
 949:../src/stm32f30x_usart.c ****              ##### Multi-Processor Communication functions #####
 950:../src/stm32f30x_usart.c ****  ===============================================================================
 951:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
 952:../src/stm32f30x_usart.c ****          multiprocessor communication.
 953:../src/stm32f30x_usart.c ****     [..] For instance one of the USARTs can be the master, its TX output is
 954:../src/stm32f30x_usart.c ****          connected to the RX input of the other USART. The others are slaves,
 955:../src/stm32f30x_usart.c ****          their respective TX outputs are logically ANDed together and connected 
 956:../src/stm32f30x_usart.c ****          to the RX input of the master. USART multiprocessor communication is 
 957:../src/stm32f30x_usart.c ****          possible through the following procedure:
 958:../src/stm32f30x_usart.c ****          (#) Program the Baud rate, Word length = 9 bits, Stop bits, Parity, 
 959:../src/stm32f30x_usart.c ****              Mode transmitter or Mode receiver and hardware flow control values 
 960:../src/stm32f30x_usart.c ****              using the USART_Init() function.
 961:../src/stm32f30x_usart.c ****          (#) Configures the USART address using the USART_SetAddress() function.
 962:../src/stm32f30x_usart.c ****          (#) Configures the wake up methode (USART_WakeUp_IdleLine or 
 963:../src/stm32f30x_usart.c ****              USART_WakeUp_AddressMark) using USART_WakeUpConfig() function only 
 964:../src/stm32f30x_usart.c ****              for the slaves.
 965:../src/stm32f30x_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
 966:../src/stm32f30x_usart.c ****          (#) Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() 
 967:../src/stm32f30x_usart.c ****              function.
 968:../src/stm32f30x_usart.c ****     [..] The USART Slave exit from mute mode when receive the wake up condition.
 969:../src/stm32f30x_usart.c **** 
 970:../src/stm32f30x_usart.c **** @endverbatim
 971:../src/stm32f30x_usart.c ****   * @{
 972:../src/stm32f30x_usart.c ****   */
 973:../src/stm32f30x_usart.c **** 
 974:../src/stm32f30x_usart.c **** /**
 975:../src/stm32f30x_usart.c ****   * @brief  Sets the address of the USART node.
 976:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 977:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 978:../src/stm32f30x_usart.c ****   * @param  USART_Address: Indicates the address of the USART node.
 979:../src/stm32f30x_usart.c ****   * @retval None
 980:../src/stm32f30x_usart.c ****   */
 981:../src/stm32f30x_usart.c **** void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
 982:../src/stm32f30x_usart.c **** {
 1384              		.loc 1 982 0
 1385              		.cfi_startproc
 1386              		@ args = 0, pretend = 0, frame = 8
 1387              		@ frame_needed = 1, uses_anonymous_args = 0
 1388              		@ link register save eliminated.
 1389 06a4 80B4     		push	{r7}
 1390              	.LCFI66:
 1391              		.cfi_def_cfa_offset 4
 1392              		.cfi_offset 7, -4
 1393 06a6 83B0     		sub	sp, sp, #12
 1394              	.LCFI67:
 1395              		.cfi_def_cfa_offset 16
 1396 06a8 00AF     		add	r7, sp, #0
 1397              	.LCFI68:
 1398              		.cfi_def_cfa_register 7
 1399 06aa 7860     		str	r0, [r7, #4]
 1400 06ac 0B46     		mov	r3, r1
 1401 06ae FB70     		strb	r3, [r7, #3]
 983:../src/stm32f30x_usart.c ****   /* Check the parameters */
 984:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 985:../src/stm32f30x_usart.c **** 
 986:../src/stm32f30x_usart.c ****   /* Clear the USART address */
 987:../src/stm32f30x_usart.c ****   USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADD);
 1402              		.loc 1 987 0
 1403 06b0 7B68     		ldr	r3, [r7, #4]
 1404 06b2 5B68     		ldr	r3, [r3, #4]
 1405 06b4 23F07F42 		bic	r2, r3, #-16777216
 1406 06b8 7B68     		ldr	r3, [r7, #4]
 1407 06ba 5A60     		str	r2, [r3, #4]
 988:../src/stm32f30x_usart.c ****   /* Set the USART address node */
 989:../src/stm32f30x_usart.c ****   USARTx->CR2 |=((uint32_t)USART_Address << (uint32_t)0x18);
 1408              		.loc 1 989 0
 1409 06bc 7B68     		ldr	r3, [r7, #4]
 1410 06be 5A68     		ldr	r2, [r3, #4]
 1411 06c0 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1412 06c2 4FEA0363 		lsl	r3, r3, #24
 1413 06c6 1A43     		orrs	r2, r2, r3
 1414 06c8 7B68     		ldr	r3, [r7, #4]
 1415 06ca 5A60     		str	r2, [r3, #4]
 990:../src/stm32f30x_usart.c **** }
 1416              		.loc 1 990 0
 1417 06cc 07F10C07 		add	r7, r7, #12
 1418 06d0 BD46     		mov	sp, r7
 1419 06d2 80BC     		pop	{r7}
 1420 06d4 7047     		bx	lr
 1421              		.cfi_endproc
 1422              	.LFE133:
 1424 06d6 00BF     		.align	2
 1425              		.global	USART_MuteModeCmd
 1426              		.thumb
 1427              		.thumb_func
 1429              	USART_MuteModeCmd:
 1430              	.LFB134:
 991:../src/stm32f30x_usart.c **** 
 992:../src/stm32f30x_usart.c **** /**
 993:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's mute mode.
 994:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 995:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 996:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USART mute mode.
 997:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 998:../src/stm32f30x_usart.c ****   * @retval None
 999:../src/stm32f30x_usart.c ****   */
1000:../src/stm32f30x_usart.c **** void USART_MuteModeCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1001:../src/stm32f30x_usart.c **** {
 1431              		.loc 1 1001 0
 1432              		.cfi_startproc
 1433              		@ args = 0, pretend = 0, frame = 8
 1434              		@ frame_needed = 1, uses_anonymous_args = 0
 1435              		@ link register save eliminated.
 1436 06d8 80B4     		push	{r7}
 1437              	.LCFI69:
 1438              		.cfi_def_cfa_offset 4
 1439              		.cfi_offset 7, -4
 1440 06da 83B0     		sub	sp, sp, #12
 1441              	.LCFI70:
 1442              		.cfi_def_cfa_offset 16
 1443 06dc 00AF     		add	r7, sp, #0
 1444              	.LCFI71:
 1445              		.cfi_def_cfa_register 7
 1446 06de 7860     		str	r0, [r7, #4]
 1447 06e0 0B46     		mov	r3, r1
 1448 06e2 FB70     		strb	r3, [r7, #3]
1002:../src/stm32f30x_usart.c ****   /* Check the parameters */
1003:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1004:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
1005:../src/stm32f30x_usart.c **** 
1006:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 1449              		.loc 1 1006 0
 1450 06e4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1451 06e6 002B     		cmp	r3, #0
 1452 06e8 06D0     		beq	.L62
1007:../src/stm32f30x_usart.c ****   {
1008:../src/stm32f30x_usart.c ****     /* Enable the USART mute mode by setting the MME bit in the CR1 register */
1009:../src/stm32f30x_usart.c ****     USARTx->CR1 |= USART_CR1_MME;
 1453              		.loc 1 1009 0
 1454 06ea 7B68     		ldr	r3, [r7, #4]
 1455 06ec 1B68     		ldr	r3, [r3, #0]
 1456 06ee 43F40052 		orr	r2, r3, #8192
 1457 06f2 7B68     		ldr	r3, [r7, #4]
 1458 06f4 1A60     		str	r2, [r3, #0]
 1459 06f6 05E0     		b	.L61
 1460              	.L62:
1010:../src/stm32f30x_usart.c ****   }
1011:../src/stm32f30x_usart.c ****   else
1012:../src/stm32f30x_usart.c ****   {
1013:../src/stm32f30x_usart.c ****     /* Disable the USART mute mode by clearing the MME bit in the CR1 register */
1014:../src/stm32f30x_usart.c ****     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_MME);
 1461              		.loc 1 1014 0
 1462 06f8 7B68     		ldr	r3, [r7, #4]
 1463 06fa 1B68     		ldr	r3, [r3, #0]
 1464 06fc 23F40052 		bic	r2, r3, #8192
 1465 0700 7B68     		ldr	r3, [r7, #4]
 1466 0702 1A60     		str	r2, [r3, #0]
 1467              	.L61:
1015:../src/stm32f30x_usart.c ****   }
1016:../src/stm32f30x_usart.c **** }
 1468              		.loc 1 1016 0
 1469 0704 07F10C07 		add	r7, r7, #12
 1470 0708 BD46     		mov	sp, r7
 1471 070a 80BC     		pop	{r7}
 1472 070c 7047     		bx	lr
 1473              		.cfi_endproc
 1474              	.LFE134:
 1476 070e 00BF     		.align	2
 1477              		.global	USART_MuteModeWakeUpConfig
 1478              		.thumb
 1479              		.thumb_func
 1481              	USART_MuteModeWakeUpConfig:
 1482              	.LFB135:
1017:../src/stm32f30x_usart.c **** 
1018:../src/stm32f30x_usart.c **** /**
1019:../src/stm32f30x_usart.c ****   * @brief  Selects the USART WakeUp method from mute mode.
1020:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1021:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1022:../src/stm32f30x_usart.c ****   * @param  USART_WakeUp: specifies the USART wakeup method.
1023:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1024:../src/stm32f30x_usart.c ****   *         @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
1025:../src/stm32f30x_usart.c ****   *         @arg USART_WakeUp_AddressMark: WakeUp by an address mark
1026:../src/stm32f30x_usart.c ****   * @retval None
1027:../src/stm32f30x_usart.c ****   */
1028:../src/stm32f30x_usart.c **** void USART_MuteModeWakeUpConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUp)
1029:../src/stm32f30x_usart.c **** {
 1483              		.loc 1 1029 0
 1484              		.cfi_startproc
 1485              		@ args = 0, pretend = 0, frame = 8
 1486              		@ frame_needed = 1, uses_anonymous_args = 0
 1487              		@ link register save eliminated.
 1488 0710 80B4     		push	{r7}
 1489              	.LCFI72:
 1490              		.cfi_def_cfa_offset 4
 1491              		.cfi_offset 7, -4
 1492 0712 83B0     		sub	sp, sp, #12
 1493              	.LCFI73:
 1494              		.cfi_def_cfa_offset 16
 1495 0714 00AF     		add	r7, sp, #0
 1496              	.LCFI74:
 1497              		.cfi_def_cfa_register 7
 1498 0716 7860     		str	r0, [r7, #4]
 1499 0718 3960     		str	r1, [r7, #0]
1030:../src/stm32f30x_usart.c ****   /* Check the parameters */
1031:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1032:../src/stm32f30x_usart.c ****   assert_param(IS_USART_MUTEMODE_WAKEUP(USART_WakeUp));
1033:../src/stm32f30x_usart.c **** 
1034:../src/stm32f30x_usart.c ****   USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_WAKE);
 1500              		.loc 1 1034 0
 1501 071a 7B68     		ldr	r3, [r7, #4]
 1502 071c 1B68     		ldr	r3, [r3, #0]
 1503 071e 23F40062 		bic	r2, r3, #2048
 1504 0722 7B68     		ldr	r3, [r7, #4]
 1505 0724 1A60     		str	r2, [r3, #0]
1035:../src/stm32f30x_usart.c ****   USARTx->CR1 |= USART_WakeUp;
 1506              		.loc 1 1035 0
 1507 0726 7B68     		ldr	r3, [r7, #4]
 1508 0728 1A68     		ldr	r2, [r3, #0]
 1509 072a 3B68     		ldr	r3, [r7, #0]
 1510 072c 1A43     		orrs	r2, r2, r3
 1511 072e 7B68     		ldr	r3, [r7, #4]
 1512 0730 1A60     		str	r2, [r3, #0]
1036:../src/stm32f30x_usart.c **** }
 1513              		.loc 1 1036 0
 1514 0732 07F10C07 		add	r7, r7, #12
 1515 0736 BD46     		mov	sp, r7
 1516 0738 80BC     		pop	{r7}
 1517 073a 7047     		bx	lr
 1518              		.cfi_endproc
 1519              	.LFE135:
 1521              		.align	2
 1522              		.global	USART_AddressDetectionConfig
 1523              		.thumb
 1524              		.thumb_func
 1526              	USART_AddressDetectionConfig:
 1527              	.LFB136:
1037:../src/stm32f30x_usart.c **** 
1038:../src/stm32f30x_usart.c **** /**
1039:../src/stm32f30x_usart.c ****   * @brief  Configure the the USART Address detection length.
1040:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1041:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1042:../src/stm32f30x_usart.c ****   * @param  USART_AddressLength: specifies the USART address length detection.
1043:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1044:../src/stm32f30x_usart.c ****   *         @arg USART_AddressLength_4b: 4-bit address length detection 
1045:../src/stm32f30x_usart.c ****   *         @arg USART_AddressLength_7b: 7-bit address length detection 
1046:../src/stm32f30x_usart.c ****   * @retval None
1047:../src/stm32f30x_usart.c ****   */
1048:../src/stm32f30x_usart.c **** void USART_AddressDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_AddressLength)
1049:../src/stm32f30x_usart.c **** {
 1528              		.loc 1 1049 0
 1529              		.cfi_startproc
 1530              		@ args = 0, pretend = 0, frame = 8
 1531              		@ frame_needed = 1, uses_anonymous_args = 0
 1532              		@ link register save eliminated.
 1533 073c 80B4     		push	{r7}
 1534              	.LCFI75:
 1535              		.cfi_def_cfa_offset 4
 1536              		.cfi_offset 7, -4
 1537 073e 83B0     		sub	sp, sp, #12
 1538              	.LCFI76:
 1539              		.cfi_def_cfa_offset 16
 1540 0740 00AF     		add	r7, sp, #0
 1541              	.LCFI77:
 1542              		.cfi_def_cfa_register 7
 1543 0742 7860     		str	r0, [r7, #4]
 1544 0744 3960     		str	r1, [r7, #0]
1050:../src/stm32f30x_usart.c ****   /* Check the parameters */
1051:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1052:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ADDRESS_DETECTION(USART_AddressLength));
1053:../src/stm32f30x_usart.c **** 
1054:../src/stm32f30x_usart.c ****   USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADDM7);
 1545              		.loc 1 1054 0
 1546 0746 7B68     		ldr	r3, [r7, #4]
 1547 0748 5B68     		ldr	r3, [r3, #4]
 1548 074a 23F01002 		bic	r2, r3, #16
 1549 074e 7B68     		ldr	r3, [r7, #4]
 1550 0750 5A60     		str	r2, [r3, #4]
1055:../src/stm32f30x_usart.c ****   USARTx->CR2 |= USART_AddressLength;
 1551              		.loc 1 1055 0
 1552 0752 7B68     		ldr	r3, [r7, #4]
 1553 0754 5A68     		ldr	r2, [r3, #4]
 1554 0756 3B68     		ldr	r3, [r7, #0]
 1555 0758 1A43     		orrs	r2, r2, r3
 1556 075a 7B68     		ldr	r3, [r7, #4]
 1557 075c 5A60     		str	r2, [r3, #4]
1056:../src/stm32f30x_usart.c **** }
 1558              		.loc 1 1056 0
 1559 075e 07F10C07 		add	r7, r7, #12
 1560 0762 BD46     		mov	sp, r7
 1561 0764 80BC     		pop	{r7}
 1562 0766 7047     		bx	lr
 1563              		.cfi_endproc
 1564              	.LFE136:
 1566              		.align	2
 1567              		.global	USART_LINBreakDetectLengthConfig
 1568              		.thumb
 1569              		.thumb_func
 1571              	USART_LINBreakDetectLengthConfig:
 1572              	.LFB137:
1057:../src/stm32f30x_usart.c **** 
1058:../src/stm32f30x_usart.c **** /**
1059:../src/stm32f30x_usart.c ****   * @}
1060:../src/stm32f30x_usart.c ****   */
1061:../src/stm32f30x_usart.c **** 
1062:../src/stm32f30x_usart.c **** /** @defgroup USART_Group6 LIN mode functions
1063:../src/stm32f30x_usart.c ****  *  @brief   LIN mode functions 
1064:../src/stm32f30x_usart.c ****  *
1065:../src/stm32f30x_usart.c **** @verbatim   
1066:../src/stm32f30x_usart.c ****  ===============================================================================
1067:../src/stm32f30x_usart.c ****                        ##### LIN mode functions #####
1068:../src/stm32f30x_usart.c ****  ===============================================================================
1069:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART 
1070:../src/stm32f30x_usart.c ****          LIN Mode communication.
1071:../src/stm32f30x_usart.c ****     [..] In LIN mode, 8-bit data format with 1 stop bit is required in accordance 
1072:../src/stm32f30x_usart.c ****          with the LIN standard.
1073:../src/stm32f30x_usart.c ****     [..] Only this LIN Feature is supported by the USART IP:
1074:../src/stm32f30x_usart.c ****          (+) LIN Master Synchronous Break send capability and LIN slave break 
1075:../src/stm32f30x_usart.c ****              detection capability :  13-bit break generation and 10/11 bit break 
1076:../src/stm32f30x_usart.c ****              detection.
1077:../src/stm32f30x_usart.c ****     [..] USART LIN Master transmitter communication is possible through the 
1078:../src/stm32f30x_usart.c ****          following procedure:
1079:../src/stm32f30x_usart.c ****          (#) Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
1080:../src/stm32f30x_usart.c ****              Mode transmitter or Mode receiver and hardware flow control values 
1081:../src/stm32f30x_usart.c ****              using the USART_Init() function.
1082:../src/stm32f30x_usart.c ****          (#) Enable the LIN mode using the USART_LINCmd() function.
1083:../src/stm32f30x_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1084:../src/stm32f30x_usart.c ****          (#) Send the break character using USART_SendBreak() function.
1085:../src/stm32f30x_usart.c ****     [..] USART LIN Master receiver communication is possible through the 
1086:../src/stm32f30x_usart.c ****          following procedure:
1087:../src/stm32f30x_usart.c ****          (#) Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
1088:../src/stm32f30x_usart.c ****              Mode transmitter or Mode receiver and hardware flow control values 
1089:../src/stm32f30x_usart.c ****              using the USART_Init() function.
1090:../src/stm32f30x_usart.c ****          (#) Configures the break detection length 
1091:../src/stm32f30x_usart.c ****              using the USART_LINBreakDetectLengthConfig() function.
1092:../src/stm32f30x_usart.c ****          (#) Enable the LIN mode using the USART_LINCmd() function.
1093:../src/stm32f30x_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1094:../src/stm32f30x_usart.c ****          [..]
1095:../src/stm32f30x_usart.c ****          (@) In LIN mode, the following bits must be kept cleared:
1096:../src/stm32f30x_usart.c ****              (+@) CLKEN in the USART_CR2 register.
1097:../src/stm32f30x_usart.c ****              (+@) STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
1098:../src/stm32f30x_usart.c **** 
1099:../src/stm32f30x_usart.c **** @endverbatim
1100:../src/stm32f30x_usart.c ****   * @{
1101:../src/stm32f30x_usart.c ****   */
1102:../src/stm32f30x_usart.c **** 
1103:../src/stm32f30x_usart.c **** /**
1104:../src/stm32f30x_usart.c ****   * @brief  Sets the USART LIN Break detection length.
1105:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1106:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1107:../src/stm32f30x_usart.c ****   * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
1108:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1109:../src/stm32f30x_usart.c ****   *         @arg USART_LINBreakDetectLength_10b: 10-bit break detection
1110:../src/stm32f30x_usart.c ****   *         @arg USART_LINBreakDetectLength_11b: 11-bit break detection
1111:../src/stm32f30x_usart.c ****   * @retval None
1112:../src/stm32f30x_usart.c ****   */
1113:../src/stm32f30x_usart.c **** void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint32_t USART_LINBreakDetectLength)
1114:../src/stm32f30x_usart.c **** {
 1573              		.loc 1 1114 0
 1574              		.cfi_startproc
 1575              		@ args = 0, pretend = 0, frame = 8
 1576              		@ frame_needed = 1, uses_anonymous_args = 0
 1577              		@ link register save eliminated.
 1578 0768 80B4     		push	{r7}
 1579              	.LCFI78:
 1580              		.cfi_def_cfa_offset 4
 1581              		.cfi_offset 7, -4
 1582 076a 83B0     		sub	sp, sp, #12
 1583              	.LCFI79:
 1584              		.cfi_def_cfa_offset 16
 1585 076c 00AF     		add	r7, sp, #0
 1586              	.LCFI80:
 1587              		.cfi_def_cfa_register 7
 1588 076e 7860     		str	r0, [r7, #4]
 1589 0770 3960     		str	r1, [r7, #0]
1115:../src/stm32f30x_usart.c ****   /* Check the parameters */
1116:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1117:../src/stm32f30x_usart.c ****   assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
1118:../src/stm32f30x_usart.c **** 
1119:../src/stm32f30x_usart.c ****   USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LBDL);
 1590              		.loc 1 1119 0
 1591 0772 7B68     		ldr	r3, [r7, #4]
 1592 0774 5B68     		ldr	r3, [r3, #4]
 1593 0776 23F02002 		bic	r2, r3, #32
 1594 077a 7B68     		ldr	r3, [r7, #4]
 1595 077c 5A60     		str	r2, [r3, #4]
1120:../src/stm32f30x_usart.c ****   USARTx->CR2 |= USART_LINBreakDetectLength;  
 1596              		.loc 1 1120 0
 1597 077e 7B68     		ldr	r3, [r7, #4]
 1598 0780 5A68     		ldr	r2, [r3, #4]
 1599 0782 3B68     		ldr	r3, [r7, #0]
 1600 0784 1A43     		orrs	r2, r2, r3
 1601 0786 7B68     		ldr	r3, [r7, #4]
 1602 0788 5A60     		str	r2, [r3, #4]
1121:../src/stm32f30x_usart.c **** }
 1603              		.loc 1 1121 0
 1604 078a 07F10C07 		add	r7, r7, #12
 1605 078e BD46     		mov	sp, r7
 1606 0790 80BC     		pop	{r7}
 1607 0792 7047     		bx	lr
 1608              		.cfi_endproc
 1609              	.LFE137:
 1611              		.align	2
 1612              		.global	USART_LINCmd
 1613              		.thumb
 1614              		.thumb_func
 1616              	USART_LINCmd:
 1617              	.LFB138:
1122:../src/stm32f30x_usart.c **** 
1123:../src/stm32f30x_usart.c **** /**
1124:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's LIN mode.
1125:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1126:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1127:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USART LIN mode.
1128:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
1129:../src/stm32f30x_usart.c ****   * @retval None
1130:../src/stm32f30x_usart.c ****   */
1131:../src/stm32f30x_usart.c **** void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1132:../src/stm32f30x_usart.c **** {
 1618              		.loc 1 1132 0
 1619              		.cfi_startproc
 1620              		@ args = 0, pretend = 0, frame = 8
 1621              		@ frame_needed = 1, uses_anonymous_args = 0
 1622              		@ link register save eliminated.
 1623 0794 80B4     		push	{r7}
 1624              	.LCFI81:
 1625              		.cfi_def_cfa_offset 4
 1626              		.cfi_offset 7, -4
 1627 0796 83B0     		sub	sp, sp, #12
 1628              	.LCFI82:
 1629              		.cfi_def_cfa_offset 16
 1630 0798 00AF     		add	r7, sp, #0
 1631              	.LCFI83:
 1632              		.cfi_def_cfa_register 7
 1633 079a 7860     		str	r0, [r7, #4]
 1634 079c 0B46     		mov	r3, r1
 1635 079e FB70     		strb	r3, [r7, #3]
1133:../src/stm32f30x_usart.c ****   /* Check the parameters */
1134:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1135:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1136:../src/stm32f30x_usart.c **** 
1137:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 1636              		.loc 1 1137 0
 1637 07a0 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1638 07a2 002B     		cmp	r3, #0
 1639 07a4 06D0     		beq	.L68
1138:../src/stm32f30x_usart.c ****   {
1139:../src/stm32f30x_usart.c ****     /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
1140:../src/stm32f30x_usart.c ****     USARTx->CR2 |= USART_CR2_LINEN;
 1640              		.loc 1 1140 0
 1641 07a6 7B68     		ldr	r3, [r7, #4]
 1642 07a8 5B68     		ldr	r3, [r3, #4]
 1643 07aa 43F48042 		orr	r2, r3, #16384
 1644 07ae 7B68     		ldr	r3, [r7, #4]
 1645 07b0 5A60     		str	r2, [r3, #4]
 1646 07b2 05E0     		b	.L67
 1647              	.L68:
1141:../src/stm32f30x_usart.c ****   }
1142:../src/stm32f30x_usart.c ****   else
1143:../src/stm32f30x_usart.c ****   {
1144:../src/stm32f30x_usart.c ****     /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
1145:../src/stm32f30x_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LINEN);
 1648              		.loc 1 1145 0
 1649 07b4 7B68     		ldr	r3, [r7, #4]
 1650 07b6 5B68     		ldr	r3, [r3, #4]
 1651 07b8 23F48042 		bic	r2, r3, #16384
 1652 07bc 7B68     		ldr	r3, [r7, #4]
 1653 07be 5A60     		str	r2, [r3, #4]
 1654              	.L67:
1146:../src/stm32f30x_usart.c ****   }
1147:../src/stm32f30x_usart.c **** }
 1655              		.loc 1 1147 0
 1656 07c0 07F10C07 		add	r7, r7, #12
 1657 07c4 BD46     		mov	sp, r7
 1658 07c6 80BC     		pop	{r7}
 1659 07c8 7047     		bx	lr
 1660              		.cfi_endproc
 1661              	.LFE138:
 1663 07ca 00BF     		.align	2
 1664              		.global	USART_HalfDuplexCmd
 1665              		.thumb
 1666              		.thumb_func
 1668              	USART_HalfDuplexCmd:
 1669              	.LFB139:
1148:../src/stm32f30x_usart.c **** 
1149:../src/stm32f30x_usart.c **** /**
1150:../src/stm32f30x_usart.c ****   * @}
1151:../src/stm32f30x_usart.c ****   */
1152:../src/stm32f30x_usart.c **** 
1153:../src/stm32f30x_usart.c **** /** @defgroup USART_Group7 Halfduplex mode function
1154:../src/stm32f30x_usart.c ****  *  @brief   Half-duplex mode function 
1155:../src/stm32f30x_usart.c ****  *
1156:../src/stm32f30x_usart.c **** @verbatim   
1157:../src/stm32f30x_usart.c ****  ===============================================================================
1158:../src/stm32f30x_usart.c ****                    ##### Half-duplex mode function #####
1159:../src/stm32f30x_usart.c ****  ===============================================================================
1160:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
1161:../src/stm32f30x_usart.c ****          Half-duplex communication.
1162:../src/stm32f30x_usart.c ****     [..] The USART can be configured to follow a single-wire half-duplex protocol 
1163:../src/stm32f30x_usart.c ****          where the TX and RX lines are internally connected.
1164:../src/stm32f30x_usart.c ****     [..] USART Half duplex communication is possible through the following procedure:
1165:../src/stm32f30x_usart.c ****          (#) Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
1166:../src/stm32f30x_usart.c ****              or Mode receiver and hardware flow control values using the USART_Init()
1167:../src/stm32f30x_usart.c ****             function.
1168:../src/stm32f30x_usart.c ****          (#) Configures the USART address using the USART_SetAddress() function.
1169:../src/stm32f30x_usart.c ****          (#) Enable the half duplex mode using USART_HalfDuplexCmd() function.
1170:../src/stm32f30x_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1171:../src/stm32f30x_usart.c ****          [..]
1172:../src/stm32f30x_usart.c ****          (@) The RX pin is no longer used.
1173:../src/stm32f30x_usart.c ****          (@) In Half-duplex mode the following bits must be kept cleared:
1174:../src/stm32f30x_usart.c ****              (+@) LINEN and CLKEN bits in the USART_CR2 register.
1175:../src/stm32f30x_usart.c ****              (+@) SCEN and IREN bits in the USART_CR3 register.
1176:../src/stm32f30x_usart.c **** 
1177:../src/stm32f30x_usart.c **** @endverbatim
1178:../src/stm32f30x_usart.c ****   * @{
1179:../src/stm32f30x_usart.c ****   */
1180:../src/stm32f30x_usart.c **** 
1181:../src/stm32f30x_usart.c **** /**
1182:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's Half Duplex communication.
1183:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1184:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1185:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USART Communication.
1186:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
1187:../src/stm32f30x_usart.c ****   * @retval None
1188:../src/stm32f30x_usart.c ****   */
1189:../src/stm32f30x_usart.c **** void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1190:../src/stm32f30x_usart.c **** {
 1670              		.loc 1 1190 0
 1671              		.cfi_startproc
 1672              		@ args = 0, pretend = 0, frame = 8
 1673              		@ frame_needed = 1, uses_anonymous_args = 0
 1674              		@ link register save eliminated.
 1675 07cc 80B4     		push	{r7}
 1676              	.LCFI84:
 1677              		.cfi_def_cfa_offset 4
 1678              		.cfi_offset 7, -4
 1679 07ce 83B0     		sub	sp, sp, #12
 1680              	.LCFI85:
 1681              		.cfi_def_cfa_offset 16
 1682 07d0 00AF     		add	r7, sp, #0
 1683              	.LCFI86:
 1684              		.cfi_def_cfa_register 7
 1685 07d2 7860     		str	r0, [r7, #4]
 1686 07d4 0B46     		mov	r3, r1
 1687 07d6 FB70     		strb	r3, [r7, #3]
1191:../src/stm32f30x_usart.c ****   /* Check the parameters */
1192:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1193:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1194:../src/stm32f30x_usart.c ****   
1195:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 1688              		.loc 1 1195 0
 1689 07d8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1690 07da 002B     		cmp	r3, #0
 1691 07dc 06D0     		beq	.L71
1196:../src/stm32f30x_usart.c ****   {
1197:../src/stm32f30x_usart.c ****     /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
1198:../src/stm32f30x_usart.c ****     USARTx->CR3 |= USART_CR3_HDSEL;
 1692              		.loc 1 1198 0
 1693 07de 7B68     		ldr	r3, [r7, #4]
 1694 07e0 9B68     		ldr	r3, [r3, #8]
 1695 07e2 43F00802 		orr	r2, r3, #8
 1696 07e6 7B68     		ldr	r3, [r7, #4]
 1697 07e8 9A60     		str	r2, [r3, #8]
 1698 07ea 05E0     		b	.L70
 1699              	.L71:
1199:../src/stm32f30x_usart.c ****   }
1200:../src/stm32f30x_usart.c ****   else
1201:../src/stm32f30x_usart.c ****   {
1202:../src/stm32f30x_usart.c ****     /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
1203:../src/stm32f30x_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_HDSEL);
 1700              		.loc 1 1203 0
 1701 07ec 7B68     		ldr	r3, [r7, #4]
 1702 07ee 9B68     		ldr	r3, [r3, #8]
 1703 07f0 23F00802 		bic	r2, r3, #8
 1704 07f4 7B68     		ldr	r3, [r7, #4]
 1705 07f6 9A60     		str	r2, [r3, #8]
 1706              	.L70:
1204:../src/stm32f30x_usart.c ****   }
1205:../src/stm32f30x_usart.c **** }
 1707              		.loc 1 1205 0
 1708 07f8 07F10C07 		add	r7, r7, #12
 1709 07fc BD46     		mov	sp, r7
 1710 07fe 80BC     		pop	{r7}
 1711 0800 7047     		bx	lr
 1712              		.cfi_endproc
 1713              	.LFE139:
 1715 0802 00BF     		.align	2
 1716              		.global	USART_SetGuardTime
 1717              		.thumb
 1718              		.thumb_func
 1720              	USART_SetGuardTime:
 1721              	.LFB140:
1206:../src/stm32f30x_usart.c **** 
1207:../src/stm32f30x_usart.c **** /**
1208:../src/stm32f30x_usart.c ****   * @}
1209:../src/stm32f30x_usart.c ****   */
1210:../src/stm32f30x_usart.c **** 
1211:../src/stm32f30x_usart.c **** 
1212:../src/stm32f30x_usart.c **** /** @defgroup USART_Group8 Smartcard mode functions
1213:../src/stm32f30x_usart.c ****  *  @brief   Smartcard mode functions 
1214:../src/stm32f30x_usart.c ****  *
1215:../src/stm32f30x_usart.c **** @verbatim   
1216:../src/stm32f30x_usart.c ****  ===============================================================================
1217:../src/stm32f30x_usart.c ****                      ##### Smartcard mode functions #####
1218:../src/stm32f30x_usart.c ****  ===============================================================================
1219:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
1220:../src/stm32f30x_usart.c ****          Smartcard communication.
1221:../src/stm32f30x_usart.c ****     [..] The Smartcard interface is designed to support asynchronous protocol 
1222:../src/stm32f30x_usart.c ****          Smartcards as defined in the ISO 7816-3 standard. The USART can provide 
1223:../src/stm32f30x_usart.c ****          a clock to the smartcard through the SCLK output. In smartcard mode, 
1224:../src/stm32f30x_usart.c ****          SCLK is not associated to the communication but is simply derived from 
1225:../src/stm32f30x_usart.c ****          the internal peripheral input clock through a 5-bit prescaler.
1226:../src/stm32f30x_usart.c ****     [..] Smartcard communication is possible through the following procedure:
1227:../src/stm32f30x_usart.c ****          (#) Configures the Smartcard Prsecaler using the USART_SetPrescaler() 
1228:../src/stm32f30x_usart.c ****              function.
1229:../src/stm32f30x_usart.c ****          (#) Configures the Smartcard Guard Time using the USART_SetGuardTime() 
1230:../src/stm32f30x_usart.c ****              function.
1231:../src/stm32f30x_usart.c ****          (#) Program the USART clock using the USART_ClockInit() function as following:
1232:../src/stm32f30x_usart.c ****              (++) USART Clock enabled.
1233:../src/stm32f30x_usart.c ****              (++) USART CPOL Low.
1234:../src/stm32f30x_usart.c ****              (++) USART CPHA on first edge.
1235:../src/stm32f30x_usart.c ****              (++) USART Last Bit Clock Enabled.
1236:../src/stm32f30x_usart.c ****          (#) Program the Smartcard interface using the USART_Init() function as 
1237:../src/stm32f30x_usart.c ****              following:
1238:../src/stm32f30x_usart.c ****              (++) Word Length = 9 Bits.
1239:../src/stm32f30x_usart.c ****              (++) 1.5 Stop Bit.
1240:../src/stm32f30x_usart.c ****              (++) Even parity.
1241:../src/stm32f30x_usart.c ****              (++) BaudRate = 12096 baud.
1242:../src/stm32f30x_usart.c ****              (++) Hardware flow control disabled (RTS and CTS signals).
1243:../src/stm32f30x_usart.c ****              (++) Tx and Rx enabled
1244:../src/stm32f30x_usart.c ****          (#) Optionally you can enable the parity error interrupt using 
1245:../src/stm32f30x_usart.c ****              the USART_ITConfig() function.
1246:../src/stm32f30x_usart.c ****          (#) Enable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
1247:../src/stm32f30x_usart.c ****          (#) Enable the Smartcard interface using the USART_SmartCardCmd() function.
1248:../src/stm32f30x_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1249:../src/stm32f30x_usart.c ****     [..] 
1250:../src/stm32f30x_usart.c ****   Please refer to the ISO 7816-3 specification for more details.
1251:../src/stm32f30x_usart.c ****     [..] 
1252:../src/stm32f30x_usart.c ****          (@) It is also possible to choose 0.5 stop bit for receiving but it is 
1253:../src/stm32f30x_usart.c ****              recommended to use 1.5 stop bits for both transmitting and receiving 
1254:../src/stm32f30x_usart.c ****              to avoid switching between the two configurations.
1255:../src/stm32f30x_usart.c ****          (@) In smartcard mode, the following bits must be kept cleared:
1256:../src/stm32f30x_usart.c ****              (+@) LINEN bit in the USART_CR2 register.
1257:../src/stm32f30x_usart.c ****              (+@) HDSEL and IREN bits in the USART_CR3 register.
1258:../src/stm32f30x_usart.c **** 
1259:../src/stm32f30x_usart.c **** @endverbatim
1260:../src/stm32f30x_usart.c ****   * @{
1261:../src/stm32f30x_usart.c ****   */
1262:../src/stm32f30x_usart.c **** 
1263:../src/stm32f30x_usart.c **** /**
1264:../src/stm32f30x_usart.c ****   * @brief  Sets the specified USART guard time.
1265:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1266:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3.
1267:../src/stm32f30x_usart.c ****   * @param  USART_GuardTime: specifies the guard time.
1268:../src/stm32f30x_usart.c ****   * @retval None
1269:../src/stm32f30x_usart.c ****   */
1270:../src/stm32f30x_usart.c **** void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
1271:../src/stm32f30x_usart.c **** {    
 1722              		.loc 1 1271 0
 1723              		.cfi_startproc
 1724              		@ args = 0, pretend = 0, frame = 8
 1725              		@ frame_needed = 1, uses_anonymous_args = 0
 1726              		@ link register save eliminated.
 1727 0804 80B4     		push	{r7}
 1728              	.LCFI87:
 1729              		.cfi_def_cfa_offset 4
 1730              		.cfi_offset 7, -4
 1731 0806 83B0     		sub	sp, sp, #12
 1732              	.LCFI88:
 1733              		.cfi_def_cfa_offset 16
 1734 0808 00AF     		add	r7, sp, #0
 1735              	.LCFI89:
 1736              		.cfi_def_cfa_register 7
 1737 080a 7860     		str	r0, [r7, #4]
 1738 080c 0B46     		mov	r3, r1
 1739 080e FB70     		strb	r3, [r7, #3]
1272:../src/stm32f30x_usart.c ****   /* Check the parameters */
1273:../src/stm32f30x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1274:../src/stm32f30x_usart.c **** 
1275:../src/stm32f30x_usart.c ****   /* Clear the USART Guard time */
1276:../src/stm32f30x_usart.c ****   USARTx->GTPR &= USART_GTPR_PSC;
 1740              		.loc 1 1276 0
 1741 0810 7B68     		ldr	r3, [r7, #4]
 1742 0812 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1743 0814 9BB2     		uxth	r3, r3
 1744 0816 DBB2     		uxtb	r3, r3
 1745 0818 9AB2     		uxth	r2, r3
 1746 081a 7B68     		ldr	r3, [r7, #4]
 1747 081c 1A82     		strh	r2, [r3, #16]	@ movhi
1277:../src/stm32f30x_usart.c ****   /* Set the USART guard time */
1278:../src/stm32f30x_usart.c ****   USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 1748              		.loc 1 1278 0
 1749 081e 7B68     		ldr	r3, [r7, #4]
 1750 0820 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1751 0822 9AB2     		uxth	r2, r3
 1752 0824 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1753 0826 9BB2     		uxth	r3, r3
 1754 0828 4FEA0323 		lsl	r3, r3, #8
 1755 082c 9BB2     		uxth	r3, r3
 1756 082e 1343     		orrs	r3, r3, r2
 1757 0830 9AB2     		uxth	r2, r3
 1758 0832 7B68     		ldr	r3, [r7, #4]
 1759 0834 1A82     		strh	r2, [r3, #16]	@ movhi
1279:../src/stm32f30x_usart.c **** }
 1760              		.loc 1 1279 0
 1761 0836 07F10C07 		add	r7, r7, #12
 1762 083a BD46     		mov	sp, r7
 1763 083c 80BC     		pop	{r7}
 1764 083e 7047     		bx	lr
 1765              		.cfi_endproc
 1766              	.LFE140:
 1768              		.align	2
 1769              		.global	USART_SmartCardCmd
 1770              		.thumb
 1771              		.thumb_func
 1773              	USART_SmartCardCmd:
 1774              	.LFB141:
1280:../src/stm32f30x_usart.c **** 
1281:../src/stm32f30x_usart.c **** /**
1282:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's Smart Card mode.
1283:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1284:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3.
1285:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the Smart Card mode.
1286:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.      
1287:../src/stm32f30x_usart.c ****   * @retval None
1288:../src/stm32f30x_usart.c ****   */
1289:../src/stm32f30x_usart.c **** void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1290:../src/stm32f30x_usart.c **** {
 1775              		.loc 1 1290 0
 1776              		.cfi_startproc
 1777              		@ args = 0, pretend = 0, frame = 8
 1778              		@ frame_needed = 1, uses_anonymous_args = 0
 1779              		@ link register save eliminated.
 1780 0840 80B4     		push	{r7}
 1781              	.LCFI90:
 1782              		.cfi_def_cfa_offset 4
 1783              		.cfi_offset 7, -4
 1784 0842 83B0     		sub	sp, sp, #12
 1785              	.LCFI91:
 1786              		.cfi_def_cfa_offset 16
 1787 0844 00AF     		add	r7, sp, #0
 1788              	.LCFI92:
 1789              		.cfi_def_cfa_register 7
 1790 0846 7860     		str	r0, [r7, #4]
 1791 0848 0B46     		mov	r3, r1
 1792 084a FB70     		strb	r3, [r7, #3]
1291:../src/stm32f30x_usart.c ****   /* Check the parameters */
1292:../src/stm32f30x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1293:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1294:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 1793              		.loc 1 1294 0
 1794 084c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1795 084e 002B     		cmp	r3, #0
 1796 0850 06D0     		beq	.L75
1295:../src/stm32f30x_usart.c ****   {
1296:../src/stm32f30x_usart.c ****     /* Enable the SC mode by setting the SCEN bit in the CR3 register */
1297:../src/stm32f30x_usart.c ****     USARTx->CR3 |= USART_CR3_SCEN;
 1797              		.loc 1 1297 0
 1798 0852 7B68     		ldr	r3, [r7, #4]
 1799 0854 9B68     		ldr	r3, [r3, #8]
 1800 0856 43F02002 		orr	r2, r3, #32
 1801 085a 7B68     		ldr	r3, [r7, #4]
 1802 085c 9A60     		str	r2, [r3, #8]
 1803 085e 05E0     		b	.L74
 1804              	.L75:
1298:../src/stm32f30x_usart.c ****   }
1299:../src/stm32f30x_usart.c ****   else
1300:../src/stm32f30x_usart.c ****   {
1301:../src/stm32f30x_usart.c ****     /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
1302:../src/stm32f30x_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCEN);
 1805              		.loc 1 1302 0
 1806 0860 7B68     		ldr	r3, [r7, #4]
 1807 0862 9B68     		ldr	r3, [r3, #8]
 1808 0864 23F02002 		bic	r2, r3, #32
 1809 0868 7B68     		ldr	r3, [r7, #4]
 1810 086a 9A60     		str	r2, [r3, #8]
 1811              	.L74:
1303:../src/stm32f30x_usart.c ****   }
1304:../src/stm32f30x_usart.c **** }
 1812              		.loc 1 1304 0
 1813 086c 07F10C07 		add	r7, r7, #12
 1814 0870 BD46     		mov	sp, r7
 1815 0872 80BC     		pop	{r7}
 1816 0874 7047     		bx	lr
 1817              		.cfi_endproc
 1818              	.LFE141:
 1820 0876 00BF     		.align	2
 1821              		.global	USART_SmartCardNACKCmd
 1822              		.thumb
 1823              		.thumb_func
 1825              	USART_SmartCardNACKCmd:
 1826              	.LFB142:
1305:../src/stm32f30x_usart.c **** 
1306:../src/stm32f30x_usart.c **** /**
1307:../src/stm32f30x_usart.c ****   * @brief  Enables or disables NACK transmission.
1308:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1309:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3.
1310:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the NACK transmission.
1311:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.  
1312:../src/stm32f30x_usart.c ****   * @retval None
1313:../src/stm32f30x_usart.c ****   */
1314:../src/stm32f30x_usart.c **** void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1315:../src/stm32f30x_usart.c **** {
 1827              		.loc 1 1315 0
 1828              		.cfi_startproc
 1829              		@ args = 0, pretend = 0, frame = 8
 1830              		@ frame_needed = 1, uses_anonymous_args = 0
 1831              		@ link register save eliminated.
 1832 0878 80B4     		push	{r7}
 1833              	.LCFI93:
 1834              		.cfi_def_cfa_offset 4
 1835              		.cfi_offset 7, -4
 1836 087a 83B0     		sub	sp, sp, #12
 1837              	.LCFI94:
 1838              		.cfi_def_cfa_offset 16
 1839 087c 00AF     		add	r7, sp, #0
 1840              	.LCFI95:
 1841              		.cfi_def_cfa_register 7
 1842 087e 7860     		str	r0, [r7, #4]
 1843 0880 0B46     		mov	r3, r1
 1844 0882 FB70     		strb	r3, [r7, #3]
1316:../src/stm32f30x_usart.c ****   /* Check the parameters */
1317:../src/stm32f30x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx)); 
1318:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1319:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 1845              		.loc 1 1319 0
 1846 0884 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1847 0886 002B     		cmp	r3, #0
 1848 0888 06D0     		beq	.L78
1320:../src/stm32f30x_usart.c ****   {
1321:../src/stm32f30x_usart.c ****     /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
1322:../src/stm32f30x_usart.c ****     USARTx->CR3 |= USART_CR3_NACK;
 1849              		.loc 1 1322 0
 1850 088a 7B68     		ldr	r3, [r7, #4]
 1851 088c 9B68     		ldr	r3, [r3, #8]
 1852 088e 43F01002 		orr	r2, r3, #16
 1853 0892 7B68     		ldr	r3, [r7, #4]
 1854 0894 9A60     		str	r2, [r3, #8]
 1855 0896 05E0     		b	.L77
 1856              	.L78:
1323:../src/stm32f30x_usart.c ****   }
1324:../src/stm32f30x_usart.c ****   else
1325:../src/stm32f30x_usart.c ****   {
1326:../src/stm32f30x_usart.c ****     /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
1327:../src/stm32f30x_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_NACK);
 1857              		.loc 1 1327 0
 1858 0898 7B68     		ldr	r3, [r7, #4]
 1859 089a 9B68     		ldr	r3, [r3, #8]
 1860 089c 23F01002 		bic	r2, r3, #16
 1861 08a0 7B68     		ldr	r3, [r7, #4]
 1862 08a2 9A60     		str	r2, [r3, #8]
 1863              	.L77:
1328:../src/stm32f30x_usart.c ****   }
1329:../src/stm32f30x_usart.c **** }
 1864              		.loc 1 1329 0
 1865 08a4 07F10C07 		add	r7, r7, #12
 1866 08a8 BD46     		mov	sp, r7
 1867 08aa 80BC     		pop	{r7}
 1868 08ac 7047     		bx	lr
 1869              		.cfi_endproc
 1870              	.LFE142:
 1872 08ae 00BF     		.align	2
 1873              		.global	USART_SetAutoRetryCount
 1874              		.thumb
 1875              		.thumb_func
 1877              	USART_SetAutoRetryCount:
 1878              	.LFB143:
1330:../src/stm32f30x_usart.c **** 
1331:../src/stm32f30x_usart.c **** /**
1332:../src/stm32f30x_usart.c ****   * @brief  Sets the Smart Card number of retries in transmit and receive.
1333:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1334:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3.
1335:../src/stm32f30x_usart.c ****   * @param  USART_AutoCount: specifies the Smart Card auto retry count.
1336:../src/stm32f30x_usart.c ****   * @retval None
1337:../src/stm32f30x_usart.c ****   */
1338:../src/stm32f30x_usart.c **** void USART_SetAutoRetryCount(USART_TypeDef* USARTx, uint8_t USART_AutoCount)
1339:../src/stm32f30x_usart.c **** {    
 1879              		.loc 1 1339 0
 1880              		.cfi_startproc
 1881              		@ args = 0, pretend = 0, frame = 8
 1882              		@ frame_needed = 1, uses_anonymous_args = 0
 1883              		@ link register save eliminated.
 1884 08b0 80B4     		push	{r7}
 1885              	.LCFI96:
 1886              		.cfi_def_cfa_offset 4
 1887              		.cfi_offset 7, -4
 1888 08b2 83B0     		sub	sp, sp, #12
 1889              	.LCFI97:
 1890              		.cfi_def_cfa_offset 16
 1891 08b4 00AF     		add	r7, sp, #0
 1892              	.LCFI98:
 1893              		.cfi_def_cfa_register 7
 1894 08b6 7860     		str	r0, [r7, #4]
 1895 08b8 0B46     		mov	r3, r1
 1896 08ba FB70     		strb	r3, [r7, #3]
1340:../src/stm32f30x_usart.c ****   /* Check the parameters */
1341:../src/stm32f30x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1342:../src/stm32f30x_usart.c ****   assert_param(IS_USART_AUTO_RETRY_COUNTER(USART_AutoCount));
1343:../src/stm32f30x_usart.c ****   /* Clear the USART auto retry count */
1344:../src/stm32f30x_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCARCNT);
 1897              		.loc 1 1344 0
 1898 08bc 7B68     		ldr	r3, [r7, #4]
 1899 08be 9B68     		ldr	r3, [r3, #8]
 1900 08c0 23F46022 		bic	r2, r3, #917504
 1901 08c4 7B68     		ldr	r3, [r7, #4]
 1902 08c6 9A60     		str	r2, [r3, #8]
1345:../src/stm32f30x_usart.c ****   /* Set the USART auto retry count*/
1346:../src/stm32f30x_usart.c ****   USARTx->CR3 |= (uint32_t)((uint32_t)USART_AutoCount << 0x11);
 1903              		.loc 1 1346 0
 1904 08c8 7B68     		ldr	r3, [r7, #4]
 1905 08ca 9A68     		ldr	r2, [r3, #8]
 1906 08cc FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1907 08ce 4FEA4343 		lsl	r3, r3, #17
 1908 08d2 1A43     		orrs	r2, r2, r3
 1909 08d4 7B68     		ldr	r3, [r7, #4]
 1910 08d6 9A60     		str	r2, [r3, #8]
1347:../src/stm32f30x_usart.c **** }
 1911              		.loc 1 1347 0
 1912 08d8 07F10C07 		add	r7, r7, #12
 1913 08dc BD46     		mov	sp, r7
 1914 08de 80BC     		pop	{r7}
 1915 08e0 7047     		bx	lr
 1916              		.cfi_endproc
 1917              	.LFE143:
 1919 08e2 00BF     		.align	2
 1920              		.global	USART_SetBlockLength
 1921              		.thumb
 1922              		.thumb_func
 1924              	USART_SetBlockLength:
 1925              	.LFB144:
1348:../src/stm32f30x_usart.c **** 
1349:../src/stm32f30x_usart.c **** /**
1350:../src/stm32f30x_usart.c ****   * @brief  Sets the Smart Card Block length.
1351:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1352:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3.
1353:../src/stm32f30x_usart.c ****   * @param  USART_BlockLength: specifies the Smart Card block length.
1354:../src/stm32f30x_usart.c ****   * @retval None
1355:../src/stm32f30x_usart.c ****   */
1356:../src/stm32f30x_usart.c **** void USART_SetBlockLength(USART_TypeDef* USARTx, uint8_t USART_BlockLength)
1357:../src/stm32f30x_usart.c **** {    
 1926              		.loc 1 1357 0
 1927              		.cfi_startproc
 1928              		@ args = 0, pretend = 0, frame = 8
 1929              		@ frame_needed = 1, uses_anonymous_args = 0
 1930              		@ link register save eliminated.
 1931 08e4 80B4     		push	{r7}
 1932              	.LCFI99:
 1933              		.cfi_def_cfa_offset 4
 1934              		.cfi_offset 7, -4
 1935 08e6 83B0     		sub	sp, sp, #12
 1936              	.LCFI100:
 1937              		.cfi_def_cfa_offset 16
 1938 08e8 00AF     		add	r7, sp, #0
 1939              	.LCFI101:
 1940              		.cfi_def_cfa_register 7
 1941 08ea 7860     		str	r0, [r7, #4]
 1942 08ec 0B46     		mov	r3, r1
 1943 08ee FB70     		strb	r3, [r7, #3]
1358:../src/stm32f30x_usart.c ****   /* Check the parameters */
1359:../src/stm32f30x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1360:../src/stm32f30x_usart.c **** 
1361:../src/stm32f30x_usart.c ****   /* Clear the Smart card block length */
1362:../src/stm32f30x_usart.c ****   USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_BLEN);
 1944              		.loc 1 1362 0
 1945 08f0 7B68     		ldr	r3, [r7, #4]
 1946 08f2 5B69     		ldr	r3, [r3, #20]
 1947 08f4 23F07F42 		bic	r2, r3, #-16777216
 1948 08f8 7B68     		ldr	r3, [r7, #4]
 1949 08fa 5A61     		str	r2, [r3, #20]
1363:../src/stm32f30x_usart.c ****   /* Set the Smart Card block length */
1364:../src/stm32f30x_usart.c ****   USARTx->RTOR |= (uint32_t)((uint32_t)USART_BlockLength << 0x18);
 1950              		.loc 1 1364 0
 1951 08fc 7B68     		ldr	r3, [r7, #4]
 1952 08fe 5A69     		ldr	r2, [r3, #20]
 1953 0900 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1954 0902 4FEA0363 		lsl	r3, r3, #24
 1955 0906 1A43     		orrs	r2, r2, r3
 1956 0908 7B68     		ldr	r3, [r7, #4]
 1957 090a 5A61     		str	r2, [r3, #20]
1365:../src/stm32f30x_usart.c **** }
 1958              		.loc 1 1365 0
 1959 090c 07F10C07 		add	r7, r7, #12
 1960 0910 BD46     		mov	sp, r7
 1961 0912 80BC     		pop	{r7}
 1962 0914 7047     		bx	lr
 1963              		.cfi_endproc
 1964              	.LFE144:
 1966 0916 00BF     		.align	2
 1967              		.global	USART_IrDAConfig
 1968              		.thumb
 1969              		.thumb_func
 1971              	USART_IrDAConfig:
 1972              	.LFB145:
1366:../src/stm32f30x_usart.c **** 
1367:../src/stm32f30x_usart.c **** /**
1368:../src/stm32f30x_usart.c ****   * @}
1369:../src/stm32f30x_usart.c ****   */
1370:../src/stm32f30x_usart.c **** 
1371:../src/stm32f30x_usart.c **** /** @defgroup USART_Group9 IrDA mode functions
1372:../src/stm32f30x_usart.c ****  *  @brief   IrDA mode functions 
1373:../src/stm32f30x_usart.c ****  *
1374:../src/stm32f30x_usart.c **** @verbatim   
1375:../src/stm32f30x_usart.c ****  ===============================================================================
1376:../src/stm32f30x_usart.c ****                         ##### IrDA mode functions #####
1377:../src/stm32f30x_usart.c ****  ===============================================================================
1378:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
1379:../src/stm32f30x_usart.c ****          IrDA communication.
1380:../src/stm32f30x_usart.c ****     [..] IrDA is a half duplex communication protocol. If the Transmitter is busy, 
1381:../src/stm32f30x_usart.c ****          any data on the IrDA receive line will be ignored by the IrDA decoder 
1382:../src/stm32f30x_usart.c ****          and if the Receiver is busy, data on the TX from the USART to IrDA will 
1383:../src/stm32f30x_usart.c ****          not be encoded by IrDA. While receiving data, transmission should be 
1384:../src/stm32f30x_usart.c ****          avoided as the data to be transmitted could be corrupted.
1385:../src/stm32f30x_usart.c ****     [..] IrDA communication is possible through the following procedure:
1386:../src/stm32f30x_usart.c ****          (#) Program the Baud rate, Word length = 8 bits, Stop bits, Parity, 
1387:../src/stm32f30x_usart.c ****              Transmitter/Receiver modes and hardware flow control values using 
1388:../src/stm32f30x_usart.c ****              the USART_Init() function.
1389:../src/stm32f30x_usart.c ****          (#) Configures the IrDA pulse width by configuring the prescaler using  
1390:../src/stm32f30x_usart.c ****              the USART_SetPrescaler() function.
1391:../src/stm32f30x_usart.c ****          (#) Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal 
1392:../src/stm32f30x_usart.c ****              mode using the USART_IrDAConfig() function.
1393:../src/stm32f30x_usart.c ****          (#) Enable the IrDA using the USART_IrDACmd() function.
1394:../src/stm32f30x_usart.c ****          (#) Enable the USART using the USART_Cmd() function.         
1395:../src/stm32f30x_usart.c ****     [..]
1396:../src/stm32f30x_usart.c ****     (@) A pulse of width less than two and greater than one PSC period(s) may or 
1397:../src/stm32f30x_usart.c ****         may not be rejected.
1398:../src/stm32f30x_usart.c ****     (@) The receiver set up time should be managed by software. The IrDA physical 
1399:../src/stm32f30x_usart.c ****         layer specification specifies a minimum of 10 ms delay between 
1400:../src/stm32f30x_usart.c ****         transmission and reception (IrDA is a half duplex protocol).
1401:../src/stm32f30x_usart.c ****     (@) In IrDA mode, the following bits must be kept cleared:
1402:../src/stm32f30x_usart.c ****         (+@) LINEN, STOP and CLKEN bits in the USART_CR2 register.
1403:../src/stm32f30x_usart.c ****         (+@) SCEN and HDSEL bits in the USART_CR3 register.
1404:../src/stm32f30x_usart.c **** 
1405:../src/stm32f30x_usart.c **** @endverbatim
1406:../src/stm32f30x_usart.c ****   * @{
1407:../src/stm32f30x_usart.c ****   */
1408:../src/stm32f30x_usart.c **** 
1409:../src/stm32f30x_usart.c **** /**
1410:../src/stm32f30x_usart.c ****   * @brief  Configures the USART's IrDA interface.
1411:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1412:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1413:../src/stm32f30x_usart.c ****   * @param  USART_IrDAMode: specifies the IrDA mode.
1414:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1415:../src/stm32f30x_usart.c ****   *         @arg USART_IrDAMode_LowPower
1416:../src/stm32f30x_usart.c ****   *         @arg USART_IrDAMode_Normal
1417:../src/stm32f30x_usart.c ****   * @retval None
1418:../src/stm32f30x_usart.c ****   */
1419:../src/stm32f30x_usart.c **** void USART_IrDAConfig(USART_TypeDef* USARTx, uint32_t USART_IrDAMode)
1420:../src/stm32f30x_usart.c **** {
 1973              		.loc 1 1420 0
 1974              		.cfi_startproc
 1975              		@ args = 0, pretend = 0, frame = 8
 1976              		@ frame_needed = 1, uses_anonymous_args = 0
 1977              		@ link register save eliminated.
 1978 0918 80B4     		push	{r7}
 1979              	.LCFI102:
 1980              		.cfi_def_cfa_offset 4
 1981              		.cfi_offset 7, -4
 1982 091a 83B0     		sub	sp, sp, #12
 1983              	.LCFI103:
 1984              		.cfi_def_cfa_offset 16
 1985 091c 00AF     		add	r7, sp, #0
 1986              	.LCFI104:
 1987              		.cfi_def_cfa_register 7
 1988 091e 7860     		str	r0, [r7, #4]
 1989 0920 3960     		str	r1, [r7, #0]
1421:../src/stm32f30x_usart.c ****   /* Check the parameters */
1422:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1423:../src/stm32f30x_usart.c ****   assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
1424:../src/stm32f30x_usart.c **** 
1425:../src/stm32f30x_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IRLP);
 1990              		.loc 1 1425 0
 1991 0922 7B68     		ldr	r3, [r7, #4]
 1992 0924 9B68     		ldr	r3, [r3, #8]
 1993 0926 23F00402 		bic	r2, r3, #4
 1994 092a 7B68     		ldr	r3, [r7, #4]
 1995 092c 9A60     		str	r2, [r3, #8]
1426:../src/stm32f30x_usart.c ****   USARTx->CR3 |= USART_IrDAMode;
 1996              		.loc 1 1426 0
 1997 092e 7B68     		ldr	r3, [r7, #4]
 1998 0930 9A68     		ldr	r2, [r3, #8]
 1999 0932 3B68     		ldr	r3, [r7, #0]
 2000 0934 1A43     		orrs	r2, r2, r3
 2001 0936 7B68     		ldr	r3, [r7, #4]
 2002 0938 9A60     		str	r2, [r3, #8]
1427:../src/stm32f30x_usart.c **** }
 2003              		.loc 1 1427 0
 2004 093a 07F10C07 		add	r7, r7, #12
 2005 093e BD46     		mov	sp, r7
 2006 0940 80BC     		pop	{r7}
 2007 0942 7047     		bx	lr
 2008              		.cfi_endproc
 2009              	.LFE145:
 2011              		.align	2
 2012              		.global	USART_IrDACmd
 2013              		.thumb
 2014              		.thumb_func
 2016              	USART_IrDACmd:
 2017              	.LFB146:
1428:../src/stm32f30x_usart.c **** 
1429:../src/stm32f30x_usart.c **** /**
1430:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's IrDA interface. 
1431:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1432:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1433:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the IrDA mode.
1434:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
1435:../src/stm32f30x_usart.c ****   * @retval None
1436:../src/stm32f30x_usart.c ****   */
1437:../src/stm32f30x_usart.c **** void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
1438:../src/stm32f30x_usart.c **** {
 2018              		.loc 1 1438 0
 2019              		.cfi_startproc
 2020              		@ args = 0, pretend = 0, frame = 8
 2021              		@ frame_needed = 1, uses_anonymous_args = 0
 2022              		@ link register save eliminated.
 2023 0944 80B4     		push	{r7}
 2024              	.LCFI105:
 2025              		.cfi_def_cfa_offset 4
 2026              		.cfi_offset 7, -4
 2027 0946 83B0     		sub	sp, sp, #12
 2028              	.LCFI106:
 2029              		.cfi_def_cfa_offset 16
 2030 0948 00AF     		add	r7, sp, #0
 2031              	.LCFI107:
 2032              		.cfi_def_cfa_register 7
 2033 094a 7860     		str	r0, [r7, #4]
 2034 094c 0B46     		mov	r3, r1
 2035 094e FB70     		strb	r3, [r7, #3]
1439:../src/stm32f30x_usart.c ****   /* Check the parameters */
1440:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1441:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1442:../src/stm32f30x_usart.c **** 
1443:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 2036              		.loc 1 1443 0
 2037 0950 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2038 0952 002B     		cmp	r3, #0
 2039 0954 06D0     		beq	.L84
1444:../src/stm32f30x_usart.c ****   {
1445:../src/stm32f30x_usart.c ****     /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
1446:../src/stm32f30x_usart.c ****     USARTx->CR3 |= USART_CR3_IREN;
 2040              		.loc 1 1446 0
 2041 0956 7B68     		ldr	r3, [r7, #4]
 2042 0958 9B68     		ldr	r3, [r3, #8]
 2043 095a 43F00202 		orr	r2, r3, #2
 2044 095e 7B68     		ldr	r3, [r7, #4]
 2045 0960 9A60     		str	r2, [r3, #8]
 2046 0962 05E0     		b	.L83
 2047              	.L84:
1447:../src/stm32f30x_usart.c ****   }
1448:../src/stm32f30x_usart.c ****   else
1449:../src/stm32f30x_usart.c ****   {
1450:../src/stm32f30x_usart.c ****     /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
1451:../src/stm32f30x_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IREN);
 2048              		.loc 1 1451 0
 2049 0964 7B68     		ldr	r3, [r7, #4]
 2050 0966 9B68     		ldr	r3, [r3, #8]
 2051 0968 23F00202 		bic	r2, r3, #2
 2052 096c 7B68     		ldr	r3, [r7, #4]
 2053 096e 9A60     		str	r2, [r3, #8]
 2054              	.L83:
1452:../src/stm32f30x_usart.c ****   }
1453:../src/stm32f30x_usart.c **** }
 2055              		.loc 1 1453 0
 2056 0970 07F10C07 		add	r7, r7, #12
 2057 0974 BD46     		mov	sp, r7
 2058 0976 80BC     		pop	{r7}
 2059 0978 7047     		bx	lr
 2060              		.cfi_endproc
 2061              	.LFE146:
 2063 097a 00BF     		.align	2
 2064              		.global	USART_DECmd
 2065              		.thumb
 2066              		.thumb_func
 2068              	USART_DECmd:
 2069              	.LFB147:
1454:../src/stm32f30x_usart.c **** /**
1455:../src/stm32f30x_usart.c ****   * @}
1456:../src/stm32f30x_usart.c ****   */
1457:../src/stm32f30x_usart.c **** 
1458:../src/stm32f30x_usart.c **** /** @defgroup USART_Group10 RS485 mode function
1459:../src/stm32f30x_usart.c ****  *  @brief   RS485 mode function 
1460:../src/stm32f30x_usart.c ****  *
1461:../src/stm32f30x_usart.c **** @verbatim  
1462:../src/stm32f30x_usart.c ****  ===============================================================================
1463:../src/stm32f30x_usart.c ****                         ##### RS485 mode functions #####
1464:../src/stm32f30x_usart.c ****  ===============================================================================
1465:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
1466:../src/stm32f30x_usart.c ****          RS485 flow control.
1467:../src/stm32f30x_usart.c ****     [..] RS485 flow control (Driver enable feature) handling is possible through
1468:../src/stm32f30x_usart.c ****          the following procedure:
1469:../src/stm32f30x_usart.c ****          (#) Program the Baud rate, Word length = 8 bits, Stop bits, Parity, 
1470:../src/stm32f30x_usart.c ****              Transmitter/Receiver modes and hardware flow control values using 
1471:../src/stm32f30x_usart.c ****              the USART_Init() function.
1472:../src/stm32f30x_usart.c ****          (#) Enable the Driver Enable using the USART_DECmd() function.
1473:../src/stm32f30x_usart.c ****          (#) Configures the Driver Enable polarity using the USART_DEPolarityConfig()
1474:../src/stm32f30x_usart.c ****              function.
1475:../src/stm32f30x_usart.c ****          (#) Configures the Driver Enable assertion time using USART_SetDEAssertionTime() 
1476:../src/stm32f30x_usart.c ****              function and deassertion time using the USART_SetDEDeassertionTime()
1477:../src/stm32f30x_usart.c ****              function.    
1478:../src/stm32f30x_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1479:../src/stm32f30x_usart.c ****       [..]  
1480:../src/stm32f30x_usart.c ****        (@) The assertion and dessertion times are expressed in sample time units (1/8 or 
1481:../src/stm32f30x_usart.c ****             1/16 bit time, depending on the oversampling rate).
1482:../src/stm32f30x_usart.c ****        
1483:../src/stm32f30x_usart.c **** @endverbatim
1484:../src/stm32f30x_usart.c ****   * @{
1485:../src/stm32f30x_usart.c ****   */
1486:../src/stm32f30x_usart.c **** 
1487:../src/stm32f30x_usart.c **** /**
1488:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's DE functionality.
1489:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1490:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1491:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the driver enable mode.
1492:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.      
1493:../src/stm32f30x_usart.c ****   * @retval None
1494:../src/stm32f30x_usart.c ****   */
1495:../src/stm32f30x_usart.c **** void USART_DECmd(USART_TypeDef* USARTx, FunctionalState NewState)
1496:../src/stm32f30x_usart.c **** {
 2070              		.loc 1 1496 0
 2071              		.cfi_startproc
 2072              		@ args = 0, pretend = 0, frame = 8
 2073              		@ frame_needed = 1, uses_anonymous_args = 0
 2074              		@ link register save eliminated.
 2075 097c 80B4     		push	{r7}
 2076              	.LCFI108:
 2077              		.cfi_def_cfa_offset 4
 2078              		.cfi_offset 7, -4
 2079 097e 83B0     		sub	sp, sp, #12
 2080              	.LCFI109:
 2081              		.cfi_def_cfa_offset 16
 2082 0980 00AF     		add	r7, sp, #0
 2083              	.LCFI110:
 2084              		.cfi_def_cfa_register 7
 2085 0982 7860     		str	r0, [r7, #4]
 2086 0984 0B46     		mov	r3, r1
 2087 0986 FB70     		strb	r3, [r7, #3]
1497:../src/stm32f30x_usart.c ****   /* Check the parameters */
1498:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1499:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1500:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 2088              		.loc 1 1500 0
 2089 0988 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2090 098a 002B     		cmp	r3, #0
 2091 098c 06D0     		beq	.L87
1501:../src/stm32f30x_usart.c ****   {
1502:../src/stm32f30x_usart.c ****     /* Enable the DE functionality by setting the DEM bit in the CR3 register */
1503:../src/stm32f30x_usart.c ****     USARTx->CR3 |= USART_CR3_DEM;
 2092              		.loc 1 1503 0
 2093 098e 7B68     		ldr	r3, [r7, #4]
 2094 0990 9B68     		ldr	r3, [r3, #8]
 2095 0992 43F48042 		orr	r2, r3, #16384
 2096 0996 7B68     		ldr	r3, [r7, #4]
 2097 0998 9A60     		str	r2, [r3, #8]
 2098 099a 05E0     		b	.L86
 2099              	.L87:
1504:../src/stm32f30x_usart.c ****   }
1505:../src/stm32f30x_usart.c ****   else
1506:../src/stm32f30x_usart.c ****   {
1507:../src/stm32f30x_usart.c ****     /* Disable the DE functionality by clearing the DEM bit in the CR3 register */
1508:../src/stm32f30x_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEM);
 2100              		.loc 1 1508 0
 2101 099c 7B68     		ldr	r3, [r7, #4]
 2102 099e 9B68     		ldr	r3, [r3, #8]
 2103 09a0 23F48042 		bic	r2, r3, #16384
 2104 09a4 7B68     		ldr	r3, [r7, #4]
 2105 09a6 9A60     		str	r2, [r3, #8]
 2106              	.L86:
1509:../src/stm32f30x_usart.c ****   }
1510:../src/stm32f30x_usart.c **** }
 2107              		.loc 1 1510 0
 2108 09a8 07F10C07 		add	r7, r7, #12
 2109 09ac BD46     		mov	sp, r7
 2110 09ae 80BC     		pop	{r7}
 2111 09b0 7047     		bx	lr
 2112              		.cfi_endproc
 2113              	.LFE147:
 2115 09b2 00BF     		.align	2
 2116              		.global	USART_DEPolarityConfig
 2117              		.thumb
 2118              		.thumb_func
 2120              	USART_DEPolarityConfig:
 2121              	.LFB148:
1511:../src/stm32f30x_usart.c **** 
1512:../src/stm32f30x_usart.c **** /**
1513:../src/stm32f30x_usart.c ****   * @brief  Configures the USART's DE polarity
1514:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1515:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1516:../src/stm32f30x_usart.c ****   * @param  USART_DEPolarity: specifies the DE polarity.
1517:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1518:../src/stm32f30x_usart.c ****   *         @arg USART_DEPolarity_Low
1519:../src/stm32f30x_usart.c ****   *         @arg USART_DEPolarity_High
1520:../src/stm32f30x_usart.c ****   * @retval None
1521:../src/stm32f30x_usart.c ****   */
1522:../src/stm32f30x_usart.c **** void USART_DEPolarityConfig(USART_TypeDef* USARTx, uint32_t USART_DEPolarity)
1523:../src/stm32f30x_usart.c **** {
 2122              		.loc 1 1523 0
 2123              		.cfi_startproc
 2124              		@ args = 0, pretend = 0, frame = 8
 2125              		@ frame_needed = 1, uses_anonymous_args = 0
 2126              		@ link register save eliminated.
 2127 09b4 80B4     		push	{r7}
 2128              	.LCFI111:
 2129              		.cfi_def_cfa_offset 4
 2130              		.cfi_offset 7, -4
 2131 09b6 83B0     		sub	sp, sp, #12
 2132              	.LCFI112:
 2133              		.cfi_def_cfa_offset 16
 2134 09b8 00AF     		add	r7, sp, #0
 2135              	.LCFI113:
 2136              		.cfi_def_cfa_register 7
 2137 09ba 7860     		str	r0, [r7, #4]
 2138 09bc 3960     		str	r1, [r7, #0]
1524:../src/stm32f30x_usart.c ****   /* Check the parameters */
1525:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1526:../src/stm32f30x_usart.c ****   assert_param(IS_USART_DE_POLARITY(USART_DEPolarity));
1527:../src/stm32f30x_usart.c **** 
1528:../src/stm32f30x_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEP);
 2139              		.loc 1 1528 0
 2140 09be 7B68     		ldr	r3, [r7, #4]
 2141 09c0 9B68     		ldr	r3, [r3, #8]
 2142 09c2 23F40042 		bic	r2, r3, #32768
 2143 09c6 7B68     		ldr	r3, [r7, #4]
 2144 09c8 9A60     		str	r2, [r3, #8]
1529:../src/stm32f30x_usart.c ****   USARTx->CR3 |= USART_DEPolarity;
 2145              		.loc 1 1529 0
 2146 09ca 7B68     		ldr	r3, [r7, #4]
 2147 09cc 9A68     		ldr	r2, [r3, #8]
 2148 09ce 3B68     		ldr	r3, [r7, #0]
 2149 09d0 1A43     		orrs	r2, r2, r3
 2150 09d2 7B68     		ldr	r3, [r7, #4]
 2151 09d4 9A60     		str	r2, [r3, #8]
1530:../src/stm32f30x_usart.c **** }
 2152              		.loc 1 1530 0
 2153 09d6 07F10C07 		add	r7, r7, #12
 2154 09da BD46     		mov	sp, r7
 2155 09dc 80BC     		pop	{r7}
 2156 09de 7047     		bx	lr
 2157              		.cfi_endproc
 2158              	.LFE148:
 2160              		.align	2
 2161              		.global	USART_SetDEAssertionTime
 2162              		.thumb
 2163              		.thumb_func
 2165              	USART_SetDEAssertionTime:
 2166              	.LFB149:
1531:../src/stm32f30x_usart.c **** 
1532:../src/stm32f30x_usart.c **** /**
1533:../src/stm32f30x_usart.c ****   * @brief  Sets the specified RS485 DE assertion time
1534:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1535:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1536:../src/stm32f30x_usart.c ****   * @param  USART_AssertionTime: specifies the time between the activation of the DE
1537:../src/stm32f30x_usart.c ****   *          signal and the beginning of the start bit
1538:../src/stm32f30x_usart.c ****   * @retval None
1539:../src/stm32f30x_usart.c ****   */
1540:../src/stm32f30x_usart.c **** void USART_SetDEAssertionTime(USART_TypeDef* USARTx, uint32_t USART_DEAssertionTime)
1541:../src/stm32f30x_usart.c **** {
 2167              		.loc 1 1541 0
 2168              		.cfi_startproc
 2169              		@ args = 0, pretend = 0, frame = 8
 2170              		@ frame_needed = 1, uses_anonymous_args = 0
 2171              		@ link register save eliminated.
 2172 09e0 80B4     		push	{r7}
 2173              	.LCFI114:
 2174              		.cfi_def_cfa_offset 4
 2175              		.cfi_offset 7, -4
 2176 09e2 83B0     		sub	sp, sp, #12
 2177              	.LCFI115:
 2178              		.cfi_def_cfa_offset 16
 2179 09e4 00AF     		add	r7, sp, #0
 2180              	.LCFI116:
 2181              		.cfi_def_cfa_register 7
 2182 09e6 7860     		str	r0, [r7, #4]
 2183 09e8 3960     		str	r1, [r7, #0]
1542:../src/stm32f30x_usart.c ****   /* Check the parameters */
1543:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1544:../src/stm32f30x_usart.c ****   assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEAssertionTime)); 
1545:../src/stm32f30x_usart.c **** 
1546:../src/stm32f30x_usart.c ****   /* Clear the DE assertion time */
1547:../src/stm32f30x_usart.c ****   USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEAT);
 2184              		.loc 1 1547 0
 2185 09ea 7B68     		ldr	r3, [r7, #4]
 2186 09ec 1B68     		ldr	r3, [r3, #0]
 2187 09ee 23F07872 		bic	r2, r3, #65011712
 2188 09f2 7B68     		ldr	r3, [r7, #4]
 2189 09f4 1A60     		str	r2, [r3, #0]
1548:../src/stm32f30x_usart.c ****   /* Set the new value for the DE assertion time */
1549:../src/stm32f30x_usart.c ****   USARTx->CR1 |=((uint32_t)USART_DEAssertionTime << (uint32_t)0x15);
 2190              		.loc 1 1549 0
 2191 09f6 7B68     		ldr	r3, [r7, #4]
 2192 09f8 1A68     		ldr	r2, [r3, #0]
 2193 09fa 3B68     		ldr	r3, [r7, #0]
 2194 09fc 4FEA4353 		lsl	r3, r3, #21
 2195 0a00 1A43     		orrs	r2, r2, r3
 2196 0a02 7B68     		ldr	r3, [r7, #4]
 2197 0a04 1A60     		str	r2, [r3, #0]
1550:../src/stm32f30x_usart.c **** }
 2198              		.loc 1 1550 0
 2199 0a06 07F10C07 		add	r7, r7, #12
 2200 0a0a BD46     		mov	sp, r7
 2201 0a0c 80BC     		pop	{r7}
 2202 0a0e 7047     		bx	lr
 2203              		.cfi_endproc
 2204              	.LFE149:
 2206              		.align	2
 2207              		.global	USART_SetDEDeassertionTime
 2208              		.thumb
 2209              		.thumb_func
 2211              	USART_SetDEDeassertionTime:
 2212              	.LFB150:
1551:../src/stm32f30x_usart.c **** 
1552:../src/stm32f30x_usart.c **** /**
1553:../src/stm32f30x_usart.c ****   * @brief  Sets the specified RS485 DE deassertion time
1554:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1555:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1556:../src/stm32f30x_usart.c ****   * @param  USART_DeassertionTime: specifies the time between the middle of the last 
1557:../src/stm32f30x_usart.c ****   *         stop bit in a transmitted message and the de-activation of the DE signal
1558:../src/stm32f30x_usart.c ****   * @retval None
1559:../src/stm32f30x_usart.c ****   */
1560:../src/stm32f30x_usart.c **** void USART_SetDEDeassertionTime(USART_TypeDef* USARTx, uint32_t USART_DEDeassertionTime)
1561:../src/stm32f30x_usart.c **** {
 2213              		.loc 1 1561 0
 2214              		.cfi_startproc
 2215              		@ args = 0, pretend = 0, frame = 8
 2216              		@ frame_needed = 1, uses_anonymous_args = 0
 2217              		@ link register save eliminated.
 2218 0a10 80B4     		push	{r7}
 2219              	.LCFI117:
 2220              		.cfi_def_cfa_offset 4
 2221              		.cfi_offset 7, -4
 2222 0a12 83B0     		sub	sp, sp, #12
 2223              	.LCFI118:
 2224              		.cfi_def_cfa_offset 16
 2225 0a14 00AF     		add	r7, sp, #0
 2226              	.LCFI119:
 2227              		.cfi_def_cfa_register 7
 2228 0a16 7860     		str	r0, [r7, #4]
 2229 0a18 3960     		str	r1, [r7, #0]
1562:../src/stm32f30x_usart.c ****   /* Check the parameters */
1563:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1564:../src/stm32f30x_usart.c ****   assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEDeassertionTime)); 
1565:../src/stm32f30x_usart.c **** 
1566:../src/stm32f30x_usart.c ****   /* Clear the DE deassertion time */
1567:../src/stm32f30x_usart.c ****   USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEDT);
 2230              		.loc 1 1567 0
 2231 0a1a 7B68     		ldr	r3, [r7, #4]
 2232 0a1c 1B68     		ldr	r3, [r3, #0]
 2233 0a1e 23F4F812 		bic	r2, r3, #2031616
 2234 0a22 7B68     		ldr	r3, [r7, #4]
 2235 0a24 1A60     		str	r2, [r3, #0]
1568:../src/stm32f30x_usart.c ****   /* Set the new value for the DE deassertion time */
1569:../src/stm32f30x_usart.c ****   USARTx->CR1 |=((uint32_t)USART_DEDeassertionTime << (uint32_t)0x10);
 2236              		.loc 1 1569 0
 2237 0a26 7B68     		ldr	r3, [r7, #4]
 2238 0a28 1A68     		ldr	r2, [r3, #0]
 2239 0a2a 3B68     		ldr	r3, [r7, #0]
 2240 0a2c 4FEA0343 		lsl	r3, r3, #16
 2241 0a30 1A43     		orrs	r2, r2, r3
 2242 0a32 7B68     		ldr	r3, [r7, #4]
 2243 0a34 1A60     		str	r2, [r3, #0]
1570:../src/stm32f30x_usart.c **** }
 2244              		.loc 1 1570 0
 2245 0a36 07F10C07 		add	r7, r7, #12
 2246 0a3a BD46     		mov	sp, r7
 2247 0a3c 80BC     		pop	{r7}
 2248 0a3e 7047     		bx	lr
 2249              		.cfi_endproc
 2250              	.LFE150:
 2252              		.align	2
 2253              		.global	USART_DMACmd
 2254              		.thumb
 2255              		.thumb_func
 2257              	USART_DMACmd:
 2258              	.LFB151:
1571:../src/stm32f30x_usart.c **** 
1572:../src/stm32f30x_usart.c **** /**
1573:../src/stm32f30x_usart.c ****   * @}
1574:../src/stm32f30x_usart.c ****   */
1575:../src/stm32f30x_usart.c **** 
1576:../src/stm32f30x_usart.c **** /** @defgroup USART_Group11 DMA transfers management functions
1577:../src/stm32f30x_usart.c ****  *  @brief   DMA transfers management functions
1578:../src/stm32f30x_usart.c ****  *
1579:../src/stm32f30x_usart.c **** @verbatim   
1580:../src/stm32f30x_usart.c ****  ===============================================================================
1581:../src/stm32f30x_usart.c ****                ##### DMA transfers management functions #####
1582:../src/stm32f30x_usart.c ****  ===============================================================================
1583:../src/stm32f30x_usart.c ****     [..] This section provides two functions that can be used only in DMA mode.
1584:../src/stm32f30x_usart.c ****     [..] In DMA Mode, the USART communication can be managed by 2 DMA Channel 
1585:../src/stm32f30x_usart.c ****          requests:
1586:../src/stm32f30x_usart.c ****          (#) USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request.
1587:../src/stm32f30x_usart.c ****          (#) USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request.
1588:../src/stm32f30x_usart.c ****     [..] In this Mode it is advised to use the following function:
1589:../src/stm32f30x_usart.c ****          (+) void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, 
1590:../src/stm32f30x_usart.c ****              FunctionalState NewState).
1591:../src/stm32f30x_usart.c **** @endverbatim
1592:../src/stm32f30x_usart.c ****   * @{
1593:../src/stm32f30x_usart.c ****   */
1594:../src/stm32f30x_usart.c **** 
1595:../src/stm32f30x_usart.c **** /**
1596:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's DMA interface.
1597:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1598:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4.
1599:../src/stm32f30x_usart.c ****   * @param  USART_DMAReq: specifies the DMA request.
1600:../src/stm32f30x_usart.c ****   *         This parameter can be any combination of the following values:
1601:../src/stm32f30x_usart.c ****   *         @arg USART_DMAReq_Tx: USART DMA transmit request
1602:../src/stm32f30x_usart.c ****   *         @arg USART_DMAReq_Rx: USART DMA receive request
1603:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the DMA Request sources.
1604:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.  
1605:../src/stm32f30x_usart.c ****   * @retval None
1606:../src/stm32f30x_usart.c ****   */
1607:../src/stm32f30x_usart.c **** void USART_DMACmd(USART_TypeDef* USARTx, uint32_t USART_DMAReq, FunctionalState NewState)
1608:../src/stm32f30x_usart.c **** {
 2259              		.loc 1 1608 0
 2260              		.cfi_startproc
 2261              		@ args = 0, pretend = 0, frame = 16
 2262              		@ frame_needed = 1, uses_anonymous_args = 0
 2263              		@ link register save eliminated.
 2264 0a40 80B4     		push	{r7}
 2265              	.LCFI120:
 2266              		.cfi_def_cfa_offset 4
 2267              		.cfi_offset 7, -4
 2268 0a42 85B0     		sub	sp, sp, #20
 2269              	.LCFI121:
 2270              		.cfi_def_cfa_offset 24
 2271 0a44 00AF     		add	r7, sp, #0
 2272              	.LCFI122:
 2273              		.cfi_def_cfa_register 7
 2274 0a46 F860     		str	r0, [r7, #12]
 2275 0a48 B960     		str	r1, [r7, #8]
 2276 0a4a 1346     		mov	r3, r2
 2277 0a4c FB71     		strb	r3, [r7, #7]
1609:../src/stm32f30x_usart.c ****   /* Check the parameters */
1610:../src/stm32f30x_usart.c ****   assert_param(IS_USART_1234_PERIPH(USARTx));
1611:../src/stm32f30x_usart.c ****   assert_param(IS_USART_DMAREQ(USART_DMAReq));  
1612:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
1613:../src/stm32f30x_usart.c **** 
1614:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 2278              		.loc 1 1614 0
 2279 0a4e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2280 0a50 002B     		cmp	r3, #0
 2281 0a52 06D0     		beq	.L93
1615:../src/stm32f30x_usart.c ****   {
1616:../src/stm32f30x_usart.c ****     /* Enable the DMA transfer for selected requests by setting the DMAT and/or
1617:../src/stm32f30x_usart.c ****        DMAR bits in the USART CR3 register */
1618:../src/stm32f30x_usart.c ****     USARTx->CR3 |= USART_DMAReq;
 2282              		.loc 1 1618 0
 2283 0a54 FB68     		ldr	r3, [r7, #12]
 2284 0a56 9A68     		ldr	r2, [r3, #8]
 2285 0a58 BB68     		ldr	r3, [r7, #8]
 2286 0a5a 1A43     		orrs	r2, r2, r3
 2287 0a5c FB68     		ldr	r3, [r7, #12]
 2288 0a5e 9A60     		str	r2, [r3, #8]
 2289 0a60 07E0     		b	.L92
 2290              	.L93:
1619:../src/stm32f30x_usart.c ****   }
1620:../src/stm32f30x_usart.c ****   else
1621:../src/stm32f30x_usart.c ****   {
1622:../src/stm32f30x_usart.c ****     /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
1623:../src/stm32f30x_usart.c ****        DMAR bits in the USART CR3 register */
1624:../src/stm32f30x_usart.c ****     USARTx->CR3 &= (uint32_t)~USART_DMAReq;
 2291              		.loc 1 1624 0
 2292 0a62 FB68     		ldr	r3, [r7, #12]
 2293 0a64 9A68     		ldr	r2, [r3, #8]
 2294 0a66 BB68     		ldr	r3, [r7, #8]
 2295 0a68 6FEA0303 		mvn	r3, r3
 2296 0a6c 1A40     		ands	r2, r2, r3
 2297 0a6e FB68     		ldr	r3, [r7, #12]
 2298 0a70 9A60     		str	r2, [r3, #8]
 2299              	.L92:
1625:../src/stm32f30x_usart.c ****   }
1626:../src/stm32f30x_usart.c **** }
 2300              		.loc 1 1626 0
 2301 0a72 07F11407 		add	r7, r7, #20
 2302 0a76 BD46     		mov	sp, r7
 2303 0a78 80BC     		pop	{r7}
 2304 0a7a 7047     		bx	lr
 2305              		.cfi_endproc
 2306              	.LFE151:
 2308              		.align	2
 2309              		.global	USART_DMAReceptionErrorConfig
 2310              		.thumb
 2311              		.thumb_func
 2313              	USART_DMAReceptionErrorConfig:
 2314              	.LFB152:
1627:../src/stm32f30x_usart.c **** 
1628:../src/stm32f30x_usart.c **** /**
1629:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's DMA interface when reception error occurs.
1630:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1631:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4.
1632:../src/stm32f30x_usart.c ****   * @param  USART_DMAOnError: specifies the DMA status in case of reception error.
1633:../src/stm32f30x_usart.c ****   *         This parameter can be any combination of the following values:
1634:../src/stm32f30x_usart.c ****   *         @arg USART_DMAOnError_Enable: DMA receive request enabled when the USART DMA  
1635:../src/stm32f30x_usart.c ****   *          reception error is asserted.
1636:../src/stm32f30x_usart.c ****   *         @arg USART_DMAOnError_Disable: DMA receive request disabled when the USART DMA 
1637:../src/stm32f30x_usart.c ****   *          reception error is asserted.
1638:../src/stm32f30x_usart.c ****   * @retval None
1639:../src/stm32f30x_usart.c ****   */
1640:../src/stm32f30x_usart.c **** void USART_DMAReceptionErrorConfig(USART_TypeDef* USARTx, uint32_t USART_DMAOnError)
1641:../src/stm32f30x_usart.c **** {
 2315              		.loc 1 1641 0
 2316              		.cfi_startproc
 2317              		@ args = 0, pretend = 0, frame = 8
 2318              		@ frame_needed = 1, uses_anonymous_args = 0
 2319              		@ link register save eliminated.
 2320 0a7c 80B4     		push	{r7}
 2321              	.LCFI123:
 2322              		.cfi_def_cfa_offset 4
 2323              		.cfi_offset 7, -4
 2324 0a7e 83B0     		sub	sp, sp, #12
 2325              	.LCFI124:
 2326              		.cfi_def_cfa_offset 16
 2327 0a80 00AF     		add	r7, sp, #0
 2328              	.LCFI125:
 2329              		.cfi_def_cfa_register 7
 2330 0a82 7860     		str	r0, [r7, #4]
 2331 0a84 3960     		str	r1, [r7, #0]
1642:../src/stm32f30x_usart.c ****   /* Check the parameters */
1643:../src/stm32f30x_usart.c ****   assert_param(IS_USART_1234_PERIPH(USARTx));
1644:../src/stm32f30x_usart.c ****   assert_param(IS_USART_DMAONERROR(USART_DMAOnError)); 
1645:../src/stm32f30x_usart.c ****   
1646:../src/stm32f30x_usart.c ****   /* Clear the DMA Reception error detection bit */
1647:../src/stm32f30x_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DDRE);
 2332              		.loc 1 1647 0
 2333 0a86 7B68     		ldr	r3, [r7, #4]
 2334 0a88 9B68     		ldr	r3, [r3, #8]
 2335 0a8a 23F40052 		bic	r2, r3, #8192
 2336 0a8e 7B68     		ldr	r3, [r7, #4]
 2337 0a90 9A60     		str	r2, [r3, #8]
1648:../src/stm32f30x_usart.c ****   /* Set the new value for the DMA Reception error detection bit */
1649:../src/stm32f30x_usart.c ****   USARTx->CR3 |= USART_DMAOnError;
 2338              		.loc 1 1649 0
 2339 0a92 7B68     		ldr	r3, [r7, #4]
 2340 0a94 9A68     		ldr	r2, [r3, #8]
 2341 0a96 3B68     		ldr	r3, [r7, #0]
 2342 0a98 1A43     		orrs	r2, r2, r3
 2343 0a9a 7B68     		ldr	r3, [r7, #4]
 2344 0a9c 9A60     		str	r2, [r3, #8]
1650:../src/stm32f30x_usart.c **** }
 2345              		.loc 1 1650 0
 2346 0a9e 07F10C07 		add	r7, r7, #12
 2347 0aa2 BD46     		mov	sp, r7
 2348 0aa4 80BC     		pop	{r7}
 2349 0aa6 7047     		bx	lr
 2350              		.cfi_endproc
 2351              	.LFE152:
 2353              		.align	2
 2354              		.global	USART_ITConfig
 2355              		.thumb
 2356              		.thumb_func
 2358              	USART_ITConfig:
 2359              	.LFB153:
1651:../src/stm32f30x_usart.c **** 
1652:../src/stm32f30x_usart.c **** /**
1653:../src/stm32f30x_usart.c ****   * @}
1654:../src/stm32f30x_usart.c ****   */
1655:../src/stm32f30x_usart.c ****   
1656:../src/stm32f30x_usart.c **** /** @defgroup USART_Group12 Interrupts and flags management functions
1657:../src/stm32f30x_usart.c ****  *  @brief   Interrupts and flags management functions 
1658:../src/stm32f30x_usart.c ****  *
1659:../src/stm32f30x_usart.c **** @verbatim   
1660:../src/stm32f30x_usart.c ****  ===============================================================================
1661:../src/stm32f30x_usart.c ****             ##### Interrupts and flags management functions #####
1662:../src/stm32f30x_usart.c ****  ===============================================================================
1663:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to configure the 
1664:../src/stm32f30x_usart.c ****          USART Interrupts sources, Requests and check or clear the flags or pending bits status. 
1665:../src/stm32f30x_usart.c ****          The user should identify which mode will be used in his application to 
1666:../src/stm32f30x_usart.c ****          manage the communication: Polling mode, Interrupt mode.
1667:../src/stm32f30x_usart.c ****          
1668:../src/stm32f30x_usart.c ****  *** Polling Mode ***
1669:../src/stm32f30x_usart.c ****  ====================
1670:../src/stm32f30x_usart.c ****     [..] In Polling Mode, the SPI communication can be managed by these flags:
1671:../src/stm32f30x_usart.c ****          (#) USART_FLAG_REACK: to indicate the status of the Receive Enable 
1672:../src/stm32f30x_usart.c ****              acknowledge flag
1673:../src/stm32f30x_usart.c ****          (#) USART_FLAG_TEACK: to indicate the status of the Transmit Enable 
1674:../src/stm32f30x_usart.c ****              acknowledge flag.
1675:../src/stm32f30x_usart.c ****          (#) USART_FLAG_WUF: to indicate the status of the Wake up flag.
1676:../src/stm32f30x_usart.c ****          (#) USART_FLAG_RWU: to indicate the status of the Receive Wake up flag.
1677:../src/stm32f30x_usart.c ****          (#) USART_FLAG_SBK: to indicate the status of the Send Break flag.
1678:../src/stm32f30x_usart.c ****          (#) USART_FLAG_CMF: to indicate the status of the Character match flag.
1679:../src/stm32f30x_usart.c ****          (#) USART_FLAG_BUSY: to indicate the status of the Busy flag.
1680:../src/stm32f30x_usart.c ****          (#) USART_FLAG_ABRF: to indicate the status of the Auto baud rate flag.
1681:../src/stm32f30x_usart.c ****          (#) USART_FLAG_ABRE: to indicate the status of the Auto baud rate error flag.
1682:../src/stm32f30x_usart.c ****          (#) USART_FLAG_EOBF: to indicate the status of the End of block flag.
1683:../src/stm32f30x_usart.c ****          (#) USART_FLAG_RTOF: to indicate the status of the Receive time out flag.
1684:../src/stm32f30x_usart.c ****          (#) USART_FLAG_nCTSS: to indicate the status of the Inverted nCTS input 
1685:../src/stm32f30x_usart.c ****              bit status.
1686:../src/stm32f30x_usart.c ****          (#) USART_FLAG_TXE: to indicate the status of the transmit buffer register.
1687:../src/stm32f30x_usart.c ****          (#) USART_FLAG_RXNE: to indicate the status of the receive buffer register.
1688:../src/stm32f30x_usart.c ****          (#) USART_FLAG_TC: to indicate the status of the transmit operation.
1689:../src/stm32f30x_usart.c ****          (#) USART_FLAG_IDLE: to indicate the status of the Idle Line.
1690:../src/stm32f30x_usart.c ****          (#) USART_FLAG_CTS: to indicate the status of the nCTS input.
1691:../src/stm32f30x_usart.c ****          (#) USART_FLAG_LBD: to indicate the status of the LIN break detection.
1692:../src/stm32f30x_usart.c ****          (#) USART_FLAG_NE: to indicate if a noise error occur.
1693:../src/stm32f30x_usart.c ****          (#) USART_FLAG_FE: to indicate if a frame error occur.
1694:../src/stm32f30x_usart.c ****          (#) USART_FLAG_PE: to indicate if a parity error occur.
1695:../src/stm32f30x_usart.c ****          (#) USART_FLAG_ORE: to indicate if an Overrun error occur.
1696:../src/stm32f30x_usart.c ****     [..] In this Mode it is advised to use the following functions:
1697:../src/stm32f30x_usart.c ****          (+) FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG).
1698:../src/stm32f30x_usart.c ****          (+) void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG).
1699:../src/stm32f30x_usart.c ****                
1700:../src/stm32f30x_usart.c ****  *** Interrupt Mode ***
1701:../src/stm32f30x_usart.c ****  ======================
1702:../src/stm32f30x_usart.c ****     [..] In Interrupt Mode, the USART communication can be managed by 8 interrupt 
1703:../src/stm32f30x_usart.c ****          sources and 10 pending bits:
1704:../src/stm32f30x_usart.c ****          (+) Pending Bits:
1705:../src/stm32f30x_usart.c ****              (##) USART_IT_WU: to indicate the status of the Wake up interrupt.
1706:../src/stm32f30x_usart.c ****              (##) USART_IT_CM: to indicate the status of Character match interrupt.
1707:../src/stm32f30x_usart.c ****              (##) USART_IT_EOB: to indicate the status of End of block interrupt.
1708:../src/stm32f30x_usart.c ****              (##) USART_IT_RTO: to indicate the status of Receive time out interrupt.
1709:../src/stm32f30x_usart.c ****              (##) USART_IT_CTS: to indicate the status of CTS change interrupt.
1710:../src/stm32f30x_usart.c ****              (##) USART_IT_LBD: to indicate the status of LIN Break detection interrupt.
1711:../src/stm32f30x_usart.c ****              (##) USART_IT_TC: to indicate the status of Transmission complete interrupt.
1712:../src/stm32f30x_usart.c ****              (##) USART_IT_IDLE: to indicate the status of IDLE line detected interrupt.
1713:../src/stm32f30x_usart.c ****              (##) USART_IT_ORE: to indicate the status of OverRun Error interrupt.
1714:../src/stm32f30x_usart.c ****              (##) USART_IT_NE: to indicate the status of Noise Error interrupt.
1715:../src/stm32f30x_usart.c ****              (##) USART_IT_FE: to indicate the status of Framing Error interrupt.
1716:../src/stm32f30x_usart.c ****              (##) USART_IT_PE: to indicate the status of Parity Error interrupt.  
1717:../src/stm32f30x_usart.c ****               
1718:../src/stm32f30x_usart.c ****          (+) Interrupt Source:
1719:../src/stm32f30x_usart.c ****              (##) USART_IT_WU: specifies the interrupt source for Wake up interrupt.
1720:../src/stm32f30x_usart.c ****              (##) USART_IT_CM: specifies the interrupt source for Character match 
1721:../src/stm32f30x_usart.c ****                   interrupt.
1722:../src/stm32f30x_usart.c ****              (##) USART_IT_EOB: specifies the interrupt source for End of block
1723:../src/stm32f30x_usart.c ****                   interrupt.
1724:../src/stm32f30x_usart.c ****              (##) USART_IT_RTO: specifies the interrupt source for Receive time-out
1725:../src/stm32f30x_usart.c ****                   interrupt.
1726:../src/stm32f30x_usart.c ****              (##) USART_IT_CTS: specifies the interrupt source for CTS change interrupt.
1727:../src/stm32f30x_usart.c ****              (##) USART_IT_LBD: specifies the interrupt source for LIN Break 
1728:../src/stm32f30x_usart.c ****                   detection interrupt.
1729:../src/stm32f30x_usart.c ****              (##) USART_IT_TXE: specifies the interrupt source for Tansmit Data 
1730:../src/stm32f30x_usart.c ****                   Register empty interrupt.
1731:../src/stm32f30x_usart.c ****              (##) USART_IT_TC: specifies the interrupt source for Transmission 
1732:../src/stm32f30x_usart.c ****                   complete interrupt.
1733:../src/stm32f30x_usart.c ****              (##) USART_IT_RXNE: specifies the interrupt source for Receive Data 
1734:../src/stm32f30x_usart.c ****                   register not empty interrupt.
1735:../src/stm32f30x_usart.c ****              (##) USART_IT_IDLE: specifies the interrupt source for Idle line 
1736:../src/stm32f30x_usart.c ****                   detection interrupt.
1737:../src/stm32f30x_usart.c ****              (##) USART_IT_PE: specifies the interrupt source for Parity Error interrupt.
1738:../src/stm32f30x_usart.c ****              (##) USART_IT_ERR: specifies the interrupt source for Error interrupt
1739:../src/stm32f30x_usart.c ****                   (Frame error, noise error, overrun error)
1740:../src/stm32f30x_usart.c ****              -@@- Some parameters are coded in order to use them as interrupt 
1741:../src/stm32f30x_usart.c ****                  source or as pending bits.
1742:../src/stm32f30x_usart.c ****     [..] In this Mode it is advised to use the following functions:
1743:../src/stm32f30x_usart.c ****          (+) void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState
1744:../src/stm32f30x_usart.c ****          (+) ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT).
1745:../src/stm32f30x_usart.c ****          (+) void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT).
1746:../src/stm32f30x_usart.c **** 
1747:../src/stm32f30x_usart.c **** @endverbatim
1748:../src/stm32f30x_usart.c ****   * @{
1749:../src/stm32f30x_usart.c ****   */
1750:../src/stm32f30x_usart.c **** 
1751:../src/stm32f30x_usart.c **** /**
1752:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the specified USART interrupts.
1753:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1754:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1755:../src/stm32f30x_usart.c ****   * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
1756:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1757:../src/stm32f30x_usart.c ****   *         @arg USART_IT_WU:  Wake up interrupt.
1758:../src/stm32f30x_usart.c ****   *         @arg USART_IT_CM:  Character match interrupt.
1759:../src/stm32f30x_usart.c ****   *         @arg USART_IT_EOB:  End of block interrupt.
1760:../src/stm32f30x_usart.c ****   *         @arg USART_IT_RTO:  Receive time out interrupt.
1761:../src/stm32f30x_usart.c ****   *         @arg USART_IT_CTS:  CTS change interrupt.
1762:../src/stm32f30x_usart.c ****   *         @arg USART_IT_LBD:  LIN Break detection interrupt.
1763:../src/stm32f30x_usart.c ****   *         @arg USART_IT_TXE:  Tansmit Data Register empty interrupt.
1764:../src/stm32f30x_usart.c ****   *         @arg USART_IT_TC:  Transmission complete interrupt.
1765:../src/stm32f30x_usart.c ****   *         @arg USART_IT_RXNE:  Receive Data register not empty interrupt.
1766:../src/stm32f30x_usart.c ****   *         @arg USART_IT_IDLE:  Idle line detection interrupt.
1767:../src/stm32f30x_usart.c ****   *         @arg USART_IT_PE:  Parity Error interrupt.
1768:../src/stm32f30x_usart.c ****   *         @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
1769:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the specified USARTx interrupts.
1770:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
1771:../src/stm32f30x_usart.c ****   * @retval None
1772:../src/stm32f30x_usart.c ****   */
1773:../src/stm32f30x_usart.c **** void USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState)
1774:../src/stm32f30x_usart.c **** {
 2360              		.loc 1 1774 0
 2361              		.cfi_startproc
 2362              		@ args = 0, pretend = 0, frame = 32
 2363              		@ frame_needed = 1, uses_anonymous_args = 0
 2364              		@ link register save eliminated.
 2365 0aa8 80B4     		push	{r7}
 2366              	.LCFI126:
 2367              		.cfi_def_cfa_offset 4
 2368              		.cfi_offset 7, -4
 2369 0aaa 89B0     		sub	sp, sp, #36
 2370              	.LCFI127:
 2371              		.cfi_def_cfa_offset 40
 2372 0aac 00AF     		add	r7, sp, #0
 2373              	.LCFI128:
 2374              		.cfi_def_cfa_register 7
 2375 0aae F860     		str	r0, [r7, #12]
 2376 0ab0 B960     		str	r1, [r7, #8]
 2377 0ab2 1346     		mov	r3, r2
 2378 0ab4 FB71     		strb	r3, [r7, #7]
1775:../src/stm32f30x_usart.c ****   uint32_t usartreg = 0, itpos = 0, itmask = 0;
 2379              		.loc 1 1775 0
 2380 0ab6 4FF00003 		mov	r3, #0
 2381 0aba BB61     		str	r3, [r7, #24]
 2382 0abc 4FF00003 		mov	r3, #0
 2383 0ac0 7B61     		str	r3, [r7, #20]
 2384 0ac2 4FF00003 		mov	r3, #0
 2385 0ac6 3B61     		str	r3, [r7, #16]
1776:../src/stm32f30x_usart.c ****   uint32_t usartxbase = 0;
 2386              		.loc 1 1776 0
 2387 0ac8 4FF00003 		mov	r3, #0
 2388 0acc FB61     		str	r3, [r7, #28]
1777:../src/stm32f30x_usart.c ****   /* Check the parameters */
1778:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1779:../src/stm32f30x_usart.c ****   assert_param(IS_USART_CONFIG_IT(USART_IT));
1780:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1781:../src/stm32f30x_usart.c ****   
1782:../src/stm32f30x_usart.c ****   usartxbase = (uint32_t)USARTx;
 2389              		.loc 1 1782 0
 2390 0ace FB68     		ldr	r3, [r7, #12]
 2391 0ad0 FB61     		str	r3, [r7, #28]
1783:../src/stm32f30x_usart.c **** 
1784:../src/stm32f30x_usart.c ****   /* Get the USART register index */
1785:../src/stm32f30x_usart.c ****   usartreg = (((uint16_t)USART_IT) >> 0x08);
 2392              		.loc 1 1785 0
 2393 0ad2 BB68     		ldr	r3, [r7, #8]
 2394 0ad4 9BB2     		uxth	r3, r3
 2395 0ad6 4FEA1323 		lsr	r3, r3, #8
 2396 0ada 9BB2     		uxth	r3, r3
 2397 0adc BB61     		str	r3, [r7, #24]
1786:../src/stm32f30x_usart.c **** 
1787:../src/stm32f30x_usart.c ****   /* Get the interrupt position */
1788:../src/stm32f30x_usart.c ****   itpos = USART_IT & IT_MASK;
 2398              		.loc 1 1788 0
 2399 0ade BB68     		ldr	r3, [r7, #8]
 2400 0ae0 DBB2     		uxtb	r3, r3
 2401 0ae2 7B61     		str	r3, [r7, #20]
1789:../src/stm32f30x_usart.c ****   itmask = (((uint32_t)0x01) << itpos);
 2402              		.loc 1 1789 0
 2403 0ae4 7B69     		ldr	r3, [r7, #20]
 2404 0ae6 4FF00102 		mov	r2, #1
 2405 0aea 02FA03F3 		lsl	r3, r2, r3
 2406 0aee 3B61     		str	r3, [r7, #16]
1790:../src/stm32f30x_usart.c **** 
1791:../src/stm32f30x_usart.c ****   if (usartreg == 0x02) /* The IT is in CR2 register */
 2407              		.loc 1 1791 0
 2408 0af0 BB69     		ldr	r3, [r7, #24]
 2409 0af2 022B     		cmp	r3, #2
 2410 0af4 04D1     		bne	.L97
1792:../src/stm32f30x_usart.c ****   {
1793:../src/stm32f30x_usart.c ****     usartxbase += 0x04;
 2411              		.loc 1 1793 0
 2412 0af6 FB69     		ldr	r3, [r7, #28]
 2413 0af8 03F10403 		add	r3, r3, #4
 2414 0afc FB61     		str	r3, [r7, #28]
 2415 0afe 06E0     		b	.L98
 2416              	.L97:
1794:../src/stm32f30x_usart.c ****   }
1795:../src/stm32f30x_usart.c ****   else if (usartreg == 0x03) /* The IT is in CR3 register */
 2417              		.loc 1 1795 0
 2418 0b00 BB69     		ldr	r3, [r7, #24]
 2419 0b02 032B     		cmp	r3, #3
 2420 0b04 03D1     		bne	.L98
1796:../src/stm32f30x_usart.c ****   {
1797:../src/stm32f30x_usart.c ****     usartxbase += 0x08;
 2421              		.loc 1 1797 0
 2422 0b06 FB69     		ldr	r3, [r7, #28]
 2423 0b08 03F10803 		add	r3, r3, #8
 2424 0b0c FB61     		str	r3, [r7, #28]
 2425              	.L98:
1798:../src/stm32f30x_usart.c ****   }
1799:../src/stm32f30x_usart.c ****   else /* The IT is in CR1 register */
1800:../src/stm32f30x_usart.c ****   {
1801:../src/stm32f30x_usart.c ****   }
1802:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 2426              		.loc 1 1802 0
 2427 0b0e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2428 0b10 002B     		cmp	r3, #0
 2429 0b12 06D0     		beq	.L99
1803:../src/stm32f30x_usart.c ****   {
1804:../src/stm32f30x_usart.c ****     *(__IO uint32_t*)usartxbase  |= itmask;
 2430              		.loc 1 1804 0
 2431 0b14 FB69     		ldr	r3, [r7, #28]
 2432 0b16 FA69     		ldr	r2, [r7, #28]
 2433 0b18 1168     		ldr	r1, [r2, #0]
 2434 0b1a 3A69     		ldr	r2, [r7, #16]
 2435 0b1c 0A43     		orrs	r2, r2, r1
 2436 0b1e 1A60     		str	r2, [r3, #0]
 2437 0b20 07E0     		b	.L96
 2438              	.L99:
1805:../src/stm32f30x_usart.c ****   }
1806:../src/stm32f30x_usart.c ****   else
1807:../src/stm32f30x_usart.c ****   {
1808:../src/stm32f30x_usart.c ****     *(__IO uint32_t*)usartxbase &= ~itmask;
 2439              		.loc 1 1808 0
 2440 0b22 FB69     		ldr	r3, [r7, #28]
 2441 0b24 FA69     		ldr	r2, [r7, #28]
 2442 0b26 1168     		ldr	r1, [r2, #0]
 2443 0b28 3A69     		ldr	r2, [r7, #16]
 2444 0b2a 6FEA0202 		mvn	r2, r2
 2445 0b2e 0A40     		ands	r2, r2, r1
 2446 0b30 1A60     		str	r2, [r3, #0]
 2447              	.L96:
1809:../src/stm32f30x_usart.c ****   }
1810:../src/stm32f30x_usart.c **** }
 2448              		.loc 1 1810 0
 2449 0b32 07F12407 		add	r7, r7, #36
 2450 0b36 BD46     		mov	sp, r7
 2451 0b38 80BC     		pop	{r7}
 2452 0b3a 7047     		bx	lr
 2453              		.cfi_endproc
 2454              	.LFE153:
 2456              		.align	2
 2457              		.global	USART_RequestCmd
 2458              		.thumb
 2459              		.thumb_func
 2461              	USART_RequestCmd:
 2462              	.LFB154:
1811:../src/stm32f30x_usart.c **** 
1812:../src/stm32f30x_usart.c **** /**
1813:../src/stm32f30x_usart.c ****   * @brief  Enables the specified USART's Request.
1814:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1815:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1816:../src/stm32f30x_usart.c ****   * @param  USART_Request: specifies the USART request.
1817:../src/stm32f30x_usart.c ****   *         This parameter can be any combination of the following values:
1818:../src/stm32f30x_usart.c ****   *         @arg USART_Request_TXFRQ: Transmit data flush ReQuest
1819:../src/stm32f30x_usart.c ****   *         @arg USART_Request_RXFRQ: Receive data flush ReQuest
1820:../src/stm32f30x_usart.c ****   *         @arg USART_Request_MMRQ: Mute Mode ReQuest
1821:../src/stm32f30x_usart.c ****   *         @arg USART_Request_SBKRQ: Send Break ReQuest
1822:../src/stm32f30x_usart.c ****   *         @arg USART_Request_ABRRQ: Auto Baud Rate ReQuest
1823:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the DMA interface when reception error occurs.
1824:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.  
1825:../src/stm32f30x_usart.c ****   * @retval None
1826:../src/stm32f30x_usart.c ****   */
1827:../src/stm32f30x_usart.c **** void USART_RequestCmd(USART_TypeDef* USARTx, uint32_t USART_Request, FunctionalState NewState)
1828:../src/stm32f30x_usart.c **** {
 2463              		.loc 1 1828 0
 2464              		.cfi_startproc
 2465              		@ args = 0, pretend = 0, frame = 16
 2466              		@ frame_needed = 1, uses_anonymous_args = 0
 2467              		@ link register save eliminated.
 2468 0b3c 80B4     		push	{r7}
 2469              	.LCFI129:
 2470              		.cfi_def_cfa_offset 4
 2471              		.cfi_offset 7, -4
 2472 0b3e 85B0     		sub	sp, sp, #20
 2473              	.LCFI130:
 2474              		.cfi_def_cfa_offset 24
 2475 0b40 00AF     		add	r7, sp, #0
 2476              	.LCFI131:
 2477              		.cfi_def_cfa_register 7
 2478 0b42 F860     		str	r0, [r7, #12]
 2479 0b44 B960     		str	r1, [r7, #8]
 2480 0b46 1346     		mov	r3, r2
 2481 0b48 FB71     		strb	r3, [r7, #7]
1829:../src/stm32f30x_usart.c ****   /* Check the parameters */
1830:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1831:../src/stm32f30x_usart.c ****   assert_param(IS_USART_REQUEST(USART_Request));
1832:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
1833:../src/stm32f30x_usart.c **** 
1834:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 2482              		.loc 1 1834 0
 2483 0b4a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2484 0b4c 002B     		cmp	r3, #0
 2485 0b4e 09D0     		beq	.L102
1835:../src/stm32f30x_usart.c ****   {
1836:../src/stm32f30x_usart.c ****     /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
1837:../src/stm32f30x_usart.c ****        register.*/
1838:../src/stm32f30x_usart.c ****     USARTx->RQR |= USART_Request;
 2486              		.loc 1 1838 0
 2487 0b50 FB68     		ldr	r3, [r7, #12]
 2488 0b52 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 2489 0b54 9AB2     		uxth	r2, r3
 2490 0b56 BB68     		ldr	r3, [r7, #8]
 2491 0b58 9BB2     		uxth	r3, r3
 2492 0b5a 1343     		orrs	r3, r3, r2
 2493 0b5c 9AB2     		uxth	r2, r3
 2494 0b5e FB68     		ldr	r3, [r7, #12]
 2495 0b60 1A83     		strh	r2, [r3, #24]	@ movhi
 2496 0b62 0BE0     		b	.L101
 2497              	.L102:
1839:../src/stm32f30x_usart.c ****   }
1840:../src/stm32f30x_usart.c ****   else
1841:../src/stm32f30x_usart.c ****   {
1842:../src/stm32f30x_usart.c ****     /* Disable the USART ReQuest by clearing the dedicated request bit in the RQR
1843:../src/stm32f30x_usart.c ****        register.*/
1844:../src/stm32f30x_usart.c ****     USARTx->RQR &= (uint32_t)~USART_Request;
 2498              		.loc 1 1844 0
 2499 0b64 FB68     		ldr	r3, [r7, #12]
 2500 0b66 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 2501 0b68 9AB2     		uxth	r2, r3
 2502 0b6a BB68     		ldr	r3, [r7, #8]
 2503 0b6c 9BB2     		uxth	r3, r3
 2504 0b6e 6FEA0303 		mvn	r3, r3
 2505 0b72 9BB2     		uxth	r3, r3
 2506 0b74 1340     		ands	r3, r3, r2
 2507 0b76 9AB2     		uxth	r2, r3
 2508 0b78 FB68     		ldr	r3, [r7, #12]
 2509 0b7a 1A83     		strh	r2, [r3, #24]	@ movhi
 2510              	.L101:
1845:../src/stm32f30x_usart.c ****   }
1846:../src/stm32f30x_usart.c **** }
 2511              		.loc 1 1846 0
 2512 0b7c 07F11407 		add	r7, r7, #20
 2513 0b80 BD46     		mov	sp, r7
 2514 0b82 80BC     		pop	{r7}
 2515 0b84 7047     		bx	lr
 2516              		.cfi_endproc
 2517              	.LFE154:
 2519 0b86 00BF     		.align	2
 2520              		.global	USART_OverrunDetectionConfig
 2521              		.thumb
 2522              		.thumb_func
 2524              	USART_OverrunDetectionConfig:
 2525              	.LFB155:
1847:../src/stm32f30x_usart.c **** 
1848:../src/stm32f30x_usart.c **** /**
1849:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's Overrun detection.
1850:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1851:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1852:../src/stm32f30x_usart.c ****   * @param  USART_OVRDetection: specifies the OVR detection status in case of OVR error.
1853:../src/stm32f30x_usart.c ****   *         This parameter can be any combination of the following values:
1854:../src/stm32f30x_usart.c ****   *         @arg USART_OVRDetection_Enable: OVR error detection enabled when the USART OVR error 
1855:../src/stm32f30x_usart.c ****   *          is asserted.
1856:../src/stm32f30x_usart.c ****   *         @arg USART_OVRDetection_Disable: OVR error detection disabled when the USART OVR error 
1857:../src/stm32f30x_usart.c ****   *          is asserted.
1858:../src/stm32f30x_usart.c ****   * @retval None
1859:../src/stm32f30x_usart.c ****   */
1860:../src/stm32f30x_usart.c **** void USART_OverrunDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_OVRDetection)
1861:../src/stm32f30x_usart.c **** {
 2526              		.loc 1 1861 0
 2527              		.cfi_startproc
 2528              		@ args = 0, pretend = 0, frame = 8
 2529              		@ frame_needed = 1, uses_anonymous_args = 0
 2530              		@ link register save eliminated.
 2531 0b88 80B4     		push	{r7}
 2532              	.LCFI132:
 2533              		.cfi_def_cfa_offset 4
 2534              		.cfi_offset 7, -4
 2535 0b8a 83B0     		sub	sp, sp, #12
 2536              	.LCFI133:
 2537              		.cfi_def_cfa_offset 16
 2538 0b8c 00AF     		add	r7, sp, #0
 2539              	.LCFI134:
 2540              		.cfi_def_cfa_register 7
 2541 0b8e 7860     		str	r0, [r7, #4]
 2542 0b90 3960     		str	r1, [r7, #0]
1862:../src/stm32f30x_usart.c ****   /* Check the parameters */
1863:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1864:../src/stm32f30x_usart.c ****   assert_param(IS_USART_OVRDETECTION(USART_OVRDetection));
1865:../src/stm32f30x_usart.c ****   
1866:../src/stm32f30x_usart.c ****   /* Clear the OVR detection bit */
1867:../src/stm32f30x_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_OVRDIS);
 2543              		.loc 1 1867 0
 2544 0b92 7B68     		ldr	r3, [r7, #4]
 2545 0b94 9B68     		ldr	r3, [r3, #8]
 2546 0b96 23F48052 		bic	r2, r3, #4096
 2547 0b9a 7B68     		ldr	r3, [r7, #4]
 2548 0b9c 9A60     		str	r2, [r3, #8]
1868:../src/stm32f30x_usart.c ****   /* Set the new value for the OVR detection bit */
1869:../src/stm32f30x_usart.c ****   USARTx->CR3 |= USART_OVRDetection;
 2549              		.loc 1 1869 0
 2550 0b9e 7B68     		ldr	r3, [r7, #4]
 2551 0ba0 9A68     		ldr	r2, [r3, #8]
 2552 0ba2 3B68     		ldr	r3, [r7, #0]
 2553 0ba4 1A43     		orrs	r2, r2, r3
 2554 0ba6 7B68     		ldr	r3, [r7, #4]
 2555 0ba8 9A60     		str	r2, [r3, #8]
1870:../src/stm32f30x_usart.c **** }
 2556              		.loc 1 1870 0
 2557 0baa 07F10C07 		add	r7, r7, #12
 2558 0bae BD46     		mov	sp, r7
 2559 0bb0 80BC     		pop	{r7}
 2560 0bb2 7047     		bx	lr
 2561              		.cfi_endproc
 2562              	.LFE155:
 2564              		.align	2
 2565              		.global	USART_GetFlagStatus
 2566              		.thumb
 2567              		.thumb_func
 2569              	USART_GetFlagStatus:
 2570              	.LFB156:
1871:../src/stm32f30x_usart.c **** 
1872:../src/stm32f30x_usart.c **** /**
1873:../src/stm32f30x_usart.c ****   * @brief  Checks whether the specified USART flag is set or not.
1874:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1875:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1876:../src/stm32f30x_usart.c ****   * @param  USART_FLAG: specifies the flag to check.
1877:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1878:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_REACK:  Receive Enable acknowledge flag.
1879:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_TEACK:  Transmit Enable acknowledge flag.
1880:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_WUF:  Wake up flag.
1881:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_RWU:  Receive Wake up flag.
1882:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_SBK:  Send Break flag.
1883:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_CMF:  Character match flag.
1884:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_BUSY:  Busy flag.
1885:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_ABRF:  Auto baud rate flag.
1886:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_ABRE:  Auto baud rate error flag.
1887:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_EOBF:  End of block flag.
1888:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_RTOF:  Receive time out flag.
1889:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_nCTSS:  Inverted nCTS input bit status.
1890:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_CTS:  CTS Change flag.
1891:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_LBD:  LIN Break detection flag.
1892:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_TXE:  Transmit data register empty flag.
1893:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_TC:  Transmission Complete flag.
1894:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_RXNE:  Receive data register not empty flag.
1895:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_IDLE:  Idle Line detection flag.
1896:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_ORE:  OverRun Error flag.
1897:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_NE:  Noise Error flag.
1898:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_FE:  Framing Error flag.
1899:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_PE:  Parity Error flag.
1900:../src/stm32f30x_usart.c ****   * @retval The new state of USART_FLAG (SET or RESET).
1901:../src/stm32f30x_usart.c ****   */
1902:../src/stm32f30x_usart.c **** FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint32_t USART_FLAG)
1903:../src/stm32f30x_usart.c **** {
 2571              		.loc 1 1903 0
 2572              		.cfi_startproc
 2573              		@ args = 0, pretend = 0, frame = 16
 2574              		@ frame_needed = 1, uses_anonymous_args = 0
 2575              		@ link register save eliminated.
 2576 0bb4 80B4     		push	{r7}
 2577              	.LCFI135:
 2578              		.cfi_def_cfa_offset 4
 2579              		.cfi_offset 7, -4
 2580 0bb6 85B0     		sub	sp, sp, #20
 2581              	.LCFI136:
 2582              		.cfi_def_cfa_offset 24
 2583 0bb8 00AF     		add	r7, sp, #0
 2584              	.LCFI137:
 2585              		.cfi_def_cfa_register 7
 2586 0bba 7860     		str	r0, [r7, #4]
 2587 0bbc 3960     		str	r1, [r7, #0]
1904:../src/stm32f30x_usart.c ****   FlagStatus bitstatus = RESET;
 2588              		.loc 1 1904 0
 2589 0bbe 4FF00003 		mov	r3, #0
 2590 0bc2 FB73     		strb	r3, [r7, #15]
1905:../src/stm32f30x_usart.c ****   /* Check the parameters */
1906:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1907:../src/stm32f30x_usart.c ****   assert_param(IS_USART_FLAG(USART_FLAG));
1908:../src/stm32f30x_usart.c ****   
1909:../src/stm32f30x_usart.c ****   if ((USARTx->ISR & USART_FLAG) != (uint16_t)RESET)
 2591              		.loc 1 1909 0
 2592 0bc4 7B68     		ldr	r3, [r7, #4]
 2593 0bc6 DA69     		ldr	r2, [r3, #28]
 2594 0bc8 3B68     		ldr	r3, [r7, #0]
 2595 0bca 1340     		ands	r3, r3, r2
 2596 0bcc 002B     		cmp	r3, #0
 2597 0bce 03D0     		beq	.L106
1910:../src/stm32f30x_usart.c ****   {
1911:../src/stm32f30x_usart.c ****     bitstatus = SET;
 2598              		.loc 1 1911 0
 2599 0bd0 4FF00103 		mov	r3, #1
 2600 0bd4 FB73     		strb	r3, [r7, #15]
 2601 0bd6 02E0     		b	.L107
 2602              	.L106:
1912:../src/stm32f30x_usart.c ****   }
1913:../src/stm32f30x_usart.c ****   else
1914:../src/stm32f30x_usart.c ****   {
1915:../src/stm32f30x_usart.c ****     bitstatus = RESET;
 2603              		.loc 1 1915 0
 2604 0bd8 4FF00003 		mov	r3, #0
 2605 0bdc FB73     		strb	r3, [r7, #15]
 2606              	.L107:
1916:../src/stm32f30x_usart.c ****   }
1917:../src/stm32f30x_usart.c ****   return bitstatus;
 2607              		.loc 1 1917 0
 2608 0bde FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1918:../src/stm32f30x_usart.c **** }
 2609              		.loc 1 1918 0
 2610 0be0 1846     		mov	r0, r3
 2611 0be2 07F11407 		add	r7, r7, #20
 2612 0be6 BD46     		mov	sp, r7
 2613 0be8 80BC     		pop	{r7}
 2614 0bea 7047     		bx	lr
 2615              		.cfi_endproc
 2616              	.LFE156:
 2618              		.align	2
 2619              		.global	USART_ClearFlag
 2620              		.thumb
 2621              		.thumb_func
 2623              	USART_ClearFlag:
 2624              	.LFB157:
1919:../src/stm32f30x_usart.c **** 
1920:../src/stm32f30x_usart.c **** /**
1921:../src/stm32f30x_usart.c ****   * @brief  Clears the USARTx's pending flags.
1922:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1923:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1924:../src/stm32f30x_usart.c ****   * @param  USART_FLAG: specifies the flag to clear.
1925:../src/stm32f30x_usart.c ****   *         This parameter can be any combination of the following values:
1926:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_WUF:  Wake up flag.
1927:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_CMF:  Character match flag.
1928:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_EOBF:  End of block flag.
1929:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_RTOF:  Receive time out flag.
1930:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_CTS:  CTS Change flag.
1931:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_LBD:  LIN Break detection flag.
1932:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_TC:  Transmission Complete flag.
1933:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_IDLE:  IDLE line detected flag.
1934:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_ORE:  OverRun Error flag.
1935:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_NE: Noise Error flag.
1936:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_FE: Framing Error flag.
1937:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_PE:   Parity Errorflag.
1938:../src/stm32f30x_usart.c ****   *
1939:../src/stm32f30x_usart.c ****   * @note
1940:../src/stm32f30x_usart.c ****   *   - RXNE pending bit is cleared by a read to the USART_RDR register 
1941:../src/stm32f30x_usart.c ****   *     (USART_ReceiveData()) or by writing 1 to the RXFRQ in the register USART_RQR
1942:../src/stm32f30x_usart.c ****   *     (USART_RequestCmd()).
1943:../src/stm32f30x_usart.c ****   *   - TC flag can be also cleared by software sequence: a read operation to 
1944:../src/stm32f30x_usart.c ****   *     USART_SR register (USART_GetFlagStatus()) followed by a write operation
1945:../src/stm32f30x_usart.c ****   *     to USART_TDR register (USART_SendData()).
1946:../src/stm32f30x_usart.c ****   *   - TXE flag is cleared by a write to the USART_TDR register 
1947:../src/stm32f30x_usart.c ****   *     (USART_SendData()) or by writing 1 to the TXFRQ in the register USART_RQR
1948:../src/stm32f30x_usart.c ****   *     (USART_RequestCmd()).
1949:../src/stm32f30x_usart.c ****   *   - SBKF flag is cleared by 1 to the SBKRQ in the register USART_RQR
1950:../src/stm32f30x_usart.c ****   *     (USART_RequestCmd()).
1951:../src/stm32f30x_usart.c ****   * @retval None
1952:../src/stm32f30x_usart.c ****   */
1953:../src/stm32f30x_usart.c **** void USART_ClearFlag(USART_TypeDef* USARTx, uint32_t USART_FLAG)
1954:../src/stm32f30x_usart.c **** {
 2625              		.loc 1 1954 0
 2626              		.cfi_startproc
 2627              		@ args = 0, pretend = 0, frame = 8
 2628              		@ frame_needed = 1, uses_anonymous_args = 0
 2629              		@ link register save eliminated.
 2630 0bec 80B4     		push	{r7}
 2631              	.LCFI138:
 2632              		.cfi_def_cfa_offset 4
 2633              		.cfi_offset 7, -4
 2634 0bee 83B0     		sub	sp, sp, #12
 2635              	.LCFI139:
 2636              		.cfi_def_cfa_offset 16
 2637 0bf0 00AF     		add	r7, sp, #0
 2638              	.LCFI140:
 2639              		.cfi_def_cfa_register 7
 2640 0bf2 7860     		str	r0, [r7, #4]
 2641 0bf4 3960     		str	r1, [r7, #0]
1955:../src/stm32f30x_usart.c ****   /* Check the parameters */
1956:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1957:../src/stm32f30x_usart.c ****   assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
1958:../src/stm32f30x_usart.c ****      
1959:../src/stm32f30x_usart.c ****   USARTx->ICR = USART_FLAG;
 2642              		.loc 1 1959 0
 2643 0bf6 7B68     		ldr	r3, [r7, #4]
 2644 0bf8 3A68     		ldr	r2, [r7, #0]
 2645 0bfa 1A62     		str	r2, [r3, #32]
1960:../src/stm32f30x_usart.c **** }
 2646              		.loc 1 1960 0
 2647 0bfc 07F10C07 		add	r7, r7, #12
 2648 0c00 BD46     		mov	sp, r7
 2649 0c02 80BC     		pop	{r7}
 2650 0c04 7047     		bx	lr
 2651              		.cfi_endproc
 2652              	.LFE157:
 2654 0c06 00BF     		.align	2
 2655              		.global	USART_GetITStatus
 2656              		.thumb
 2657              		.thumb_func
 2659              	USART_GetITStatus:
 2660              	.LFB158:
1961:../src/stm32f30x_usart.c **** 
1962:../src/stm32f30x_usart.c **** /**
1963:../src/stm32f30x_usart.c ****   * @brief  Checks whether the specified USART interrupt has occurred or not.
1964:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1965:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1966:../src/stm32f30x_usart.c ****   * @param  USART_IT: specifies the USART interrupt source to check.
1967:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1968:../src/stm32f30x_usart.c ****   *         @arg USART_IT_WU:  Wake up interrupt.
1969:../src/stm32f30x_usart.c ****   *         @arg USART_IT_CM:  Character match interrupt.
1970:../src/stm32f30x_usart.c ****   *         @arg USART_IT_EOB:  End of block interrupt.
1971:../src/stm32f30x_usart.c ****   *         @arg USART_IT_RTO:  Receive time out interrupt.
1972:../src/stm32f30x_usart.c ****   *         @arg USART_IT_CTS:  CTS change interrupt.
1973:../src/stm32f30x_usart.c ****   *         @arg USART_IT_LBD:  LIN Break detection interrupt.
1974:../src/stm32f30x_usart.c ****   *         @arg USART_IT_TXE:  Tansmit Data Register empty interrupt.
1975:../src/stm32f30x_usart.c ****   *         @arg USART_IT_TC:  Transmission complete interrupt.
1976:../src/stm32f30x_usart.c ****   *         @arg USART_IT_RXNE:  Receive Data register not empty interrupt.
1977:../src/stm32f30x_usart.c ****   *         @arg USART_IT_IDLE:  Idle line detection interrupt.
1978:../src/stm32f30x_usart.c ****   *         @arg USART_IT_ORE:  OverRun Error interrupt.
1979:../src/stm32f30x_usart.c ****   *         @arg USART_IT_NE:  Noise Error interrupt.
1980:../src/stm32f30x_usart.c ****   *         @arg USART_IT_FE:  Framing Error interrupt.
1981:../src/stm32f30x_usart.c ****   *         @arg USART_IT_PE:  Parity Error interrupt.
1982:../src/stm32f30x_usart.c ****   * @retval The new state of USART_IT (SET or RESET).
1983:../src/stm32f30x_usart.c ****   */
1984:../src/stm32f30x_usart.c **** ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint32_t USART_IT)
1985:../src/stm32f30x_usart.c **** {
 2661              		.loc 1 1985 0
 2662              		.cfi_startproc
 2663              		@ args = 0, pretend = 0, frame = 24
 2664              		@ frame_needed = 1, uses_anonymous_args = 0
 2665              		@ link register save eliminated.
 2666 0c08 80B4     		push	{r7}
 2667              	.LCFI141:
 2668              		.cfi_def_cfa_offset 4
 2669              		.cfi_offset 7, -4
 2670 0c0a 87B0     		sub	sp, sp, #28
 2671              	.LCFI142:
 2672              		.cfi_def_cfa_offset 32
 2673 0c0c 00AF     		add	r7, sp, #0
 2674              	.LCFI143:
 2675              		.cfi_def_cfa_register 7
 2676 0c0e 7860     		str	r0, [r7, #4]
 2677 0c10 3960     		str	r1, [r7, #0]
1986:../src/stm32f30x_usart.c ****   uint32_t bitpos = 0, itmask = 0, usartreg = 0;
 2678              		.loc 1 1986 0
 2679 0c12 4FF00003 		mov	r3, #0
 2680 0c16 FB60     		str	r3, [r7, #12]
 2681 0c18 4FF00003 		mov	r3, #0
 2682 0c1c 7B61     		str	r3, [r7, #20]
 2683 0c1e 4FF00003 		mov	r3, #0
 2684 0c22 BB60     		str	r3, [r7, #8]
1987:../src/stm32f30x_usart.c ****   ITStatus bitstatus = RESET;
 2685              		.loc 1 1987 0
 2686 0c24 4FF00003 		mov	r3, #0
 2687 0c28 FB74     		strb	r3, [r7, #19]
1988:../src/stm32f30x_usart.c ****   /* Check the parameters */
1989:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1990:../src/stm32f30x_usart.c ****   assert_param(IS_USART_GET_IT(USART_IT)); 
1991:../src/stm32f30x_usart.c ****   
1992:../src/stm32f30x_usart.c ****   /* Get the USART register index */
1993:../src/stm32f30x_usart.c ****   usartreg = (((uint16_t)USART_IT) >> 0x08);
 2688              		.loc 1 1993 0
 2689 0c2a 3B68     		ldr	r3, [r7, #0]
 2690 0c2c 9BB2     		uxth	r3, r3
 2691 0c2e 4FEA1323 		lsr	r3, r3, #8
 2692 0c32 9BB2     		uxth	r3, r3
 2693 0c34 BB60     		str	r3, [r7, #8]
1994:../src/stm32f30x_usart.c ****   /* Get the interrupt position */
1995:../src/stm32f30x_usart.c ****   itmask = USART_IT & IT_MASK;
 2694              		.loc 1 1995 0
 2695 0c36 3B68     		ldr	r3, [r7, #0]
 2696 0c38 DBB2     		uxtb	r3, r3
 2697 0c3a 7B61     		str	r3, [r7, #20]
1996:../src/stm32f30x_usart.c ****   itmask = (uint32_t)0x01 << itmask;
 2698              		.loc 1 1996 0
 2699 0c3c 7B69     		ldr	r3, [r7, #20]
 2700 0c3e 4FF00102 		mov	r2, #1
 2701 0c42 02FA03F3 		lsl	r3, r2, r3
 2702 0c46 7B61     		str	r3, [r7, #20]
1997:../src/stm32f30x_usart.c ****   
1998:../src/stm32f30x_usart.c ****   if (usartreg == 0x01) /* The IT  is in CR1 register */
 2703              		.loc 1 1998 0
 2704 0c48 BB68     		ldr	r3, [r7, #8]
 2705 0c4a 012B     		cmp	r3, #1
 2706 0c4c 05D1     		bne	.L111
1999:../src/stm32f30x_usart.c ****   {
2000:../src/stm32f30x_usart.c ****     itmask &= USARTx->CR1;
 2707              		.loc 1 2000 0
 2708 0c4e 7B68     		ldr	r3, [r7, #4]
 2709 0c50 1B68     		ldr	r3, [r3, #0]
 2710 0c52 7A69     		ldr	r2, [r7, #20]
 2711 0c54 1340     		ands	r3, r3, r2
 2712 0c56 7B61     		str	r3, [r7, #20]
 2713 0c58 0DE0     		b	.L112
 2714              	.L111:
2001:../src/stm32f30x_usart.c ****   }
2002:../src/stm32f30x_usart.c ****   else if (usartreg == 0x02) /* The IT  is in CR2 register */
 2715              		.loc 1 2002 0
 2716 0c5a BB68     		ldr	r3, [r7, #8]
 2717 0c5c 022B     		cmp	r3, #2
 2718 0c5e 05D1     		bne	.L113
2003:../src/stm32f30x_usart.c ****   {
2004:../src/stm32f30x_usart.c ****     itmask &= USARTx->CR2;
 2719              		.loc 1 2004 0
 2720 0c60 7B68     		ldr	r3, [r7, #4]
 2721 0c62 5B68     		ldr	r3, [r3, #4]
 2722 0c64 7A69     		ldr	r2, [r7, #20]
 2723 0c66 1340     		ands	r3, r3, r2
 2724 0c68 7B61     		str	r3, [r7, #20]
 2725 0c6a 04E0     		b	.L112
 2726              	.L113:
2005:../src/stm32f30x_usart.c ****   }
2006:../src/stm32f30x_usart.c ****   else /* The IT  is in CR3 register */
2007:../src/stm32f30x_usart.c ****   {
2008:../src/stm32f30x_usart.c ****     itmask &= USARTx->CR3;
 2727              		.loc 1 2008 0
 2728 0c6c 7B68     		ldr	r3, [r7, #4]
 2729 0c6e 9B68     		ldr	r3, [r3, #8]
 2730 0c70 7A69     		ldr	r2, [r7, #20]
 2731 0c72 1340     		ands	r3, r3, r2
 2732 0c74 7B61     		str	r3, [r7, #20]
 2733              	.L112:
2009:../src/stm32f30x_usart.c ****   }
2010:../src/stm32f30x_usart.c ****   
2011:../src/stm32f30x_usart.c ****   bitpos = USART_IT >> 0x10;
 2734              		.loc 1 2011 0
 2735 0c76 3B68     		ldr	r3, [r7, #0]
 2736 0c78 4FEA1343 		lsr	r3, r3, #16
 2737 0c7c FB60     		str	r3, [r7, #12]
2012:../src/stm32f30x_usart.c ****   bitpos = (uint32_t)0x01 << bitpos;
 2738              		.loc 1 2012 0
 2739 0c7e FB68     		ldr	r3, [r7, #12]
 2740 0c80 4FF00102 		mov	r2, #1
 2741 0c84 02FA03F3 		lsl	r3, r2, r3
 2742 0c88 FB60     		str	r3, [r7, #12]
2013:../src/stm32f30x_usart.c ****   bitpos &= USARTx->ISR;
 2743              		.loc 1 2013 0
 2744 0c8a 7B68     		ldr	r3, [r7, #4]
 2745 0c8c DB69     		ldr	r3, [r3, #28]
 2746 0c8e FA68     		ldr	r2, [r7, #12]
 2747 0c90 1340     		ands	r3, r3, r2
 2748 0c92 FB60     		str	r3, [r7, #12]
2014:../src/stm32f30x_usart.c ****   if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 2749              		.loc 1 2014 0
 2750 0c94 7B69     		ldr	r3, [r7, #20]
 2751 0c96 002B     		cmp	r3, #0
 2752 0c98 06D0     		beq	.L114
 2753              		.loc 1 2014 0 is_stmt 0 discriminator 1
 2754 0c9a FB68     		ldr	r3, [r7, #12]
 2755 0c9c 002B     		cmp	r3, #0
 2756 0c9e 03D0     		beq	.L114
2015:../src/stm32f30x_usart.c ****   {
2016:../src/stm32f30x_usart.c ****     bitstatus = SET;
 2757              		.loc 1 2016 0 is_stmt 1
 2758 0ca0 4FF00103 		mov	r3, #1
 2759 0ca4 FB74     		strb	r3, [r7, #19]
 2760 0ca6 02E0     		b	.L115
 2761              	.L114:
2017:../src/stm32f30x_usart.c ****   }
2018:../src/stm32f30x_usart.c ****   else
2019:../src/stm32f30x_usart.c ****   {
2020:../src/stm32f30x_usart.c ****     bitstatus = RESET;
 2762              		.loc 1 2020 0
 2763 0ca8 4FF00003 		mov	r3, #0
 2764 0cac FB74     		strb	r3, [r7, #19]
 2765              	.L115:
2021:../src/stm32f30x_usart.c ****   }
2022:../src/stm32f30x_usart.c ****   
2023:../src/stm32f30x_usart.c ****   return bitstatus;  
 2766              		.loc 1 2023 0
 2767 0cae FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
2024:../src/stm32f30x_usart.c **** }
 2768              		.loc 1 2024 0
 2769 0cb0 1846     		mov	r0, r3
 2770 0cb2 07F11C07 		add	r7, r7, #28
 2771 0cb6 BD46     		mov	sp, r7
 2772 0cb8 80BC     		pop	{r7}
 2773 0cba 7047     		bx	lr
 2774              		.cfi_endproc
 2775              	.LFE158:
 2777              		.align	2
 2778              		.global	USART_ClearITPendingBit
 2779              		.thumb
 2780              		.thumb_func
 2782              	USART_ClearITPendingBit:
 2783              	.LFB159:
2025:../src/stm32f30x_usart.c **** 
2026:../src/stm32f30x_usart.c **** /**
2027:../src/stm32f30x_usart.c ****   * @brief  Clears the USARTx's interrupt pending bits.
2028:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
2029:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
2030:../src/stm32f30x_usart.c ****   * @param  USART_IT: specifies the interrupt pending bit to clear.
2031:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
2032:../src/stm32f30x_usart.c ****   *         @arg USART_IT_WU:  Wake up interrupt.
2033:../src/stm32f30x_usart.c ****   *         @arg USART_IT_CM:  Character match interrupt.
2034:../src/stm32f30x_usart.c ****   *         @arg USART_IT_EOB:  End of block interrupt.
2035:../src/stm32f30x_usart.c ****   *         @arg USART_IT_RTO:  Receive time out interrupt.
2036:../src/stm32f30x_usart.c ****   *         @arg USART_IT_CTS:  CTS change interrupt.
2037:../src/stm32f30x_usart.c ****   *         @arg USART_IT_LBD:  LIN Break detection interrupt.
2038:../src/stm32f30x_usart.c ****   *         @arg USART_IT_TC:  Transmission complete interrupt.
2039:../src/stm32f30x_usart.c ****   *         @arg USART_IT_IDLE:  IDLE line detected interrupt.
2040:../src/stm32f30x_usart.c ****   *         @arg USART_IT_ORE:  OverRun Error interrupt.
2041:../src/stm32f30x_usart.c ****   *         @arg USART_IT_NE:  Noise Error interrupt.
2042:../src/stm32f30x_usart.c ****   *         @arg USART_IT_FE:  Framing Error interrupt.
2043:../src/stm32f30x_usart.c ****   *         @arg USART_IT_PE:  Parity Error interrupt.
2044:../src/stm32f30x_usart.c ****   * @note
2045:../src/stm32f30x_usart.c ****   *   - RXNE pending bit is cleared by a read to the USART_RDR register 
2046:../src/stm32f30x_usart.c ****   *     (USART_ReceiveData()) or by writing 1 to the RXFRQ in the register USART_RQR
2047:../src/stm32f30x_usart.c ****   *     (USART_RequestCmd()).
2048:../src/stm32f30x_usart.c ****   *   - TC pending bit can be also cleared by software sequence: a read 
2049:../src/stm32f30x_usart.c ****   *     operation to USART_SR register (USART_GetITStatus()) followed by a write 
2050:../src/stm32f30x_usart.c ****   *     operation to USART_TDR register (USART_SendData()).
2051:../src/stm32f30x_usart.c ****   *   - TXE pending bit is cleared by a write to the USART_TDR register 
2052:../src/stm32f30x_usart.c ****   *     (USART_SendData()) or by writing 1 to the TXFRQ in the register USART_RQR
2053:../src/stm32f30x_usart.c ****   *     (USART_RequestCmd()).
2054:../src/stm32f30x_usart.c ****   * @retval None
2055:../src/stm32f30x_usart.c ****   */
2056:../src/stm32f30x_usart.c **** void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint32_t USART_IT)
2057:../src/stm32f30x_usart.c **** {
 2784              		.loc 1 2057 0
 2785              		.cfi_startproc
 2786              		@ args = 0, pretend = 0, frame = 16
 2787              		@ frame_needed = 1, uses_anonymous_args = 0
 2788              		@ link register save eliminated.
 2789 0cbc 80B4     		push	{r7}
 2790              	.LCFI144:
 2791              		.cfi_def_cfa_offset 4
 2792              		.cfi_offset 7, -4
 2793 0cbe 85B0     		sub	sp, sp, #20
 2794              	.LCFI145:
 2795              		.cfi_def_cfa_offset 24
 2796 0cc0 00AF     		add	r7, sp, #0
 2797              	.LCFI146:
 2798              		.cfi_def_cfa_register 7
 2799 0cc2 7860     		str	r0, [r7, #4]
 2800 0cc4 3960     		str	r1, [r7, #0]
2058:../src/stm32f30x_usart.c ****   uint32_t bitpos = 0, itmask = 0;
 2801              		.loc 1 2058 0
 2802 0cc6 4FF00003 		mov	r3, #0
 2803 0cca FB60     		str	r3, [r7, #12]
 2804 0ccc 4FF00003 		mov	r3, #0
 2805 0cd0 BB60     		str	r3, [r7, #8]
2059:../src/stm32f30x_usart.c ****   /* Check the parameters */
2060:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
2061:../src/stm32f30x_usart.c ****   assert_param(IS_USART_CLEAR_IT(USART_IT)); 
2062:../src/stm32f30x_usart.c ****   
2063:../src/stm32f30x_usart.c ****   bitpos = USART_IT >> 0x10;
 2806              		.loc 1 2063 0
 2807 0cd2 3B68     		ldr	r3, [r7, #0]
 2808 0cd4 4FEA1343 		lsr	r3, r3, #16
 2809 0cd8 FB60     		str	r3, [r7, #12]
2064:../src/stm32f30x_usart.c ****   itmask = ((uint32_t)0x01 << (uint32_t)bitpos);
 2810              		.loc 1 2064 0
 2811 0cda FB68     		ldr	r3, [r7, #12]
 2812 0cdc 4FF00102 		mov	r2, #1
 2813 0ce0 02FA03F3 		lsl	r3, r2, r3
 2814 0ce4 BB60     		str	r3, [r7, #8]
2065:../src/stm32f30x_usart.c ****   USARTx->ICR = (uint32_t)itmask;
 2815              		.loc 1 2065 0
 2816 0ce6 7B68     		ldr	r3, [r7, #4]
 2817 0ce8 BA68     		ldr	r2, [r7, #8]
 2818 0cea 1A62     		str	r2, [r3, #32]
2066:../src/stm32f30x_usart.c **** }
 2819              		.loc 1 2066 0
 2820 0cec 07F11407 		add	r7, r7, #20
 2821 0cf0 BD46     		mov	sp, r7
 2822 0cf2 80BC     		pop	{r7}
 2823 0cf4 7047     		bx	lr
 2824              		.cfi_endproc
 2825              	.LFE159:
 2827              	.Letext0:
 2828              		.file 2 "/home/aghosh01/gcc-arm-none-eabi-4_7-2012q4/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../.
 2829              		.file 3 "/home/aghosh01/Embedded/stm32_dev_wkspace/STM32F3x/inc/stm32f30x.h"
 2830              		.file 4 "/home/aghosh01/Embedded/stm32_dev_wkspace/STM32F3x/inc/stm32f30x_rcc.h"
 2831              		.file 5 "/home/aghosh01/Embedded/stm32_dev_wkspace/STM32F3x/inc/stm32f30x_usart.h"
 2832              		.file 6 "/home/aghosh01/Embedded/stm32_dev_wkspace/STM32F3x/inc/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f30x_usart.c
     /tmp/cc4ENGMW.s:20     .text:00000000 $t
     /tmp/cc4ENGMW.s:25     .text:00000000 USART_DeInit
     /tmp/cc4ENGMW.s:135    .text:000000d8 USART_Init
     /tmp/cc4ENGMW.s:369    .text:00000268 USART_StructInit
     /tmp/cc4ENGMW.s:424    .text:000002ac USART_ClockInit
     /tmp/cc4ENGMW.s:490    .text:000002f8 USART_ClockStructInit
     /tmp/cc4ENGMW.s:537    .text:0000032c USART_Cmd
     /tmp/cc4ENGMW.s:589    .text:00000364 USART_DirectionModeCmd
     /tmp/cc4ENGMW.s:645    .text:000003a0 USART_OverSampling8Cmd
     /tmp/cc4ENGMW.s:697    .text:000003d8 USART_OneBitMethodCmd
     /tmp/cc4ENGMW.s:749    .text:00000410 USART_MSBFirstCmd
     /tmp/cc4ENGMW.s:801    .text:00000448 USART_DataInvCmd
     /tmp/cc4ENGMW.s:853    .text:00000480 USART_InvPinCmd
     /tmp/cc4ENGMW.s:909    .text:000004bc USART_SWAPPinCmd
     /tmp/cc4ENGMW.s:961    .text:000004f4 USART_ReceiverTimeOutCmd
     /tmp/cc4ENGMW.s:1013   .text:0000052c USART_SetReceiverTimeOut
     /tmp/cc4ENGMW.s:1058   .text:00000558 USART_SetPrescaler
     /tmp/cc4ENGMW.s:1109   .text:00000590 USART_STOPModeCmd
     /tmp/cc4ENGMW.s:1161   .text:000005c8 USART_StopModeWakeUpSourceConfig
     /tmp/cc4ENGMW.s:1206   .text:000005f4 USART_AutoBaudRateCmd
     /tmp/cc4ENGMW.s:1258   .text:0000062c USART_AutoBaudRateConfig
     /tmp/cc4ENGMW.s:1303   .text:00000658 USART_SendData
     /tmp/cc4ENGMW.s:1343   .text:00000680 USART_ReceiveData
     /tmp/cc4ENGMW.s:1382   .text:000006a4 USART_SetAddress
     /tmp/cc4ENGMW.s:1429   .text:000006d8 USART_MuteModeCmd
     /tmp/cc4ENGMW.s:1481   .text:00000710 USART_MuteModeWakeUpConfig
     /tmp/cc4ENGMW.s:1526   .text:0000073c USART_AddressDetectionConfig
     /tmp/cc4ENGMW.s:1571   .text:00000768 USART_LINBreakDetectLengthConfig
     /tmp/cc4ENGMW.s:1616   .text:00000794 USART_LINCmd
     /tmp/cc4ENGMW.s:1668   .text:000007cc USART_HalfDuplexCmd
     /tmp/cc4ENGMW.s:1720   .text:00000804 USART_SetGuardTime
     /tmp/cc4ENGMW.s:1773   .text:00000840 USART_SmartCardCmd
     /tmp/cc4ENGMW.s:1825   .text:00000878 USART_SmartCardNACKCmd
     /tmp/cc4ENGMW.s:1877   .text:000008b0 USART_SetAutoRetryCount
     /tmp/cc4ENGMW.s:1924   .text:000008e4 USART_SetBlockLength
     /tmp/cc4ENGMW.s:1971   .text:00000918 USART_IrDAConfig
     /tmp/cc4ENGMW.s:2016   .text:00000944 USART_IrDACmd
     /tmp/cc4ENGMW.s:2068   .text:0000097c USART_DECmd
     /tmp/cc4ENGMW.s:2120   .text:000009b4 USART_DEPolarityConfig
     /tmp/cc4ENGMW.s:2165   .text:000009e0 USART_SetDEAssertionTime
     /tmp/cc4ENGMW.s:2211   .text:00000a10 USART_SetDEDeassertionTime
     /tmp/cc4ENGMW.s:2257   .text:00000a40 USART_DMACmd
     /tmp/cc4ENGMW.s:2313   .text:00000a7c USART_DMAReceptionErrorConfig
     /tmp/cc4ENGMW.s:2358   .text:00000aa8 USART_ITConfig
     /tmp/cc4ENGMW.s:2461   .text:00000b3c USART_RequestCmd
     /tmp/cc4ENGMW.s:2524   .text:00000b88 USART_OverrunDetectionConfig
     /tmp/cc4ENGMW.s:2569   .text:00000bb4 USART_GetFlagStatus
     /tmp/cc4ENGMW.s:2623   .text:00000bec USART_ClearFlag
     /tmp/cc4ENGMW.s:2659   .text:00000c08 USART_GetITStatus
     /tmp/cc4ENGMW.s:2782   .text:00000cbc USART_ClearITPendingBit
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.743cd71370ebc432b539c5dba7924ecc
                           .group:00000000 wm4.stm32f30x.h.56.6f19c65e98e3319a61449cb2b2455af5
                           .group:00000000 wm4.core_cm4.h.32.1434cd257ff5806b1b03cd32ab0641e9
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.core_cmInstr.h.25.d8165482ef3061013a2fc83e2d85f3d9
                           .group:00000000 wm4.core_cm4_simd.h.29.013e5bcf58dba2d27c60184174208e07
                           .group:00000000 wm4.core_cm4.h.155.cf7c793e178943e1bbf613f1b21cd51a
                           .group:00000000 wm4.stm32f30x.h.294.d8a54360eca16e4157694b52a095202d
                           .group:00000000 wm4.stm32f30x_adc.h.130.cbebad91f78fb87381fe0860eea6104e
                           .group:00000000 wm4.stm32f30x_can.h.50.8b8f5d301152c422a6e50622b33ef620
                           .group:00000000 wm4.stm32f30x_crc.h.54.66d4c5e565e18566aebd9abfd4bcd4b0
                           .group:00000000 wm4.stm32f30x_comp.h.91.06ae44150aaaa82c077b71df8db3541a
                           .group:00000000 wm4.stm32f30x_dac.h.49.b1b5b26e4ca241dbe67fa16dc86a615f
                           .group:00000000 wm4.stm32f30x_dbgmcu.h.53.b238a263ce6a2cc83f610cc35302a38b
                           .group:00000000 wm4.stm32f30x_dma.h.96.d7a2ddd10023e12781aa8ff5ac15d212
                           .group:00000000 wm4.stm32f30x_exti.h.60.8ca0809491a21dec6fc69cf7471e2bab
                           .group:00000000 wm4.stm32f30x_flash.h.70.32613455dfe7328932f786a224daac23
                           .group:00000000 wm4.stm32f30x_gpio.h.50.408e1f6250246e4cc28221970909d34c
                           .group:00000000 wm4.stm32f30x_syscfg.h.58.4cadeb4ec8e47d36b972bbb6b96b7161
                           .group:00000000 wm4.stm32f30x_i2c.h.86.3d51d4edc0e3b9ee9aae045ccbb7739a
                           .group:00000000 wm4.stm32f30x_iwdg.h.59.467d704fb073a015941f19b50fa6470a
                           .group:00000000 wm4.stm32f30x_opamp.h.75.704e2e5e2aab039de307aaa2dcc99fa5
                           .group:00000000 wm4.stm32f30x_pwr.h.59.5c85acff2a3e3c5085b2140c06025cfc
                           .group:00000000 wm4.stm32f30x_rcc.h.79.5ba7cac1e74879861a72556c25322aa4
                           .group:00000000 wm4.stm32f30x_rtc.h.133.d184e08ff40bda44db4bed94f9633384
                           .group:00000000 wm4.stm32f30x_spi.h.119.4d21ec94ec14f3553a127e61c0a9874f
                           .group:00000000 wm4.stm32f30x_tim.h.175.d4a93cff2e7924577147254e501271b6
                           .group:00000000 wm4.stm32f30x_wwdg.h.58.4688eee61a2709866472b4b4c07d9275
                           .group:00000000 wm4.stm32f30x_misc.h.113.6a52e4fe7c3825a3ab05990f30dddf92
                           .group:00000000 wm4.stm32f30x_usart.h.110.c89016273702821ff4f9fe43881f70b5

UNDEFINED SYMBOLS
RCC_APB2PeriphResetCmd
RCC_APB1PeriphResetCmd
RCC_GetClocksFreq
