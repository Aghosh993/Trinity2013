   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"stm32f30x_usart.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.align	2
  20              		.global	USART_DeInit
  21              		.thumb
  22              		.thumb_func
  24              	USART_DeInit:
  25              	.LFB111:
  26              		.file 1 "../src/stm32f30x_usart.c"
   1:../src/stm32f30x_usart.c **** /**
   2:../src/stm32f30x_usart.c ****   ******************************************************************************
   3:../src/stm32f30x_usart.c ****   * @file    stm32f30x_usart.c
   4:../src/stm32f30x_usart.c ****   * @author  MCD Application Team
   5:../src/stm32f30x_usart.c ****   * @version V1.0.1
   6:../src/stm32f30x_usart.c ****   * @date    23-October-2012
   7:../src/stm32f30x_usart.c ****   * @brief   This file provides firmware functions to manage the following
   8:../src/stm32f30x_usart.c ****   *          functionalities of the Universal synchronous asynchronous receiver
   9:../src/stm32f30x_usart.c ****   *          transmitter (USART):
  10:../src/stm32f30x_usart.c ****   *           + Initialization and Configuration
  11:../src/stm32f30x_usart.c ****   *           + STOP Mode
  12:../src/stm32f30x_usart.c ****   *           + AutoBaudRate
  13:../src/stm32f30x_usart.c ****   *           + Data transfers
  14:../src/stm32f30x_usart.c ****   *           + Multi-Processor Communication
  15:../src/stm32f30x_usart.c ****   *           + LIN mode
  16:../src/stm32f30x_usart.c ****   *           + Half-duplex mode
  17:../src/stm32f30x_usart.c ****   *           + Smartcard mode
  18:../src/stm32f30x_usart.c ****   *           + IrDA mode
  19:../src/stm32f30x_usart.c ****   *           + RS485 mode  
  20:../src/stm32f30x_usart.c ****   *           + DMA transfers management
  21:../src/stm32f30x_usart.c ****   *           + Interrupts and flags management
  22:../src/stm32f30x_usart.c ****   *           
  23:../src/stm32f30x_usart.c ****   *  @verbatim  
  24:../src/stm32f30x_usart.c ****  ===============================================================================
  25:../src/stm32f30x_usart.c ****                       ##### How to use this driver #####
  26:../src/stm32f30x_usart.c ****  ===============================================================================
  27:../src/stm32f30x_usart.c ****       [..]
  28:../src/stm32f30x_usart.c ****           (#) Enable peripheral clock using RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE)
  29:../src/stm32f30x_usart.c ****              function for USART1 or using RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE)
  30:../src/stm32f30x_usart.c ****              function for USART2, USART3, UART4 and UART5.
  31:../src/stm32f30x_usart.c ****           (#)  According to the USART mode, enable the GPIO clocks using
  32:../src/stm32f30x_usart.c ****               RCC_AHBPeriphClockCmd() function. (The I/O can be TX, RX, CTS,
  33:../src/stm32f30x_usart.c ****               or and SCLK).
  34:../src/stm32f30x_usart.c ****           (#) Peripheral's alternate function:
  35:../src/stm32f30x_usart.c ****               (++) Connect the pin to the desired peripherals' Alternate
  36:../src/stm32f30x_usart.c ****                    Function (AF) using GPIO_PinAFConfig() function.
  37:../src/stm32f30x_usart.c ****               (++) Configure the desired pin in alternate function by:
  38:../src/stm32f30x_usart.c ****                    GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF.
  39:../src/stm32f30x_usart.c ****               (++) Select the type, pull-up/pull-down and output speed via
  40:../src/stm32f30x_usart.c ****                    GPIO_PuPd, GPIO_OType and GPIO_Speed members.
  41:../src/stm32f30x_usart.c ****               (++) Call GPIO_Init() function.
  42:../src/stm32f30x_usart.c ****           (#) Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware
  43:../src/stm32f30x_usart.c ****              flow control and Mode(Receiver/Transmitter) using the SPI_Init()
  44:../src/stm32f30x_usart.c ****              function.
  45:../src/stm32f30x_usart.c ****           (#) For synchronous mode, enable the clock and program the polarity,
  46:../src/stm32f30x_usart.c ****              phase and last bit using the USART_ClockInit() function.
  47:../src/stm32f30x_usart.c ****           (#) Enable the NVIC and the corresponding interrupt using the function
  48:../src/stm32f30x_usart.c ****              USART_ITConfig() if you need to use interrupt mode.
  49:../src/stm32f30x_usart.c ****           (#) When using the DMA mode:
  50:../src/stm32f30x_usart.c ****               (++) Configure the DMA using DMA_Init() function.
  51:../src/stm32f30x_usart.c ****               (++) Active the needed channel Request using USART_DMACmd() function.
  52:../src/stm32f30x_usart.c ****           (#) Enable the USART using the USART_Cmd() function.
  53:../src/stm32f30x_usart.c ****           (#) Enable the DMA using the DMA_Cmd() function, when using DMA mode.
  54:../src/stm32f30x_usart.c ****       [..]
  55:../src/stm32f30x_usart.c ****               Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
  56:../src/stm32f30x_usart.c ****               for more details.
  57:../src/stm32f30x_usart.c **** 
  58:../src/stm32f30x_usart.c ****    @endverbatim
  59:../src/stm32f30x_usart.c **** 
  60:../src/stm32f30x_usart.c ****   ******************************************************************************
  61:../src/stm32f30x_usart.c ****   * @attention
  62:../src/stm32f30x_usart.c ****   *
  63:../src/stm32f30x_usart.c ****   * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
  64:../src/stm32f30x_usart.c ****   *
  65:../src/stm32f30x_usart.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  66:../src/stm32f30x_usart.c ****   * You may not use this file except in compliance with the License.
  67:../src/stm32f30x_usart.c ****   * You may obtain a copy of the License at:
  68:../src/stm32f30x_usart.c ****   *
  69:../src/stm32f30x_usart.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  70:../src/stm32f30x_usart.c ****   *
  71:../src/stm32f30x_usart.c ****   * Unless required by applicable law or agreed to in writing, software 
  72:../src/stm32f30x_usart.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  73:../src/stm32f30x_usart.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  74:../src/stm32f30x_usart.c ****   * See the License for the specific language governing permissions and
  75:../src/stm32f30x_usart.c ****   * limitations under the License.
  76:../src/stm32f30x_usart.c ****   *
  77:../src/stm32f30x_usart.c ****   ******************************************************************************
  78:../src/stm32f30x_usart.c ****   */
  79:../src/stm32f30x_usart.c **** 
  80:../src/stm32f30x_usart.c **** /* Includes ------------------------------------------------------------------*/
  81:../src/stm32f30x_usart.c **** #include "stm32f30x_usart.h"
  82:../src/stm32f30x_usart.c **** #include "stm32f30x_rcc.h"
  83:../src/stm32f30x_usart.c **** 
  84:../src/stm32f30x_usart.c **** /** @addtogroup STM32F30x_StdPeriph_Driver
  85:../src/stm32f30x_usart.c ****   * @{
  86:../src/stm32f30x_usart.c ****   */
  87:../src/stm32f30x_usart.c **** 
  88:../src/stm32f30x_usart.c **** /** @defgroup USART 
  89:../src/stm32f30x_usart.c ****   * @brief USART driver modules
  90:../src/stm32f30x_usart.c ****   * @{
  91:../src/stm32f30x_usart.c ****   */
  92:../src/stm32f30x_usart.c **** 
  93:../src/stm32f30x_usart.c **** /* Private typedef -----------------------------------------------------------*/
  94:../src/stm32f30x_usart.c **** /* Private define ------------------------------------------------------------*/
  95:../src/stm32f30x_usart.c **** 
  96:../src/stm32f30x_usart.c **** /*!< USART CR1 register clear Mask ((~(uint32_t)0xFFFFE6F3)) */
  97:../src/stm32f30x_usart.c **** #define CR1_CLEAR_MASK            ((uint32_t)(USART_CR1_M | USART_CR1_PCE | \
  98:../src/stm32f30x_usart.c ****                                               USART_CR1_PS | USART_CR1_TE | \
  99:../src/stm32f30x_usart.c ****                                               USART_CR1_RE))
 100:../src/stm32f30x_usart.c **** 
 101:../src/stm32f30x_usart.c **** /*!< USART CR2 register clock bits clear Mask ((~(uint32_t)0xFFFFF0FF)) */
 102:../src/stm32f30x_usart.c **** #define CR2_CLOCK_CLEAR_MASK      ((uint32_t)(USART_CR2_CLKEN | USART_CR2_CPOL | \
 103:../src/stm32f30x_usart.c ****                                               USART_CR2_CPHA | USART_CR2_LBCL))
 104:../src/stm32f30x_usart.c **** 
 105:../src/stm32f30x_usart.c **** /*!< USART CR3 register clear Mask ((~(uint32_t)0xFFFFFCFF)) */
 106:../src/stm32f30x_usart.c **** #define CR3_CLEAR_MASK            ((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE))
 107:../src/stm32f30x_usart.c **** 
 108:../src/stm32f30x_usart.c **** /*!< USART Interrupts mask */
 109:../src/stm32f30x_usart.c **** #define IT_MASK                   ((uint32_t)0x000000FF)
 110:../src/stm32f30x_usart.c **** 
 111:../src/stm32f30x_usart.c **** /* Private macro -------------------------------------------------------------*/
 112:../src/stm32f30x_usart.c **** /* Private variables ---------------------------------------------------------*/
 113:../src/stm32f30x_usart.c **** /* Private function prototypes -----------------------------------------------*/
 114:../src/stm32f30x_usart.c **** /* Private functions ---------------------------------------------------------*/
 115:../src/stm32f30x_usart.c **** 
 116:../src/stm32f30x_usart.c **** /** @defgroup USART_Private_Functions
 117:../src/stm32f30x_usart.c ****   * @{
 118:../src/stm32f30x_usart.c ****   */
 119:../src/stm32f30x_usart.c **** 
 120:../src/stm32f30x_usart.c **** /** @defgroup USART_Group1 Initialization and Configuration functions
 121:../src/stm32f30x_usart.c ****  *  @brief   Initialization and Configuration functions 
 122:../src/stm32f30x_usart.c ****  *
 123:../src/stm32f30x_usart.c **** @verbatim 
 124:../src/stm32f30x_usart.c ****  ===============================================================================
 125:../src/stm32f30x_usart.c ****            ##### Initialization and Configuration functions #####
 126:../src/stm32f30x_usart.c ****  ===============================================================================  
 127:../src/stm32f30x_usart.c ****   [..]
 128:../src/stm32f30x_usart.c ****       This subsection provides a set of functions allowing to initialize the USART 
 129:../src/stm32f30x_usart.c ****       in asynchronous and in synchronous modes.
 130:../src/stm32f30x_usart.c ****        (+) For the asynchronous mode only these parameters can be configured: 
 131:../src/stm32f30x_usart.c ****             (++) Baud Rate.
 132:../src/stm32f30x_usart.c ****             (++) Word Length. 
 133:../src/stm32f30x_usart.c ****             (++) Stop Bit.
 134:../src/stm32f30x_usart.c ****             (++) Parity: If the parity is enabled, then the MSB bit of the data written
 135:../src/stm32f30x_usart.c ****                  in the data register is transmitted but is changed by the parity bit.
 136:../src/stm32f30x_usart.c ****                  Depending on the frame length defined by the M bit (8-bits or 9-bits),
 137:../src/stm32f30x_usart.c ****                  the possible USART frame formats are as listed in the following table:
 138:../src/stm32f30x_usart.c ****     [..]
 139:../src/stm32f30x_usart.c ****    +-------------------------------------------------------------+     
 140:../src/stm32f30x_usart.c ****    |   M bit |  PCE bit  |            USART frame                |
 141:../src/stm32f30x_usart.c ****    |---------------------|---------------------------------------|             
 142:../src/stm32f30x_usart.c ****    |    0    |    0      |    | SB | 8 bit data | STB |          |
 143:../src/stm32f30x_usart.c ****    |---------|-----------|---------------------------------------|  
 144:../src/stm32f30x_usart.c ****    |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
 145:../src/stm32f30x_usart.c ****    |---------|-----------|---------------------------------------|  
 146:../src/stm32f30x_usart.c ****    |    1    |    0      |    | SB | 9 bit data | STB |          |
 147:../src/stm32f30x_usart.c ****    |---------|-----------|---------------------------------------|  
 148:../src/stm32f30x_usart.c ****    |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
 149:../src/stm32f30x_usart.c ****    +-------------------------------------------------------------+            
 150:../src/stm32f30x_usart.c ****     [..]
 151:../src/stm32f30x_usart.c ****            (++) Hardware flow control.
 152:../src/stm32f30x_usart.c ****            (++) Receiver/transmitter modes.
 153:../src/stm32f30x_usart.c ****     [..] The USART_Init() function follows the USART  asynchronous configuration 
 154:../src/stm32f30x_usart.c ****          procedure(details for the procedure are available in reference manual.
 155:../src/stm32f30x_usart.c ****         (+) For the synchronous mode in addition to the asynchronous mode parameters
 156:../src/stm32f30x_usart.c ****             these parameters should be also configured:
 157:../src/stm32f30x_usart.c ****             (++) USART Clock Enabled.
 158:../src/stm32f30x_usart.c ****             (++) USART polarity.
 159:../src/stm32f30x_usart.c ****             (++) USART phase.
 160:../src/stm32f30x_usart.c ****             (++) USART LastBit.
 161:../src/stm32f30x_usart.c ****     [..] These parameters can be configured using the USART_ClockInit() function.
 162:../src/stm32f30x_usart.c **** 
 163:../src/stm32f30x_usart.c **** @endverbatim
 164:../src/stm32f30x_usart.c ****   * @{
 165:../src/stm32f30x_usart.c ****   */
 166:../src/stm32f30x_usart.c ****   
 167:../src/stm32f30x_usart.c **** /**
 168:../src/stm32f30x_usart.c ****   * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
 169:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 170:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 171:../src/stm32f30x_usart.c ****   * @retval None
 172:../src/stm32f30x_usart.c ****   */
 173:../src/stm32f30x_usart.c **** void USART_DeInit(USART_TypeDef* USARTx)
 174:../src/stm32f30x_usart.c **** {
  27              		.loc 1 174 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31 0000 80B5     		push	{r7, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  36 0002 82B0     		sub	sp, sp, #8
  37              	.LCFI1:
  38              		.cfi_def_cfa_offset 16
  39 0004 00AF     		add	r7, sp, #0
  40              	.LCFI2:
  41              		.cfi_def_cfa_register 7
  42 0006 7860     		str	r0, [r7, #4]
 175:../src/stm32f30x_usart.c ****   /* Check the parameters */
 176:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 177:../src/stm32f30x_usart.c **** 
 178:../src/stm32f30x_usart.c ****   if (USARTx == USART1)
  43              		.loc 1 178 0
  44 0008 7A68     		ldr	r2, [r7, #4]
  45 000a 4FF46053 		mov	r3, #14336
  46 000e C4F20103 		movt	r3, 16385
  47 0012 9A42     		cmp	r2, r3
  48 0014 0CD1     		bne	.L2
 179:../src/stm32f30x_usart.c ****   {
 180:../src/stm32f30x_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
  49              		.loc 1 180 0
  50 0016 4FF48040 		mov	r0, #16384
  51 001a 4FF00101 		mov	r1, #1
  52 001e FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 181:../src/stm32f30x_usart.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  53              		.loc 1 181 0
  54 0022 4FF48040 		mov	r0, #16384
  55 0026 4FF00001 		mov	r1, #0
  56 002a FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  57 002e 4EE0     		b	.L1
  58              	.L2:
 182:../src/stm32f30x_usart.c ****   }
 183:../src/stm32f30x_usart.c ****   else if (USARTx == USART2)
  59              		.loc 1 183 0
  60 0030 7A68     		ldr	r2, [r7, #4]
  61 0032 4FF48843 		mov	r3, #17408
  62 0036 C4F20003 		movt	r3, 16384
  63 003a 9A42     		cmp	r2, r3
  64 003c 0CD1     		bne	.L4
 184:../src/stm32f30x_usart.c ****   {
 185:../src/stm32f30x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
  65              		.loc 1 185 0
  66 003e 4FF40030 		mov	r0, #131072
  67 0042 4FF00101 		mov	r1, #1
  68 0046 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 186:../src/stm32f30x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  69              		.loc 1 186 0
  70 004a 4FF40030 		mov	r0, #131072
  71 004e 4FF00001 		mov	r1, #0
  72 0052 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  73 0056 3AE0     		b	.L1
  74              	.L4:
 187:../src/stm32f30x_usart.c ****   }
 188:../src/stm32f30x_usart.c ****   else if (USARTx == USART3)
  75              		.loc 1 188 0
  76 0058 7A68     		ldr	r2, [r7, #4]
  77 005a 4FF49043 		mov	r3, #18432
  78 005e C4F20003 		movt	r3, 16384
  79 0062 9A42     		cmp	r2, r3
  80 0064 0CD1     		bne	.L5
 189:../src/stm32f30x_usart.c ****   {
 190:../src/stm32f30x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
  81              		.loc 1 190 0
  82 0066 4FF48020 		mov	r0, #262144
  83 006a 4FF00101 		mov	r1, #1
  84 006e FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 191:../src/stm32f30x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  85              		.loc 1 191 0
  86 0072 4FF48020 		mov	r0, #262144
  87 0076 4FF00001 		mov	r1, #0
  88 007a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  89 007e 26E0     		b	.L1
  90              	.L5:
 192:../src/stm32f30x_usart.c ****   }
 193:../src/stm32f30x_usart.c ****   else if (USARTx == UART4)
  91              		.loc 1 193 0
  92 0080 7A68     		ldr	r2, [r7, #4]
  93 0082 4FF49843 		mov	r3, #19456
  94 0086 C4F20003 		movt	r3, 16384
  95 008a 9A42     		cmp	r2, r3
  96 008c 0CD1     		bne	.L6
 194:../src/stm32f30x_usart.c ****   {
 195:../src/stm32f30x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
  97              		.loc 1 195 0
  98 008e 4FF40020 		mov	r0, #524288
  99 0092 4FF00101 		mov	r1, #1
 100 0096 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 196:../src/stm32f30x_usart.c ****     RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 101              		.loc 1 196 0
 102 009a 4FF40020 		mov	r0, #524288
 103 009e 4FF00001 		mov	r1, #0
 104 00a2 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 105 00a6 12E0     		b	.L1
 106              	.L6:
 197:../src/stm32f30x_usart.c ****   }
 198:../src/stm32f30x_usart.c ****   else
 199:../src/stm32f30x_usart.c ****   {
 200:../src/stm32f30x_usart.c ****     if  (USARTx == UART5)
 107              		.loc 1 200 0
 108 00a8 7A68     		ldr	r2, [r7, #4]
 109 00aa 4FF4A043 		mov	r3, #20480
 110 00ae C4F20003 		movt	r3, 16384
 111 00b2 9A42     		cmp	r2, r3
 112 00b4 0BD1     		bne	.L1
 201:../src/stm32f30x_usart.c ****     {
 202:../src/stm32f30x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 113              		.loc 1 202 0
 114 00b6 4FF48010 		mov	r0, #1048576
 115 00ba 4FF00101 		mov	r1, #1
 116 00be FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 203:../src/stm32f30x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 117              		.loc 1 203 0
 118 00c2 4FF48010 		mov	r0, #1048576
 119 00c6 4FF00001 		mov	r1, #0
 120 00ca FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 121              	.L1:
 204:../src/stm32f30x_usart.c ****     }
 205:../src/stm32f30x_usart.c ****   }
 206:../src/stm32f30x_usart.c **** }
 122              		.loc 1 206 0
 123 00ce 07F10807 		add	r7, r7, #8
 124 00d2 BD46     		mov	sp, r7
 125 00d4 80BD     		pop	{r7, pc}
 126              		.cfi_endproc
 127              	.LFE111:
 129 00d6 00BF     		.align	2
 130              		.global	USART_Init
 131              		.thumb
 132              		.thumb_func
 134              	USART_Init:
 135              	.LFB112:
 207:../src/stm32f30x_usart.c **** 
 208:../src/stm32f30x_usart.c **** /**
 209:../src/stm32f30x_usart.c ****   * @brief  Initializes the USARTx peripheral according to the specified
 210:../src/stm32f30x_usart.c ****   *         parameters in the USART_InitStruct .
 211:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 212:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 213:../src/stm32f30x_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
 214:../src/stm32f30x_usart.c ****   *         that contains the configuration information for the specified USART peripheral.
 215:../src/stm32f30x_usart.c ****   * @retval None
 216:../src/stm32f30x_usart.c ****   */
 217:../src/stm32f30x_usart.c **** void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
 218:../src/stm32f30x_usart.c **** {
 136              		.loc 1 218 0
 137              		.cfi_startproc
 138              		@ args = 0, pretend = 0, frame = 80
 139              		@ frame_needed = 1, uses_anonymous_args = 0
 140 00d8 80B5     		push	{r7, lr}
 141              	.LCFI3:
 142              		.cfi_def_cfa_offset 8
 143              		.cfi_offset 7, -8
 144              		.cfi_offset 14, -4
 145 00da 94B0     		sub	sp, sp, #80
 146              	.LCFI4:
 147              		.cfi_def_cfa_offset 88
 148 00dc 00AF     		add	r7, sp, #0
 149              	.LCFI5:
 150              		.cfi_def_cfa_register 7
 151 00de 7860     		str	r0, [r7, #4]
 152 00e0 3960     		str	r1, [r7, #0]
 219:../src/stm32f30x_usart.c ****   uint32_t divider = 0, apbclock = 0, tmpreg = 0;
 153              		.loc 1 219 0
 154 00e2 4FF00003 		mov	r3, #0
 155 00e6 FB64     		str	r3, [r7, #76]
 156 00e8 4FF00003 		mov	r3, #0
 157 00ec BB64     		str	r3, [r7, #72]
 158 00ee 4FF00003 		mov	r3, #0
 159 00f2 7B64     		str	r3, [r7, #68]
 220:../src/stm32f30x_usart.c ****   RCC_ClocksTypeDef RCC_ClocksStatus;
 221:../src/stm32f30x_usart.c ****   
 222:../src/stm32f30x_usart.c ****   /* Check the parameters */
 223:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 224:../src/stm32f30x_usart.c ****   assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));
 225:../src/stm32f30x_usart.c ****   assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
 226:../src/stm32f30x_usart.c ****   assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
 227:../src/stm32f30x_usart.c ****   assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
 228:../src/stm32f30x_usart.c ****   assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
 229:../src/stm32f30x_usart.c ****   assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
 230:../src/stm32f30x_usart.c ****   
 231:../src/stm32f30x_usart.c ****   /* Disable USART */
 232:../src/stm32f30x_usart.c ****   USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 160              		.loc 1 232 0
 161 00f4 7B68     		ldr	r3, [r7, #4]
 162 00f6 1B68     		ldr	r3, [r3, #0]
 163 00f8 23F00102 		bic	r2, r3, #1
 164 00fc 7B68     		ldr	r3, [r7, #4]
 165 00fe 1A60     		str	r2, [r3, #0]
 233:../src/stm32f30x_usart.c ****   
 234:../src/stm32f30x_usart.c ****   /*---------------------------- USART CR2 Configuration -----------------------*/
 235:../src/stm32f30x_usart.c ****   tmpreg = USARTx->CR2;
 166              		.loc 1 235 0
 167 0100 7B68     		ldr	r3, [r7, #4]
 168 0102 5B68     		ldr	r3, [r3, #4]
 169 0104 7B64     		str	r3, [r7, #68]
 236:../src/stm32f30x_usart.c ****   /* Clear STOP[13:12] bits */
 237:../src/stm32f30x_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 170              		.loc 1 237 0
 171 0106 7B6C     		ldr	r3, [r7, #68]
 172 0108 23F44053 		bic	r3, r3, #12288
 173 010c 7B64     		str	r3, [r7, #68]
 238:../src/stm32f30x_usart.c ****   
 239:../src/stm32f30x_usart.c ****   /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
 240:../src/stm32f30x_usart.c ****   /* Set STOP[13:12] bits according to USART_StopBits value */
 241:../src/stm32f30x_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 174              		.loc 1 241 0
 175 010e 3B68     		ldr	r3, [r7, #0]
 176 0110 9B68     		ldr	r3, [r3, #8]
 177 0112 7A6C     		ldr	r2, [r7, #68]
 178 0114 1343     		orrs	r3, r3, r2
 179 0116 7B64     		str	r3, [r7, #68]
 242:../src/stm32f30x_usart.c ****   
 243:../src/stm32f30x_usart.c ****   /* Write to USART CR2 */
 244:../src/stm32f30x_usart.c ****   USARTx->CR2 = tmpreg;
 180              		.loc 1 244 0
 181 0118 7B68     		ldr	r3, [r7, #4]
 182 011a 7A6C     		ldr	r2, [r7, #68]
 183 011c 5A60     		str	r2, [r3, #4]
 245:../src/stm32f30x_usart.c ****   
 246:../src/stm32f30x_usart.c ****   /*---------------------------- USART CR1 Configuration -----------------------*/
 247:../src/stm32f30x_usart.c ****   tmpreg = USARTx->CR1;
 184              		.loc 1 247 0
 185 011e 7B68     		ldr	r3, [r7, #4]
 186 0120 1B68     		ldr	r3, [r3, #0]
 187 0122 7B64     		str	r3, [r7, #68]
 248:../src/stm32f30x_usart.c ****   /* Clear M, PCE, PS, TE and RE bits */
 249:../src/stm32f30x_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 188              		.loc 1 249 0
 189 0124 7B6C     		ldr	r3, [r7, #68]
 190 0126 23F4B053 		bic	r3, r3, #5632
 191 012a 23F00C03 		bic	r3, r3, #12
 192 012e 7B64     		str	r3, [r7, #68]
 250:../src/stm32f30x_usart.c ****   
 251:../src/stm32f30x_usart.c ****   /* Configure the USART Word Length, Parity and mode ----------------------- */
 252:../src/stm32f30x_usart.c ****   /* Set the M bits according to USART_WordLength value */
 253:../src/stm32f30x_usart.c ****   /* Set PCE and PS bits according to USART_Parity value */
 254:../src/stm32f30x_usart.c ****   /* Set TE and RE bits according to USART_Mode value */
 255:../src/stm32f30x_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 193              		.loc 1 255 0
 194 0130 3B68     		ldr	r3, [r7, #0]
 195 0132 5A68     		ldr	r2, [r3, #4]
 196 0134 3B68     		ldr	r3, [r7, #0]
 197 0136 DB68     		ldr	r3, [r3, #12]
 198 0138 1A43     		orrs	r2, r2, r3
 256:../src/stm32f30x_usart.c ****     USART_InitStruct->USART_Mode;
 199              		.loc 1 256 0
 200 013a 3B68     		ldr	r3, [r7, #0]
 201 013c 1B69     		ldr	r3, [r3, #16]
 255:../src/stm32f30x_usart.c ****   tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 202              		.loc 1 255 0
 203 013e 1343     		orrs	r3, r3, r2
 204 0140 7A6C     		ldr	r2, [r7, #68]
 205 0142 1343     		orrs	r3, r3, r2
 206 0144 7B64     		str	r3, [r7, #68]
 257:../src/stm32f30x_usart.c ****   
 258:../src/stm32f30x_usart.c ****   /* Write to USART CR1 */
 259:../src/stm32f30x_usart.c ****   USARTx->CR1 = tmpreg;
 207              		.loc 1 259 0
 208 0146 7B68     		ldr	r3, [r7, #4]
 209 0148 7A6C     		ldr	r2, [r7, #68]
 210 014a 1A60     		str	r2, [r3, #0]
 260:../src/stm32f30x_usart.c ****   
 261:../src/stm32f30x_usart.c ****   /*---------------------------- USART CR3 Configuration -----------------------*/
 262:../src/stm32f30x_usart.c ****   tmpreg = USARTx->CR3;
 211              		.loc 1 262 0
 212 014c 7B68     		ldr	r3, [r7, #4]
 213 014e 9B68     		ldr	r3, [r3, #8]
 214 0150 7B64     		str	r3, [r7, #68]
 263:../src/stm32f30x_usart.c ****   /* Clear CTSE and RTSE bits */
 264:../src/stm32f30x_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 215              		.loc 1 264 0
 216 0152 7B6C     		ldr	r3, [r7, #68]
 217 0154 23F44073 		bic	r3, r3, #768
 218 0158 7B64     		str	r3, [r7, #68]
 265:../src/stm32f30x_usart.c ****   
 266:../src/stm32f30x_usart.c ****   /* Configure the USART HFC -------------------------------------------------*/
 267:../src/stm32f30x_usart.c ****   /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
 268:../src/stm32f30x_usart.c ****   tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 219              		.loc 1 268 0
 220 015a 3B68     		ldr	r3, [r7, #0]
 221 015c 5B69     		ldr	r3, [r3, #20]
 222 015e 7A6C     		ldr	r2, [r7, #68]
 223 0160 1343     		orrs	r3, r3, r2
 224 0162 7B64     		str	r3, [r7, #68]
 269:../src/stm32f30x_usart.c ****   
 270:../src/stm32f30x_usart.c ****   /* Write to USART CR3 */
 271:../src/stm32f30x_usart.c ****   USARTx->CR3 = tmpreg;
 225              		.loc 1 271 0
 226 0164 7B68     		ldr	r3, [r7, #4]
 227 0166 7A6C     		ldr	r2, [r7, #68]
 228 0168 9A60     		str	r2, [r3, #8]
 272:../src/stm32f30x_usart.c ****   
 273:../src/stm32f30x_usart.c ****   /*---------------------------- USART BRR Configuration -----------------------*/
 274:../src/stm32f30x_usart.c ****   /* Configure the USART Baud Rate -------------------------------------------*/
 275:../src/stm32f30x_usart.c ****   RCC_GetClocksFreq(&RCC_ClocksStatus);
 229              		.loc 1 275 0
 230 016a 07F10803 		add	r3, r7, #8
 231 016e 1846     		mov	r0, r3
 232 0170 FFF7FEFF 		bl	RCC_GetClocksFreq
 276:../src/stm32f30x_usart.c ****   
 277:../src/stm32f30x_usart.c ****   if (USARTx == USART1)
 233              		.loc 1 277 0
 234 0174 7A68     		ldr	r2, [r7, #4]
 235 0176 4FF46053 		mov	r3, #14336
 236 017a C4F20103 		movt	r3, 16385
 237 017e 9A42     		cmp	r2, r3
 238 0180 02D1     		bne	.L8
 278:../src/stm32f30x_usart.c ****   {
 279:../src/stm32f30x_usart.c ****     apbclock = RCC_ClocksStatus.USART1CLK_Frequency;
 239              		.loc 1 279 0
 240 0182 3B6B     		ldr	r3, [r7, #48]
 241 0184 BB64     		str	r3, [r7, #72]
 242 0186 1FE0     		b	.L9
 243              	.L8:
 280:../src/stm32f30x_usart.c ****   }
 281:../src/stm32f30x_usart.c ****   else if (USARTx == USART2)
 244              		.loc 1 281 0
 245 0188 7A68     		ldr	r2, [r7, #4]
 246 018a 4FF48843 		mov	r3, #17408
 247 018e C4F20003 		movt	r3, 16384
 248 0192 9A42     		cmp	r2, r3
 249 0194 02D1     		bne	.L10
 282:../src/stm32f30x_usart.c ****   {
 283:../src/stm32f30x_usart.c ****     apbclock = RCC_ClocksStatus.USART2CLK_Frequency;
 250              		.loc 1 283 0
 251 0196 7B6B     		ldr	r3, [r7, #52]
 252 0198 BB64     		str	r3, [r7, #72]
 253 019a 15E0     		b	.L9
 254              	.L10:
 284:../src/stm32f30x_usart.c ****   }
 285:../src/stm32f30x_usart.c ****   else if (USARTx == USART3)
 255              		.loc 1 285 0
 256 019c 7A68     		ldr	r2, [r7, #4]
 257 019e 4FF49043 		mov	r3, #18432
 258 01a2 C4F20003 		movt	r3, 16384
 259 01a6 9A42     		cmp	r2, r3
 260 01a8 02D1     		bne	.L11
 286:../src/stm32f30x_usart.c ****   {
 287:../src/stm32f30x_usart.c ****     apbclock = RCC_ClocksStatus.USART3CLK_Frequency;
 261              		.loc 1 287 0
 262 01aa BB6B     		ldr	r3, [r7, #56]
 263 01ac BB64     		str	r3, [r7, #72]
 264 01ae 0BE0     		b	.L9
 265              	.L11:
 288:../src/stm32f30x_usart.c ****   }
 289:../src/stm32f30x_usart.c ****   else if (USARTx == UART4)
 266              		.loc 1 289 0
 267 01b0 7A68     		ldr	r2, [r7, #4]
 268 01b2 4FF49843 		mov	r3, #19456
 269 01b6 C4F20003 		movt	r3, 16384
 270 01ba 9A42     		cmp	r2, r3
 271 01bc 02D1     		bne	.L12
 290:../src/stm32f30x_usart.c ****   {
 291:../src/stm32f30x_usart.c ****     apbclock = RCC_ClocksStatus.UART4CLK_Frequency;
 272              		.loc 1 291 0
 273 01be FB6B     		ldr	r3, [r7, #60]
 274 01c0 BB64     		str	r3, [r7, #72]
 275 01c2 01E0     		b	.L9
 276              	.L12:
 292:../src/stm32f30x_usart.c ****   }
 293:../src/stm32f30x_usart.c ****   else 
 294:../src/stm32f30x_usart.c ****   {
 295:../src/stm32f30x_usart.c ****     apbclock = RCC_ClocksStatus.UART5CLK_Frequency;
 277              		.loc 1 295 0
 278 01c4 3B6C     		ldr	r3, [r7, #64]
 279 01c6 BB64     		str	r3, [r7, #72]
 280              	.L9:
 296:../src/stm32f30x_usart.c ****   }  
 297:../src/stm32f30x_usart.c ****   
 298:../src/stm32f30x_usart.c ****   /* Determine the integer part */
 299:../src/stm32f30x_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 281              		.loc 1 299 0
 282 01c8 7B68     		ldr	r3, [r7, #4]
 283 01ca 1B68     		ldr	r3, [r3, #0]
 284 01cc 03F40043 		and	r3, r3, #32768
 285 01d0 002B     		cmp	r3, #0
 286 01d2 13D0     		beq	.L13
 300:../src/stm32f30x_usart.c ****   {
 301:../src/stm32f30x_usart.c ****     /* (divider * 10) computing in case Oversampling mode is 8 Samples */
 302:../src/stm32f30x_usart.c ****     divider = (uint32_t)((2 * apbclock) / (USART_InitStruct->USART_BaudRate));
 287              		.loc 1 302 0
 288 01d4 BB6C     		ldr	r3, [r7, #72]
 289 01d6 4FEA4302 		lsl	r2, r3, #1
 290 01da 3B68     		ldr	r3, [r7, #0]
 291 01dc 1B68     		ldr	r3, [r3, #0]
 292 01de B2FBF3F3 		udiv	r3, r2, r3
 293 01e2 FB64     		str	r3, [r7, #76]
 303:../src/stm32f30x_usart.c ****     tmpreg  = (uint32_t)((2 * apbclock) % (USART_InitStruct->USART_BaudRate));
 294              		.loc 1 303 0
 295 01e4 BB6C     		ldr	r3, [r7, #72]
 296 01e6 4FEA4303 		lsl	r3, r3, #1
 297 01ea 3A68     		ldr	r2, [r7, #0]
 298 01ec 1268     		ldr	r2, [r2, #0]
 299 01ee B3FBF2F1 		udiv	r1, r3, r2
 300 01f2 02FB01F2 		mul	r2, r2, r1
 301 01f6 9B1A     		subs	r3, r3, r2
 302 01f8 7B64     		str	r3, [r7, #68]
 303 01fa 0EE0     		b	.L14
 304              	.L13:
 304:../src/stm32f30x_usart.c ****   }
 305:../src/stm32f30x_usart.c ****   else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
 306:../src/stm32f30x_usart.c ****   {
 307:../src/stm32f30x_usart.c ****     /* (divider * 10) computing in case Oversampling mode is 16 Samples */
 308:../src/stm32f30x_usart.c ****     divider = (uint32_t)((apbclock) / (USART_InitStruct->USART_BaudRate));
 305              		.loc 1 308 0
 306 01fc 3B68     		ldr	r3, [r7, #0]
 307 01fe 1B68     		ldr	r3, [r3, #0]
 308 0200 BA6C     		ldr	r2, [r7, #72]
 309 0202 B2FBF3F3 		udiv	r3, r2, r3
 310 0206 FB64     		str	r3, [r7, #76]
 309:../src/stm32f30x_usart.c ****     tmpreg  = (uint32_t)((apbclock) % (USART_InitStruct->USART_BaudRate));
 311              		.loc 1 309 0
 312 0208 3B68     		ldr	r3, [r7, #0]
 313 020a 1A68     		ldr	r2, [r3, #0]
 314 020c BB6C     		ldr	r3, [r7, #72]
 315 020e B3FBF2F1 		udiv	r1, r3, r2
 316 0212 02FB01F2 		mul	r2, r2, r1
 317 0216 9B1A     		subs	r3, r3, r2
 318 0218 7B64     		str	r3, [r7, #68]
 319              	.L14:
 310:../src/stm32f30x_usart.c ****   }
 311:../src/stm32f30x_usart.c ****   
 312:../src/stm32f30x_usart.c ****   /* round the divider : if fractional part i greater than 0.5 increment divider */
 313:../src/stm32f30x_usart.c ****   if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
 320              		.loc 1 313 0
 321 021a 3B68     		ldr	r3, [r7, #0]
 322 021c 1B68     		ldr	r3, [r3, #0]
 323 021e 4FEA5302 		lsr	r2, r3, #1
 324 0222 7B6C     		ldr	r3, [r7, #68]
 325 0224 9A42     		cmp	r2, r3
 326 0226 03D8     		bhi	.L15
 314:../src/stm32f30x_usart.c ****   {
 315:../src/stm32f30x_usart.c ****     divider++;
 327              		.loc 1 315 0
 328 0228 FB6C     		ldr	r3, [r7, #76]
 329 022a 03F10103 		add	r3, r3, #1
 330 022e FB64     		str	r3, [r7, #76]
 331              	.L15:
 316:../src/stm32f30x_usart.c ****   } 
 317:../src/stm32f30x_usart.c ****   
 318:../src/stm32f30x_usart.c ****   /* Implement the divider in case Oversampling mode is 8 Samples */
 319:../src/stm32f30x_usart.c ****   if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 332              		.loc 1 319 0
 333 0230 7B68     		ldr	r3, [r7, #4]
 334 0232 1B68     		ldr	r3, [r3, #0]
 335 0234 03F40043 		and	r3, r3, #32768
 336 0238 002B     		cmp	r3, #0
 337 023a 0CD0     		beq	.L16
 320:../src/stm32f30x_usart.c ****   {
 321:../src/stm32f30x_usart.c ****     /* get the LSB of divider and shift it to the right by 1 bit */
 322:../src/stm32f30x_usart.c ****     tmpreg = (divider & (uint16_t)0x000F) >> 1;
 338              		.loc 1 322 0
 339 023c FB6C     		ldr	r3, [r7, #76]
 340 023e 03F00F03 		and	r3, r3, #15
 341 0242 4FEA5303 		lsr	r3, r3, #1
 342 0246 7B64     		str	r3, [r7, #68]
 323:../src/stm32f30x_usart.c ****     
 324:../src/stm32f30x_usart.c ****     /* update the divider value */
 325:../src/stm32f30x_usart.c ****     divider = (divider & (uint16_t)0xFFF0) | tmpreg;
 343              		.loc 1 325 0
 344 0248 FA6C     		ldr	r2, [r7, #76]
 345 024a 4FF6F073 		movw	r3, #65520
 346 024e 1340     		ands	r3, r3, r2
 347 0250 7A6C     		ldr	r2, [r7, #68]
 348 0252 1343     		orrs	r3, r3, r2
 349 0254 FB64     		str	r3, [r7, #76]
 350              	.L16:
 326:../src/stm32f30x_usart.c ****   }
 327:../src/stm32f30x_usart.c ****   
 328:../src/stm32f30x_usart.c ****   /* Write to USART BRR */
 329:../src/stm32f30x_usart.c ****   USARTx->BRR = (uint16_t)divider;
 351              		.loc 1 329 0
 352 0256 FB6C     		ldr	r3, [r7, #76]
 353 0258 9AB2     		uxth	r2, r3
 354 025a 7B68     		ldr	r3, [r7, #4]
 355 025c 9A81     		strh	r2, [r3, #12]	@ movhi
 330:../src/stm32f30x_usart.c **** }
 356              		.loc 1 330 0
 357 025e 07F15007 		add	r7, r7, #80
 358 0262 BD46     		mov	sp, r7
 359 0264 80BD     		pop	{r7, pc}
 360              		.cfi_endproc
 361              	.LFE112:
 363 0266 00BF     		.align	2
 364              		.global	USART_StructInit
 365              		.thumb
 366              		.thumb_func
 368              	USART_StructInit:
 369              	.LFB113:
 331:../src/stm32f30x_usart.c **** 
 332:../src/stm32f30x_usart.c **** /**
 333:../src/stm32f30x_usart.c ****   * @brief  Fills each USART_InitStruct member with its default value.
 334:../src/stm32f30x_usart.c ****   * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
 335:../src/stm32f30x_usart.c ****   *         which will be initialized.
 336:../src/stm32f30x_usart.c ****   * @retval None
 337:../src/stm32f30x_usart.c ****   */
 338:../src/stm32f30x_usart.c **** void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
 339:../src/stm32f30x_usart.c **** {
 370              		.loc 1 339 0
 371              		.cfi_startproc
 372              		@ args = 0, pretend = 0, frame = 8
 373              		@ frame_needed = 1, uses_anonymous_args = 0
 374              		@ link register save eliminated.
 375 0268 80B4     		push	{r7}
 376              	.LCFI6:
 377              		.cfi_def_cfa_offset 4
 378              		.cfi_offset 7, -4
 379 026a 83B0     		sub	sp, sp, #12
 380              	.LCFI7:
 381              		.cfi_def_cfa_offset 16
 382 026c 00AF     		add	r7, sp, #0
 383              	.LCFI8:
 384              		.cfi_def_cfa_register 7
 385 026e 7860     		str	r0, [r7, #4]
 340:../src/stm32f30x_usart.c ****   /* USART_InitStruct members default value */
 341:../src/stm32f30x_usart.c ****   USART_InitStruct->USART_BaudRate = 9600;
 386              		.loc 1 341 0
 387 0270 7B68     		ldr	r3, [r7, #4]
 388 0272 4FF41652 		mov	r2, #9600
 389 0276 1A60     		str	r2, [r3, #0]
 342:../src/stm32f30x_usart.c ****   USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 390              		.loc 1 342 0
 391 0278 7B68     		ldr	r3, [r7, #4]
 392 027a 4FF00002 		mov	r2, #0
 393 027e 5A60     		str	r2, [r3, #4]
 343:../src/stm32f30x_usart.c ****   USART_InitStruct->USART_StopBits = USART_StopBits_1;
 394              		.loc 1 343 0
 395 0280 7B68     		ldr	r3, [r7, #4]
 396 0282 4FF00002 		mov	r2, #0
 397 0286 9A60     		str	r2, [r3, #8]
 344:../src/stm32f30x_usart.c ****   USART_InitStruct->USART_Parity = USART_Parity_No ;
 398              		.loc 1 344 0
 399 0288 7B68     		ldr	r3, [r7, #4]
 400 028a 4FF00002 		mov	r2, #0
 401 028e DA60     		str	r2, [r3, #12]
 345:../src/stm32f30x_usart.c ****   USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 402              		.loc 1 345 0
 403 0290 7B68     		ldr	r3, [r7, #4]
 404 0292 4FF00C02 		mov	r2, #12
 405 0296 1A61     		str	r2, [r3, #16]
 346:../src/stm32f30x_usart.c ****   USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 406              		.loc 1 346 0
 407 0298 7B68     		ldr	r3, [r7, #4]
 408 029a 4FF00002 		mov	r2, #0
 409 029e 5A61     		str	r2, [r3, #20]
 347:../src/stm32f30x_usart.c **** }
 410              		.loc 1 347 0
 411 02a0 07F10C07 		add	r7, r7, #12
 412 02a4 BD46     		mov	sp, r7
 413 02a6 80BC     		pop	{r7}
 414 02a8 7047     		bx	lr
 415              		.cfi_endproc
 416              	.LFE113:
 418 02aa 00BF     		.align	2
 419              		.global	USART_ClockInit
 420              		.thumb
 421              		.thumb_func
 423              	USART_ClockInit:
 424              	.LFB114:
 348:../src/stm32f30x_usart.c **** 
 349:../src/stm32f30x_usart.c **** /**
 350:../src/stm32f30x_usart.c ****   * @brief  Initializes the USARTx peripheral Clock according to the
 351:../src/stm32f30x_usart.c ****   *         specified parameters in the USART_ClockInitStruct.
 352:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the
 353:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3.
 354:../src/stm32f30x_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
 355:../src/stm32f30x_usart.c ****   *         structure that contains the configuration information for the specified
 356:../src/stm32f30x_usart.c ****   *         USART peripheral.
 357:../src/stm32f30x_usart.c ****   * @retval None
 358:../src/stm32f30x_usart.c ****   */
 359:../src/stm32f30x_usart.c **** void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
 360:../src/stm32f30x_usart.c **** {
 425              		.loc 1 360 0
 426              		.cfi_startproc
 427              		@ args = 0, pretend = 0, frame = 16
 428              		@ frame_needed = 1, uses_anonymous_args = 0
 429              		@ link register save eliminated.
 430 02ac 80B4     		push	{r7}
 431              	.LCFI9:
 432              		.cfi_def_cfa_offset 4
 433              		.cfi_offset 7, -4
 434 02ae 85B0     		sub	sp, sp, #20
 435              	.LCFI10:
 436              		.cfi_def_cfa_offset 24
 437 02b0 00AF     		add	r7, sp, #0
 438              	.LCFI11:
 439              		.cfi_def_cfa_register 7
 440 02b2 7860     		str	r0, [r7, #4]
 441 02b4 3960     		str	r1, [r7, #0]
 361:../src/stm32f30x_usart.c ****   uint32_t tmpreg = 0;
 442              		.loc 1 361 0
 443 02b6 4FF00003 		mov	r3, #0
 444 02ba FB60     		str	r3, [r7, #12]
 362:../src/stm32f30x_usart.c ****   /* Check the parameters */
 363:../src/stm32f30x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 364:../src/stm32f30x_usart.c ****   assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
 365:../src/stm32f30x_usart.c ****   assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
 366:../src/stm32f30x_usart.c ****   assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
 367:../src/stm32f30x_usart.c ****   assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
 368:../src/stm32f30x_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 369:../src/stm32f30x_usart.c ****   tmpreg = USARTx->CR2;
 445              		.loc 1 369 0
 446 02bc 7B68     		ldr	r3, [r7, #4]
 447 02be 5B68     		ldr	r3, [r3, #4]
 448 02c0 FB60     		str	r3, [r7, #12]
 370:../src/stm32f30x_usart.c ****   /* Clear CLKEN, CPOL, CPHA, LBCL and SSM bits */
 371:../src/stm32f30x_usart.c ****   tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 449              		.loc 1 371 0
 450 02c2 FB68     		ldr	r3, [r7, #12]
 451 02c4 23F47063 		bic	r3, r3, #3840
 452 02c8 FB60     		str	r3, [r7, #12]
 372:../src/stm32f30x_usart.c ****   /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
 373:../src/stm32f30x_usart.c ****   /* Set CLKEN bit according to USART_Clock value */
 374:../src/stm32f30x_usart.c ****   /* Set CPOL bit according to USART_CPOL value */
 375:../src/stm32f30x_usart.c ****   /* Set CPHA bit according to USART_CPHA value */
 376:../src/stm32f30x_usart.c ****   /* Set LBCL bit according to USART_LastBit value */
 377:../src/stm32f30x_usart.c ****   tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 453              		.loc 1 377 0
 454 02ca 3B68     		ldr	r3, [r7, #0]
 455 02cc 1A68     		ldr	r2, [r3, #0]
 456 02ce 3B68     		ldr	r3, [r7, #0]
 457 02d0 5B68     		ldr	r3, [r3, #4]
 458 02d2 1A43     		orrs	r2, r2, r3
 378:../src/stm32f30x_usart.c ****                        USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit);
 459              		.loc 1 378 0
 460 02d4 3B68     		ldr	r3, [r7, #0]
 461 02d6 9B68     		ldr	r3, [r3, #8]
 377:../src/stm32f30x_usart.c ****   tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 462              		.loc 1 377 0
 463 02d8 1A43     		orrs	r2, r2, r3
 464              		.loc 1 378 0
 465 02da 3B68     		ldr	r3, [r7, #0]
 466 02dc DB68     		ldr	r3, [r3, #12]
 377:../src/stm32f30x_usart.c ****   tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 467              		.loc 1 377 0
 468 02de 1343     		orrs	r3, r3, r2
 469 02e0 FA68     		ldr	r2, [r7, #12]
 470 02e2 1343     		orrs	r3, r3, r2
 471 02e4 FB60     		str	r3, [r7, #12]
 379:../src/stm32f30x_usart.c ****   /* Write to USART CR2 */
 380:../src/stm32f30x_usart.c ****   USARTx->CR2 = tmpreg;
 472              		.loc 1 380 0
 473 02e6 7B68     		ldr	r3, [r7, #4]
 474 02e8 FA68     		ldr	r2, [r7, #12]
 475 02ea 5A60     		str	r2, [r3, #4]
 381:../src/stm32f30x_usart.c **** }
 476              		.loc 1 381 0
 477 02ec 07F11407 		add	r7, r7, #20
 478 02f0 BD46     		mov	sp, r7
 479 02f2 80BC     		pop	{r7}
 480 02f4 7047     		bx	lr
 481              		.cfi_endproc
 482              	.LFE114:
 484 02f6 00BF     		.align	2
 485              		.global	USART_ClockStructInit
 486              		.thumb
 487              		.thumb_func
 489              	USART_ClockStructInit:
 490              	.LFB115:
 382:../src/stm32f30x_usart.c **** 
 383:../src/stm32f30x_usart.c **** /**
 384:../src/stm32f30x_usart.c ****   * @brief  Fills each USART_ClockInitStruct member with its default value.
 385:../src/stm32f30x_usart.c ****   * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
 386:../src/stm32f30x_usart.c ****   *         structure which will be initialized.
 387:../src/stm32f30x_usart.c ****   * @retval None
 388:../src/stm32f30x_usart.c ****   */
 389:../src/stm32f30x_usart.c **** void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
 390:../src/stm32f30x_usart.c **** {
 491              		.loc 1 390 0
 492              		.cfi_startproc
 493              		@ args = 0, pretend = 0, frame = 8
 494              		@ frame_needed = 1, uses_anonymous_args = 0
 495              		@ link register save eliminated.
 496 02f8 80B4     		push	{r7}
 497              	.LCFI12:
 498              		.cfi_def_cfa_offset 4
 499              		.cfi_offset 7, -4
 500 02fa 83B0     		sub	sp, sp, #12
 501              	.LCFI13:
 502              		.cfi_def_cfa_offset 16
 503 02fc 00AF     		add	r7, sp, #0
 504              	.LCFI14:
 505              		.cfi_def_cfa_register 7
 506 02fe 7860     		str	r0, [r7, #4]
 391:../src/stm32f30x_usart.c ****   /* USART_ClockInitStruct members default value */
 392:../src/stm32f30x_usart.c ****   USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 507              		.loc 1 392 0
 508 0300 7B68     		ldr	r3, [r7, #4]
 509 0302 4FF00002 		mov	r2, #0
 510 0306 1A60     		str	r2, [r3, #0]
 393:../src/stm32f30x_usart.c ****   USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 511              		.loc 1 393 0
 512 0308 7B68     		ldr	r3, [r7, #4]
 513 030a 4FF00002 		mov	r2, #0
 514 030e 5A60     		str	r2, [r3, #4]
 394:../src/stm32f30x_usart.c ****   USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 515              		.loc 1 394 0
 516 0310 7B68     		ldr	r3, [r7, #4]
 517 0312 4FF00002 		mov	r2, #0
 518 0316 9A60     		str	r2, [r3, #8]
 395:../src/stm32f30x_usart.c ****   USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 519              		.loc 1 395 0
 520 0318 7B68     		ldr	r3, [r7, #4]
 521 031a 4FF00002 		mov	r2, #0
 522 031e DA60     		str	r2, [r3, #12]
 396:../src/stm32f30x_usart.c **** }
 523              		.loc 1 396 0
 524 0320 07F10C07 		add	r7, r7, #12
 525 0324 BD46     		mov	sp, r7
 526 0326 80BC     		pop	{r7}
 527 0328 7047     		bx	lr
 528              		.cfi_endproc
 529              	.LFE115:
 531 032a 00BF     		.align	2
 532              		.global	USART_Cmd
 533              		.thumb
 534              		.thumb_func
 536              	USART_Cmd:
 537              	.LFB116:
 397:../src/stm32f30x_usart.c **** 
 398:../src/stm32f30x_usart.c **** /**
 399:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the specified USART peripheral.
 400:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the
 401:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 402:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USARTx peripheral.
 403:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 404:../src/stm32f30x_usart.c ****   * @retval None
 405:../src/stm32f30x_usart.c ****   */
 406:../src/stm32f30x_usart.c **** void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 407:../src/stm32f30x_usart.c **** {
 538              		.loc 1 407 0
 539              		.cfi_startproc
 540              		@ args = 0, pretend = 0, frame = 8
 541              		@ frame_needed = 1, uses_anonymous_args = 0
 542              		@ link register save eliminated.
 543 032c 80B4     		push	{r7}
 544              	.LCFI15:
 545              		.cfi_def_cfa_offset 4
 546              		.cfi_offset 7, -4
 547 032e 83B0     		sub	sp, sp, #12
 548              	.LCFI16:
 549              		.cfi_def_cfa_offset 16
 550 0330 00AF     		add	r7, sp, #0
 551              	.LCFI17:
 552              		.cfi_def_cfa_register 7
 553 0332 7860     		str	r0, [r7, #4]
 554 0334 0B46     		mov	r3, r1
 555 0336 FB70     		strb	r3, [r7, #3]
 408:../src/stm32f30x_usart.c ****   /* Check the parameters */
 409:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 410:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 411:../src/stm32f30x_usart.c ****   
 412:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 556              		.loc 1 412 0
 557 0338 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 558 033a 002B     		cmp	r3, #0
 559 033c 06D0     		beq	.L21
 413:../src/stm32f30x_usart.c ****   {
 414:../src/stm32f30x_usart.c ****     /* Enable the selected USART by setting the UE bit in the CR1 register */
 415:../src/stm32f30x_usart.c ****     USARTx->CR1 |= USART_CR1_UE;
 560              		.loc 1 415 0
 561 033e 7B68     		ldr	r3, [r7, #4]
 562 0340 1B68     		ldr	r3, [r3, #0]
 563 0342 43F00102 		orr	r2, r3, #1
 564 0346 7B68     		ldr	r3, [r7, #4]
 565 0348 1A60     		str	r2, [r3, #0]
 566 034a 05E0     		b	.L20
 567              	.L21:
 416:../src/stm32f30x_usart.c ****   }
 417:../src/stm32f30x_usart.c ****   else
 418:../src/stm32f30x_usart.c ****   {
 419:../src/stm32f30x_usart.c ****     /* Disable the selected USART by clearing the UE bit in the CR1 register */
 420:../src/stm32f30x_usart.c ****     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 568              		.loc 1 420 0
 569 034c 7B68     		ldr	r3, [r7, #4]
 570 034e 1B68     		ldr	r3, [r3, #0]
 571 0350 23F00102 		bic	r2, r3, #1
 572 0354 7B68     		ldr	r3, [r7, #4]
 573 0356 1A60     		str	r2, [r3, #0]
 574              	.L20:
 421:../src/stm32f30x_usart.c ****   }
 422:../src/stm32f30x_usart.c **** }
 575              		.loc 1 422 0
 576 0358 07F10C07 		add	r7, r7, #12
 577 035c BD46     		mov	sp, r7
 578 035e 80BC     		pop	{r7}
 579 0360 7047     		bx	lr
 580              		.cfi_endproc
 581              	.LFE116:
 583 0362 00BF     		.align	2
 584              		.global	USART_DirectionModeCmd
 585              		.thumb
 586              		.thumb_func
 588              	USART_DirectionModeCmd:
 589              	.LFB117:
 423:../src/stm32f30x_usart.c **** 
 424:../src/stm32f30x_usart.c **** /**
 425:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's transmitter or receiver.
 426:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 427:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 428:../src/stm32f30x_usart.c ****   * @param  USART_Direction: specifies the USART direction.
 429:../src/stm32f30x_usart.c ****   *         This parameter can be any combination of the following values:
 430:../src/stm32f30x_usart.c ****   *         @arg USART_Mode_Tx: USART Transmitter
 431:../src/stm32f30x_usart.c ****   *         @arg USART_Mode_Rx: USART Receiver
 432:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USART transfer direction.
 433:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.  
 434:../src/stm32f30x_usart.c ****   * @retval None
 435:../src/stm32f30x_usart.c ****   */
 436:../src/stm32f30x_usart.c **** void USART_DirectionModeCmd(USART_TypeDef* USARTx, uint32_t USART_DirectionMode, FunctionalState Ne
 437:../src/stm32f30x_usart.c **** {
 590              		.loc 1 437 0
 591              		.cfi_startproc
 592              		@ args = 0, pretend = 0, frame = 16
 593              		@ frame_needed = 1, uses_anonymous_args = 0
 594              		@ link register save eliminated.
 595 0364 80B4     		push	{r7}
 596              	.LCFI18:
 597              		.cfi_def_cfa_offset 4
 598              		.cfi_offset 7, -4
 599 0366 85B0     		sub	sp, sp, #20
 600              	.LCFI19:
 601              		.cfi_def_cfa_offset 24
 602 0368 00AF     		add	r7, sp, #0
 603              	.LCFI20:
 604              		.cfi_def_cfa_register 7
 605 036a F860     		str	r0, [r7, #12]
 606 036c B960     		str	r1, [r7, #8]
 607 036e 1346     		mov	r3, r2
 608 0370 FB71     		strb	r3, [r7, #7]
 438:../src/stm32f30x_usart.c ****   /* Check the parameters */
 439:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 440:../src/stm32f30x_usart.c ****   assert_param(IS_USART_MODE(USART_DirectionMode));
 441:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 442:../src/stm32f30x_usart.c **** 
 443:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 609              		.loc 1 443 0
 610 0372 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 611 0374 002B     		cmp	r3, #0
 612 0376 06D0     		beq	.L24
 444:../src/stm32f30x_usart.c ****   {
 445:../src/stm32f30x_usart.c ****     /* Enable the USART's transfer interface by setting the TE and/or RE bits 
 446:../src/stm32f30x_usart.c ****        in the USART CR1 register */
 447:../src/stm32f30x_usart.c ****     USARTx->CR1 |= USART_DirectionMode;
 613              		.loc 1 447 0
 614 0378 FB68     		ldr	r3, [r7, #12]
 615 037a 1A68     		ldr	r2, [r3, #0]
 616 037c BB68     		ldr	r3, [r7, #8]
 617 037e 1A43     		orrs	r2, r2, r3
 618 0380 FB68     		ldr	r3, [r7, #12]
 619 0382 1A60     		str	r2, [r3, #0]
 620 0384 07E0     		b	.L23
 621              	.L24:
 448:../src/stm32f30x_usart.c ****   }
 449:../src/stm32f30x_usart.c ****   else
 450:../src/stm32f30x_usart.c ****   {
 451:../src/stm32f30x_usart.c ****     /* Disable the USART's transfer interface by clearing the TE and/or RE bits
 452:../src/stm32f30x_usart.c ****        in the USART CR3 register */
 453:../src/stm32f30x_usart.c ****     USARTx->CR1 &= (uint32_t)~USART_DirectionMode;
 622              		.loc 1 453 0
 623 0386 FB68     		ldr	r3, [r7, #12]
 624 0388 1A68     		ldr	r2, [r3, #0]
 625 038a BB68     		ldr	r3, [r7, #8]
 626 038c 6FEA0303 		mvn	r3, r3
 627 0390 1A40     		ands	r2, r2, r3
 628 0392 FB68     		ldr	r3, [r7, #12]
 629 0394 1A60     		str	r2, [r3, #0]
 630              	.L23:
 454:../src/stm32f30x_usart.c ****   }
 455:../src/stm32f30x_usart.c **** }
 631              		.loc 1 455 0
 632 0396 07F11407 		add	r7, r7, #20
 633 039a BD46     		mov	sp, r7
 634 039c 80BC     		pop	{r7}
 635 039e 7047     		bx	lr
 636              		.cfi_endproc
 637              	.LFE117:
 639              		.align	2
 640              		.global	USART_OverSampling8Cmd
 641              		.thumb
 642              		.thumb_func
 644              	USART_OverSampling8Cmd:
 645              	.LFB118:
 456:../src/stm32f30x_usart.c **** 
 457:../src/stm32f30x_usart.c **** /**
 458:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's 8x oversampling mode.
 459:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 460:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 461:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USART 8x oversampling mode.
 462:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 463:../src/stm32f30x_usart.c ****   * @note
 464:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Init()
 465:../src/stm32f30x_usart.c ****   *   function in order to have correct baudrate Divider value.
 466:../src/stm32f30x_usart.c ****   * @retval None
 467:../src/stm32f30x_usart.c ****   */
 468:../src/stm32f30x_usart.c **** void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 469:../src/stm32f30x_usart.c **** {
 646              		.loc 1 469 0
 647              		.cfi_startproc
 648              		@ args = 0, pretend = 0, frame = 8
 649              		@ frame_needed = 1, uses_anonymous_args = 0
 650              		@ link register save eliminated.
 651 03a0 80B4     		push	{r7}
 652              	.LCFI21:
 653              		.cfi_def_cfa_offset 4
 654              		.cfi_offset 7, -4
 655 03a2 83B0     		sub	sp, sp, #12
 656              	.LCFI22:
 657              		.cfi_def_cfa_offset 16
 658 03a4 00AF     		add	r7, sp, #0
 659              	.LCFI23:
 660              		.cfi_def_cfa_register 7
 661 03a6 7860     		str	r0, [r7, #4]
 662 03a8 0B46     		mov	r3, r1
 663 03aa FB70     		strb	r3, [r7, #3]
 470:../src/stm32f30x_usart.c ****   /* Check the parameters */
 471:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 472:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 473:../src/stm32f30x_usart.c ****   
 474:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 664              		.loc 1 474 0
 665 03ac FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 666 03ae 002B     		cmp	r3, #0
 667 03b0 06D0     		beq	.L27
 475:../src/stm32f30x_usart.c ****   {
 476:../src/stm32f30x_usart.c ****     /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
 477:../src/stm32f30x_usart.c ****     USARTx->CR1 |= USART_CR1_OVER8;
 668              		.loc 1 477 0
 669 03b2 7B68     		ldr	r3, [r7, #4]
 670 03b4 1B68     		ldr	r3, [r3, #0]
 671 03b6 43F40042 		orr	r2, r3, #32768
 672 03ba 7B68     		ldr	r3, [r7, #4]
 673 03bc 1A60     		str	r2, [r3, #0]
 674 03be 05E0     		b	.L26
 675              	.L27:
 478:../src/stm32f30x_usart.c ****   }
 479:../src/stm32f30x_usart.c ****   else
 480:../src/stm32f30x_usart.c ****   {
 481:../src/stm32f30x_usart.c ****     /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
 482:../src/stm32f30x_usart.c ****     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_OVER8);
 676              		.loc 1 482 0
 677 03c0 7B68     		ldr	r3, [r7, #4]
 678 03c2 1B68     		ldr	r3, [r3, #0]
 679 03c4 23F40042 		bic	r2, r3, #32768
 680 03c8 7B68     		ldr	r3, [r7, #4]
 681 03ca 1A60     		str	r2, [r3, #0]
 682              	.L26:
 483:../src/stm32f30x_usart.c ****   }
 484:../src/stm32f30x_usart.c **** }
 683              		.loc 1 484 0
 684 03cc 07F10C07 		add	r7, r7, #12
 685 03d0 BD46     		mov	sp, r7
 686 03d2 80BC     		pop	{r7}
 687 03d4 7047     		bx	lr
 688              		.cfi_endproc
 689              	.LFE118:
 691 03d6 00BF     		.align	2
 692              		.global	USART_OneBitMethodCmd
 693              		.thumb
 694              		.thumb_func
 696              	USART_OneBitMethodCmd:
 697              	.LFB119:
 485:../src/stm32f30x_usart.c **** 
 486:../src/stm32f30x_usart.c **** /**
 487:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's one bit sampling method.
 488:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the
 489:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 490:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USART one bit sampling method.
 491:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 492:../src/stm32f30x_usart.c ****   * @note
 493:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function.
 494:../src/stm32f30x_usart.c ****   * @retval None
 495:../src/stm32f30x_usart.c ****   */
 496:../src/stm32f30x_usart.c **** void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 497:../src/stm32f30x_usart.c **** {
 698              		.loc 1 497 0
 699              		.cfi_startproc
 700              		@ args = 0, pretend = 0, frame = 8
 701              		@ frame_needed = 1, uses_anonymous_args = 0
 702              		@ link register save eliminated.
 703 03d8 80B4     		push	{r7}
 704              	.LCFI24:
 705              		.cfi_def_cfa_offset 4
 706              		.cfi_offset 7, -4
 707 03da 83B0     		sub	sp, sp, #12
 708              	.LCFI25:
 709              		.cfi_def_cfa_offset 16
 710 03dc 00AF     		add	r7, sp, #0
 711              	.LCFI26:
 712              		.cfi_def_cfa_register 7
 713 03de 7860     		str	r0, [r7, #4]
 714 03e0 0B46     		mov	r3, r1
 715 03e2 FB70     		strb	r3, [r7, #3]
 498:../src/stm32f30x_usart.c ****   /* Check the parameters */
 499:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 500:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 501:../src/stm32f30x_usart.c **** 
 502:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 716              		.loc 1 502 0
 717 03e4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 718 03e6 002B     		cmp	r3, #0
 719 03e8 06D0     		beq	.L30
 503:../src/stm32f30x_usart.c ****   {
 504:../src/stm32f30x_usart.c ****     /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
 505:../src/stm32f30x_usart.c ****     USARTx->CR3 |= USART_CR3_ONEBIT;
 720              		.loc 1 505 0
 721 03ea 7B68     		ldr	r3, [r7, #4]
 722 03ec 9B68     		ldr	r3, [r3, #8]
 723 03ee 43F40062 		orr	r2, r3, #2048
 724 03f2 7B68     		ldr	r3, [r7, #4]
 725 03f4 9A60     		str	r2, [r3, #8]
 726 03f6 05E0     		b	.L29
 727              	.L30:
 506:../src/stm32f30x_usart.c ****   }
 507:../src/stm32f30x_usart.c ****   else
 508:../src/stm32f30x_usart.c ****   {
 509:../src/stm32f30x_usart.c ****     /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
 510:../src/stm32f30x_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_ONEBIT);
 728              		.loc 1 510 0
 729 03f8 7B68     		ldr	r3, [r7, #4]
 730 03fa 9B68     		ldr	r3, [r3, #8]
 731 03fc 23F40062 		bic	r2, r3, #2048
 732 0400 7B68     		ldr	r3, [r7, #4]
 733 0402 9A60     		str	r2, [r3, #8]
 734              	.L29:
 511:../src/stm32f30x_usart.c ****   }
 512:../src/stm32f30x_usart.c **** }
 735              		.loc 1 512 0
 736 0404 07F10C07 		add	r7, r7, #12
 737 0408 BD46     		mov	sp, r7
 738 040a 80BC     		pop	{r7}
 739 040c 7047     		bx	lr
 740              		.cfi_endproc
 741              	.LFE119:
 743 040e 00BF     		.align	2
 744              		.global	USART_MSBFirstCmd
 745              		.thumb
 746              		.thumb_func
 748              	USART_MSBFirstCmd:
 749              	.LFB120:
 513:../src/stm32f30x_usart.c **** 
 514:../src/stm32f30x_usart.c **** /**
 515:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's most significant bit first 
 516:../src/stm32f30x_usart.c ****   *         transmitted/received following the start bit.
 517:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the
 518:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 519:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USART most significant bit first
 520:../src/stm32f30x_usart.c ****   *         transmitted/received following the start bit.
 521:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 522:../src/stm32f30x_usart.c ****   * @note
 523:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function. 
 524:../src/stm32f30x_usart.c ****   * @retval None
 525:../src/stm32f30x_usart.c ****   */
 526:../src/stm32f30x_usart.c **** void USART_MSBFirstCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 527:../src/stm32f30x_usart.c **** {
 750              		.loc 1 527 0
 751              		.cfi_startproc
 752              		@ args = 0, pretend = 0, frame = 8
 753              		@ frame_needed = 1, uses_anonymous_args = 0
 754              		@ link register save eliminated.
 755 0410 80B4     		push	{r7}
 756              	.LCFI27:
 757              		.cfi_def_cfa_offset 4
 758              		.cfi_offset 7, -4
 759 0412 83B0     		sub	sp, sp, #12
 760              	.LCFI28:
 761              		.cfi_def_cfa_offset 16
 762 0414 00AF     		add	r7, sp, #0
 763              	.LCFI29:
 764              		.cfi_def_cfa_register 7
 765 0416 7860     		str	r0, [r7, #4]
 766 0418 0B46     		mov	r3, r1
 767 041a FB70     		strb	r3, [r7, #3]
 528:../src/stm32f30x_usart.c ****   /* Check the parameters */
 529:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 530:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 531:../src/stm32f30x_usart.c **** 
 532:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 768              		.loc 1 532 0
 769 041c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 770 041e 002B     		cmp	r3, #0
 771 0420 06D0     		beq	.L33
 533:../src/stm32f30x_usart.c ****   {
 534:../src/stm32f30x_usart.c ****     /* Enable the most significant bit first transmitted/received following the
 535:../src/stm32f30x_usart.c ****        start bit by setting the MSBFIRST bit in the CR2 register */
 536:../src/stm32f30x_usart.c ****     USARTx->CR2 |= USART_CR2_MSBFIRST;
 772              		.loc 1 536 0
 773 0422 7B68     		ldr	r3, [r7, #4]
 774 0424 5B68     		ldr	r3, [r3, #4]
 775 0426 43F40022 		orr	r2, r3, #524288
 776 042a 7B68     		ldr	r3, [r7, #4]
 777 042c 5A60     		str	r2, [r3, #4]
 778 042e 05E0     		b	.L32
 779              	.L33:
 537:../src/stm32f30x_usart.c ****   }
 538:../src/stm32f30x_usart.c ****   else
 539:../src/stm32f30x_usart.c ****   {
 540:../src/stm32f30x_usart.c ****     /* Disable the most significant bit first transmitted/received following the
 541:../src/stm32f30x_usart.c ****        start bit by clearing the MSBFIRST bit in the CR2 register */
 542:../src/stm32f30x_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_MSBFIRST);
 780              		.loc 1 542 0
 781 0430 7B68     		ldr	r3, [r7, #4]
 782 0432 5B68     		ldr	r3, [r3, #4]
 783 0434 23F40022 		bic	r2, r3, #524288
 784 0438 7B68     		ldr	r3, [r7, #4]
 785 043a 5A60     		str	r2, [r3, #4]
 786              	.L32:
 543:../src/stm32f30x_usart.c ****   }
 544:../src/stm32f30x_usart.c **** }
 787              		.loc 1 544 0
 788 043c 07F10C07 		add	r7, r7, #12
 789 0440 BD46     		mov	sp, r7
 790 0442 80BC     		pop	{r7}
 791 0444 7047     		bx	lr
 792              		.cfi_endproc
 793              	.LFE120:
 795 0446 00BF     		.align	2
 796              		.global	USART_DataInvCmd
 797              		.thumb
 798              		.thumb_func
 800              	USART_DataInvCmd:
 801              	.LFB121:
 545:../src/stm32f30x_usart.c **** 
 546:../src/stm32f30x_usart.c **** /**
 547:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the binary data inversion.
 548:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 549:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 550:../src/stm32f30x_usart.c ****   * @param  NewState: new defined levels for the USART data.
 551:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 552:../src/stm32f30x_usart.c ****   *   @arg  ENABLE: Logical data from the data register are send/received in negative
 553:../src/stm32f30x_usart.c ****   *         logic. (1=L, 0=H). The parity bit is also inverted.
 554:../src/stm32f30x_usart.c ****   *   @arg  DISABLE: Logical data from the data register are send/received in positive
 555:../src/stm32f30x_usart.c ****   *         logic. (1=H, 0=L) 
 556:../src/stm32f30x_usart.c ****   * @note
 557:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function. 
 558:../src/stm32f30x_usart.c ****   * @retval None
 559:../src/stm32f30x_usart.c ****   */
 560:../src/stm32f30x_usart.c **** void USART_DataInvCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 561:../src/stm32f30x_usart.c **** {
 802              		.loc 1 561 0
 803              		.cfi_startproc
 804              		@ args = 0, pretend = 0, frame = 8
 805              		@ frame_needed = 1, uses_anonymous_args = 0
 806              		@ link register save eliminated.
 807 0448 80B4     		push	{r7}
 808              	.LCFI30:
 809              		.cfi_def_cfa_offset 4
 810              		.cfi_offset 7, -4
 811 044a 83B0     		sub	sp, sp, #12
 812              	.LCFI31:
 813              		.cfi_def_cfa_offset 16
 814 044c 00AF     		add	r7, sp, #0
 815              	.LCFI32:
 816              		.cfi_def_cfa_register 7
 817 044e 7860     		str	r0, [r7, #4]
 818 0450 0B46     		mov	r3, r1
 819 0452 FB70     		strb	r3, [r7, #3]
 562:../src/stm32f30x_usart.c ****   /* Check the parameters */
 563:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 564:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 565:../src/stm32f30x_usart.c **** 
 566:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 820              		.loc 1 566 0
 821 0454 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 822 0456 002B     		cmp	r3, #0
 823 0458 06D0     		beq	.L36
 567:../src/stm32f30x_usart.c ****   {
 568:../src/stm32f30x_usart.c ****     /* Enable the binary data inversion feature by setting the DATAINV bit in
 569:../src/stm32f30x_usart.c ****        the CR2 register */
 570:../src/stm32f30x_usart.c ****     USARTx->CR2 |= USART_CR2_DATAINV;
 824              		.loc 1 570 0
 825 045a 7B68     		ldr	r3, [r7, #4]
 826 045c 5B68     		ldr	r3, [r3, #4]
 827 045e 43F48022 		orr	r2, r3, #262144
 828 0462 7B68     		ldr	r3, [r7, #4]
 829 0464 5A60     		str	r2, [r3, #4]
 830 0466 05E0     		b	.L35
 831              	.L36:
 571:../src/stm32f30x_usart.c ****   }
 572:../src/stm32f30x_usart.c ****   else
 573:../src/stm32f30x_usart.c ****   {
 574:../src/stm32f30x_usart.c ****     /* Disable the binary data inversion feature by clearing the DATAINV bit in
 575:../src/stm32f30x_usart.c ****        the CR2 register */
 576:../src/stm32f30x_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_DATAINV);
 832              		.loc 1 576 0
 833 0468 7B68     		ldr	r3, [r7, #4]
 834 046a 5B68     		ldr	r3, [r3, #4]
 835 046c 23F48022 		bic	r2, r3, #262144
 836 0470 7B68     		ldr	r3, [r7, #4]
 837 0472 5A60     		str	r2, [r3, #4]
 838              	.L35:
 577:../src/stm32f30x_usart.c ****   }
 578:../src/stm32f30x_usart.c **** }
 839              		.loc 1 578 0
 840 0474 07F10C07 		add	r7, r7, #12
 841 0478 BD46     		mov	sp, r7
 842 047a 80BC     		pop	{r7}
 843 047c 7047     		bx	lr
 844              		.cfi_endproc
 845              	.LFE121:
 847 047e 00BF     		.align	2
 848              		.global	USART_InvPinCmd
 849              		.thumb
 850              		.thumb_func
 852              	USART_InvPinCmd:
 853              	.LFB122:
 579:../src/stm32f30x_usart.c **** 
 580:../src/stm32f30x_usart.c **** /**
 581:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the Pin(s) active level inversion.
 582:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 583:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 584:../src/stm32f30x_usart.c ****   * @param  USART_InvPin: specifies the USART pin(s) to invert.
 585:../src/stm32f30x_usart.c ****   *         This parameter can be any combination of the following values:
 586:../src/stm32f30x_usart.c ****   *         @arg USART_InvPin_Tx: USART Tx pin active level inversion.
 587:../src/stm32f30x_usart.c ****   *         @arg USART_InvPin_Rx: USART Rx pin active level inversion.
 588:../src/stm32f30x_usart.c ****   * @param  NewState: new active level status for the USART pin(s).
 589:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 590:../src/stm32f30x_usart.c ****   *          - ENABLE: pin(s) signal values are inverted (Vdd =0, Gnd =1).
 591:../src/stm32f30x_usart.c ****   *          - DISABLE: pin(s) signal works using the standard logic levels (Vdd =1, Gnd =0).
 592:../src/stm32f30x_usart.c ****   * @note
 593:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function.  
 594:../src/stm32f30x_usart.c ****   * @retval None
 595:../src/stm32f30x_usart.c ****   */
 596:../src/stm32f30x_usart.c **** void USART_InvPinCmd(USART_TypeDef* USARTx, uint32_t USART_InvPin, FunctionalState NewState)
 597:../src/stm32f30x_usart.c **** {
 854              		.loc 1 597 0
 855              		.cfi_startproc
 856              		@ args = 0, pretend = 0, frame = 16
 857              		@ frame_needed = 1, uses_anonymous_args = 0
 858              		@ link register save eliminated.
 859 0480 80B4     		push	{r7}
 860              	.LCFI33:
 861              		.cfi_def_cfa_offset 4
 862              		.cfi_offset 7, -4
 863 0482 85B0     		sub	sp, sp, #20
 864              	.LCFI34:
 865              		.cfi_def_cfa_offset 24
 866 0484 00AF     		add	r7, sp, #0
 867              	.LCFI35:
 868              		.cfi_def_cfa_register 7
 869 0486 F860     		str	r0, [r7, #12]
 870 0488 B960     		str	r1, [r7, #8]
 871 048a 1346     		mov	r3, r2
 872 048c FB71     		strb	r3, [r7, #7]
 598:../src/stm32f30x_usart.c ****   /* Check the parameters */
 599:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 600:../src/stm32f30x_usart.c ****   assert_param(IS_USART_INVERSTION_PIN(USART_InvPin));
 601:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 602:../src/stm32f30x_usart.c **** 
 603:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 873              		.loc 1 603 0
 874 048e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 875 0490 002B     		cmp	r3, #0
 876 0492 06D0     		beq	.L39
 604:../src/stm32f30x_usart.c ****   {
 605:../src/stm32f30x_usart.c ****     /* Enable the active level inversion for selected pins by setting the TXINV 
 606:../src/stm32f30x_usart.c ****        and/or RXINV bits in the USART CR2 register */
 607:../src/stm32f30x_usart.c ****     USARTx->CR2 |= USART_InvPin;
 877              		.loc 1 607 0
 878 0494 FB68     		ldr	r3, [r7, #12]
 879 0496 5A68     		ldr	r2, [r3, #4]
 880 0498 BB68     		ldr	r3, [r7, #8]
 881 049a 1A43     		orrs	r2, r2, r3
 882 049c FB68     		ldr	r3, [r7, #12]
 883 049e 5A60     		str	r2, [r3, #4]
 884 04a0 07E0     		b	.L38
 885              	.L39:
 608:../src/stm32f30x_usart.c ****   }
 609:../src/stm32f30x_usart.c ****   else
 610:../src/stm32f30x_usart.c ****   {
 611:../src/stm32f30x_usart.c ****     /* Disable the active level inversion for selected requests by clearing the 
 612:../src/stm32f30x_usart.c ****        TXINV and/or RXINV bits in the USART CR2 register */
 613:../src/stm32f30x_usart.c ****     USARTx->CR2 &= (uint32_t)~USART_InvPin;
 886              		.loc 1 613 0
 887 04a2 FB68     		ldr	r3, [r7, #12]
 888 04a4 5A68     		ldr	r2, [r3, #4]
 889 04a6 BB68     		ldr	r3, [r7, #8]
 890 04a8 6FEA0303 		mvn	r3, r3
 891 04ac 1A40     		ands	r2, r2, r3
 892 04ae FB68     		ldr	r3, [r7, #12]
 893 04b0 5A60     		str	r2, [r3, #4]
 894              	.L38:
 614:../src/stm32f30x_usart.c ****   }
 615:../src/stm32f30x_usart.c **** }
 895              		.loc 1 615 0
 896 04b2 07F11407 		add	r7, r7, #20
 897 04b6 BD46     		mov	sp, r7
 898 04b8 80BC     		pop	{r7}
 899 04ba 7047     		bx	lr
 900              		.cfi_endproc
 901              	.LFE122:
 903              		.align	2
 904              		.global	USART_SWAPPinCmd
 905              		.thumb
 906              		.thumb_func
 908              	USART_SWAPPinCmd:
 909              	.LFB123:
 616:../src/stm32f30x_usart.c **** 
 617:../src/stm32f30x_usart.c **** /**
 618:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the swap Tx/Rx pins.
 619:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the
 620:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 621:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USARTx TX/RX pins pinout.
 622:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 623:../src/stm32f30x_usart.c ****   *         @arg ENABLE: The TX and RX pins functions are swapped.
 624:../src/stm32f30x_usart.c ****   *         @arg DISABLE: TX/RX pins are used as defined in standard pinout
 625:../src/stm32f30x_usart.c ****   * @note
 626:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function.
 627:../src/stm32f30x_usart.c ****   * @retval None
 628:../src/stm32f30x_usart.c ****   */
 629:../src/stm32f30x_usart.c **** void USART_SWAPPinCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 630:../src/stm32f30x_usart.c **** {
 910              		.loc 1 630 0
 911              		.cfi_startproc
 912              		@ args = 0, pretend = 0, frame = 8
 913              		@ frame_needed = 1, uses_anonymous_args = 0
 914              		@ link register save eliminated.
 915 04bc 80B4     		push	{r7}
 916              	.LCFI36:
 917              		.cfi_def_cfa_offset 4
 918              		.cfi_offset 7, -4
 919 04be 83B0     		sub	sp, sp, #12
 920              	.LCFI37:
 921              		.cfi_def_cfa_offset 16
 922 04c0 00AF     		add	r7, sp, #0
 923              	.LCFI38:
 924              		.cfi_def_cfa_register 7
 925 04c2 7860     		str	r0, [r7, #4]
 926 04c4 0B46     		mov	r3, r1
 927 04c6 FB70     		strb	r3, [r7, #3]
 631:../src/stm32f30x_usart.c ****   /* Check the parameters */
 632:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 633:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 634:../src/stm32f30x_usart.c **** 
 635:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 928              		.loc 1 635 0
 929 04c8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 930 04ca 002B     		cmp	r3, #0
 931 04cc 06D0     		beq	.L42
 636:../src/stm32f30x_usart.c ****   {
 637:../src/stm32f30x_usart.c ****     /* Enable the SWAP feature by setting the SWAP bit in the CR2 register */
 638:../src/stm32f30x_usart.c ****     USARTx->CR2 |= USART_CR2_SWAP;
 932              		.loc 1 638 0
 933 04ce 7B68     		ldr	r3, [r7, #4]
 934 04d0 5B68     		ldr	r3, [r3, #4]
 935 04d2 43F40042 		orr	r2, r3, #32768
 936 04d6 7B68     		ldr	r3, [r7, #4]
 937 04d8 5A60     		str	r2, [r3, #4]
 938 04da 05E0     		b	.L41
 939              	.L42:
 639:../src/stm32f30x_usart.c ****   }
 640:../src/stm32f30x_usart.c ****   else
 641:../src/stm32f30x_usart.c ****   {
 642:../src/stm32f30x_usart.c ****     /* Disable the SWAP feature by clearing the SWAP bit in the CR2 register */
 643:../src/stm32f30x_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_SWAP);
 940              		.loc 1 643 0
 941 04dc 7B68     		ldr	r3, [r7, #4]
 942 04de 5B68     		ldr	r3, [r3, #4]
 943 04e0 23F40042 		bic	r2, r3, #32768
 944 04e4 7B68     		ldr	r3, [r7, #4]
 945 04e6 5A60     		str	r2, [r3, #4]
 946              	.L41:
 644:../src/stm32f30x_usart.c ****   }
 645:../src/stm32f30x_usart.c **** }
 947              		.loc 1 645 0
 948 04e8 07F10C07 		add	r7, r7, #12
 949 04ec BD46     		mov	sp, r7
 950 04ee 80BC     		pop	{r7}
 951 04f0 7047     		bx	lr
 952              		.cfi_endproc
 953              	.LFE123:
 955 04f2 00BF     		.align	2
 956              		.global	USART_ReceiverTimeOutCmd
 957              		.thumb
 958              		.thumb_func
 960              	USART_ReceiverTimeOutCmd:
 961              	.LFB124:
 646:../src/stm32f30x_usart.c **** 
 647:../src/stm32f30x_usart.c **** /**
 648:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the receiver Time Out feature.
 649:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 650:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 651:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USARTx receiver Time Out.
 652:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 653:../src/stm32f30x_usart.c ****   * @retval None
 654:../src/stm32f30x_usart.c ****   */
 655:../src/stm32f30x_usart.c **** void USART_ReceiverTimeOutCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 656:../src/stm32f30x_usart.c **** {
 962              		.loc 1 656 0
 963              		.cfi_startproc
 964              		@ args = 0, pretend = 0, frame = 8
 965              		@ frame_needed = 1, uses_anonymous_args = 0
 966              		@ link register save eliminated.
 967 04f4 80B4     		push	{r7}
 968              	.LCFI39:
 969              		.cfi_def_cfa_offset 4
 970              		.cfi_offset 7, -4
 971 04f6 83B0     		sub	sp, sp, #12
 972              	.LCFI40:
 973              		.cfi_def_cfa_offset 16
 974 04f8 00AF     		add	r7, sp, #0
 975              	.LCFI41:
 976              		.cfi_def_cfa_register 7
 977 04fa 7860     		str	r0, [r7, #4]
 978 04fc 0B46     		mov	r3, r1
 979 04fe FB70     		strb	r3, [r7, #3]
 657:../src/stm32f30x_usart.c ****   /* Check the parameters */
 658:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 659:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 660:../src/stm32f30x_usart.c **** 
 661:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 980              		.loc 1 661 0
 981 0500 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 982 0502 002B     		cmp	r3, #0
 983 0504 06D0     		beq	.L45
 662:../src/stm32f30x_usart.c ****   {
 663:../src/stm32f30x_usart.c ****     /* Enable the receiver time out feature by setting the RTOEN bit in the CR2 
 664:../src/stm32f30x_usart.c ****        register */
 665:../src/stm32f30x_usart.c ****     USARTx->CR2 |= USART_CR2_RTOEN;
 984              		.loc 1 665 0
 985 0506 7B68     		ldr	r3, [r7, #4]
 986 0508 5B68     		ldr	r3, [r3, #4]
 987 050a 43F40002 		orr	r2, r3, #8388608
 988 050e 7B68     		ldr	r3, [r7, #4]
 989 0510 5A60     		str	r2, [r3, #4]
 990 0512 05E0     		b	.L44
 991              	.L45:
 666:../src/stm32f30x_usart.c ****   }
 667:../src/stm32f30x_usart.c ****   else
 668:../src/stm32f30x_usart.c ****   {
 669:../src/stm32f30x_usart.c ****     /* Disable the receiver time out feature by clearing the RTOEN bit in the CR2 
 670:../src/stm32f30x_usart.c ****        register */
 671:../src/stm32f30x_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_RTOEN);
 992              		.loc 1 671 0
 993 0514 7B68     		ldr	r3, [r7, #4]
 994 0516 5B68     		ldr	r3, [r3, #4]
 995 0518 23F40002 		bic	r2, r3, #8388608
 996 051c 7B68     		ldr	r3, [r7, #4]
 997 051e 5A60     		str	r2, [r3, #4]
 998              	.L44:
 672:../src/stm32f30x_usart.c ****   }
 673:../src/stm32f30x_usart.c **** }
 999              		.loc 1 673 0
 1000 0520 07F10C07 		add	r7, r7, #12
 1001 0524 BD46     		mov	sp, r7
 1002 0526 80BC     		pop	{r7}
 1003 0528 7047     		bx	lr
 1004              		.cfi_endproc
 1005              	.LFE124:
 1007 052a 00BF     		.align	2
 1008              		.global	USART_SetReceiverTimeOut
 1009              		.thumb
 1010              		.thumb_func
 1012              	USART_SetReceiverTimeOut:
 1013              	.LFB125:
 674:../src/stm32f30x_usart.c **** 
 675:../src/stm32f30x_usart.c **** /**
 676:../src/stm32f30x_usart.c ****   * @brief  Sets the receiver Time Out value.
 677:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 678:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 679:../src/stm32f30x_usart.c ****   * @param  USART_ReceiverTimeOut: specifies the Receiver Time Out value.
 680:../src/stm32f30x_usart.c ****   * @retval None
 681:../src/stm32f30x_usart.c ****   */
 682:../src/stm32f30x_usart.c **** void USART_SetReceiverTimeOut(USART_TypeDef* USARTx, uint32_t USART_ReceiverTimeOut)
 683:../src/stm32f30x_usart.c **** {    
 1014              		.loc 1 683 0
 1015              		.cfi_startproc
 1016              		@ args = 0, pretend = 0, frame = 8
 1017              		@ frame_needed = 1, uses_anonymous_args = 0
 1018              		@ link register save eliminated.
 1019 052c 80B4     		push	{r7}
 1020              	.LCFI42:
 1021              		.cfi_def_cfa_offset 4
 1022              		.cfi_offset 7, -4
 1023 052e 83B0     		sub	sp, sp, #12
 1024              	.LCFI43:
 1025              		.cfi_def_cfa_offset 16
 1026 0530 00AF     		add	r7, sp, #0
 1027              	.LCFI44:
 1028              		.cfi_def_cfa_register 7
 1029 0532 7860     		str	r0, [r7, #4]
 1030 0534 3960     		str	r1, [r7, #0]
 684:../src/stm32f30x_usart.c ****   /* Check the parameters */
 685:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 686:../src/stm32f30x_usart.c ****   assert_param(IS_USART_TIMEOUT(USART_ReceiverTimeOut));
 687:../src/stm32f30x_usart.c **** 
 688:../src/stm32f30x_usart.c ****   /* Clear the receiver Time Out value by clearing the RTO[23:0] bits in the RTOR
 689:../src/stm32f30x_usart.c ****      register  */
 690:../src/stm32f30x_usart.c ****   USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_RTO);
 1031              		.loc 1 690 0
 1032 0536 7B68     		ldr	r3, [r7, #4]
 1033 0538 5B69     		ldr	r3, [r3, #20]
 1034 053a 03F07F42 		and	r2, r3, #-16777216
 1035 053e 7B68     		ldr	r3, [r7, #4]
 1036 0540 5A61     		str	r2, [r3, #20]
 691:../src/stm32f30x_usart.c ****   /* Set the receiver Time Out value by setting the RTO[23:0] bits in the RTOR
 692:../src/stm32f30x_usart.c ****      register  */
 693:../src/stm32f30x_usart.c ****   USARTx->RTOR |= USART_ReceiverTimeOut;
 1037              		.loc 1 693 0
 1038 0542 7B68     		ldr	r3, [r7, #4]
 1039 0544 5A69     		ldr	r2, [r3, #20]
 1040 0546 3B68     		ldr	r3, [r7, #0]
 1041 0548 1A43     		orrs	r2, r2, r3
 1042 054a 7B68     		ldr	r3, [r7, #4]
 1043 054c 5A61     		str	r2, [r3, #20]
 694:../src/stm32f30x_usart.c **** }
 1044              		.loc 1 694 0
 1045 054e 07F10C07 		add	r7, r7, #12
 1046 0552 BD46     		mov	sp, r7
 1047 0554 80BC     		pop	{r7}
 1048 0556 7047     		bx	lr
 1049              		.cfi_endproc
 1050              	.LFE125:
 1052              		.align	2
 1053              		.global	USART_SetPrescaler
 1054              		.thumb
 1055              		.thumb_func
 1057              	USART_SetPrescaler:
 1058              	.LFB126:
 695:../src/stm32f30x_usart.c **** 
 696:../src/stm32f30x_usart.c **** /**
 697:../src/stm32f30x_usart.c ****   * @brief  Sets the system clock prescaler.
 698:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the
 699:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 700:../src/stm32f30x_usart.c ****   * @param  USART_Prescaler: specifies the prescaler clock.  
 701:../src/stm32f30x_usart.c ****   * @note
 702:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function.  
 703:../src/stm32f30x_usart.c ****   * @retval None
 704:../src/stm32f30x_usart.c ****   */
 705:../src/stm32f30x_usart.c **** void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
 706:../src/stm32f30x_usart.c **** {
 1059              		.loc 1 706 0
 1060              		.cfi_startproc
 1061              		@ args = 0, pretend = 0, frame = 8
 1062              		@ frame_needed = 1, uses_anonymous_args = 0
 1063              		@ link register save eliminated.
 1064 0558 80B4     		push	{r7}
 1065              	.LCFI45:
 1066              		.cfi_def_cfa_offset 4
 1067              		.cfi_offset 7, -4
 1068 055a 83B0     		sub	sp, sp, #12
 1069              	.LCFI46:
 1070              		.cfi_def_cfa_offset 16
 1071 055c 00AF     		add	r7, sp, #0
 1072              	.LCFI47:
 1073              		.cfi_def_cfa_register 7
 1074 055e 7860     		str	r0, [r7, #4]
 1075 0560 0B46     		mov	r3, r1
 1076 0562 FB70     		strb	r3, [r7, #3]
 707:../src/stm32f30x_usart.c ****   /* Check the parameters */
 708:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 709:../src/stm32f30x_usart.c **** 
 710:../src/stm32f30x_usart.c ****   /* Clear the USART prescaler */
 711:../src/stm32f30x_usart.c ****   USARTx->GTPR &= USART_GTPR_GT;
 1077              		.loc 1 711 0
 1078 0564 7B68     		ldr	r3, [r7, #4]
 1079 0566 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1080 0568 9BB2     		uxth	r3, r3
 1081 056a 23F0FF03 		bic	r3, r3, #255
 1082 056e 9AB2     		uxth	r2, r3
 1083 0570 7B68     		ldr	r3, [r7, #4]
 1084 0572 1A82     		strh	r2, [r3, #16]	@ movhi
 712:../src/stm32f30x_usart.c ****   /* Set the USART prescaler */
 713:../src/stm32f30x_usart.c ****   USARTx->GTPR |= USART_Prescaler;
 1085              		.loc 1 713 0
 1086 0574 7B68     		ldr	r3, [r7, #4]
 1087 0576 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1088 0578 9AB2     		uxth	r2, r3
 1089 057a FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1090 057c 9BB2     		uxth	r3, r3
 1091 057e 1343     		orrs	r3, r3, r2
 1092 0580 9AB2     		uxth	r2, r3
 1093 0582 7B68     		ldr	r3, [r7, #4]
 1094 0584 1A82     		strh	r2, [r3, #16]	@ movhi
 714:../src/stm32f30x_usart.c **** }
 1095              		.loc 1 714 0
 1096 0586 07F10C07 		add	r7, r7, #12
 1097 058a BD46     		mov	sp, r7
 1098 058c 80BC     		pop	{r7}
 1099 058e 7047     		bx	lr
 1100              		.cfi_endproc
 1101              	.LFE126:
 1103              		.align	2
 1104              		.global	USART_STOPModeCmd
 1105              		.thumb
 1106              		.thumb_func
 1108              	USART_STOPModeCmd:
 1109              	.LFB127:
 715:../src/stm32f30x_usart.c **** 
 716:../src/stm32f30x_usart.c **** /**
 717:../src/stm32f30x_usart.c ****   * @}
 718:../src/stm32f30x_usart.c ****   */
 719:../src/stm32f30x_usart.c **** 
 720:../src/stm32f30x_usart.c **** 
 721:../src/stm32f30x_usart.c **** /** @defgroup USART_Group2 STOP Mode functions
 722:../src/stm32f30x_usart.c ****  *  @brief   STOP Mode functions
 723:../src/stm32f30x_usart.c ****  *
 724:../src/stm32f30x_usart.c **** @verbatim
 725:../src/stm32f30x_usart.c ****  ===============================================================================
 726:../src/stm32f30x_usart.c ****                         ##### STOP Mode functions #####
 727:../src/stm32f30x_usart.c ****  ===============================================================================
 728:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage 
 729:../src/stm32f30x_usart.c ****          WakeUp from STOP mode.
 730:../src/stm32f30x_usart.c **** 
 731:../src/stm32f30x_usart.c ****     [..] The USART is able to WakeUp from Stop Mode if USART clock is set to HSI
 732:../src/stm32f30x_usart.c ****          or LSI.
 733:../src/stm32f30x_usart.c ****          
 734:../src/stm32f30x_usart.c ****     [..] The WakeUp source is configured by calling USART_StopModeWakeUpSourceConfig()
 735:../src/stm32f30x_usart.c ****          function.
 736:../src/stm32f30x_usart.c ****          
 737:../src/stm32f30x_usart.c ****     [..] After configuring the source of WakeUp and before entering in Stop Mode 
 738:../src/stm32f30x_usart.c ****          USART_STOPModeCmd() function should be called to allow USART WakeUp.
 739:../src/stm32f30x_usart.c ****                            
 740:../src/stm32f30x_usart.c **** @endverbatim
 741:../src/stm32f30x_usart.c ****   * @{
 742:../src/stm32f30x_usart.c ****   */
 743:../src/stm32f30x_usart.c ****   
 744:../src/stm32f30x_usart.c **** /**
 745:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the specified USART peripheral in STOP Mode.
 746:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the
 747:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 748:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USARTx peripheral state in stop mode.
 749:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 750:../src/stm32f30x_usart.c ****   * @note
 751:../src/stm32f30x_usart.c ****   *   This function has to be called when USART clock is set to HSI or LSE.
 752:../src/stm32f30x_usart.c ****   * @retval None
 753:../src/stm32f30x_usart.c ****   */
 754:../src/stm32f30x_usart.c **** void USART_STOPModeCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 755:../src/stm32f30x_usart.c **** {
 1110              		.loc 1 755 0
 1111              		.cfi_startproc
 1112              		@ args = 0, pretend = 0, frame = 8
 1113              		@ frame_needed = 1, uses_anonymous_args = 0
 1114              		@ link register save eliminated.
 1115 0590 80B4     		push	{r7}
 1116              	.LCFI48:
 1117              		.cfi_def_cfa_offset 4
 1118              		.cfi_offset 7, -4
 1119 0592 83B0     		sub	sp, sp, #12
 1120              	.LCFI49:
 1121              		.cfi_def_cfa_offset 16
 1122 0594 00AF     		add	r7, sp, #0
 1123              	.LCFI50:
 1124              		.cfi_def_cfa_register 7
 1125 0596 7860     		str	r0, [r7, #4]
 1126 0598 0B46     		mov	r3, r1
 1127 059a FB70     		strb	r3, [r7, #3]
 756:../src/stm32f30x_usart.c ****   /* Check the parameters */
 757:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 758:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 759:../src/stm32f30x_usart.c ****   
 760:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 1128              		.loc 1 760 0
 1129 059c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1130 059e 002B     		cmp	r3, #0
 1131 05a0 06D0     		beq	.L50
 761:../src/stm32f30x_usart.c ****   {
 762:../src/stm32f30x_usart.c ****     /* Enable the selected USART in STOP mode by setting the UESM bit in the CR1
 763:../src/stm32f30x_usart.c ****        register */
 764:../src/stm32f30x_usart.c ****     USARTx->CR1 |= USART_CR1_UESM;
 1132              		.loc 1 764 0
 1133 05a2 7B68     		ldr	r3, [r7, #4]
 1134 05a4 1B68     		ldr	r3, [r3, #0]
 1135 05a6 43F00202 		orr	r2, r3, #2
 1136 05aa 7B68     		ldr	r3, [r7, #4]
 1137 05ac 1A60     		str	r2, [r3, #0]
 1138 05ae 05E0     		b	.L49
 1139              	.L50:
 765:../src/stm32f30x_usart.c ****   }
 766:../src/stm32f30x_usart.c ****   else
 767:../src/stm32f30x_usart.c ****   {
 768:../src/stm32f30x_usart.c ****     /* Disable the selected USART in STOP mode by clearing the UE bit in the CR1
 769:../src/stm32f30x_usart.c ****        register */
 770:../src/stm32f30x_usart.c ****     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UESM);
 1140              		.loc 1 770 0
 1141 05b0 7B68     		ldr	r3, [r7, #4]
 1142 05b2 1B68     		ldr	r3, [r3, #0]
 1143 05b4 23F00202 		bic	r2, r3, #2
 1144 05b8 7B68     		ldr	r3, [r7, #4]
 1145 05ba 1A60     		str	r2, [r3, #0]
 1146              	.L49:
 771:../src/stm32f30x_usart.c ****   }
 772:../src/stm32f30x_usart.c **** }
 1147              		.loc 1 772 0
 1148 05bc 07F10C07 		add	r7, r7, #12
 1149 05c0 BD46     		mov	sp, r7
 1150 05c2 80BC     		pop	{r7}
 1151 05c4 7047     		bx	lr
 1152              		.cfi_endproc
 1153              	.LFE127:
 1155 05c6 00BF     		.align	2
 1156              		.global	USART_StopModeWakeUpSourceConfig
 1157              		.thumb
 1158              		.thumb_func
 1160              	USART_StopModeWakeUpSourceConfig:
 1161              	.LFB128:
 773:../src/stm32f30x_usart.c **** 
 774:../src/stm32f30x_usart.c **** /**
 775:../src/stm32f30x_usart.c ****   * @brief  Selects the USART WakeUp method form stop mode.
 776:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 777:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 778:../src/stm32f30x_usart.c ****   * @param  USART_WakeUp: specifies the selected USART wakeup method.
 779:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
 780:../src/stm32f30x_usart.c ****   *         @arg USART_WakeUpSource_AddressMatch: WUF active on address match.
 781:../src/stm32f30x_usart.c ****   *         @arg USART_WakeUpSource_StartBit: WUF active on Start bit detection.
 782:../src/stm32f30x_usart.c ****   *         @arg USART_WakeUpSource_RXNE: WUF active on RXNE.
 783:../src/stm32f30x_usart.c ****   * @note
 784:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function.  
 785:../src/stm32f30x_usart.c ****   * @retval None
 786:../src/stm32f30x_usart.c ****   */
 787:../src/stm32f30x_usart.c **** void USART_StopModeWakeUpSourceConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUpSource)
 788:../src/stm32f30x_usart.c **** {
 1162              		.loc 1 788 0
 1163              		.cfi_startproc
 1164              		@ args = 0, pretend = 0, frame = 8
 1165              		@ frame_needed = 1, uses_anonymous_args = 0
 1166              		@ link register save eliminated.
 1167 05c8 80B4     		push	{r7}
 1168              	.LCFI51:
 1169              		.cfi_def_cfa_offset 4
 1170              		.cfi_offset 7, -4
 1171 05ca 83B0     		sub	sp, sp, #12
 1172              	.LCFI52:
 1173              		.cfi_def_cfa_offset 16
 1174 05cc 00AF     		add	r7, sp, #0
 1175              	.LCFI53:
 1176              		.cfi_def_cfa_register 7
 1177 05ce 7860     		str	r0, [r7, #4]
 1178 05d0 3960     		str	r1, [r7, #0]
 789:../src/stm32f30x_usart.c ****   /* Check the parameters */
 790:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 791:../src/stm32f30x_usart.c ****   assert_param(IS_USART_STOPMODE_WAKEUPSOURCE(USART_WakeUpSource));
 792:../src/stm32f30x_usart.c **** 
 793:../src/stm32f30x_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_WUS);
 1179              		.loc 1 793 0
 1180 05d2 7B68     		ldr	r3, [r7, #4]
 1181 05d4 9B68     		ldr	r3, [r3, #8]
 1182 05d6 23F44012 		bic	r2, r3, #3145728
 1183 05da 7B68     		ldr	r3, [r7, #4]
 1184 05dc 9A60     		str	r2, [r3, #8]
 794:../src/stm32f30x_usart.c ****   USARTx->CR3 |= USART_WakeUpSource;
 1185              		.loc 1 794 0
 1186 05de 7B68     		ldr	r3, [r7, #4]
 1187 05e0 9A68     		ldr	r2, [r3, #8]
 1188 05e2 3B68     		ldr	r3, [r7, #0]
 1189 05e4 1A43     		orrs	r2, r2, r3
 1190 05e6 7B68     		ldr	r3, [r7, #4]
 1191 05e8 9A60     		str	r2, [r3, #8]
 795:../src/stm32f30x_usart.c **** }
 1192              		.loc 1 795 0
 1193 05ea 07F10C07 		add	r7, r7, #12
 1194 05ee BD46     		mov	sp, r7
 1195 05f0 80BC     		pop	{r7}
 1196 05f2 7047     		bx	lr
 1197              		.cfi_endproc
 1198              	.LFE128:
 1200              		.align	2
 1201              		.global	USART_AutoBaudRateCmd
 1202              		.thumb
 1203              		.thumb_func
 1205              	USART_AutoBaudRateCmd:
 1206              	.LFB129:
 796:../src/stm32f30x_usart.c **** 
 797:../src/stm32f30x_usart.c **** /**
 798:../src/stm32f30x_usart.c ****   * @}
 799:../src/stm32f30x_usart.c ****   */
 800:../src/stm32f30x_usart.c **** 
 801:../src/stm32f30x_usart.c **** 
 802:../src/stm32f30x_usart.c **** /** @defgroup USART_Group3 AutoBaudRate functions
 803:../src/stm32f30x_usart.c ****  *  @brief   AutoBaudRate functions 
 804:../src/stm32f30x_usart.c ****  *
 805:../src/stm32f30x_usart.c **** @verbatim
 806:../src/stm32f30x_usart.c ****  ===============================================================================
 807:../src/stm32f30x_usart.c ****                        ##### AutoBaudRate functions #####
 808:../src/stm32f30x_usart.c ****  ===============================================================================
 809:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage 
 810:../src/stm32f30x_usart.c ****          the AutoBaudRate detections.
 811:../src/stm32f30x_usart.c ****          
 812:../src/stm32f30x_usart.c ****     [..] Before Enabling AutoBaudRate detection using USART_AutoBaudRateCmd ()
 813:../src/stm32f30x_usart.c ****          The character patterns used to calculate baudrate must be chosen by calling 
 814:../src/stm32f30x_usart.c ****          USART_AutoBaudRateConfig() function. These function take as parameter :
 815:../src/stm32f30x_usart.c ****         (#)USART_AutoBaudRate_StartBit : any character starting with a bit 1.
 816:../src/stm32f30x_usart.c ****         (#)USART_AutoBaudRate_FallingEdge : any character starting with a 10xx bit pattern. 
 817:../src/stm32f30x_usart.c ****                           
 818:../src/stm32f30x_usart.c ****     [..] At any later time, another request for AutoBaudRate detection can be performed
 819:../src/stm32f30x_usart.c ****          using USART_RequestCmd() function.
 820:../src/stm32f30x_usart.c ****          
 821:../src/stm32f30x_usart.c ****     [..] The AutoBaudRate detection is monitored by the status of ABRF flag which indicate
 822:../src/stm32f30x_usart.c ****          that the AutoBaudRate detection is completed. In addition to ABRF flag, the ABRE flag
 823:../src/stm32f30x_usart.c ****          indicate that this procedure is completed without success. USART_GetFlagStatus () 
 824:../src/stm32f30x_usart.c ****          function should be used to monitor the status of these flags.  
 825:../src/stm32f30x_usart.c ****              
 826:../src/stm32f30x_usart.c **** @endverbatim
 827:../src/stm32f30x_usart.c ****   * @{
 828:../src/stm32f30x_usart.c ****   */
 829:../src/stm32f30x_usart.c ****   
 830:../src/stm32f30x_usart.c **** /**
 831:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the Auto Baud Rate.
 832:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 833:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 834:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USARTx auto baud rate.
 835:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 836:../src/stm32f30x_usart.c ****   * @retval None
 837:../src/stm32f30x_usart.c ****   */
 838:../src/stm32f30x_usart.c **** void USART_AutoBaudRateCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 839:../src/stm32f30x_usart.c **** {
 1207              		.loc 1 839 0
 1208              		.cfi_startproc
 1209              		@ args = 0, pretend = 0, frame = 8
 1210              		@ frame_needed = 1, uses_anonymous_args = 0
 1211              		@ link register save eliminated.
 1212 05f4 80B4     		push	{r7}
 1213              	.LCFI54:
 1214              		.cfi_def_cfa_offset 4
 1215              		.cfi_offset 7, -4
 1216 05f6 83B0     		sub	sp, sp, #12
 1217              	.LCFI55:
 1218              		.cfi_def_cfa_offset 16
 1219 05f8 00AF     		add	r7, sp, #0
 1220              	.LCFI56:
 1221              		.cfi_def_cfa_register 7
 1222 05fa 7860     		str	r0, [r7, #4]
 1223 05fc 0B46     		mov	r3, r1
 1224 05fe FB70     		strb	r3, [r7, #3]
 840:../src/stm32f30x_usart.c ****   /* Check the parameters */
 841:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 842:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 843:../src/stm32f30x_usart.c **** 
 844:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 1225              		.loc 1 844 0
 1226 0600 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1227 0602 002B     		cmp	r3, #0
 1228 0604 06D0     		beq	.L54
 845:../src/stm32f30x_usart.c ****   {
 846:../src/stm32f30x_usart.c ****     /* Enable the auto baud rate feature by setting the ABREN bit in the CR2 
 847:../src/stm32f30x_usart.c ****        register */
 848:../src/stm32f30x_usart.c ****     USARTx->CR2 |= USART_CR2_ABREN;
 1229              		.loc 1 848 0
 1230 0606 7B68     		ldr	r3, [r7, #4]
 1231 0608 5B68     		ldr	r3, [r3, #4]
 1232 060a 43F48012 		orr	r2, r3, #1048576
 1233 060e 7B68     		ldr	r3, [r7, #4]
 1234 0610 5A60     		str	r2, [r3, #4]
 1235 0612 05E0     		b	.L53
 1236              	.L54:
 849:../src/stm32f30x_usart.c ****   }
 850:../src/stm32f30x_usart.c ****   else
 851:../src/stm32f30x_usart.c ****   {
 852:../src/stm32f30x_usart.c ****     /* Disable the auto baud rate feature by clearing the ABREN bit in the CR2 
 853:../src/stm32f30x_usart.c ****        register */
 854:../src/stm32f30x_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABREN);
 1237              		.loc 1 854 0
 1238 0614 7B68     		ldr	r3, [r7, #4]
 1239 0616 5B68     		ldr	r3, [r3, #4]
 1240 0618 23F48012 		bic	r2, r3, #1048576
 1241 061c 7B68     		ldr	r3, [r7, #4]
 1242 061e 5A60     		str	r2, [r3, #4]
 1243              	.L53:
 855:../src/stm32f30x_usart.c ****   }
 856:../src/stm32f30x_usart.c **** }
 1244              		.loc 1 856 0
 1245 0620 07F10C07 		add	r7, r7, #12
 1246 0624 BD46     		mov	sp, r7
 1247 0626 80BC     		pop	{r7}
 1248 0628 7047     		bx	lr
 1249              		.cfi_endproc
 1250              	.LFE129:
 1252 062a 00BF     		.align	2
 1253              		.global	USART_AutoBaudRateConfig
 1254              		.thumb
 1255              		.thumb_func
 1257              	USART_AutoBaudRateConfig:
 1258              	.LFB130:
 857:../src/stm32f30x_usart.c **** 
 858:../src/stm32f30x_usart.c **** /**
 859:../src/stm32f30x_usart.c ****   * @brief  Selects the USART auto baud rate method.
 860:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 861:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 862:../src/stm32f30x_usart.c ****   * @param  USART_AutoBaudRate: specifies the selected USART auto baud rate method.
 863:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
 864:../src/stm32f30x_usart.c ****   *         @arg USART_AutoBaudRate_StartBit: Start Bit duration measurement.
 865:../src/stm32f30x_usart.c ****   *         @arg USART_AutoBaudRate_FallingEdge: Falling edge to falling edge measurement.
 866:../src/stm32f30x_usart.c ****   *         @arg USART_AutoBaudRate_0x7FFrame: 0x7F frame.
 867:../src/stm32f30x_usart.c ****   *         @arg USART_AutoBaudRate_0x55Frame: 0x55 frame.
 868:../src/stm32f30x_usart.c ****   * @note
 869:../src/stm32f30x_usart.c ****   *   This function has to be called before calling USART_Cmd() function. 
 870:../src/stm32f30x_usart.c ****   * @retval None
 871:../src/stm32f30x_usart.c ****   */
 872:../src/stm32f30x_usart.c **** void USART_AutoBaudRateConfig(USART_TypeDef* USARTx, uint32_t USART_AutoBaudRate)
 873:../src/stm32f30x_usart.c **** {
 1259              		.loc 1 873 0
 1260              		.cfi_startproc
 1261              		@ args = 0, pretend = 0, frame = 8
 1262              		@ frame_needed = 1, uses_anonymous_args = 0
 1263              		@ link register save eliminated.
 1264 062c 80B4     		push	{r7}
 1265              	.LCFI57:
 1266              		.cfi_def_cfa_offset 4
 1267              		.cfi_offset 7, -4
 1268 062e 83B0     		sub	sp, sp, #12
 1269              	.LCFI58:
 1270              		.cfi_def_cfa_offset 16
 1271 0630 00AF     		add	r7, sp, #0
 1272              	.LCFI59:
 1273              		.cfi_def_cfa_register 7
 1274 0632 7860     		str	r0, [r7, #4]
 1275 0634 3960     		str	r1, [r7, #0]
 874:../src/stm32f30x_usart.c ****   /* Check the parameters */
 875:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 876:../src/stm32f30x_usart.c ****   assert_param(IS_USART_AUTOBAUDRATE_MODE(USART_AutoBaudRate));
 877:../src/stm32f30x_usart.c **** 
 878:../src/stm32f30x_usart.c ****   USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABRMODE);
 1276              		.loc 1 878 0
 1277 0636 7B68     		ldr	r3, [r7, #4]
 1278 0638 5B68     		ldr	r3, [r3, #4]
 1279 063a 23F4C002 		bic	r2, r3, #6291456
 1280 063e 7B68     		ldr	r3, [r7, #4]
 1281 0640 5A60     		str	r2, [r3, #4]
 879:../src/stm32f30x_usart.c ****   USARTx->CR2 |= USART_AutoBaudRate;
 1282              		.loc 1 879 0
 1283 0642 7B68     		ldr	r3, [r7, #4]
 1284 0644 5A68     		ldr	r2, [r3, #4]
 1285 0646 3B68     		ldr	r3, [r7, #0]
 1286 0648 1A43     		orrs	r2, r2, r3
 1287 064a 7B68     		ldr	r3, [r7, #4]
 1288 064c 5A60     		str	r2, [r3, #4]
 880:../src/stm32f30x_usart.c **** }
 1289              		.loc 1 880 0
 1290 064e 07F10C07 		add	r7, r7, #12
 1291 0652 BD46     		mov	sp, r7
 1292 0654 80BC     		pop	{r7}
 1293 0656 7047     		bx	lr
 1294              		.cfi_endproc
 1295              	.LFE130:
 1297              		.align	2
 1298              		.global	USART_SendData
 1299              		.thumb
 1300              		.thumb_func
 1302              	USART_SendData:
 1303              	.LFB131:
 881:../src/stm32f30x_usart.c **** 
 882:../src/stm32f30x_usart.c **** /**
 883:../src/stm32f30x_usart.c ****   * @}
 884:../src/stm32f30x_usart.c ****   */
 885:../src/stm32f30x_usart.c **** 
 886:../src/stm32f30x_usart.c **** 
 887:../src/stm32f30x_usart.c **** /** @defgroup USART_Group4 Data transfers functions
 888:../src/stm32f30x_usart.c ****  *  @brief   Data transfers functions 
 889:../src/stm32f30x_usart.c ****  *
 890:../src/stm32f30x_usart.c **** @verbatim
 891:../src/stm32f30x_usart.c ****  ===============================================================================
 892:../src/stm32f30x_usart.c ****                     ##### Data transfers functions #####
 893:../src/stm32f30x_usart.c ****  ===============================================================================
 894:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage 
 895:../src/stm32f30x_usart.c ****          the USART data transfers.
 896:../src/stm32f30x_usart.c ****     [..] During an USART reception, data shifts in least significant bit first 
 897:../src/stm32f30x_usart.c ****          through the RX pin. When a transmission is taking place, a write instruction to 
 898:../src/stm32f30x_usart.c ****          the USART_TDR register stores the data in the shift register.
 899:../src/stm32f30x_usart.c ****     [..] The read access of the USART_RDR register can be done using 
 900:../src/stm32f30x_usart.c ****          the USART_ReceiveData() function and returns the RDR value.
 901:../src/stm32f30x_usart.c ****          Whereas a write access to the USART_TDR can be done using USART_SendData()
 902:../src/stm32f30x_usart.c ****          function and stores the written data into TDR.
 903:../src/stm32f30x_usart.c **** 
 904:../src/stm32f30x_usart.c **** @endverbatim
 905:../src/stm32f30x_usart.c ****   * @{
 906:../src/stm32f30x_usart.c ****   */
 907:../src/stm32f30x_usart.c **** 
 908:../src/stm32f30x_usart.c **** /**
 909:../src/stm32f30x_usart.c ****   * @brief  Transmits single data through the USARTx peripheral.
 910:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 911:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 912:../src/stm32f30x_usart.c ****   * @param  Data: the data to transmit.
 913:../src/stm32f30x_usart.c ****   * @retval None
 914:../src/stm32f30x_usart.c ****   */
 915:../src/stm32f30x_usart.c **** void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
 916:../src/stm32f30x_usart.c **** {
 1304              		.loc 1 916 0
 1305              		.cfi_startproc
 1306              		@ args = 0, pretend = 0, frame = 8
 1307              		@ frame_needed = 1, uses_anonymous_args = 0
 1308              		@ link register save eliminated.
 1309 0658 80B4     		push	{r7}
 1310              	.LCFI60:
 1311              		.cfi_def_cfa_offset 4
 1312              		.cfi_offset 7, -4
 1313 065a 83B0     		sub	sp, sp, #12
 1314              	.LCFI61:
 1315              		.cfi_def_cfa_offset 16
 1316 065c 00AF     		add	r7, sp, #0
 1317              	.LCFI62:
 1318              		.cfi_def_cfa_register 7
 1319 065e 7860     		str	r0, [r7, #4]
 1320 0660 0B46     		mov	r3, r1
 1321 0662 7B80     		strh	r3, [r7, #2]	@ movhi
 917:../src/stm32f30x_usart.c ****   /* Check the parameters */
 918:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 919:../src/stm32f30x_usart.c ****   assert_param(IS_USART_DATA(Data)); 
 920:../src/stm32f30x_usart.c **** 
 921:../src/stm32f30x_usart.c ****   /* Transmit Data */
 922:../src/stm32f30x_usart.c ****   USARTx->TDR = (Data & (uint16_t)0x01FF);
 1322              		.loc 1 922 0
 1323 0664 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1324 0666 4FEAC353 		lsl	r3, r3, #23
 1325 066a 4FEAD353 		lsr	r3, r3, #23
 1326 066e 9AB2     		uxth	r2, r3
 1327 0670 7B68     		ldr	r3, [r7, #4]
 1328 0672 1A85     		strh	r2, [r3, #40]	@ movhi
 923:../src/stm32f30x_usart.c **** }
 1329              		.loc 1 923 0
 1330 0674 07F10C07 		add	r7, r7, #12
 1331 0678 BD46     		mov	sp, r7
 1332 067a 80BC     		pop	{r7}
 1333 067c 7047     		bx	lr
 1334              		.cfi_endproc
 1335              	.LFE131:
 1337 067e 00BF     		.align	2
 1338              		.global	USART_ReceiveData
 1339              		.thumb
 1340              		.thumb_func
 1342              	USART_ReceiveData:
 1343              	.LFB132:
 924:../src/stm32f30x_usart.c **** 
 925:../src/stm32f30x_usart.c **** /**
 926:../src/stm32f30x_usart.c ****   * @brief  Returns the most recent received data by the USARTx peripheral.
 927:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 928:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 929:../src/stm32f30x_usart.c ****   * @retval The received data.
 930:../src/stm32f30x_usart.c ****   */
 931:../src/stm32f30x_usart.c **** uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
 932:../src/stm32f30x_usart.c **** {
 1344              		.loc 1 932 0
 1345              		.cfi_startproc
 1346              		@ args = 0, pretend = 0, frame = 8
 1347              		@ frame_needed = 1, uses_anonymous_args = 0
 1348              		@ link register save eliminated.
 1349 0680 80B4     		push	{r7}
 1350              	.LCFI63:
 1351              		.cfi_def_cfa_offset 4
 1352              		.cfi_offset 7, -4
 1353 0682 83B0     		sub	sp, sp, #12
 1354              	.LCFI64:
 1355              		.cfi_def_cfa_offset 16
 1356 0684 00AF     		add	r7, sp, #0
 1357              	.LCFI65:
 1358              		.cfi_def_cfa_register 7
 1359 0686 7860     		str	r0, [r7, #4]
 933:../src/stm32f30x_usart.c ****   /* Check the parameters */
 934:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 935:../src/stm32f30x_usart.c **** 
 936:../src/stm32f30x_usart.c ****   /* Receive Data */
 937:../src/stm32f30x_usart.c ****   return (uint16_t)(USARTx->RDR & (uint16_t)0x01FF);
 1360              		.loc 1 937 0
 1361 0688 7B68     		ldr	r3, [r7, #4]
 1362 068a 9B8C     		ldrh	r3, [r3, #36]	@ movhi
 1363 068c 9BB2     		uxth	r3, r3
 1364 068e 4FEAC353 		lsl	r3, r3, #23
 1365 0692 4FEAD353 		lsr	r3, r3, #23
 1366 0696 9BB2     		uxth	r3, r3
 938:../src/stm32f30x_usart.c **** }
 1367              		.loc 1 938 0
 1368 0698 1846     		mov	r0, r3
 1369 069a 07F10C07 		add	r7, r7, #12
 1370 069e BD46     		mov	sp, r7
 1371 06a0 80BC     		pop	{r7}
 1372 06a2 7047     		bx	lr
 1373              		.cfi_endproc
 1374              	.LFE132:
 1376              		.align	2
 1377              		.global	USART_SetAddress
 1378              		.thumb
 1379              		.thumb_func
 1381              	USART_SetAddress:
 1382              	.LFB133:
 939:../src/stm32f30x_usart.c **** 
 940:../src/stm32f30x_usart.c **** /**
 941:../src/stm32f30x_usart.c ****   * @}
 942:../src/stm32f30x_usart.c ****   */
 943:../src/stm32f30x_usart.c **** 
 944:../src/stm32f30x_usart.c **** /** @defgroup USART_Group5 MultiProcessor Communication functions
 945:../src/stm32f30x_usart.c ****  *  @brief   Multi-Processor Communication functions 
 946:../src/stm32f30x_usart.c ****  *
 947:../src/stm32f30x_usart.c **** @verbatim   
 948:../src/stm32f30x_usart.c ****  ===============================================================================
 949:../src/stm32f30x_usart.c ****              ##### Multi-Processor Communication functions #####
 950:../src/stm32f30x_usart.c ****  ===============================================================================
 951:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
 952:../src/stm32f30x_usart.c ****          multiprocessor communication.
 953:../src/stm32f30x_usart.c ****     [..] For instance one of the USARTs can be the master, its TX output is
 954:../src/stm32f30x_usart.c ****          connected to the RX input of the other USART. The others are slaves,
 955:../src/stm32f30x_usart.c ****          their respective TX outputs are logically ANDed together and connected 
 956:../src/stm32f30x_usart.c ****          to the RX input of the master. USART multiprocessor communication is 
 957:../src/stm32f30x_usart.c ****          possible through the following procedure:
 958:../src/stm32f30x_usart.c ****          (#) Program the Baud rate, Word length = 9 bits, Stop bits, Parity, 
 959:../src/stm32f30x_usart.c ****              Mode transmitter or Mode receiver and hardware flow control values 
 960:../src/stm32f30x_usart.c ****              using the USART_Init() function.
 961:../src/stm32f30x_usart.c ****          (#) Configures the USART address using the USART_SetAddress() function.
 962:../src/stm32f30x_usart.c ****          (#) Configures the wake up methode (USART_WakeUp_IdleLine or 
 963:../src/stm32f30x_usart.c ****              USART_WakeUp_AddressMark) using USART_WakeUpConfig() function only 
 964:../src/stm32f30x_usart.c ****              for the slaves.
 965:../src/stm32f30x_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
 966:../src/stm32f30x_usart.c ****          (#) Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() 
 967:../src/stm32f30x_usart.c ****              function.
 968:../src/stm32f30x_usart.c ****     [..] The USART Slave exit from mute mode when receive the wake up condition.
 969:../src/stm32f30x_usart.c **** 
 970:../src/stm32f30x_usart.c **** @endverbatim
 971:../src/stm32f30x_usart.c ****   * @{
 972:../src/stm32f30x_usart.c ****   */
 973:../src/stm32f30x_usart.c **** 
 974:../src/stm32f30x_usart.c **** /**
 975:../src/stm32f30x_usart.c ****   * @brief  Sets the address of the USART node.
 976:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 977:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 978:../src/stm32f30x_usart.c ****   * @param  USART_Address: Indicates the address of the USART node.
 979:../src/stm32f30x_usart.c ****   * @retval None
 980:../src/stm32f30x_usart.c ****   */
 981:../src/stm32f30x_usart.c **** void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
 982:../src/stm32f30x_usart.c **** {
 1383              		.loc 1 982 0
 1384              		.cfi_startproc
 1385              		@ args = 0, pretend = 0, frame = 8
 1386              		@ frame_needed = 1, uses_anonymous_args = 0
 1387              		@ link register save eliminated.
 1388 06a4 80B4     		push	{r7}
 1389              	.LCFI66:
 1390              		.cfi_def_cfa_offset 4
 1391              		.cfi_offset 7, -4
 1392 06a6 83B0     		sub	sp, sp, #12
 1393              	.LCFI67:
 1394              		.cfi_def_cfa_offset 16
 1395 06a8 00AF     		add	r7, sp, #0
 1396              	.LCFI68:
 1397              		.cfi_def_cfa_register 7
 1398 06aa 7860     		str	r0, [r7, #4]
 1399 06ac 0B46     		mov	r3, r1
 1400 06ae FB70     		strb	r3, [r7, #3]
 983:../src/stm32f30x_usart.c ****   /* Check the parameters */
 984:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 985:../src/stm32f30x_usart.c **** 
 986:../src/stm32f30x_usart.c ****   /* Clear the USART address */
 987:../src/stm32f30x_usart.c ****   USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADD);
 1401              		.loc 1 987 0
 1402 06b0 7B68     		ldr	r3, [r7, #4]
 1403 06b2 5B68     		ldr	r3, [r3, #4]
 1404 06b4 23F07F42 		bic	r2, r3, #-16777216
 1405 06b8 7B68     		ldr	r3, [r7, #4]
 1406 06ba 5A60     		str	r2, [r3, #4]
 988:../src/stm32f30x_usart.c ****   /* Set the USART address node */
 989:../src/stm32f30x_usart.c ****   USARTx->CR2 |=((uint32_t)USART_Address << (uint32_t)0x18);
 1407              		.loc 1 989 0
 1408 06bc 7B68     		ldr	r3, [r7, #4]
 1409 06be 5A68     		ldr	r2, [r3, #4]
 1410 06c0 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1411 06c2 4FEA0363 		lsl	r3, r3, #24
 1412 06c6 1A43     		orrs	r2, r2, r3
 1413 06c8 7B68     		ldr	r3, [r7, #4]
 1414 06ca 5A60     		str	r2, [r3, #4]
 990:../src/stm32f30x_usart.c **** }
 1415              		.loc 1 990 0
 1416 06cc 07F10C07 		add	r7, r7, #12
 1417 06d0 BD46     		mov	sp, r7
 1418 06d2 80BC     		pop	{r7}
 1419 06d4 7047     		bx	lr
 1420              		.cfi_endproc
 1421              	.LFE133:
 1423 06d6 00BF     		.align	2
 1424              		.global	USART_MuteModeCmd
 1425              		.thumb
 1426              		.thumb_func
 1428              	USART_MuteModeCmd:
 1429              	.LFB134:
 991:../src/stm32f30x_usart.c **** 
 992:../src/stm32f30x_usart.c **** /**
 993:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's mute mode.
 994:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
 995:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
 996:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USART mute mode.
 997:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
 998:../src/stm32f30x_usart.c ****   * @retval None
 999:../src/stm32f30x_usart.c ****   */
1000:../src/stm32f30x_usart.c **** void USART_MuteModeCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1001:../src/stm32f30x_usart.c **** {
 1430              		.loc 1 1001 0
 1431              		.cfi_startproc
 1432              		@ args = 0, pretend = 0, frame = 8
 1433              		@ frame_needed = 1, uses_anonymous_args = 0
 1434              		@ link register save eliminated.
 1435 06d8 80B4     		push	{r7}
 1436              	.LCFI69:
 1437              		.cfi_def_cfa_offset 4
 1438              		.cfi_offset 7, -4
 1439 06da 83B0     		sub	sp, sp, #12
 1440              	.LCFI70:
 1441              		.cfi_def_cfa_offset 16
 1442 06dc 00AF     		add	r7, sp, #0
 1443              	.LCFI71:
 1444              		.cfi_def_cfa_register 7
 1445 06de 7860     		str	r0, [r7, #4]
 1446 06e0 0B46     		mov	r3, r1
 1447 06e2 FB70     		strb	r3, [r7, #3]
1002:../src/stm32f30x_usart.c ****   /* Check the parameters */
1003:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1004:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
1005:../src/stm32f30x_usart.c **** 
1006:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 1448              		.loc 1 1006 0
 1449 06e4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1450 06e6 002B     		cmp	r3, #0
 1451 06e8 06D0     		beq	.L62
1007:../src/stm32f30x_usart.c ****   {
1008:../src/stm32f30x_usart.c ****     /* Enable the USART mute mode by setting the MME bit in the CR1 register */
1009:../src/stm32f30x_usart.c ****     USARTx->CR1 |= USART_CR1_MME;
 1452              		.loc 1 1009 0
 1453 06ea 7B68     		ldr	r3, [r7, #4]
 1454 06ec 1B68     		ldr	r3, [r3, #0]
 1455 06ee 43F40052 		orr	r2, r3, #8192
 1456 06f2 7B68     		ldr	r3, [r7, #4]
 1457 06f4 1A60     		str	r2, [r3, #0]
 1458 06f6 05E0     		b	.L61
 1459              	.L62:
1010:../src/stm32f30x_usart.c ****   }
1011:../src/stm32f30x_usart.c ****   else
1012:../src/stm32f30x_usart.c ****   {
1013:../src/stm32f30x_usart.c ****     /* Disable the USART mute mode by clearing the MME bit in the CR1 register */
1014:../src/stm32f30x_usart.c ****     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_MME);
 1460              		.loc 1 1014 0
 1461 06f8 7B68     		ldr	r3, [r7, #4]
 1462 06fa 1B68     		ldr	r3, [r3, #0]
 1463 06fc 23F40052 		bic	r2, r3, #8192
 1464 0700 7B68     		ldr	r3, [r7, #4]
 1465 0702 1A60     		str	r2, [r3, #0]
 1466              	.L61:
1015:../src/stm32f30x_usart.c ****   }
1016:../src/stm32f30x_usart.c **** }
 1467              		.loc 1 1016 0
 1468 0704 07F10C07 		add	r7, r7, #12
 1469 0708 BD46     		mov	sp, r7
 1470 070a 80BC     		pop	{r7}
 1471 070c 7047     		bx	lr
 1472              		.cfi_endproc
 1473              	.LFE134:
 1475 070e 00BF     		.align	2
 1476              		.global	USART_MuteModeWakeUpConfig
 1477              		.thumb
 1478              		.thumb_func
 1480              	USART_MuteModeWakeUpConfig:
 1481              	.LFB135:
1017:../src/stm32f30x_usart.c **** 
1018:../src/stm32f30x_usart.c **** /**
1019:../src/stm32f30x_usart.c ****   * @brief  Selects the USART WakeUp method from mute mode.
1020:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1021:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1022:../src/stm32f30x_usart.c ****   * @param  USART_WakeUp: specifies the USART wakeup method.
1023:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1024:../src/stm32f30x_usart.c ****   *         @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
1025:../src/stm32f30x_usart.c ****   *         @arg USART_WakeUp_AddressMark: WakeUp by an address mark
1026:../src/stm32f30x_usart.c ****   * @retval None
1027:../src/stm32f30x_usart.c ****   */
1028:../src/stm32f30x_usart.c **** void USART_MuteModeWakeUpConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUp)
1029:../src/stm32f30x_usart.c **** {
 1482              		.loc 1 1029 0
 1483              		.cfi_startproc
 1484              		@ args = 0, pretend = 0, frame = 8
 1485              		@ frame_needed = 1, uses_anonymous_args = 0
 1486              		@ link register save eliminated.
 1487 0710 80B4     		push	{r7}
 1488              	.LCFI72:
 1489              		.cfi_def_cfa_offset 4
 1490              		.cfi_offset 7, -4
 1491 0712 83B0     		sub	sp, sp, #12
 1492              	.LCFI73:
 1493              		.cfi_def_cfa_offset 16
 1494 0714 00AF     		add	r7, sp, #0
 1495              	.LCFI74:
 1496              		.cfi_def_cfa_register 7
 1497 0716 7860     		str	r0, [r7, #4]
 1498 0718 3960     		str	r1, [r7, #0]
1030:../src/stm32f30x_usart.c ****   /* Check the parameters */
1031:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1032:../src/stm32f30x_usart.c ****   assert_param(IS_USART_MUTEMODE_WAKEUP(USART_WakeUp));
1033:../src/stm32f30x_usart.c **** 
1034:../src/stm32f30x_usart.c ****   USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_WAKE);
 1499              		.loc 1 1034 0
 1500 071a 7B68     		ldr	r3, [r7, #4]
 1501 071c 1B68     		ldr	r3, [r3, #0]
 1502 071e 23F40062 		bic	r2, r3, #2048
 1503 0722 7B68     		ldr	r3, [r7, #4]
 1504 0724 1A60     		str	r2, [r3, #0]
1035:../src/stm32f30x_usart.c ****   USARTx->CR1 |= USART_WakeUp;
 1505              		.loc 1 1035 0
 1506 0726 7B68     		ldr	r3, [r7, #4]
 1507 0728 1A68     		ldr	r2, [r3, #0]
 1508 072a 3B68     		ldr	r3, [r7, #0]
 1509 072c 1A43     		orrs	r2, r2, r3
 1510 072e 7B68     		ldr	r3, [r7, #4]
 1511 0730 1A60     		str	r2, [r3, #0]
1036:../src/stm32f30x_usart.c **** }
 1512              		.loc 1 1036 0
 1513 0732 07F10C07 		add	r7, r7, #12
 1514 0736 BD46     		mov	sp, r7
 1515 0738 80BC     		pop	{r7}
 1516 073a 7047     		bx	lr
 1517              		.cfi_endproc
 1518              	.LFE135:
 1520              		.align	2
 1521              		.global	USART_AddressDetectionConfig
 1522              		.thumb
 1523              		.thumb_func
 1525              	USART_AddressDetectionConfig:
 1526              	.LFB136:
1037:../src/stm32f30x_usart.c **** 
1038:../src/stm32f30x_usart.c **** /**
1039:../src/stm32f30x_usart.c ****   * @brief  Configure the the USART Address detection length.
1040:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1041:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1042:../src/stm32f30x_usart.c ****   * @param  USART_AddressLength: specifies the USART address length detection.
1043:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1044:../src/stm32f30x_usart.c ****   *         @arg USART_AddressLength_4b: 4-bit address length detection 
1045:../src/stm32f30x_usart.c ****   *         @arg USART_AddressLength_7b: 7-bit address length detection 
1046:../src/stm32f30x_usart.c ****   * @retval None
1047:../src/stm32f30x_usart.c ****   */
1048:../src/stm32f30x_usart.c **** void USART_AddressDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_AddressLength)
1049:../src/stm32f30x_usart.c **** {
 1527              		.loc 1 1049 0
 1528              		.cfi_startproc
 1529              		@ args = 0, pretend = 0, frame = 8
 1530              		@ frame_needed = 1, uses_anonymous_args = 0
 1531              		@ link register save eliminated.
 1532 073c 80B4     		push	{r7}
 1533              	.LCFI75:
 1534              		.cfi_def_cfa_offset 4
 1535              		.cfi_offset 7, -4
 1536 073e 83B0     		sub	sp, sp, #12
 1537              	.LCFI76:
 1538              		.cfi_def_cfa_offset 16
 1539 0740 00AF     		add	r7, sp, #0
 1540              	.LCFI77:
 1541              		.cfi_def_cfa_register 7
 1542 0742 7860     		str	r0, [r7, #4]
 1543 0744 3960     		str	r1, [r7, #0]
1050:../src/stm32f30x_usart.c ****   /* Check the parameters */
1051:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1052:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ADDRESS_DETECTION(USART_AddressLength));
1053:../src/stm32f30x_usart.c **** 
1054:../src/stm32f30x_usart.c ****   USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADDM7);
 1544              		.loc 1 1054 0
 1545 0746 7B68     		ldr	r3, [r7, #4]
 1546 0748 5B68     		ldr	r3, [r3, #4]
 1547 074a 23F01002 		bic	r2, r3, #16
 1548 074e 7B68     		ldr	r3, [r7, #4]
 1549 0750 5A60     		str	r2, [r3, #4]
1055:../src/stm32f30x_usart.c ****   USARTx->CR2 |= USART_AddressLength;
 1550              		.loc 1 1055 0
 1551 0752 7B68     		ldr	r3, [r7, #4]
 1552 0754 5A68     		ldr	r2, [r3, #4]
 1553 0756 3B68     		ldr	r3, [r7, #0]
 1554 0758 1A43     		orrs	r2, r2, r3
 1555 075a 7B68     		ldr	r3, [r7, #4]
 1556 075c 5A60     		str	r2, [r3, #4]
1056:../src/stm32f30x_usart.c **** }
 1557              		.loc 1 1056 0
 1558 075e 07F10C07 		add	r7, r7, #12
 1559 0762 BD46     		mov	sp, r7
 1560 0764 80BC     		pop	{r7}
 1561 0766 7047     		bx	lr
 1562              		.cfi_endproc
 1563              	.LFE136:
 1565              		.align	2
 1566              		.global	USART_LINBreakDetectLengthConfig
 1567              		.thumb
 1568              		.thumb_func
 1570              	USART_LINBreakDetectLengthConfig:
 1571              	.LFB137:
1057:../src/stm32f30x_usart.c **** 
1058:../src/stm32f30x_usart.c **** /**
1059:../src/stm32f30x_usart.c ****   * @}
1060:../src/stm32f30x_usart.c ****   */
1061:../src/stm32f30x_usart.c **** 
1062:../src/stm32f30x_usart.c **** /** @defgroup USART_Group6 LIN mode functions
1063:../src/stm32f30x_usart.c ****  *  @brief   LIN mode functions 
1064:../src/stm32f30x_usart.c ****  *
1065:../src/stm32f30x_usart.c **** @verbatim   
1066:../src/stm32f30x_usart.c ****  ===============================================================================
1067:../src/stm32f30x_usart.c ****                        ##### LIN mode functions #####
1068:../src/stm32f30x_usart.c ****  ===============================================================================
1069:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART 
1070:../src/stm32f30x_usart.c ****          LIN Mode communication.
1071:../src/stm32f30x_usart.c ****     [..] In LIN mode, 8-bit data format with 1 stop bit is required in accordance 
1072:../src/stm32f30x_usart.c ****          with the LIN standard.
1073:../src/stm32f30x_usart.c ****     [..] Only this LIN Feature is supported by the USART IP:
1074:../src/stm32f30x_usart.c ****          (+) LIN Master Synchronous Break send capability and LIN slave break 
1075:../src/stm32f30x_usart.c ****              detection capability :  13-bit break generation and 10/11 bit break 
1076:../src/stm32f30x_usart.c ****              detection.
1077:../src/stm32f30x_usart.c ****     [..] USART LIN Master transmitter communication is possible through the 
1078:../src/stm32f30x_usart.c ****          following procedure:
1079:../src/stm32f30x_usart.c ****          (#) Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
1080:../src/stm32f30x_usart.c ****              Mode transmitter or Mode receiver and hardware flow control values 
1081:../src/stm32f30x_usart.c ****              using the USART_Init() function.
1082:../src/stm32f30x_usart.c ****          (#) Enable the LIN mode using the USART_LINCmd() function.
1083:../src/stm32f30x_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1084:../src/stm32f30x_usart.c ****          (#) Send the break character using USART_SendBreak() function.
1085:../src/stm32f30x_usart.c ****     [..] USART LIN Master receiver communication is possible through the 
1086:../src/stm32f30x_usart.c ****          following procedure:
1087:../src/stm32f30x_usart.c ****          (#) Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
1088:../src/stm32f30x_usart.c ****              Mode transmitter or Mode receiver and hardware flow control values 
1089:../src/stm32f30x_usart.c ****              using the USART_Init() function.
1090:../src/stm32f30x_usart.c ****          (#) Configures the break detection length 
1091:../src/stm32f30x_usart.c ****              using the USART_LINBreakDetectLengthConfig() function.
1092:../src/stm32f30x_usart.c ****          (#) Enable the LIN mode using the USART_LINCmd() function.
1093:../src/stm32f30x_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1094:../src/stm32f30x_usart.c ****          [..]
1095:../src/stm32f30x_usart.c ****          (@) In LIN mode, the following bits must be kept cleared:
1096:../src/stm32f30x_usart.c ****              (+@) CLKEN in the USART_CR2 register.
1097:../src/stm32f30x_usart.c ****              (+@) STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
1098:../src/stm32f30x_usart.c **** 
1099:../src/stm32f30x_usart.c **** @endverbatim
1100:../src/stm32f30x_usart.c ****   * @{
1101:../src/stm32f30x_usart.c ****   */
1102:../src/stm32f30x_usart.c **** 
1103:../src/stm32f30x_usart.c **** /**
1104:../src/stm32f30x_usart.c ****   * @brief  Sets the USART LIN Break detection length.
1105:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1106:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1107:../src/stm32f30x_usart.c ****   * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
1108:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1109:../src/stm32f30x_usart.c ****   *         @arg USART_LINBreakDetectLength_10b: 10-bit break detection
1110:../src/stm32f30x_usart.c ****   *         @arg USART_LINBreakDetectLength_11b: 11-bit break detection
1111:../src/stm32f30x_usart.c ****   * @retval None
1112:../src/stm32f30x_usart.c ****   */
1113:../src/stm32f30x_usart.c **** void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint32_t USART_LINBreakDetectLength)
1114:../src/stm32f30x_usart.c **** {
 1572              		.loc 1 1114 0
 1573              		.cfi_startproc
 1574              		@ args = 0, pretend = 0, frame = 8
 1575              		@ frame_needed = 1, uses_anonymous_args = 0
 1576              		@ link register save eliminated.
 1577 0768 80B4     		push	{r7}
 1578              	.LCFI78:
 1579              		.cfi_def_cfa_offset 4
 1580              		.cfi_offset 7, -4
 1581 076a 83B0     		sub	sp, sp, #12
 1582              	.LCFI79:
 1583              		.cfi_def_cfa_offset 16
 1584 076c 00AF     		add	r7, sp, #0
 1585              	.LCFI80:
 1586              		.cfi_def_cfa_register 7
 1587 076e 7860     		str	r0, [r7, #4]
 1588 0770 3960     		str	r1, [r7, #0]
1115:../src/stm32f30x_usart.c ****   /* Check the parameters */
1116:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1117:../src/stm32f30x_usart.c ****   assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
1118:../src/stm32f30x_usart.c **** 
1119:../src/stm32f30x_usart.c ****   USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LBDL);
 1589              		.loc 1 1119 0
 1590 0772 7B68     		ldr	r3, [r7, #4]
 1591 0774 5B68     		ldr	r3, [r3, #4]
 1592 0776 23F02002 		bic	r2, r3, #32
 1593 077a 7B68     		ldr	r3, [r7, #4]
 1594 077c 5A60     		str	r2, [r3, #4]
1120:../src/stm32f30x_usart.c ****   USARTx->CR2 |= USART_LINBreakDetectLength;  
 1595              		.loc 1 1120 0
 1596 077e 7B68     		ldr	r3, [r7, #4]
 1597 0780 5A68     		ldr	r2, [r3, #4]
 1598 0782 3B68     		ldr	r3, [r7, #0]
 1599 0784 1A43     		orrs	r2, r2, r3
 1600 0786 7B68     		ldr	r3, [r7, #4]
 1601 0788 5A60     		str	r2, [r3, #4]
1121:../src/stm32f30x_usart.c **** }
 1602              		.loc 1 1121 0
 1603 078a 07F10C07 		add	r7, r7, #12
 1604 078e BD46     		mov	sp, r7
 1605 0790 80BC     		pop	{r7}
 1606 0792 7047     		bx	lr
 1607              		.cfi_endproc
 1608              	.LFE137:
 1610              		.align	2
 1611              		.global	USART_LINCmd
 1612              		.thumb
 1613              		.thumb_func
 1615              	USART_LINCmd:
 1616              	.LFB138:
1122:../src/stm32f30x_usart.c **** 
1123:../src/stm32f30x_usart.c **** /**
1124:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's LIN mode.
1125:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1126:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1127:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USART LIN mode.
1128:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
1129:../src/stm32f30x_usart.c ****   * @retval None
1130:../src/stm32f30x_usart.c ****   */
1131:../src/stm32f30x_usart.c **** void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1132:../src/stm32f30x_usart.c **** {
 1617              		.loc 1 1132 0
 1618              		.cfi_startproc
 1619              		@ args = 0, pretend = 0, frame = 8
 1620              		@ frame_needed = 1, uses_anonymous_args = 0
 1621              		@ link register save eliminated.
 1622 0794 80B4     		push	{r7}
 1623              	.LCFI81:
 1624              		.cfi_def_cfa_offset 4
 1625              		.cfi_offset 7, -4
 1626 0796 83B0     		sub	sp, sp, #12
 1627              	.LCFI82:
 1628              		.cfi_def_cfa_offset 16
 1629 0798 00AF     		add	r7, sp, #0
 1630              	.LCFI83:
 1631              		.cfi_def_cfa_register 7
 1632 079a 7860     		str	r0, [r7, #4]
 1633 079c 0B46     		mov	r3, r1
 1634 079e FB70     		strb	r3, [r7, #3]
1133:../src/stm32f30x_usart.c ****   /* Check the parameters */
1134:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1135:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1136:../src/stm32f30x_usart.c **** 
1137:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 1635              		.loc 1 1137 0
 1636 07a0 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1637 07a2 002B     		cmp	r3, #0
 1638 07a4 06D0     		beq	.L68
1138:../src/stm32f30x_usart.c ****   {
1139:../src/stm32f30x_usart.c ****     /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
1140:../src/stm32f30x_usart.c ****     USARTx->CR2 |= USART_CR2_LINEN;
 1639              		.loc 1 1140 0
 1640 07a6 7B68     		ldr	r3, [r7, #4]
 1641 07a8 5B68     		ldr	r3, [r3, #4]
 1642 07aa 43F48042 		orr	r2, r3, #16384
 1643 07ae 7B68     		ldr	r3, [r7, #4]
 1644 07b0 5A60     		str	r2, [r3, #4]
 1645 07b2 05E0     		b	.L67
 1646              	.L68:
1141:../src/stm32f30x_usart.c ****   }
1142:../src/stm32f30x_usart.c ****   else
1143:../src/stm32f30x_usart.c ****   {
1144:../src/stm32f30x_usart.c ****     /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
1145:../src/stm32f30x_usart.c ****     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LINEN);
 1647              		.loc 1 1145 0
 1648 07b4 7B68     		ldr	r3, [r7, #4]
 1649 07b6 5B68     		ldr	r3, [r3, #4]
 1650 07b8 23F48042 		bic	r2, r3, #16384
 1651 07bc 7B68     		ldr	r3, [r7, #4]
 1652 07be 5A60     		str	r2, [r3, #4]
 1653              	.L67:
1146:../src/stm32f30x_usart.c ****   }
1147:../src/stm32f30x_usart.c **** }
 1654              		.loc 1 1147 0
 1655 07c0 07F10C07 		add	r7, r7, #12
 1656 07c4 BD46     		mov	sp, r7
 1657 07c6 80BC     		pop	{r7}
 1658 07c8 7047     		bx	lr
 1659              		.cfi_endproc
 1660              	.LFE138:
 1662 07ca 00BF     		.align	2
 1663              		.global	USART_HalfDuplexCmd
 1664              		.thumb
 1665              		.thumb_func
 1667              	USART_HalfDuplexCmd:
 1668              	.LFB139:
1148:../src/stm32f30x_usart.c **** 
1149:../src/stm32f30x_usart.c **** /**
1150:../src/stm32f30x_usart.c ****   * @}
1151:../src/stm32f30x_usart.c ****   */
1152:../src/stm32f30x_usart.c **** 
1153:../src/stm32f30x_usart.c **** /** @defgroup USART_Group7 Halfduplex mode function
1154:../src/stm32f30x_usart.c ****  *  @brief   Half-duplex mode function 
1155:../src/stm32f30x_usart.c ****  *
1156:../src/stm32f30x_usart.c **** @verbatim   
1157:../src/stm32f30x_usart.c ****  ===============================================================================
1158:../src/stm32f30x_usart.c ****                    ##### Half-duplex mode function #####
1159:../src/stm32f30x_usart.c ****  ===============================================================================
1160:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
1161:../src/stm32f30x_usart.c ****          Half-duplex communication.
1162:../src/stm32f30x_usart.c ****     [..] The USART can be configured to follow a single-wire half-duplex protocol 
1163:../src/stm32f30x_usart.c ****          where the TX and RX lines are internally connected.
1164:../src/stm32f30x_usart.c ****     [..] USART Half duplex communication is possible through the following procedure:
1165:../src/stm32f30x_usart.c ****          (#) Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
1166:../src/stm32f30x_usart.c ****              or Mode receiver and hardware flow control values using the USART_Init()
1167:../src/stm32f30x_usart.c ****             function.
1168:../src/stm32f30x_usart.c ****          (#) Configures the USART address using the USART_SetAddress() function.
1169:../src/stm32f30x_usart.c ****          (#) Enable the half duplex mode using USART_HalfDuplexCmd() function.
1170:../src/stm32f30x_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1171:../src/stm32f30x_usart.c ****          [..]
1172:../src/stm32f30x_usart.c ****          (@) The RX pin is no longer used.
1173:../src/stm32f30x_usart.c ****          (@) In Half-duplex mode the following bits must be kept cleared:
1174:../src/stm32f30x_usart.c ****              (+@) LINEN and CLKEN bits in the USART_CR2 register.
1175:../src/stm32f30x_usart.c ****              (+@) SCEN and IREN bits in the USART_CR3 register.
1176:../src/stm32f30x_usart.c **** 
1177:../src/stm32f30x_usart.c **** @endverbatim
1178:../src/stm32f30x_usart.c ****   * @{
1179:../src/stm32f30x_usart.c ****   */
1180:../src/stm32f30x_usart.c **** 
1181:../src/stm32f30x_usart.c **** /**
1182:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's Half Duplex communication.
1183:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1184:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1185:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the USART Communication.
1186:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
1187:../src/stm32f30x_usart.c ****   * @retval None
1188:../src/stm32f30x_usart.c ****   */
1189:../src/stm32f30x_usart.c **** void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1190:../src/stm32f30x_usart.c **** {
 1669              		.loc 1 1190 0
 1670              		.cfi_startproc
 1671              		@ args = 0, pretend = 0, frame = 8
 1672              		@ frame_needed = 1, uses_anonymous_args = 0
 1673              		@ link register save eliminated.
 1674 07cc 80B4     		push	{r7}
 1675              	.LCFI84:
 1676              		.cfi_def_cfa_offset 4
 1677              		.cfi_offset 7, -4
 1678 07ce 83B0     		sub	sp, sp, #12
 1679              	.LCFI85:
 1680              		.cfi_def_cfa_offset 16
 1681 07d0 00AF     		add	r7, sp, #0
 1682              	.LCFI86:
 1683              		.cfi_def_cfa_register 7
 1684 07d2 7860     		str	r0, [r7, #4]
 1685 07d4 0B46     		mov	r3, r1
 1686 07d6 FB70     		strb	r3, [r7, #3]
1191:../src/stm32f30x_usart.c ****   /* Check the parameters */
1192:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1193:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1194:../src/stm32f30x_usart.c ****   
1195:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 1687              		.loc 1 1195 0
 1688 07d8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1689 07da 002B     		cmp	r3, #0
 1690 07dc 06D0     		beq	.L71
1196:../src/stm32f30x_usart.c ****   {
1197:../src/stm32f30x_usart.c ****     /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
1198:../src/stm32f30x_usart.c ****     USARTx->CR3 |= USART_CR3_HDSEL;
 1691              		.loc 1 1198 0
 1692 07de 7B68     		ldr	r3, [r7, #4]
 1693 07e0 9B68     		ldr	r3, [r3, #8]
 1694 07e2 43F00802 		orr	r2, r3, #8
 1695 07e6 7B68     		ldr	r3, [r7, #4]
 1696 07e8 9A60     		str	r2, [r3, #8]
 1697 07ea 05E0     		b	.L70
 1698              	.L71:
1199:../src/stm32f30x_usart.c ****   }
1200:../src/stm32f30x_usart.c ****   else
1201:../src/stm32f30x_usart.c ****   {
1202:../src/stm32f30x_usart.c ****     /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
1203:../src/stm32f30x_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_HDSEL);
 1699              		.loc 1 1203 0
 1700 07ec 7B68     		ldr	r3, [r7, #4]
 1701 07ee 9B68     		ldr	r3, [r3, #8]
 1702 07f0 23F00802 		bic	r2, r3, #8
 1703 07f4 7B68     		ldr	r3, [r7, #4]
 1704 07f6 9A60     		str	r2, [r3, #8]
 1705              	.L70:
1204:../src/stm32f30x_usart.c ****   }
1205:../src/stm32f30x_usart.c **** }
 1706              		.loc 1 1205 0
 1707 07f8 07F10C07 		add	r7, r7, #12
 1708 07fc BD46     		mov	sp, r7
 1709 07fe 80BC     		pop	{r7}
 1710 0800 7047     		bx	lr
 1711              		.cfi_endproc
 1712              	.LFE139:
 1714 0802 00BF     		.align	2
 1715              		.global	USART_SetGuardTime
 1716              		.thumb
 1717              		.thumb_func
 1719              	USART_SetGuardTime:
 1720              	.LFB140:
1206:../src/stm32f30x_usart.c **** 
1207:../src/stm32f30x_usart.c **** /**
1208:../src/stm32f30x_usart.c ****   * @}
1209:../src/stm32f30x_usart.c ****   */
1210:../src/stm32f30x_usart.c **** 
1211:../src/stm32f30x_usart.c **** 
1212:../src/stm32f30x_usart.c **** /** @defgroup USART_Group8 Smartcard mode functions
1213:../src/stm32f30x_usart.c ****  *  @brief   Smartcard mode functions 
1214:../src/stm32f30x_usart.c ****  *
1215:../src/stm32f30x_usart.c **** @verbatim   
1216:../src/stm32f30x_usart.c ****  ===============================================================================
1217:../src/stm32f30x_usart.c ****                      ##### Smartcard mode functions #####
1218:../src/stm32f30x_usart.c ****  ===============================================================================
1219:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
1220:../src/stm32f30x_usart.c ****          Smartcard communication.
1221:../src/stm32f30x_usart.c ****     [..] The Smartcard interface is designed to support asynchronous protocol 
1222:../src/stm32f30x_usart.c ****          Smartcards as defined in the ISO 7816-3 standard. The USART can provide 
1223:../src/stm32f30x_usart.c ****          a clock to the smartcard through the SCLK output. In smartcard mode, 
1224:../src/stm32f30x_usart.c ****          SCLK is not associated to the communication but is simply derived from 
1225:../src/stm32f30x_usart.c ****          the internal peripheral input clock through a 5-bit prescaler.
1226:../src/stm32f30x_usart.c ****     [..] Smartcard communication is possible through the following procedure:
1227:../src/stm32f30x_usart.c ****          (#) Configures the Smartcard Prsecaler using the USART_SetPrescaler() 
1228:../src/stm32f30x_usart.c ****              function.
1229:../src/stm32f30x_usart.c ****          (#) Configures the Smartcard Guard Time using the USART_SetGuardTime() 
1230:../src/stm32f30x_usart.c ****              function.
1231:../src/stm32f30x_usart.c ****          (#) Program the USART clock using the USART_ClockInit() function as following:
1232:../src/stm32f30x_usart.c ****              (++) USART Clock enabled.
1233:../src/stm32f30x_usart.c ****              (++) USART CPOL Low.
1234:../src/stm32f30x_usart.c ****              (++) USART CPHA on first edge.
1235:../src/stm32f30x_usart.c ****              (++) USART Last Bit Clock Enabled.
1236:../src/stm32f30x_usart.c ****          (#) Program the Smartcard interface using the USART_Init() function as 
1237:../src/stm32f30x_usart.c ****              following:
1238:../src/stm32f30x_usart.c ****              (++) Word Length = 9 Bits.
1239:../src/stm32f30x_usart.c ****              (++) 1.5 Stop Bit.
1240:../src/stm32f30x_usart.c ****              (++) Even parity.
1241:../src/stm32f30x_usart.c ****              (++) BaudRate = 12096 baud.
1242:../src/stm32f30x_usart.c ****              (++) Hardware flow control disabled (RTS and CTS signals).
1243:../src/stm32f30x_usart.c ****              (++) Tx and Rx enabled
1244:../src/stm32f30x_usart.c ****          (#) Optionally you can enable the parity error interrupt using 
1245:../src/stm32f30x_usart.c ****              the USART_ITConfig() function.
1246:../src/stm32f30x_usart.c ****          (#) Enable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
1247:../src/stm32f30x_usart.c ****          (#) Enable the Smartcard interface using the USART_SmartCardCmd() function.
1248:../src/stm32f30x_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1249:../src/stm32f30x_usart.c ****     [..] 
1250:../src/stm32f30x_usart.c ****   Please refer to the ISO 7816-3 specification for more details.
1251:../src/stm32f30x_usart.c ****     [..] 
1252:../src/stm32f30x_usart.c ****          (@) It is also possible to choose 0.5 stop bit for receiving but it is 
1253:../src/stm32f30x_usart.c ****              recommended to use 1.5 stop bits for both transmitting and receiving 
1254:../src/stm32f30x_usart.c ****              to avoid switching between the two configurations.
1255:../src/stm32f30x_usart.c ****          (@) In smartcard mode, the following bits must be kept cleared:
1256:../src/stm32f30x_usart.c ****              (+@) LINEN bit in the USART_CR2 register.
1257:../src/stm32f30x_usart.c ****              (+@) HDSEL and IREN bits in the USART_CR3 register.
1258:../src/stm32f30x_usart.c **** 
1259:../src/stm32f30x_usart.c **** @endverbatim
1260:../src/stm32f30x_usart.c ****   * @{
1261:../src/stm32f30x_usart.c ****   */
1262:../src/stm32f30x_usart.c **** 
1263:../src/stm32f30x_usart.c **** /**
1264:../src/stm32f30x_usart.c ****   * @brief  Sets the specified USART guard time.
1265:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1266:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3.
1267:../src/stm32f30x_usart.c ****   * @param  USART_GuardTime: specifies the guard time.
1268:../src/stm32f30x_usart.c ****   * @retval None
1269:../src/stm32f30x_usart.c ****   */
1270:../src/stm32f30x_usart.c **** void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
1271:../src/stm32f30x_usart.c **** {    
 1721              		.loc 1 1271 0
 1722              		.cfi_startproc
 1723              		@ args = 0, pretend = 0, frame = 8
 1724              		@ frame_needed = 1, uses_anonymous_args = 0
 1725              		@ link register save eliminated.
 1726 0804 80B4     		push	{r7}
 1727              	.LCFI87:
 1728              		.cfi_def_cfa_offset 4
 1729              		.cfi_offset 7, -4
 1730 0806 83B0     		sub	sp, sp, #12
 1731              	.LCFI88:
 1732              		.cfi_def_cfa_offset 16
 1733 0808 00AF     		add	r7, sp, #0
 1734              	.LCFI89:
 1735              		.cfi_def_cfa_register 7
 1736 080a 7860     		str	r0, [r7, #4]
 1737 080c 0B46     		mov	r3, r1
 1738 080e FB70     		strb	r3, [r7, #3]
1272:../src/stm32f30x_usart.c ****   /* Check the parameters */
1273:../src/stm32f30x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1274:../src/stm32f30x_usart.c **** 
1275:../src/stm32f30x_usart.c ****   /* Clear the USART Guard time */
1276:../src/stm32f30x_usart.c ****   USARTx->GTPR &= USART_GTPR_PSC;
 1739              		.loc 1 1276 0
 1740 0810 7B68     		ldr	r3, [r7, #4]
 1741 0812 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1742 0814 9BB2     		uxth	r3, r3
 1743 0816 DBB2     		uxtb	r3, r3
 1744 0818 9AB2     		uxth	r2, r3
 1745 081a 7B68     		ldr	r3, [r7, #4]
 1746 081c 1A82     		strh	r2, [r3, #16]	@ movhi
1277:../src/stm32f30x_usart.c ****   /* Set the USART guard time */
1278:../src/stm32f30x_usart.c ****   USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 1747              		.loc 1 1278 0
 1748 081e 7B68     		ldr	r3, [r7, #4]
 1749 0820 1B8A     		ldrh	r3, [r3, #16]	@ movhi
 1750 0822 9AB2     		uxth	r2, r3
 1751 0824 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1752 0826 9BB2     		uxth	r3, r3
 1753 0828 4FEA0323 		lsl	r3, r3, #8
 1754 082c 9BB2     		uxth	r3, r3
 1755 082e 1343     		orrs	r3, r3, r2
 1756 0830 9AB2     		uxth	r2, r3
 1757 0832 7B68     		ldr	r3, [r7, #4]
 1758 0834 1A82     		strh	r2, [r3, #16]	@ movhi
1279:../src/stm32f30x_usart.c **** }
 1759              		.loc 1 1279 0
 1760 0836 07F10C07 		add	r7, r7, #12
 1761 083a BD46     		mov	sp, r7
 1762 083c 80BC     		pop	{r7}
 1763 083e 7047     		bx	lr
 1764              		.cfi_endproc
 1765              	.LFE140:
 1767              		.align	2
 1768              		.global	USART_SmartCardCmd
 1769              		.thumb
 1770              		.thumb_func
 1772              	USART_SmartCardCmd:
 1773              	.LFB141:
1280:../src/stm32f30x_usart.c **** 
1281:../src/stm32f30x_usart.c **** /**
1282:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's Smart Card mode.
1283:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1284:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3.
1285:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the Smart Card mode.
1286:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.      
1287:../src/stm32f30x_usart.c ****   * @retval None
1288:../src/stm32f30x_usart.c ****   */
1289:../src/stm32f30x_usart.c **** void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1290:../src/stm32f30x_usart.c **** {
 1774              		.loc 1 1290 0
 1775              		.cfi_startproc
 1776              		@ args = 0, pretend = 0, frame = 8
 1777              		@ frame_needed = 1, uses_anonymous_args = 0
 1778              		@ link register save eliminated.
 1779 0840 80B4     		push	{r7}
 1780              	.LCFI90:
 1781              		.cfi_def_cfa_offset 4
 1782              		.cfi_offset 7, -4
 1783 0842 83B0     		sub	sp, sp, #12
 1784              	.LCFI91:
 1785              		.cfi_def_cfa_offset 16
 1786 0844 00AF     		add	r7, sp, #0
 1787              	.LCFI92:
 1788              		.cfi_def_cfa_register 7
 1789 0846 7860     		str	r0, [r7, #4]
 1790 0848 0B46     		mov	r3, r1
 1791 084a FB70     		strb	r3, [r7, #3]
1291:../src/stm32f30x_usart.c ****   /* Check the parameters */
1292:../src/stm32f30x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1293:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1294:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 1792              		.loc 1 1294 0
 1793 084c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1794 084e 002B     		cmp	r3, #0
 1795 0850 06D0     		beq	.L75
1295:../src/stm32f30x_usart.c ****   {
1296:../src/stm32f30x_usart.c ****     /* Enable the SC mode by setting the SCEN bit in the CR3 register */
1297:../src/stm32f30x_usart.c ****     USARTx->CR3 |= USART_CR3_SCEN;
 1796              		.loc 1 1297 0
 1797 0852 7B68     		ldr	r3, [r7, #4]
 1798 0854 9B68     		ldr	r3, [r3, #8]
 1799 0856 43F02002 		orr	r2, r3, #32
 1800 085a 7B68     		ldr	r3, [r7, #4]
 1801 085c 9A60     		str	r2, [r3, #8]
 1802 085e 05E0     		b	.L74
 1803              	.L75:
1298:../src/stm32f30x_usart.c ****   }
1299:../src/stm32f30x_usart.c ****   else
1300:../src/stm32f30x_usart.c ****   {
1301:../src/stm32f30x_usart.c ****     /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
1302:../src/stm32f30x_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCEN);
 1804              		.loc 1 1302 0
 1805 0860 7B68     		ldr	r3, [r7, #4]
 1806 0862 9B68     		ldr	r3, [r3, #8]
 1807 0864 23F02002 		bic	r2, r3, #32
 1808 0868 7B68     		ldr	r3, [r7, #4]
 1809 086a 9A60     		str	r2, [r3, #8]
 1810              	.L74:
1303:../src/stm32f30x_usart.c ****   }
1304:../src/stm32f30x_usart.c **** }
 1811              		.loc 1 1304 0
 1812 086c 07F10C07 		add	r7, r7, #12
 1813 0870 BD46     		mov	sp, r7
 1814 0872 80BC     		pop	{r7}
 1815 0874 7047     		bx	lr
 1816              		.cfi_endproc
 1817              	.LFE141:
 1819 0876 00BF     		.align	2
 1820              		.global	USART_SmartCardNACKCmd
 1821              		.thumb
 1822              		.thumb_func
 1824              	USART_SmartCardNACKCmd:
 1825              	.LFB142:
1305:../src/stm32f30x_usart.c **** 
1306:../src/stm32f30x_usart.c **** /**
1307:../src/stm32f30x_usart.c ****   * @brief  Enables or disables NACK transmission.
1308:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1309:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3.
1310:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the NACK transmission.
1311:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.  
1312:../src/stm32f30x_usart.c ****   * @retval None
1313:../src/stm32f30x_usart.c ****   */
1314:../src/stm32f30x_usart.c **** void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
1315:../src/stm32f30x_usart.c **** {
 1826              		.loc 1 1315 0
 1827              		.cfi_startproc
 1828              		@ args = 0, pretend = 0, frame = 8
 1829              		@ frame_needed = 1, uses_anonymous_args = 0
 1830              		@ link register save eliminated.
 1831 0878 80B4     		push	{r7}
 1832              	.LCFI93:
 1833              		.cfi_def_cfa_offset 4
 1834              		.cfi_offset 7, -4
 1835 087a 83B0     		sub	sp, sp, #12
 1836              	.LCFI94:
 1837              		.cfi_def_cfa_offset 16
 1838 087c 00AF     		add	r7, sp, #0
 1839              	.LCFI95:
 1840              		.cfi_def_cfa_register 7
 1841 087e 7860     		str	r0, [r7, #4]
 1842 0880 0B46     		mov	r3, r1
 1843 0882 FB70     		strb	r3, [r7, #3]
1316:../src/stm32f30x_usart.c ****   /* Check the parameters */
1317:../src/stm32f30x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx)); 
1318:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1319:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 1844              		.loc 1 1319 0
 1845 0884 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1846 0886 002B     		cmp	r3, #0
 1847 0888 06D0     		beq	.L78
1320:../src/stm32f30x_usart.c ****   {
1321:../src/stm32f30x_usart.c ****     /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
1322:../src/stm32f30x_usart.c ****     USARTx->CR3 |= USART_CR3_NACK;
 1848              		.loc 1 1322 0
 1849 088a 7B68     		ldr	r3, [r7, #4]
 1850 088c 9B68     		ldr	r3, [r3, #8]
 1851 088e 43F01002 		orr	r2, r3, #16
 1852 0892 7B68     		ldr	r3, [r7, #4]
 1853 0894 9A60     		str	r2, [r3, #8]
 1854 0896 05E0     		b	.L77
 1855              	.L78:
1323:../src/stm32f30x_usart.c ****   }
1324:../src/stm32f30x_usart.c ****   else
1325:../src/stm32f30x_usart.c ****   {
1326:../src/stm32f30x_usart.c ****     /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
1327:../src/stm32f30x_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_NACK);
 1856              		.loc 1 1327 0
 1857 0898 7B68     		ldr	r3, [r7, #4]
 1858 089a 9B68     		ldr	r3, [r3, #8]
 1859 089c 23F01002 		bic	r2, r3, #16
 1860 08a0 7B68     		ldr	r3, [r7, #4]
 1861 08a2 9A60     		str	r2, [r3, #8]
 1862              	.L77:
1328:../src/stm32f30x_usart.c ****   }
1329:../src/stm32f30x_usart.c **** }
 1863              		.loc 1 1329 0
 1864 08a4 07F10C07 		add	r7, r7, #12
 1865 08a8 BD46     		mov	sp, r7
 1866 08aa 80BC     		pop	{r7}
 1867 08ac 7047     		bx	lr
 1868              		.cfi_endproc
 1869              	.LFE142:
 1871 08ae 00BF     		.align	2
 1872              		.global	USART_SetAutoRetryCount
 1873              		.thumb
 1874              		.thumb_func
 1876              	USART_SetAutoRetryCount:
 1877              	.LFB143:
1330:../src/stm32f30x_usart.c **** 
1331:../src/stm32f30x_usart.c **** /**
1332:../src/stm32f30x_usart.c ****   * @brief  Sets the Smart Card number of retries in transmit and receive.
1333:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1334:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3.
1335:../src/stm32f30x_usart.c ****   * @param  USART_AutoCount: specifies the Smart Card auto retry count.
1336:../src/stm32f30x_usart.c ****   * @retval None
1337:../src/stm32f30x_usart.c ****   */
1338:../src/stm32f30x_usart.c **** void USART_SetAutoRetryCount(USART_TypeDef* USARTx, uint8_t USART_AutoCount)
1339:../src/stm32f30x_usart.c **** {    
 1878              		.loc 1 1339 0
 1879              		.cfi_startproc
 1880              		@ args = 0, pretend = 0, frame = 8
 1881              		@ frame_needed = 1, uses_anonymous_args = 0
 1882              		@ link register save eliminated.
 1883 08b0 80B4     		push	{r7}
 1884              	.LCFI96:
 1885              		.cfi_def_cfa_offset 4
 1886              		.cfi_offset 7, -4
 1887 08b2 83B0     		sub	sp, sp, #12
 1888              	.LCFI97:
 1889              		.cfi_def_cfa_offset 16
 1890 08b4 00AF     		add	r7, sp, #0
 1891              	.LCFI98:
 1892              		.cfi_def_cfa_register 7
 1893 08b6 7860     		str	r0, [r7, #4]
 1894 08b8 0B46     		mov	r3, r1
 1895 08ba FB70     		strb	r3, [r7, #3]
1340:../src/stm32f30x_usart.c ****   /* Check the parameters */
1341:../src/stm32f30x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1342:../src/stm32f30x_usart.c ****   assert_param(IS_USART_AUTO_RETRY_COUNTER(USART_AutoCount));
1343:../src/stm32f30x_usart.c ****   /* Clear the USART auto retry count */
1344:../src/stm32f30x_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCARCNT);
 1896              		.loc 1 1344 0
 1897 08bc 7B68     		ldr	r3, [r7, #4]
 1898 08be 9B68     		ldr	r3, [r3, #8]
 1899 08c0 23F46022 		bic	r2, r3, #917504
 1900 08c4 7B68     		ldr	r3, [r7, #4]
 1901 08c6 9A60     		str	r2, [r3, #8]
1345:../src/stm32f30x_usart.c ****   /* Set the USART auto retry count*/
1346:../src/stm32f30x_usart.c ****   USARTx->CR3 |= (uint32_t)((uint32_t)USART_AutoCount << 0x11);
 1902              		.loc 1 1346 0
 1903 08c8 7B68     		ldr	r3, [r7, #4]
 1904 08ca 9A68     		ldr	r2, [r3, #8]
 1905 08cc FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1906 08ce 4FEA4343 		lsl	r3, r3, #17
 1907 08d2 1A43     		orrs	r2, r2, r3
 1908 08d4 7B68     		ldr	r3, [r7, #4]
 1909 08d6 9A60     		str	r2, [r3, #8]
1347:../src/stm32f30x_usart.c **** }
 1910              		.loc 1 1347 0
 1911 08d8 07F10C07 		add	r7, r7, #12
 1912 08dc BD46     		mov	sp, r7
 1913 08de 80BC     		pop	{r7}
 1914 08e0 7047     		bx	lr
 1915              		.cfi_endproc
 1916              	.LFE143:
 1918 08e2 00BF     		.align	2
 1919              		.global	USART_SetBlockLength
 1920              		.thumb
 1921              		.thumb_func
 1923              	USART_SetBlockLength:
 1924              	.LFB144:
1348:../src/stm32f30x_usart.c **** 
1349:../src/stm32f30x_usart.c **** /**
1350:../src/stm32f30x_usart.c ****   * @brief  Sets the Smart Card Block length.
1351:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1352:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3.
1353:../src/stm32f30x_usart.c ****   * @param  USART_BlockLength: specifies the Smart Card block length.
1354:../src/stm32f30x_usart.c ****   * @retval None
1355:../src/stm32f30x_usart.c ****   */
1356:../src/stm32f30x_usart.c **** void USART_SetBlockLength(USART_TypeDef* USARTx, uint8_t USART_BlockLength)
1357:../src/stm32f30x_usart.c **** {    
 1925              		.loc 1 1357 0
 1926              		.cfi_startproc
 1927              		@ args = 0, pretend = 0, frame = 8
 1928              		@ frame_needed = 1, uses_anonymous_args = 0
 1929              		@ link register save eliminated.
 1930 08e4 80B4     		push	{r7}
 1931              	.LCFI99:
 1932              		.cfi_def_cfa_offset 4
 1933              		.cfi_offset 7, -4
 1934 08e6 83B0     		sub	sp, sp, #12
 1935              	.LCFI100:
 1936              		.cfi_def_cfa_offset 16
 1937 08e8 00AF     		add	r7, sp, #0
 1938              	.LCFI101:
 1939              		.cfi_def_cfa_register 7
 1940 08ea 7860     		str	r0, [r7, #4]
 1941 08ec 0B46     		mov	r3, r1
 1942 08ee FB70     		strb	r3, [r7, #3]
1358:../src/stm32f30x_usart.c ****   /* Check the parameters */
1359:../src/stm32f30x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
1360:../src/stm32f30x_usart.c **** 
1361:../src/stm32f30x_usart.c ****   /* Clear the Smart card block length */
1362:../src/stm32f30x_usart.c ****   USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_BLEN);
 1943              		.loc 1 1362 0
 1944 08f0 7B68     		ldr	r3, [r7, #4]
 1945 08f2 5B69     		ldr	r3, [r3, #20]
 1946 08f4 23F07F42 		bic	r2, r3, #-16777216
 1947 08f8 7B68     		ldr	r3, [r7, #4]
 1948 08fa 5A61     		str	r2, [r3, #20]
1363:../src/stm32f30x_usart.c ****   /* Set the Smart Card block length */
1364:../src/stm32f30x_usart.c ****   USARTx->RTOR |= (uint32_t)((uint32_t)USART_BlockLength << 0x18);
 1949              		.loc 1 1364 0
 1950 08fc 7B68     		ldr	r3, [r7, #4]
 1951 08fe 5A69     		ldr	r2, [r3, #20]
 1952 0900 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1953 0902 4FEA0363 		lsl	r3, r3, #24
 1954 0906 1A43     		orrs	r2, r2, r3
 1955 0908 7B68     		ldr	r3, [r7, #4]
 1956 090a 5A61     		str	r2, [r3, #20]
1365:../src/stm32f30x_usart.c **** }
 1957              		.loc 1 1365 0
 1958 090c 07F10C07 		add	r7, r7, #12
 1959 0910 BD46     		mov	sp, r7
 1960 0912 80BC     		pop	{r7}
 1961 0914 7047     		bx	lr
 1962              		.cfi_endproc
 1963              	.LFE144:
 1965 0916 00BF     		.align	2
 1966              		.global	USART_IrDAConfig
 1967              		.thumb
 1968              		.thumb_func
 1970              	USART_IrDAConfig:
 1971              	.LFB145:
1366:../src/stm32f30x_usart.c **** 
1367:../src/stm32f30x_usart.c **** /**
1368:../src/stm32f30x_usart.c ****   * @}
1369:../src/stm32f30x_usart.c ****   */
1370:../src/stm32f30x_usart.c **** 
1371:../src/stm32f30x_usart.c **** /** @defgroup USART_Group9 IrDA mode functions
1372:../src/stm32f30x_usart.c ****  *  @brief   IrDA mode functions 
1373:../src/stm32f30x_usart.c ****  *
1374:../src/stm32f30x_usart.c **** @verbatim   
1375:../src/stm32f30x_usart.c ****  ===============================================================================
1376:../src/stm32f30x_usart.c ****                         ##### IrDA mode functions #####
1377:../src/stm32f30x_usart.c ****  ===============================================================================
1378:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
1379:../src/stm32f30x_usart.c ****          IrDA communication.
1380:../src/stm32f30x_usart.c ****     [..] IrDA is a half duplex communication protocol. If the Transmitter is busy, 
1381:../src/stm32f30x_usart.c ****          any data on the IrDA receive line will be ignored by the IrDA decoder 
1382:../src/stm32f30x_usart.c ****          and if the Receiver is busy, data on the TX from the USART to IrDA will 
1383:../src/stm32f30x_usart.c ****          not be encoded by IrDA. While receiving data, transmission should be 
1384:../src/stm32f30x_usart.c ****          avoided as the data to be transmitted could be corrupted.
1385:../src/stm32f30x_usart.c ****     [..] IrDA communication is possible through the following procedure:
1386:../src/stm32f30x_usart.c ****          (#) Program the Baud rate, Word length = 8 bits, Stop bits, Parity, 
1387:../src/stm32f30x_usart.c ****              Transmitter/Receiver modes and hardware flow control values using 
1388:../src/stm32f30x_usart.c ****              the USART_Init() function.
1389:../src/stm32f30x_usart.c ****          (#) Configures the IrDA pulse width by configuring the prescaler using  
1390:../src/stm32f30x_usart.c ****              the USART_SetPrescaler() function.
1391:../src/stm32f30x_usart.c ****          (#) Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal 
1392:../src/stm32f30x_usart.c ****              mode using the USART_IrDAConfig() function.
1393:../src/stm32f30x_usart.c ****          (#) Enable the IrDA using the USART_IrDACmd() function.
1394:../src/stm32f30x_usart.c ****          (#) Enable the USART using the USART_Cmd() function.         
1395:../src/stm32f30x_usart.c ****     [..]
1396:../src/stm32f30x_usart.c ****     (@) A pulse of width less than two and greater than one PSC period(s) may or 
1397:../src/stm32f30x_usart.c ****         may not be rejected.
1398:../src/stm32f30x_usart.c ****     (@) The receiver set up time should be managed by software. The IrDA physical 
1399:../src/stm32f30x_usart.c ****         layer specification specifies a minimum of 10 ms delay between 
1400:../src/stm32f30x_usart.c ****         transmission and reception (IrDA is a half duplex protocol).
1401:../src/stm32f30x_usart.c ****     (@) In IrDA mode, the following bits must be kept cleared:
1402:../src/stm32f30x_usart.c ****         (+@) LINEN, STOP and CLKEN bits in the USART_CR2 register.
1403:../src/stm32f30x_usart.c ****         (+@) SCEN and HDSEL bits in the USART_CR3 register.
1404:../src/stm32f30x_usart.c **** 
1405:../src/stm32f30x_usart.c **** @endverbatim
1406:../src/stm32f30x_usart.c ****   * @{
1407:../src/stm32f30x_usart.c ****   */
1408:../src/stm32f30x_usart.c **** 
1409:../src/stm32f30x_usart.c **** /**
1410:../src/stm32f30x_usart.c ****   * @brief  Configures the USART's IrDA interface.
1411:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1412:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1413:../src/stm32f30x_usart.c ****   * @param  USART_IrDAMode: specifies the IrDA mode.
1414:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1415:../src/stm32f30x_usart.c ****   *         @arg USART_IrDAMode_LowPower
1416:../src/stm32f30x_usart.c ****   *         @arg USART_IrDAMode_Normal
1417:../src/stm32f30x_usart.c ****   * @retval None
1418:../src/stm32f30x_usart.c ****   */
1419:../src/stm32f30x_usart.c **** void USART_IrDAConfig(USART_TypeDef* USARTx, uint32_t USART_IrDAMode)
1420:../src/stm32f30x_usart.c **** {
 1972              		.loc 1 1420 0
 1973              		.cfi_startproc
 1974              		@ args = 0, pretend = 0, frame = 8
 1975              		@ frame_needed = 1, uses_anonymous_args = 0
 1976              		@ link register save eliminated.
 1977 0918 80B4     		push	{r7}
 1978              	.LCFI102:
 1979              		.cfi_def_cfa_offset 4
 1980              		.cfi_offset 7, -4
 1981 091a 83B0     		sub	sp, sp, #12
 1982              	.LCFI103:
 1983              		.cfi_def_cfa_offset 16
 1984 091c 00AF     		add	r7, sp, #0
 1985              	.LCFI104:
 1986              		.cfi_def_cfa_register 7
 1987 091e 7860     		str	r0, [r7, #4]
 1988 0920 3960     		str	r1, [r7, #0]
1421:../src/stm32f30x_usart.c ****   /* Check the parameters */
1422:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1423:../src/stm32f30x_usart.c ****   assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
1424:../src/stm32f30x_usart.c **** 
1425:../src/stm32f30x_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IRLP);
 1989              		.loc 1 1425 0
 1990 0922 7B68     		ldr	r3, [r7, #4]
 1991 0924 9B68     		ldr	r3, [r3, #8]
 1992 0926 23F00402 		bic	r2, r3, #4
 1993 092a 7B68     		ldr	r3, [r7, #4]
 1994 092c 9A60     		str	r2, [r3, #8]
1426:../src/stm32f30x_usart.c ****   USARTx->CR3 |= USART_IrDAMode;
 1995              		.loc 1 1426 0
 1996 092e 7B68     		ldr	r3, [r7, #4]
 1997 0930 9A68     		ldr	r2, [r3, #8]
 1998 0932 3B68     		ldr	r3, [r7, #0]
 1999 0934 1A43     		orrs	r2, r2, r3
 2000 0936 7B68     		ldr	r3, [r7, #4]
 2001 0938 9A60     		str	r2, [r3, #8]
1427:../src/stm32f30x_usart.c **** }
 2002              		.loc 1 1427 0
 2003 093a 07F10C07 		add	r7, r7, #12
 2004 093e BD46     		mov	sp, r7
 2005 0940 80BC     		pop	{r7}
 2006 0942 7047     		bx	lr
 2007              		.cfi_endproc
 2008              	.LFE145:
 2010              		.align	2
 2011              		.global	USART_IrDACmd
 2012              		.thumb
 2013              		.thumb_func
 2015              	USART_IrDACmd:
 2016              	.LFB146:
1428:../src/stm32f30x_usart.c **** 
1429:../src/stm32f30x_usart.c **** /**
1430:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's IrDA interface. 
1431:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1432:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1433:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the IrDA mode.
1434:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
1435:../src/stm32f30x_usart.c ****   * @retval None
1436:../src/stm32f30x_usart.c ****   */
1437:../src/stm32f30x_usart.c **** void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
1438:../src/stm32f30x_usart.c **** {
 2017              		.loc 1 1438 0
 2018              		.cfi_startproc
 2019              		@ args = 0, pretend = 0, frame = 8
 2020              		@ frame_needed = 1, uses_anonymous_args = 0
 2021              		@ link register save eliminated.
 2022 0944 80B4     		push	{r7}
 2023              	.LCFI105:
 2024              		.cfi_def_cfa_offset 4
 2025              		.cfi_offset 7, -4
 2026 0946 83B0     		sub	sp, sp, #12
 2027              	.LCFI106:
 2028              		.cfi_def_cfa_offset 16
 2029 0948 00AF     		add	r7, sp, #0
 2030              	.LCFI107:
 2031              		.cfi_def_cfa_register 7
 2032 094a 7860     		str	r0, [r7, #4]
 2033 094c 0B46     		mov	r3, r1
 2034 094e FB70     		strb	r3, [r7, #3]
1439:../src/stm32f30x_usart.c ****   /* Check the parameters */
1440:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1441:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1442:../src/stm32f30x_usart.c **** 
1443:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 2035              		.loc 1 1443 0
 2036 0950 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2037 0952 002B     		cmp	r3, #0
 2038 0954 06D0     		beq	.L84
1444:../src/stm32f30x_usart.c ****   {
1445:../src/stm32f30x_usart.c ****     /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
1446:../src/stm32f30x_usart.c ****     USARTx->CR3 |= USART_CR3_IREN;
 2039              		.loc 1 1446 0
 2040 0956 7B68     		ldr	r3, [r7, #4]
 2041 0958 9B68     		ldr	r3, [r3, #8]
 2042 095a 43F00202 		orr	r2, r3, #2
 2043 095e 7B68     		ldr	r3, [r7, #4]
 2044 0960 9A60     		str	r2, [r3, #8]
 2045 0962 05E0     		b	.L83
 2046              	.L84:
1447:../src/stm32f30x_usart.c ****   }
1448:../src/stm32f30x_usart.c ****   else
1449:../src/stm32f30x_usart.c ****   {
1450:../src/stm32f30x_usart.c ****     /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
1451:../src/stm32f30x_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IREN);
 2047              		.loc 1 1451 0
 2048 0964 7B68     		ldr	r3, [r7, #4]
 2049 0966 9B68     		ldr	r3, [r3, #8]
 2050 0968 23F00202 		bic	r2, r3, #2
 2051 096c 7B68     		ldr	r3, [r7, #4]
 2052 096e 9A60     		str	r2, [r3, #8]
 2053              	.L83:
1452:../src/stm32f30x_usart.c ****   }
1453:../src/stm32f30x_usart.c **** }
 2054              		.loc 1 1453 0
 2055 0970 07F10C07 		add	r7, r7, #12
 2056 0974 BD46     		mov	sp, r7
 2057 0976 80BC     		pop	{r7}
 2058 0978 7047     		bx	lr
 2059              		.cfi_endproc
 2060              	.LFE146:
 2062 097a 00BF     		.align	2
 2063              		.global	USART_DECmd
 2064              		.thumb
 2065              		.thumb_func
 2067              	USART_DECmd:
 2068              	.LFB147:
1454:../src/stm32f30x_usart.c **** /**
1455:../src/stm32f30x_usart.c ****   * @}
1456:../src/stm32f30x_usart.c ****   */
1457:../src/stm32f30x_usart.c **** 
1458:../src/stm32f30x_usart.c **** /** @defgroup USART_Group10 RS485 mode function
1459:../src/stm32f30x_usart.c ****  *  @brief   RS485 mode function 
1460:../src/stm32f30x_usart.c ****  *
1461:../src/stm32f30x_usart.c **** @verbatim  
1462:../src/stm32f30x_usart.c ****  ===============================================================================
1463:../src/stm32f30x_usart.c ****                         ##### RS485 mode functions #####
1464:../src/stm32f30x_usart.c ****  ===============================================================================
1465:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to manage the USART
1466:../src/stm32f30x_usart.c ****          RS485 flow control.
1467:../src/stm32f30x_usart.c ****     [..] RS485 flow control (Driver enable feature) handling is possible through
1468:../src/stm32f30x_usart.c ****          the following procedure:
1469:../src/stm32f30x_usart.c ****          (#) Program the Baud rate, Word length = 8 bits, Stop bits, Parity, 
1470:../src/stm32f30x_usart.c ****              Transmitter/Receiver modes and hardware flow control values using 
1471:../src/stm32f30x_usart.c ****              the USART_Init() function.
1472:../src/stm32f30x_usart.c ****          (#) Enable the Driver Enable using the USART_DECmd() function.
1473:../src/stm32f30x_usart.c ****          (#) Configures the Driver Enable polarity using the USART_DEPolarityConfig()
1474:../src/stm32f30x_usart.c ****              function.
1475:../src/stm32f30x_usart.c ****          (#) Configures the Driver Enable assertion time using USART_SetDEAssertionTime() 
1476:../src/stm32f30x_usart.c ****              function and deassertion time using the USART_SetDEDeassertionTime()
1477:../src/stm32f30x_usart.c ****              function.    
1478:../src/stm32f30x_usart.c ****          (#) Enable the USART using the USART_Cmd() function.
1479:../src/stm32f30x_usart.c ****       [..]  
1480:../src/stm32f30x_usart.c ****        (@) The assertion and dessertion times are expressed in sample time units (1/8 or 
1481:../src/stm32f30x_usart.c ****             1/16 bit time, depending on the oversampling rate).
1482:../src/stm32f30x_usart.c ****        
1483:../src/stm32f30x_usart.c **** @endverbatim
1484:../src/stm32f30x_usart.c ****   * @{
1485:../src/stm32f30x_usart.c ****   */
1486:../src/stm32f30x_usart.c **** 
1487:../src/stm32f30x_usart.c **** /**
1488:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's DE functionality.
1489:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1490:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1491:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the driver enable mode.
1492:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.      
1493:../src/stm32f30x_usart.c ****   * @retval None
1494:../src/stm32f30x_usart.c ****   */
1495:../src/stm32f30x_usart.c **** void USART_DECmd(USART_TypeDef* USARTx, FunctionalState NewState)
1496:../src/stm32f30x_usart.c **** {
 2069              		.loc 1 1496 0
 2070              		.cfi_startproc
 2071              		@ args = 0, pretend = 0, frame = 8
 2072              		@ frame_needed = 1, uses_anonymous_args = 0
 2073              		@ link register save eliminated.
 2074 097c 80B4     		push	{r7}
 2075              	.LCFI108:
 2076              		.cfi_def_cfa_offset 4
 2077              		.cfi_offset 7, -4
 2078 097e 83B0     		sub	sp, sp, #12
 2079              	.LCFI109:
 2080              		.cfi_def_cfa_offset 16
 2081 0980 00AF     		add	r7, sp, #0
 2082              	.LCFI110:
 2083              		.cfi_def_cfa_register 7
 2084 0982 7860     		str	r0, [r7, #4]
 2085 0984 0B46     		mov	r3, r1
 2086 0986 FB70     		strb	r3, [r7, #3]
1497:../src/stm32f30x_usart.c ****   /* Check the parameters */
1498:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1499:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1500:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 2087              		.loc 1 1500 0
 2088 0988 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2089 098a 002B     		cmp	r3, #0
 2090 098c 06D0     		beq	.L87
1501:../src/stm32f30x_usart.c ****   {
1502:../src/stm32f30x_usart.c ****     /* Enable the DE functionality by setting the DEM bit in the CR3 register */
1503:../src/stm32f30x_usart.c ****     USARTx->CR3 |= USART_CR3_DEM;
 2091              		.loc 1 1503 0
 2092 098e 7B68     		ldr	r3, [r7, #4]
 2093 0990 9B68     		ldr	r3, [r3, #8]
 2094 0992 43F48042 		orr	r2, r3, #16384
 2095 0996 7B68     		ldr	r3, [r7, #4]
 2096 0998 9A60     		str	r2, [r3, #8]
 2097 099a 05E0     		b	.L86
 2098              	.L87:
1504:../src/stm32f30x_usart.c ****   }
1505:../src/stm32f30x_usart.c ****   else
1506:../src/stm32f30x_usart.c ****   {
1507:../src/stm32f30x_usart.c ****     /* Disable the DE functionality by clearing the DEM bit in the CR3 register */
1508:../src/stm32f30x_usart.c ****     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEM);
 2099              		.loc 1 1508 0
 2100 099c 7B68     		ldr	r3, [r7, #4]
 2101 099e 9B68     		ldr	r3, [r3, #8]
 2102 09a0 23F48042 		bic	r2, r3, #16384
 2103 09a4 7B68     		ldr	r3, [r7, #4]
 2104 09a6 9A60     		str	r2, [r3, #8]
 2105              	.L86:
1509:../src/stm32f30x_usart.c ****   }
1510:../src/stm32f30x_usart.c **** }
 2106              		.loc 1 1510 0
 2107 09a8 07F10C07 		add	r7, r7, #12
 2108 09ac BD46     		mov	sp, r7
 2109 09ae 80BC     		pop	{r7}
 2110 09b0 7047     		bx	lr
 2111              		.cfi_endproc
 2112              	.LFE147:
 2114 09b2 00BF     		.align	2
 2115              		.global	USART_DEPolarityConfig
 2116              		.thumb
 2117              		.thumb_func
 2119              	USART_DEPolarityConfig:
 2120              	.LFB148:
1511:../src/stm32f30x_usart.c **** 
1512:../src/stm32f30x_usart.c **** /**
1513:../src/stm32f30x_usart.c ****   * @brief  Configures the USART's DE polarity
1514:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1515:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1516:../src/stm32f30x_usart.c ****   * @param  USART_DEPolarity: specifies the DE polarity.
1517:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1518:../src/stm32f30x_usart.c ****   *         @arg USART_DEPolarity_Low
1519:../src/stm32f30x_usart.c ****   *         @arg USART_DEPolarity_High
1520:../src/stm32f30x_usart.c ****   * @retval None
1521:../src/stm32f30x_usart.c ****   */
1522:../src/stm32f30x_usart.c **** void USART_DEPolarityConfig(USART_TypeDef* USARTx, uint32_t USART_DEPolarity)
1523:../src/stm32f30x_usart.c **** {
 2121              		.loc 1 1523 0
 2122              		.cfi_startproc
 2123              		@ args = 0, pretend = 0, frame = 8
 2124              		@ frame_needed = 1, uses_anonymous_args = 0
 2125              		@ link register save eliminated.
 2126 09b4 80B4     		push	{r7}
 2127              	.LCFI111:
 2128              		.cfi_def_cfa_offset 4
 2129              		.cfi_offset 7, -4
 2130 09b6 83B0     		sub	sp, sp, #12
 2131              	.LCFI112:
 2132              		.cfi_def_cfa_offset 16
 2133 09b8 00AF     		add	r7, sp, #0
 2134              	.LCFI113:
 2135              		.cfi_def_cfa_register 7
 2136 09ba 7860     		str	r0, [r7, #4]
 2137 09bc 3960     		str	r1, [r7, #0]
1524:../src/stm32f30x_usart.c ****   /* Check the parameters */
1525:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1526:../src/stm32f30x_usart.c ****   assert_param(IS_USART_DE_POLARITY(USART_DEPolarity));
1527:../src/stm32f30x_usart.c **** 
1528:../src/stm32f30x_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEP);
 2138              		.loc 1 1528 0
 2139 09be 7B68     		ldr	r3, [r7, #4]
 2140 09c0 9B68     		ldr	r3, [r3, #8]
 2141 09c2 23F40042 		bic	r2, r3, #32768
 2142 09c6 7B68     		ldr	r3, [r7, #4]
 2143 09c8 9A60     		str	r2, [r3, #8]
1529:../src/stm32f30x_usart.c ****   USARTx->CR3 |= USART_DEPolarity;
 2144              		.loc 1 1529 0
 2145 09ca 7B68     		ldr	r3, [r7, #4]
 2146 09cc 9A68     		ldr	r2, [r3, #8]
 2147 09ce 3B68     		ldr	r3, [r7, #0]
 2148 09d0 1A43     		orrs	r2, r2, r3
 2149 09d2 7B68     		ldr	r3, [r7, #4]
 2150 09d4 9A60     		str	r2, [r3, #8]
1530:../src/stm32f30x_usart.c **** }
 2151              		.loc 1 1530 0
 2152 09d6 07F10C07 		add	r7, r7, #12
 2153 09da BD46     		mov	sp, r7
 2154 09dc 80BC     		pop	{r7}
 2155 09de 7047     		bx	lr
 2156              		.cfi_endproc
 2157              	.LFE148:
 2159              		.align	2
 2160              		.global	USART_SetDEAssertionTime
 2161              		.thumb
 2162              		.thumb_func
 2164              	USART_SetDEAssertionTime:
 2165              	.LFB149:
1531:../src/stm32f30x_usart.c **** 
1532:../src/stm32f30x_usart.c **** /**
1533:../src/stm32f30x_usart.c ****   * @brief  Sets the specified RS485 DE assertion time
1534:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1535:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1536:../src/stm32f30x_usart.c ****   * @param  USART_AssertionTime: specifies the time between the activation of the DE
1537:../src/stm32f30x_usart.c ****   *          signal and the beginning of the start bit
1538:../src/stm32f30x_usart.c ****   * @retval None
1539:../src/stm32f30x_usart.c ****   */
1540:../src/stm32f30x_usart.c **** void USART_SetDEAssertionTime(USART_TypeDef* USARTx, uint32_t USART_DEAssertionTime)
1541:../src/stm32f30x_usart.c **** {
 2166              		.loc 1 1541 0
 2167              		.cfi_startproc
 2168              		@ args = 0, pretend = 0, frame = 8
 2169              		@ frame_needed = 1, uses_anonymous_args = 0
 2170              		@ link register save eliminated.
 2171 09e0 80B4     		push	{r7}
 2172              	.LCFI114:
 2173              		.cfi_def_cfa_offset 4
 2174              		.cfi_offset 7, -4
 2175 09e2 83B0     		sub	sp, sp, #12
 2176              	.LCFI115:
 2177              		.cfi_def_cfa_offset 16
 2178 09e4 00AF     		add	r7, sp, #0
 2179              	.LCFI116:
 2180              		.cfi_def_cfa_register 7
 2181 09e6 7860     		str	r0, [r7, #4]
 2182 09e8 3960     		str	r1, [r7, #0]
1542:../src/stm32f30x_usart.c ****   /* Check the parameters */
1543:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1544:../src/stm32f30x_usart.c ****   assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEAssertionTime)); 
1545:../src/stm32f30x_usart.c **** 
1546:../src/stm32f30x_usart.c ****   /* Clear the DE assertion time */
1547:../src/stm32f30x_usart.c ****   USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEAT);
 2183              		.loc 1 1547 0
 2184 09ea 7B68     		ldr	r3, [r7, #4]
 2185 09ec 1B68     		ldr	r3, [r3, #0]
 2186 09ee 23F07872 		bic	r2, r3, #65011712
 2187 09f2 7B68     		ldr	r3, [r7, #4]
 2188 09f4 1A60     		str	r2, [r3, #0]
1548:../src/stm32f30x_usart.c ****   /* Set the new value for the DE assertion time */
1549:../src/stm32f30x_usart.c ****   USARTx->CR1 |=((uint32_t)USART_DEAssertionTime << (uint32_t)0x15);
 2189              		.loc 1 1549 0
 2190 09f6 7B68     		ldr	r3, [r7, #4]
 2191 09f8 1A68     		ldr	r2, [r3, #0]
 2192 09fa 3B68     		ldr	r3, [r7, #0]
 2193 09fc 4FEA4353 		lsl	r3, r3, #21
 2194 0a00 1A43     		orrs	r2, r2, r3
 2195 0a02 7B68     		ldr	r3, [r7, #4]
 2196 0a04 1A60     		str	r2, [r3, #0]
1550:../src/stm32f30x_usart.c **** }
 2197              		.loc 1 1550 0
 2198 0a06 07F10C07 		add	r7, r7, #12
 2199 0a0a BD46     		mov	sp, r7
 2200 0a0c 80BC     		pop	{r7}
 2201 0a0e 7047     		bx	lr
 2202              		.cfi_endproc
 2203              	.LFE149:
 2205              		.align	2
 2206              		.global	USART_SetDEDeassertionTime
 2207              		.thumb
 2208              		.thumb_func
 2210              	USART_SetDEDeassertionTime:
 2211              	.LFB150:
1551:../src/stm32f30x_usart.c **** 
1552:../src/stm32f30x_usart.c **** /**
1553:../src/stm32f30x_usart.c ****   * @brief  Sets the specified RS485 DE deassertion time
1554:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1555:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1556:../src/stm32f30x_usart.c ****   * @param  USART_DeassertionTime: specifies the time between the middle of the last 
1557:../src/stm32f30x_usart.c ****   *         stop bit in a transmitted message and the de-activation of the DE signal
1558:../src/stm32f30x_usart.c ****   * @retval None
1559:../src/stm32f30x_usart.c ****   */
1560:../src/stm32f30x_usart.c **** void USART_SetDEDeassertionTime(USART_TypeDef* USARTx, uint32_t USART_DEDeassertionTime)
1561:../src/stm32f30x_usart.c **** {
 2212              		.loc 1 1561 0
 2213              		.cfi_startproc
 2214              		@ args = 0, pretend = 0, frame = 8
 2215              		@ frame_needed = 1, uses_anonymous_args = 0
 2216              		@ link register save eliminated.
 2217 0a10 80B4     		push	{r7}
 2218              	.LCFI117:
 2219              		.cfi_def_cfa_offset 4
 2220              		.cfi_offset 7, -4
 2221 0a12 83B0     		sub	sp, sp, #12
 2222              	.LCFI118:
 2223              		.cfi_def_cfa_offset 16
 2224 0a14 00AF     		add	r7, sp, #0
 2225              	.LCFI119:
 2226              		.cfi_def_cfa_register 7
 2227 0a16 7860     		str	r0, [r7, #4]
 2228 0a18 3960     		str	r1, [r7, #0]
1562:../src/stm32f30x_usart.c ****   /* Check the parameters */
1563:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1564:../src/stm32f30x_usart.c ****   assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEDeassertionTime)); 
1565:../src/stm32f30x_usart.c **** 
1566:../src/stm32f30x_usart.c ****   /* Clear the DE deassertion time */
1567:../src/stm32f30x_usart.c ****   USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEDT);
 2229              		.loc 1 1567 0
 2230 0a1a 7B68     		ldr	r3, [r7, #4]
 2231 0a1c 1B68     		ldr	r3, [r3, #0]
 2232 0a1e 23F4F812 		bic	r2, r3, #2031616
 2233 0a22 7B68     		ldr	r3, [r7, #4]
 2234 0a24 1A60     		str	r2, [r3, #0]
1568:../src/stm32f30x_usart.c ****   /* Set the new value for the DE deassertion time */
1569:../src/stm32f30x_usart.c ****   USARTx->CR1 |=((uint32_t)USART_DEDeassertionTime << (uint32_t)0x10);
 2235              		.loc 1 1569 0
 2236 0a26 7B68     		ldr	r3, [r7, #4]
 2237 0a28 1A68     		ldr	r2, [r3, #0]
 2238 0a2a 3B68     		ldr	r3, [r7, #0]
 2239 0a2c 4FEA0343 		lsl	r3, r3, #16
 2240 0a30 1A43     		orrs	r2, r2, r3
 2241 0a32 7B68     		ldr	r3, [r7, #4]
 2242 0a34 1A60     		str	r2, [r3, #0]
1570:../src/stm32f30x_usart.c **** }
 2243              		.loc 1 1570 0
 2244 0a36 07F10C07 		add	r7, r7, #12
 2245 0a3a BD46     		mov	sp, r7
 2246 0a3c 80BC     		pop	{r7}
 2247 0a3e 7047     		bx	lr
 2248              		.cfi_endproc
 2249              	.LFE150:
 2251              		.align	2
 2252              		.global	USART_DMACmd
 2253              		.thumb
 2254              		.thumb_func
 2256              	USART_DMACmd:
 2257              	.LFB151:
1571:../src/stm32f30x_usart.c **** 
1572:../src/stm32f30x_usart.c **** /**
1573:../src/stm32f30x_usart.c ****   * @}
1574:../src/stm32f30x_usart.c ****   */
1575:../src/stm32f30x_usart.c **** 
1576:../src/stm32f30x_usart.c **** /** @defgroup USART_Group11 DMA transfers management functions
1577:../src/stm32f30x_usart.c ****  *  @brief   DMA transfers management functions
1578:../src/stm32f30x_usart.c ****  *
1579:../src/stm32f30x_usart.c **** @verbatim   
1580:../src/stm32f30x_usart.c ****  ===============================================================================
1581:../src/stm32f30x_usart.c ****                ##### DMA transfers management functions #####
1582:../src/stm32f30x_usart.c ****  ===============================================================================
1583:../src/stm32f30x_usart.c ****     [..] This section provides two functions that can be used only in DMA mode.
1584:../src/stm32f30x_usart.c ****     [..] In DMA Mode, the USART communication can be managed by 2 DMA Channel 
1585:../src/stm32f30x_usart.c ****          requests:
1586:../src/stm32f30x_usart.c ****          (#) USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request.
1587:../src/stm32f30x_usart.c ****          (#) USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request.
1588:../src/stm32f30x_usart.c ****     [..] In this Mode it is advised to use the following function:
1589:../src/stm32f30x_usart.c ****          (+) void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, 
1590:../src/stm32f30x_usart.c ****              FunctionalState NewState).
1591:../src/stm32f30x_usart.c **** @endverbatim
1592:../src/stm32f30x_usart.c ****   * @{
1593:../src/stm32f30x_usart.c ****   */
1594:../src/stm32f30x_usart.c **** 
1595:../src/stm32f30x_usart.c **** /**
1596:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's DMA interface.
1597:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1598:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4.
1599:../src/stm32f30x_usart.c ****   * @param  USART_DMAReq: specifies the DMA request.
1600:../src/stm32f30x_usart.c ****   *         This parameter can be any combination of the following values:
1601:../src/stm32f30x_usart.c ****   *         @arg USART_DMAReq_Tx: USART DMA transmit request
1602:../src/stm32f30x_usart.c ****   *         @arg USART_DMAReq_Rx: USART DMA receive request
1603:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the DMA Request sources.
1604:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.  
1605:../src/stm32f30x_usart.c ****   * @retval None
1606:../src/stm32f30x_usart.c ****   */
1607:../src/stm32f30x_usart.c **** void USART_DMACmd(USART_TypeDef* USARTx, uint32_t USART_DMAReq, FunctionalState NewState)
1608:../src/stm32f30x_usart.c **** {
 2258              		.loc 1 1608 0
 2259              		.cfi_startproc
 2260              		@ args = 0, pretend = 0, frame = 16
 2261              		@ frame_needed = 1, uses_anonymous_args = 0
 2262              		@ link register save eliminated.
 2263 0a40 80B4     		push	{r7}
 2264              	.LCFI120:
 2265              		.cfi_def_cfa_offset 4
 2266              		.cfi_offset 7, -4
 2267 0a42 85B0     		sub	sp, sp, #20
 2268              	.LCFI121:
 2269              		.cfi_def_cfa_offset 24
 2270 0a44 00AF     		add	r7, sp, #0
 2271              	.LCFI122:
 2272              		.cfi_def_cfa_register 7
 2273 0a46 F860     		str	r0, [r7, #12]
 2274 0a48 B960     		str	r1, [r7, #8]
 2275 0a4a 1346     		mov	r3, r2
 2276 0a4c FB71     		strb	r3, [r7, #7]
1609:../src/stm32f30x_usart.c ****   /* Check the parameters */
1610:../src/stm32f30x_usart.c ****   assert_param(IS_USART_1234_PERIPH(USARTx));
1611:../src/stm32f30x_usart.c ****   assert_param(IS_USART_DMAREQ(USART_DMAReq));  
1612:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
1613:../src/stm32f30x_usart.c **** 
1614:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 2277              		.loc 1 1614 0
 2278 0a4e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2279 0a50 002B     		cmp	r3, #0
 2280 0a52 06D0     		beq	.L93
1615:../src/stm32f30x_usart.c ****   {
1616:../src/stm32f30x_usart.c ****     /* Enable the DMA transfer for selected requests by setting the DMAT and/or
1617:../src/stm32f30x_usart.c ****        DMAR bits in the USART CR3 register */
1618:../src/stm32f30x_usart.c ****     USARTx->CR3 |= USART_DMAReq;
 2281              		.loc 1 1618 0
 2282 0a54 FB68     		ldr	r3, [r7, #12]
 2283 0a56 9A68     		ldr	r2, [r3, #8]
 2284 0a58 BB68     		ldr	r3, [r7, #8]
 2285 0a5a 1A43     		orrs	r2, r2, r3
 2286 0a5c FB68     		ldr	r3, [r7, #12]
 2287 0a5e 9A60     		str	r2, [r3, #8]
 2288 0a60 07E0     		b	.L92
 2289              	.L93:
1619:../src/stm32f30x_usart.c ****   }
1620:../src/stm32f30x_usart.c ****   else
1621:../src/stm32f30x_usart.c ****   {
1622:../src/stm32f30x_usart.c ****     /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
1623:../src/stm32f30x_usart.c ****        DMAR bits in the USART CR3 register */
1624:../src/stm32f30x_usart.c ****     USARTx->CR3 &= (uint32_t)~USART_DMAReq;
 2290              		.loc 1 1624 0
 2291 0a62 FB68     		ldr	r3, [r7, #12]
 2292 0a64 9A68     		ldr	r2, [r3, #8]
 2293 0a66 BB68     		ldr	r3, [r7, #8]
 2294 0a68 6FEA0303 		mvn	r3, r3
 2295 0a6c 1A40     		ands	r2, r2, r3
 2296 0a6e FB68     		ldr	r3, [r7, #12]
 2297 0a70 9A60     		str	r2, [r3, #8]
 2298              	.L92:
1625:../src/stm32f30x_usart.c ****   }
1626:../src/stm32f30x_usart.c **** }
 2299              		.loc 1 1626 0
 2300 0a72 07F11407 		add	r7, r7, #20
 2301 0a76 BD46     		mov	sp, r7
 2302 0a78 80BC     		pop	{r7}
 2303 0a7a 7047     		bx	lr
 2304              		.cfi_endproc
 2305              	.LFE151:
 2307              		.align	2
 2308              		.global	USART_DMAReceptionErrorConfig
 2309              		.thumb
 2310              		.thumb_func
 2312              	USART_DMAReceptionErrorConfig:
 2313              	.LFB152:
1627:../src/stm32f30x_usart.c **** 
1628:../src/stm32f30x_usart.c **** /**
1629:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's DMA interface when reception error occurs.
1630:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1631:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4.
1632:../src/stm32f30x_usart.c ****   * @param  USART_DMAOnError: specifies the DMA status in case of reception error.
1633:../src/stm32f30x_usart.c ****   *         This parameter can be any combination of the following values:
1634:../src/stm32f30x_usart.c ****   *         @arg USART_DMAOnError_Enable: DMA receive request enabled when the USART DMA  
1635:../src/stm32f30x_usart.c ****   *          reception error is asserted.
1636:../src/stm32f30x_usart.c ****   *         @arg USART_DMAOnError_Disable: DMA receive request disabled when the USART DMA 
1637:../src/stm32f30x_usart.c ****   *          reception error is asserted.
1638:../src/stm32f30x_usart.c ****   * @retval None
1639:../src/stm32f30x_usart.c ****   */
1640:../src/stm32f30x_usart.c **** void USART_DMAReceptionErrorConfig(USART_TypeDef* USARTx, uint32_t USART_DMAOnError)
1641:../src/stm32f30x_usart.c **** {
 2314              		.loc 1 1641 0
 2315              		.cfi_startproc
 2316              		@ args = 0, pretend = 0, frame = 8
 2317              		@ frame_needed = 1, uses_anonymous_args = 0
 2318              		@ link register save eliminated.
 2319 0a7c 80B4     		push	{r7}
 2320              	.LCFI123:
 2321              		.cfi_def_cfa_offset 4
 2322              		.cfi_offset 7, -4
 2323 0a7e 83B0     		sub	sp, sp, #12
 2324              	.LCFI124:
 2325              		.cfi_def_cfa_offset 16
 2326 0a80 00AF     		add	r7, sp, #0
 2327              	.LCFI125:
 2328              		.cfi_def_cfa_register 7
 2329 0a82 7860     		str	r0, [r7, #4]
 2330 0a84 3960     		str	r1, [r7, #0]
1642:../src/stm32f30x_usart.c ****   /* Check the parameters */
1643:../src/stm32f30x_usart.c ****   assert_param(IS_USART_1234_PERIPH(USARTx));
1644:../src/stm32f30x_usart.c ****   assert_param(IS_USART_DMAONERROR(USART_DMAOnError)); 
1645:../src/stm32f30x_usart.c ****   
1646:../src/stm32f30x_usart.c ****   /* Clear the DMA Reception error detection bit */
1647:../src/stm32f30x_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DDRE);
 2331              		.loc 1 1647 0
 2332 0a86 7B68     		ldr	r3, [r7, #4]
 2333 0a88 9B68     		ldr	r3, [r3, #8]
 2334 0a8a 23F40052 		bic	r2, r3, #8192
 2335 0a8e 7B68     		ldr	r3, [r7, #4]
 2336 0a90 9A60     		str	r2, [r3, #8]
1648:../src/stm32f30x_usart.c ****   /* Set the new value for the DMA Reception error detection bit */
1649:../src/stm32f30x_usart.c ****   USARTx->CR3 |= USART_DMAOnError;
 2337              		.loc 1 1649 0
 2338 0a92 7B68     		ldr	r3, [r7, #4]
 2339 0a94 9A68     		ldr	r2, [r3, #8]
 2340 0a96 3B68     		ldr	r3, [r7, #0]
 2341 0a98 1A43     		orrs	r2, r2, r3
 2342 0a9a 7B68     		ldr	r3, [r7, #4]
 2343 0a9c 9A60     		str	r2, [r3, #8]
1650:../src/stm32f30x_usart.c **** }
 2344              		.loc 1 1650 0
 2345 0a9e 07F10C07 		add	r7, r7, #12
 2346 0aa2 BD46     		mov	sp, r7
 2347 0aa4 80BC     		pop	{r7}
 2348 0aa6 7047     		bx	lr
 2349              		.cfi_endproc
 2350              	.LFE152:
 2352              		.align	2
 2353              		.global	USART_ITConfig
 2354              		.thumb
 2355              		.thumb_func
 2357              	USART_ITConfig:
 2358              	.LFB153:
1651:../src/stm32f30x_usart.c **** 
1652:../src/stm32f30x_usart.c **** /**
1653:../src/stm32f30x_usart.c ****   * @}
1654:../src/stm32f30x_usart.c ****   */
1655:../src/stm32f30x_usart.c ****   
1656:../src/stm32f30x_usart.c **** /** @defgroup USART_Group12 Interrupts and flags management functions
1657:../src/stm32f30x_usart.c ****  *  @brief   Interrupts and flags management functions 
1658:../src/stm32f30x_usart.c ****  *
1659:../src/stm32f30x_usart.c **** @verbatim   
1660:../src/stm32f30x_usart.c ****  ===============================================================================
1661:../src/stm32f30x_usart.c ****             ##### Interrupts and flags management functions #####
1662:../src/stm32f30x_usart.c ****  ===============================================================================
1663:../src/stm32f30x_usart.c ****     [..] This subsection provides a set of functions allowing to configure the 
1664:../src/stm32f30x_usart.c ****          USART Interrupts sources, Requests and check or clear the flags or pending bits status. 
1665:../src/stm32f30x_usart.c ****          The user should identify which mode will be used in his application to 
1666:../src/stm32f30x_usart.c ****          manage the communication: Polling mode, Interrupt mode.
1667:../src/stm32f30x_usart.c ****          
1668:../src/stm32f30x_usart.c ****  *** Polling Mode ***
1669:../src/stm32f30x_usart.c ****  ====================
1670:../src/stm32f30x_usart.c ****     [..] In Polling Mode, the SPI communication can be managed by these flags:
1671:../src/stm32f30x_usart.c ****          (#) USART_FLAG_REACK: to indicate the status of the Receive Enable 
1672:../src/stm32f30x_usart.c ****              acknowledge flag
1673:../src/stm32f30x_usart.c ****          (#) USART_FLAG_TEACK: to indicate the status of the Transmit Enable 
1674:../src/stm32f30x_usart.c ****              acknowledge flag.
1675:../src/stm32f30x_usart.c ****          (#) USART_FLAG_WUF: to indicate the status of the Wake up flag.
1676:../src/stm32f30x_usart.c ****          (#) USART_FLAG_RWU: to indicate the status of the Receive Wake up flag.
1677:../src/stm32f30x_usart.c ****          (#) USART_FLAG_SBK: to indicate the status of the Send Break flag.
1678:../src/stm32f30x_usart.c ****          (#) USART_FLAG_CMF: to indicate the status of the Character match flag.
1679:../src/stm32f30x_usart.c ****          (#) USART_FLAG_BUSY: to indicate the status of the Busy flag.
1680:../src/stm32f30x_usart.c ****          (#) USART_FLAG_ABRF: to indicate the status of the Auto baud rate flag.
1681:../src/stm32f30x_usart.c ****          (#) USART_FLAG_ABRE: to indicate the status of the Auto baud rate error flag.
1682:../src/stm32f30x_usart.c ****          (#) USART_FLAG_EOBF: to indicate the status of the End of block flag.
1683:../src/stm32f30x_usart.c ****          (#) USART_FLAG_RTOF: to indicate the status of the Receive time out flag.
1684:../src/stm32f30x_usart.c ****          (#) USART_FLAG_nCTSS: to indicate the status of the Inverted nCTS input 
1685:../src/stm32f30x_usart.c ****              bit status.
1686:../src/stm32f30x_usart.c ****          (#) USART_FLAG_TXE: to indicate the status of the transmit buffer register.
1687:../src/stm32f30x_usart.c ****          (#) USART_FLAG_RXNE: to indicate the status of the receive buffer register.
1688:../src/stm32f30x_usart.c ****          (#) USART_FLAG_TC: to indicate the status of the transmit operation.
1689:../src/stm32f30x_usart.c ****          (#) USART_FLAG_IDLE: to indicate the status of the Idle Line.
1690:../src/stm32f30x_usart.c ****          (#) USART_FLAG_CTS: to indicate the status of the nCTS input.
1691:../src/stm32f30x_usart.c ****          (#) USART_FLAG_LBD: to indicate the status of the LIN break detection.
1692:../src/stm32f30x_usart.c ****          (#) USART_FLAG_NE: to indicate if a noise error occur.
1693:../src/stm32f30x_usart.c ****          (#) USART_FLAG_FE: to indicate if a frame error occur.
1694:../src/stm32f30x_usart.c ****          (#) USART_FLAG_PE: to indicate if a parity error occur.
1695:../src/stm32f30x_usart.c ****          (#) USART_FLAG_ORE: to indicate if an Overrun error occur.
1696:../src/stm32f30x_usart.c ****     [..] In this Mode it is advised to use the following functions:
1697:../src/stm32f30x_usart.c ****          (+) FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG).
1698:../src/stm32f30x_usart.c ****          (+) void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG).
1699:../src/stm32f30x_usart.c ****                
1700:../src/stm32f30x_usart.c ****  *** Interrupt Mode ***
1701:../src/stm32f30x_usart.c ****  ======================
1702:../src/stm32f30x_usart.c ****     [..] In Interrupt Mode, the USART communication can be managed by 8 interrupt 
1703:../src/stm32f30x_usart.c ****          sources and 10 pending bits:
1704:../src/stm32f30x_usart.c ****          (+) Pending Bits:
1705:../src/stm32f30x_usart.c ****              (##) USART_IT_WU: to indicate the status of the Wake up interrupt.
1706:../src/stm32f30x_usart.c ****              (##) USART_IT_CM: to indicate the status of Character match interrupt.
1707:../src/stm32f30x_usart.c ****              (##) USART_IT_EOB: to indicate the status of End of block interrupt.
1708:../src/stm32f30x_usart.c ****              (##) USART_IT_RTO: to indicate the status of Receive time out interrupt.
1709:../src/stm32f30x_usart.c ****              (##) USART_IT_CTS: to indicate the status of CTS change interrupt.
1710:../src/stm32f30x_usart.c ****              (##) USART_IT_LBD: to indicate the status of LIN Break detection interrupt.
1711:../src/stm32f30x_usart.c ****              (##) USART_IT_TC: to indicate the status of Transmission complete interrupt.
1712:../src/stm32f30x_usart.c ****              (##) USART_IT_IDLE: to indicate the status of IDLE line detected interrupt.
1713:../src/stm32f30x_usart.c ****              (##) USART_IT_ORE: to indicate the status of OverRun Error interrupt.
1714:../src/stm32f30x_usart.c ****              (##) USART_IT_NE: to indicate the status of Noise Error interrupt.
1715:../src/stm32f30x_usart.c ****              (##) USART_IT_FE: to indicate the status of Framing Error interrupt.
1716:../src/stm32f30x_usart.c ****              (##) USART_IT_PE: to indicate the status of Parity Error interrupt.  
1717:../src/stm32f30x_usart.c ****               
1718:../src/stm32f30x_usart.c ****          (+) Interrupt Source:
1719:../src/stm32f30x_usart.c ****              (##) USART_IT_WU: specifies the interrupt source for Wake up interrupt.
1720:../src/stm32f30x_usart.c ****              (##) USART_IT_CM: specifies the interrupt source for Character match 
1721:../src/stm32f30x_usart.c ****                   interrupt.
1722:../src/stm32f30x_usart.c ****              (##) USART_IT_EOB: specifies the interrupt source for End of block
1723:../src/stm32f30x_usart.c ****                   interrupt.
1724:../src/stm32f30x_usart.c ****              (##) USART_IT_RTO: specifies the interrupt source for Receive time-out
1725:../src/stm32f30x_usart.c ****                   interrupt.
1726:../src/stm32f30x_usart.c ****              (##) USART_IT_CTS: specifies the interrupt source for CTS change interrupt.
1727:../src/stm32f30x_usart.c ****              (##) USART_IT_LBD: specifies the interrupt source for LIN Break 
1728:../src/stm32f30x_usart.c ****                   detection interrupt.
1729:../src/stm32f30x_usart.c ****              (##) USART_IT_TXE: specifies the interrupt source for Tansmit Data 
1730:../src/stm32f30x_usart.c ****                   Register empty interrupt.
1731:../src/stm32f30x_usart.c ****              (##) USART_IT_TC: specifies the interrupt source for Transmission 
1732:../src/stm32f30x_usart.c ****                   complete interrupt.
1733:../src/stm32f30x_usart.c ****              (##) USART_IT_RXNE: specifies the interrupt source for Receive Data 
1734:../src/stm32f30x_usart.c ****                   register not empty interrupt.
1735:../src/stm32f30x_usart.c ****              (##) USART_IT_IDLE: specifies the interrupt source for Idle line 
1736:../src/stm32f30x_usart.c ****                   detection interrupt.
1737:../src/stm32f30x_usart.c ****              (##) USART_IT_PE: specifies the interrupt source for Parity Error interrupt.
1738:../src/stm32f30x_usart.c ****              (##) USART_IT_ERR: specifies the interrupt source for Error interrupt
1739:../src/stm32f30x_usart.c ****                   (Frame error, noise error, overrun error)
1740:../src/stm32f30x_usart.c ****              -@@- Some parameters are coded in order to use them as interrupt 
1741:../src/stm32f30x_usart.c ****                  source or as pending bits.
1742:../src/stm32f30x_usart.c ****     [..] In this Mode it is advised to use the following functions:
1743:../src/stm32f30x_usart.c ****          (+) void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState
1744:../src/stm32f30x_usart.c ****          (+) ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT).
1745:../src/stm32f30x_usart.c ****          (+) void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT).
1746:../src/stm32f30x_usart.c **** 
1747:../src/stm32f30x_usart.c **** @endverbatim
1748:../src/stm32f30x_usart.c ****   * @{
1749:../src/stm32f30x_usart.c ****   */
1750:../src/stm32f30x_usart.c **** 
1751:../src/stm32f30x_usart.c **** /**
1752:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the specified USART interrupts.
1753:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1754:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1755:../src/stm32f30x_usart.c ****   * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
1756:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1757:../src/stm32f30x_usart.c ****   *         @arg USART_IT_WU:  Wake up interrupt.
1758:../src/stm32f30x_usart.c ****   *         @arg USART_IT_CM:  Character match interrupt.
1759:../src/stm32f30x_usart.c ****   *         @arg USART_IT_EOB:  End of block interrupt.
1760:../src/stm32f30x_usart.c ****   *         @arg USART_IT_RTO:  Receive time out interrupt.
1761:../src/stm32f30x_usart.c ****   *         @arg USART_IT_CTS:  CTS change interrupt.
1762:../src/stm32f30x_usart.c ****   *         @arg USART_IT_LBD:  LIN Break detection interrupt.
1763:../src/stm32f30x_usart.c ****   *         @arg USART_IT_TXE:  Tansmit Data Register empty interrupt.
1764:../src/stm32f30x_usart.c ****   *         @arg USART_IT_TC:  Transmission complete interrupt.
1765:../src/stm32f30x_usart.c ****   *         @arg USART_IT_RXNE:  Receive Data register not empty interrupt.
1766:../src/stm32f30x_usart.c ****   *         @arg USART_IT_IDLE:  Idle line detection interrupt.
1767:../src/stm32f30x_usart.c ****   *         @arg USART_IT_PE:  Parity Error interrupt.
1768:../src/stm32f30x_usart.c ****   *         @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
1769:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the specified USARTx interrupts.
1770:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.
1771:../src/stm32f30x_usart.c ****   * @retval None
1772:../src/stm32f30x_usart.c ****   */
1773:../src/stm32f30x_usart.c **** void USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState)
1774:../src/stm32f30x_usart.c **** {
 2359              		.loc 1 1774 0
 2360              		.cfi_startproc
 2361              		@ args = 0, pretend = 0, frame = 32
 2362              		@ frame_needed = 1, uses_anonymous_args = 0
 2363              		@ link register save eliminated.
 2364 0aa8 80B4     		push	{r7}
 2365              	.LCFI126:
 2366              		.cfi_def_cfa_offset 4
 2367              		.cfi_offset 7, -4
 2368 0aaa 89B0     		sub	sp, sp, #36
 2369              	.LCFI127:
 2370              		.cfi_def_cfa_offset 40
 2371 0aac 00AF     		add	r7, sp, #0
 2372              	.LCFI128:
 2373              		.cfi_def_cfa_register 7
 2374 0aae F860     		str	r0, [r7, #12]
 2375 0ab0 B960     		str	r1, [r7, #8]
 2376 0ab2 1346     		mov	r3, r2
 2377 0ab4 FB71     		strb	r3, [r7, #7]
1775:../src/stm32f30x_usart.c ****   uint32_t usartreg = 0, itpos = 0, itmask = 0;
 2378              		.loc 1 1775 0
 2379 0ab6 4FF00003 		mov	r3, #0
 2380 0aba BB61     		str	r3, [r7, #24]
 2381 0abc 4FF00003 		mov	r3, #0
 2382 0ac0 7B61     		str	r3, [r7, #20]
 2383 0ac2 4FF00003 		mov	r3, #0
 2384 0ac6 3B61     		str	r3, [r7, #16]
1776:../src/stm32f30x_usart.c ****   uint32_t usartxbase = 0;
 2385              		.loc 1 1776 0
 2386 0ac8 4FF00003 		mov	r3, #0
 2387 0acc FB61     		str	r3, [r7, #28]
1777:../src/stm32f30x_usart.c ****   /* Check the parameters */
1778:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1779:../src/stm32f30x_usart.c ****   assert_param(IS_USART_CONFIG_IT(USART_IT));
1780:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1781:../src/stm32f30x_usart.c ****   
1782:../src/stm32f30x_usart.c ****   usartxbase = (uint32_t)USARTx;
 2388              		.loc 1 1782 0
 2389 0ace FB68     		ldr	r3, [r7, #12]
 2390 0ad0 FB61     		str	r3, [r7, #28]
1783:../src/stm32f30x_usart.c **** 
1784:../src/stm32f30x_usart.c ****   /* Get the USART register index */
1785:../src/stm32f30x_usart.c ****   usartreg = (((uint16_t)USART_IT) >> 0x08);
 2391              		.loc 1 1785 0
 2392 0ad2 BB68     		ldr	r3, [r7, #8]
 2393 0ad4 9BB2     		uxth	r3, r3
 2394 0ad6 4FEA1323 		lsr	r3, r3, #8
 2395 0ada 9BB2     		uxth	r3, r3
 2396 0adc BB61     		str	r3, [r7, #24]
1786:../src/stm32f30x_usart.c **** 
1787:../src/stm32f30x_usart.c ****   /* Get the interrupt position */
1788:../src/stm32f30x_usart.c ****   itpos = USART_IT & IT_MASK;
 2397              		.loc 1 1788 0
 2398 0ade BB68     		ldr	r3, [r7, #8]
 2399 0ae0 DBB2     		uxtb	r3, r3
 2400 0ae2 7B61     		str	r3, [r7, #20]
1789:../src/stm32f30x_usart.c ****   itmask = (((uint32_t)0x01) << itpos);
 2401              		.loc 1 1789 0
 2402 0ae4 7B69     		ldr	r3, [r7, #20]
 2403 0ae6 4FF00102 		mov	r2, #1
 2404 0aea 02FA03F3 		lsl	r3, r2, r3
 2405 0aee 3B61     		str	r3, [r7, #16]
1790:../src/stm32f30x_usart.c **** 
1791:../src/stm32f30x_usart.c ****   if (usartreg == 0x02) /* The IT is in CR2 register */
 2406              		.loc 1 1791 0
 2407 0af0 BB69     		ldr	r3, [r7, #24]
 2408 0af2 022B     		cmp	r3, #2
 2409 0af4 04D1     		bne	.L97
1792:../src/stm32f30x_usart.c ****   {
1793:../src/stm32f30x_usart.c ****     usartxbase += 0x04;
 2410              		.loc 1 1793 0
 2411 0af6 FB69     		ldr	r3, [r7, #28]
 2412 0af8 03F10403 		add	r3, r3, #4
 2413 0afc FB61     		str	r3, [r7, #28]
 2414 0afe 06E0     		b	.L98
 2415              	.L97:
1794:../src/stm32f30x_usart.c ****   }
1795:../src/stm32f30x_usart.c ****   else if (usartreg == 0x03) /* The IT is in CR3 register */
 2416              		.loc 1 1795 0
 2417 0b00 BB69     		ldr	r3, [r7, #24]
 2418 0b02 032B     		cmp	r3, #3
 2419 0b04 03D1     		bne	.L98
1796:../src/stm32f30x_usart.c ****   {
1797:../src/stm32f30x_usart.c ****     usartxbase += 0x08;
 2420              		.loc 1 1797 0
 2421 0b06 FB69     		ldr	r3, [r7, #28]
 2422 0b08 03F10803 		add	r3, r3, #8
 2423 0b0c FB61     		str	r3, [r7, #28]
 2424              	.L98:
1798:../src/stm32f30x_usart.c ****   }
1799:../src/stm32f30x_usart.c ****   else /* The IT is in CR1 register */
1800:../src/stm32f30x_usart.c ****   {
1801:../src/stm32f30x_usart.c ****   }
1802:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 2425              		.loc 1 1802 0
 2426 0b0e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2427 0b10 002B     		cmp	r3, #0
 2428 0b12 06D0     		beq	.L99
1803:../src/stm32f30x_usart.c ****   {
1804:../src/stm32f30x_usart.c ****     *(__IO uint32_t*)usartxbase  |= itmask;
 2429              		.loc 1 1804 0
 2430 0b14 FB69     		ldr	r3, [r7, #28]
 2431 0b16 FA69     		ldr	r2, [r7, #28]
 2432 0b18 1168     		ldr	r1, [r2, #0]
 2433 0b1a 3A69     		ldr	r2, [r7, #16]
 2434 0b1c 0A43     		orrs	r2, r2, r1
 2435 0b1e 1A60     		str	r2, [r3, #0]
 2436 0b20 07E0     		b	.L96
 2437              	.L99:
1805:../src/stm32f30x_usart.c ****   }
1806:../src/stm32f30x_usart.c ****   else
1807:../src/stm32f30x_usart.c ****   {
1808:../src/stm32f30x_usart.c ****     *(__IO uint32_t*)usartxbase &= ~itmask;
 2438              		.loc 1 1808 0
 2439 0b22 FB69     		ldr	r3, [r7, #28]
 2440 0b24 FA69     		ldr	r2, [r7, #28]
 2441 0b26 1168     		ldr	r1, [r2, #0]
 2442 0b28 3A69     		ldr	r2, [r7, #16]
 2443 0b2a 6FEA0202 		mvn	r2, r2
 2444 0b2e 0A40     		ands	r2, r2, r1
 2445 0b30 1A60     		str	r2, [r3, #0]
 2446              	.L96:
1809:../src/stm32f30x_usart.c ****   }
1810:../src/stm32f30x_usart.c **** }
 2447              		.loc 1 1810 0
 2448 0b32 07F12407 		add	r7, r7, #36
 2449 0b36 BD46     		mov	sp, r7
 2450 0b38 80BC     		pop	{r7}
 2451 0b3a 7047     		bx	lr
 2452              		.cfi_endproc
 2453              	.LFE153:
 2455              		.align	2
 2456              		.global	USART_RequestCmd
 2457              		.thumb
 2458              		.thumb_func
 2460              	USART_RequestCmd:
 2461              	.LFB154:
1811:../src/stm32f30x_usart.c **** 
1812:../src/stm32f30x_usart.c **** /**
1813:../src/stm32f30x_usart.c ****   * @brief  Enables the specified USART's Request.
1814:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1815:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1816:../src/stm32f30x_usart.c ****   * @param  USART_Request: specifies the USART request.
1817:../src/stm32f30x_usart.c ****   *         This parameter can be any combination of the following values:
1818:../src/stm32f30x_usart.c ****   *         @arg USART_Request_TXFRQ: Transmit data flush ReQuest
1819:../src/stm32f30x_usart.c ****   *         @arg USART_Request_RXFRQ: Receive data flush ReQuest
1820:../src/stm32f30x_usart.c ****   *         @arg USART_Request_MMRQ: Mute Mode ReQuest
1821:../src/stm32f30x_usart.c ****   *         @arg USART_Request_SBKRQ: Send Break ReQuest
1822:../src/stm32f30x_usart.c ****   *         @arg USART_Request_ABRRQ: Auto Baud Rate ReQuest
1823:../src/stm32f30x_usart.c ****   * @param  NewState: new state of the DMA interface when reception error occurs.
1824:../src/stm32f30x_usart.c ****   *         This parameter can be: ENABLE or DISABLE.  
1825:../src/stm32f30x_usart.c ****   * @retval None
1826:../src/stm32f30x_usart.c ****   */
1827:../src/stm32f30x_usart.c **** void USART_RequestCmd(USART_TypeDef* USARTx, uint32_t USART_Request, FunctionalState NewState)
1828:../src/stm32f30x_usart.c **** {
 2462              		.loc 1 1828 0
 2463              		.cfi_startproc
 2464              		@ args = 0, pretend = 0, frame = 16
 2465              		@ frame_needed = 1, uses_anonymous_args = 0
 2466              		@ link register save eliminated.
 2467 0b3c 80B4     		push	{r7}
 2468              	.LCFI129:
 2469              		.cfi_def_cfa_offset 4
 2470              		.cfi_offset 7, -4
 2471 0b3e 85B0     		sub	sp, sp, #20
 2472              	.LCFI130:
 2473              		.cfi_def_cfa_offset 24
 2474 0b40 00AF     		add	r7, sp, #0
 2475              	.LCFI131:
 2476              		.cfi_def_cfa_register 7
 2477 0b42 F860     		str	r0, [r7, #12]
 2478 0b44 B960     		str	r1, [r7, #8]
 2479 0b46 1346     		mov	r3, r2
 2480 0b48 FB71     		strb	r3, [r7, #7]
1829:../src/stm32f30x_usart.c ****   /* Check the parameters */
1830:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1831:../src/stm32f30x_usart.c ****   assert_param(IS_USART_REQUEST(USART_Request));
1832:../src/stm32f30x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
1833:../src/stm32f30x_usart.c **** 
1834:../src/stm32f30x_usart.c ****   if (NewState != DISABLE)
 2481              		.loc 1 1834 0
 2482 0b4a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2483 0b4c 002B     		cmp	r3, #0
 2484 0b4e 09D0     		beq	.L102
1835:../src/stm32f30x_usart.c ****   {
1836:../src/stm32f30x_usart.c ****     /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
1837:../src/stm32f30x_usart.c ****        register.*/
1838:../src/stm32f30x_usart.c ****     USARTx->RQR |= USART_Request;
 2485              		.loc 1 1838 0
 2486 0b50 FB68     		ldr	r3, [r7, #12]
 2487 0b52 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 2488 0b54 9AB2     		uxth	r2, r3
 2489 0b56 BB68     		ldr	r3, [r7, #8]
 2490 0b58 9BB2     		uxth	r3, r3
 2491 0b5a 1343     		orrs	r3, r3, r2
 2492 0b5c 9AB2     		uxth	r2, r3
 2493 0b5e FB68     		ldr	r3, [r7, #12]
 2494 0b60 1A83     		strh	r2, [r3, #24]	@ movhi
 2495 0b62 0BE0     		b	.L101
 2496              	.L102:
1839:../src/stm32f30x_usart.c ****   }
1840:../src/stm32f30x_usart.c ****   else
1841:../src/stm32f30x_usart.c ****   {
1842:../src/stm32f30x_usart.c ****     /* Disable the USART ReQuest by clearing the dedicated request bit in the RQR
1843:../src/stm32f30x_usart.c ****        register.*/
1844:../src/stm32f30x_usart.c ****     USARTx->RQR &= (uint32_t)~USART_Request;
 2497              		.loc 1 1844 0
 2498 0b64 FB68     		ldr	r3, [r7, #12]
 2499 0b66 1B8B     		ldrh	r3, [r3, #24]	@ movhi
 2500 0b68 9AB2     		uxth	r2, r3
 2501 0b6a BB68     		ldr	r3, [r7, #8]
 2502 0b6c 9BB2     		uxth	r3, r3
 2503 0b6e 6FEA0303 		mvn	r3, r3
 2504 0b72 9BB2     		uxth	r3, r3
 2505 0b74 1340     		ands	r3, r3, r2
 2506 0b76 9AB2     		uxth	r2, r3
 2507 0b78 FB68     		ldr	r3, [r7, #12]
 2508 0b7a 1A83     		strh	r2, [r3, #24]	@ movhi
 2509              	.L101:
1845:../src/stm32f30x_usart.c ****   }
1846:../src/stm32f30x_usart.c **** }
 2510              		.loc 1 1846 0
 2511 0b7c 07F11407 		add	r7, r7, #20
 2512 0b80 BD46     		mov	sp, r7
 2513 0b82 80BC     		pop	{r7}
 2514 0b84 7047     		bx	lr
 2515              		.cfi_endproc
 2516              	.LFE154:
 2518 0b86 00BF     		.align	2
 2519              		.global	USART_OverrunDetectionConfig
 2520              		.thumb
 2521              		.thumb_func
 2523              	USART_OverrunDetectionConfig:
 2524              	.LFB155:
1847:../src/stm32f30x_usart.c **** 
1848:../src/stm32f30x_usart.c **** /**
1849:../src/stm32f30x_usart.c ****   * @brief  Enables or disables the USART's Overrun detection.
1850:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1851:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1852:../src/stm32f30x_usart.c ****   * @param  USART_OVRDetection: specifies the OVR detection status in case of OVR error.
1853:../src/stm32f30x_usart.c ****   *         This parameter can be any combination of the following values:
1854:../src/stm32f30x_usart.c ****   *         @arg USART_OVRDetection_Enable: OVR error detection enabled when the USART OVR error 
1855:../src/stm32f30x_usart.c ****   *          is asserted.
1856:../src/stm32f30x_usart.c ****   *         @arg USART_OVRDetection_Disable: OVR error detection disabled when the USART OVR error 
1857:../src/stm32f30x_usart.c ****   *          is asserted.
1858:../src/stm32f30x_usart.c ****   * @retval None
1859:../src/stm32f30x_usart.c ****   */
1860:../src/stm32f30x_usart.c **** void USART_OverrunDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_OVRDetection)
1861:../src/stm32f30x_usart.c **** {
 2525              		.loc 1 1861 0
 2526              		.cfi_startproc
 2527              		@ args = 0, pretend = 0, frame = 8
 2528              		@ frame_needed = 1, uses_anonymous_args = 0
 2529              		@ link register save eliminated.
 2530 0b88 80B4     		push	{r7}
 2531              	.LCFI132:
 2532              		.cfi_def_cfa_offset 4
 2533              		.cfi_offset 7, -4
 2534 0b8a 83B0     		sub	sp, sp, #12
 2535              	.LCFI133:
 2536              		.cfi_def_cfa_offset 16
 2537 0b8c 00AF     		add	r7, sp, #0
 2538              	.LCFI134:
 2539              		.cfi_def_cfa_register 7
 2540 0b8e 7860     		str	r0, [r7, #4]
 2541 0b90 3960     		str	r1, [r7, #0]
1862:../src/stm32f30x_usart.c ****   /* Check the parameters */
1863:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1864:../src/stm32f30x_usart.c ****   assert_param(IS_USART_OVRDETECTION(USART_OVRDetection));
1865:../src/stm32f30x_usart.c ****   
1866:../src/stm32f30x_usart.c ****   /* Clear the OVR detection bit */
1867:../src/stm32f30x_usart.c ****   USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_OVRDIS);
 2542              		.loc 1 1867 0
 2543 0b92 7B68     		ldr	r3, [r7, #4]
 2544 0b94 9B68     		ldr	r3, [r3, #8]
 2545 0b96 23F48052 		bic	r2, r3, #4096
 2546 0b9a 7B68     		ldr	r3, [r7, #4]
 2547 0b9c 9A60     		str	r2, [r3, #8]
1868:../src/stm32f30x_usart.c ****   /* Set the new value for the OVR detection bit */
1869:../src/stm32f30x_usart.c ****   USARTx->CR3 |= USART_OVRDetection;
 2548              		.loc 1 1869 0
 2549 0b9e 7B68     		ldr	r3, [r7, #4]
 2550 0ba0 9A68     		ldr	r2, [r3, #8]
 2551 0ba2 3B68     		ldr	r3, [r7, #0]
 2552 0ba4 1A43     		orrs	r2, r2, r3
 2553 0ba6 7B68     		ldr	r3, [r7, #4]
 2554 0ba8 9A60     		str	r2, [r3, #8]
1870:../src/stm32f30x_usart.c **** }
 2555              		.loc 1 1870 0
 2556 0baa 07F10C07 		add	r7, r7, #12
 2557 0bae BD46     		mov	sp, r7
 2558 0bb0 80BC     		pop	{r7}
 2559 0bb2 7047     		bx	lr
 2560              		.cfi_endproc
 2561              	.LFE155:
 2563              		.align	2
 2564              		.global	USART_GetFlagStatus
 2565              		.thumb
 2566              		.thumb_func
 2568              	USART_GetFlagStatus:
 2569              	.LFB156:
1871:../src/stm32f30x_usart.c **** 
1872:../src/stm32f30x_usart.c **** /**
1873:../src/stm32f30x_usart.c ****   * @brief  Checks whether the specified USART flag is set or not.
1874:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1875:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1876:../src/stm32f30x_usart.c ****   * @param  USART_FLAG: specifies the flag to check.
1877:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1878:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_REACK:  Receive Enable acknowledge flag.
1879:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_TEACK:  Transmit Enable acknowledge flag.
1880:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_WUF:  Wake up flag.
1881:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_RWU:  Receive Wake up flag.
1882:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_SBK:  Send Break flag.
1883:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_CMF:  Character match flag.
1884:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_BUSY:  Busy flag.
1885:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_ABRF:  Auto baud rate flag.
1886:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_ABRE:  Auto baud rate error flag.
1887:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_EOBF:  End of block flag.
1888:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_RTOF:  Receive time out flag.
1889:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_nCTSS:  Inverted nCTS input bit status.
1890:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_CTS:  CTS Change flag.
1891:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_LBD:  LIN Break detection flag.
1892:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_TXE:  Transmit data register empty flag.
1893:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_TC:  Transmission Complete flag.
1894:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_RXNE:  Receive data register not empty flag.
1895:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_IDLE:  Idle Line detection flag.
1896:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_ORE:  OverRun Error flag.
1897:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_NE:  Noise Error flag.
1898:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_FE:  Framing Error flag.
1899:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_PE:  Parity Error flag.
1900:../src/stm32f30x_usart.c ****   * @retval The new state of USART_FLAG (SET or RESET).
1901:../src/stm32f30x_usart.c ****   */
1902:../src/stm32f30x_usart.c **** FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint32_t USART_FLAG)
1903:../src/stm32f30x_usart.c **** {
 2570              		.loc 1 1903 0
 2571              		.cfi_startproc
 2572              		@ args = 0, pretend = 0, frame = 16
 2573              		@ frame_needed = 1, uses_anonymous_args = 0
 2574              		@ link register save eliminated.
 2575 0bb4 80B4     		push	{r7}
 2576              	.LCFI135:
 2577              		.cfi_def_cfa_offset 4
 2578              		.cfi_offset 7, -4
 2579 0bb6 85B0     		sub	sp, sp, #20
 2580              	.LCFI136:
 2581              		.cfi_def_cfa_offset 24
 2582 0bb8 00AF     		add	r7, sp, #0
 2583              	.LCFI137:
 2584              		.cfi_def_cfa_register 7
 2585 0bba 7860     		str	r0, [r7, #4]
 2586 0bbc 3960     		str	r1, [r7, #0]
1904:../src/stm32f30x_usart.c ****   FlagStatus bitstatus = RESET;
 2587              		.loc 1 1904 0
 2588 0bbe 4FF00003 		mov	r3, #0
 2589 0bc2 FB73     		strb	r3, [r7, #15]
1905:../src/stm32f30x_usart.c ****   /* Check the parameters */
1906:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1907:../src/stm32f30x_usart.c ****   assert_param(IS_USART_FLAG(USART_FLAG));
1908:../src/stm32f30x_usart.c ****   
1909:../src/stm32f30x_usart.c ****   if ((USARTx->ISR & USART_FLAG) != (uint16_t)RESET)
 2590              		.loc 1 1909 0
 2591 0bc4 7B68     		ldr	r3, [r7, #4]
 2592 0bc6 DA69     		ldr	r2, [r3, #28]
 2593 0bc8 3B68     		ldr	r3, [r7, #0]
 2594 0bca 1340     		ands	r3, r3, r2
 2595 0bcc 002B     		cmp	r3, #0
 2596 0bce 03D0     		beq	.L106
1910:../src/stm32f30x_usart.c ****   {
1911:../src/stm32f30x_usart.c ****     bitstatus = SET;
 2597              		.loc 1 1911 0
 2598 0bd0 4FF00103 		mov	r3, #1
 2599 0bd4 FB73     		strb	r3, [r7, #15]
 2600 0bd6 02E0     		b	.L107
 2601              	.L106:
1912:../src/stm32f30x_usart.c ****   }
1913:../src/stm32f30x_usart.c ****   else
1914:../src/stm32f30x_usart.c ****   {
1915:../src/stm32f30x_usart.c ****     bitstatus = RESET;
 2602              		.loc 1 1915 0
 2603 0bd8 4FF00003 		mov	r3, #0
 2604 0bdc FB73     		strb	r3, [r7, #15]
 2605              	.L107:
1916:../src/stm32f30x_usart.c ****   }
1917:../src/stm32f30x_usart.c ****   return bitstatus;
 2606              		.loc 1 1917 0
 2607 0bde FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1918:../src/stm32f30x_usart.c **** }
 2608              		.loc 1 1918 0
 2609 0be0 1846     		mov	r0, r3
 2610 0be2 07F11407 		add	r7, r7, #20
 2611 0be6 BD46     		mov	sp, r7
 2612 0be8 80BC     		pop	{r7}
 2613 0bea 7047     		bx	lr
 2614              		.cfi_endproc
 2615              	.LFE156:
 2617              		.align	2
 2618              		.global	USART_ClearFlag
 2619              		.thumb
 2620              		.thumb_func
 2622              	USART_ClearFlag:
 2623              	.LFB157:
1919:../src/stm32f30x_usart.c **** 
1920:../src/stm32f30x_usart.c **** /**
1921:../src/stm32f30x_usart.c ****   * @brief  Clears the USARTx's pending flags.
1922:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1923:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1924:../src/stm32f30x_usart.c ****   * @param  USART_FLAG: specifies the flag to clear.
1925:../src/stm32f30x_usart.c ****   *         This parameter can be any combination of the following values:
1926:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_WUF:  Wake up flag.
1927:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_CMF:  Character match flag.
1928:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_EOBF:  End of block flag.
1929:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_RTOF:  Receive time out flag.
1930:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_CTS:  CTS Change flag.
1931:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_LBD:  LIN Break detection flag.
1932:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_TC:  Transmission Complete flag.
1933:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_IDLE:  IDLE line detected flag.
1934:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_ORE:  OverRun Error flag.
1935:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_NE: Noise Error flag.
1936:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_FE: Framing Error flag.
1937:../src/stm32f30x_usart.c ****   *         @arg USART_FLAG_PE:   Parity Errorflag.
1938:../src/stm32f30x_usart.c ****   *
1939:../src/stm32f30x_usart.c ****   * @note
1940:../src/stm32f30x_usart.c ****   *   - RXNE pending bit is cleared by a read to the USART_RDR register 
1941:../src/stm32f30x_usart.c ****   *     (USART_ReceiveData()) or by writing 1 to the RXFRQ in the register USART_RQR
1942:../src/stm32f30x_usart.c ****   *     (USART_RequestCmd()).
1943:../src/stm32f30x_usart.c ****   *   - TC flag can be also cleared by software sequence: a read operation to 
1944:../src/stm32f30x_usart.c ****   *     USART_SR register (USART_GetFlagStatus()) followed by a write operation
1945:../src/stm32f30x_usart.c ****   *     to USART_TDR register (USART_SendData()).
1946:../src/stm32f30x_usart.c ****   *   - TXE flag is cleared by a write to the USART_TDR register 
1947:../src/stm32f30x_usart.c ****   *     (USART_SendData()) or by writing 1 to the TXFRQ in the register USART_RQR
1948:../src/stm32f30x_usart.c ****   *     (USART_RequestCmd()).
1949:../src/stm32f30x_usart.c ****   *   - SBKF flag is cleared by 1 to the SBKRQ in the register USART_RQR
1950:../src/stm32f30x_usart.c ****   *     (USART_RequestCmd()).
1951:../src/stm32f30x_usart.c ****   * @retval None
1952:../src/stm32f30x_usart.c ****   */
1953:../src/stm32f30x_usart.c **** void USART_ClearFlag(USART_TypeDef* USARTx, uint32_t USART_FLAG)
1954:../src/stm32f30x_usart.c **** {
 2624              		.loc 1 1954 0
 2625              		.cfi_startproc
 2626              		@ args = 0, pretend = 0, frame = 8
 2627              		@ frame_needed = 1, uses_anonymous_args = 0
 2628              		@ link register save eliminated.
 2629 0bec 80B4     		push	{r7}
 2630              	.LCFI138:
 2631              		.cfi_def_cfa_offset 4
 2632              		.cfi_offset 7, -4
 2633 0bee 83B0     		sub	sp, sp, #12
 2634              	.LCFI139:
 2635              		.cfi_def_cfa_offset 16
 2636 0bf0 00AF     		add	r7, sp, #0
 2637              	.LCFI140:
 2638              		.cfi_def_cfa_register 7
 2639 0bf2 7860     		str	r0, [r7, #4]
 2640 0bf4 3960     		str	r1, [r7, #0]
1955:../src/stm32f30x_usart.c ****   /* Check the parameters */
1956:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1957:../src/stm32f30x_usart.c ****   assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
1958:../src/stm32f30x_usart.c ****      
1959:../src/stm32f30x_usart.c ****   USARTx->ICR = USART_FLAG;
 2641              		.loc 1 1959 0
 2642 0bf6 7B68     		ldr	r3, [r7, #4]
 2643 0bf8 3A68     		ldr	r2, [r7, #0]
 2644 0bfa 1A62     		str	r2, [r3, #32]
1960:../src/stm32f30x_usart.c **** }
 2645              		.loc 1 1960 0
 2646 0bfc 07F10C07 		add	r7, r7, #12
 2647 0c00 BD46     		mov	sp, r7
 2648 0c02 80BC     		pop	{r7}
 2649 0c04 7047     		bx	lr
 2650              		.cfi_endproc
 2651              	.LFE157:
 2653 0c06 00BF     		.align	2
 2654              		.global	USART_GetITStatus
 2655              		.thumb
 2656              		.thumb_func
 2658              	USART_GetITStatus:
 2659              	.LFB158:
1961:../src/stm32f30x_usart.c **** 
1962:../src/stm32f30x_usart.c **** /**
1963:../src/stm32f30x_usart.c ****   * @brief  Checks whether the specified USART interrupt has occurred or not.
1964:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
1965:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
1966:../src/stm32f30x_usart.c ****   * @param  USART_IT: specifies the USART interrupt source to check.
1967:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
1968:../src/stm32f30x_usart.c ****   *         @arg USART_IT_WU:  Wake up interrupt.
1969:../src/stm32f30x_usart.c ****   *         @arg USART_IT_CM:  Character match interrupt.
1970:../src/stm32f30x_usart.c ****   *         @arg USART_IT_EOB:  End of block interrupt.
1971:../src/stm32f30x_usart.c ****   *         @arg USART_IT_RTO:  Receive time out interrupt.
1972:../src/stm32f30x_usart.c ****   *         @arg USART_IT_CTS:  CTS change interrupt.
1973:../src/stm32f30x_usart.c ****   *         @arg USART_IT_LBD:  LIN Break detection interrupt.
1974:../src/stm32f30x_usart.c ****   *         @arg USART_IT_TXE:  Tansmit Data Register empty interrupt.
1975:../src/stm32f30x_usart.c ****   *         @arg USART_IT_TC:  Transmission complete interrupt.
1976:../src/stm32f30x_usart.c ****   *         @arg USART_IT_RXNE:  Receive Data register not empty interrupt.
1977:../src/stm32f30x_usart.c ****   *         @arg USART_IT_IDLE:  Idle line detection interrupt.
1978:../src/stm32f30x_usart.c ****   *         @arg USART_IT_ORE:  OverRun Error interrupt.
1979:../src/stm32f30x_usart.c ****   *         @arg USART_IT_NE:  Noise Error interrupt.
1980:../src/stm32f30x_usart.c ****   *         @arg USART_IT_FE:  Framing Error interrupt.
1981:../src/stm32f30x_usart.c ****   *         @arg USART_IT_PE:  Parity Error interrupt.
1982:../src/stm32f30x_usart.c ****   * @retval The new state of USART_IT (SET or RESET).
1983:../src/stm32f30x_usart.c ****   */
1984:../src/stm32f30x_usart.c **** ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint32_t USART_IT)
1985:../src/stm32f30x_usart.c **** {
 2660              		.loc 1 1985 0
 2661              		.cfi_startproc
 2662              		@ args = 0, pretend = 0, frame = 24
 2663              		@ frame_needed = 1, uses_anonymous_args = 0
 2664              		@ link register save eliminated.
 2665 0c08 80B4     		push	{r7}
 2666              	.LCFI141:
 2667              		.cfi_def_cfa_offset 4
 2668              		.cfi_offset 7, -4
 2669 0c0a 87B0     		sub	sp, sp, #28
 2670              	.LCFI142:
 2671              		.cfi_def_cfa_offset 32
 2672 0c0c 00AF     		add	r7, sp, #0
 2673              	.LCFI143:
 2674              		.cfi_def_cfa_register 7
 2675 0c0e 7860     		str	r0, [r7, #4]
 2676 0c10 3960     		str	r1, [r7, #0]
1986:../src/stm32f30x_usart.c ****   uint32_t bitpos = 0, itmask = 0, usartreg = 0;
 2677              		.loc 1 1986 0
 2678 0c12 4FF00003 		mov	r3, #0
 2679 0c16 FB60     		str	r3, [r7, #12]
 2680 0c18 4FF00003 		mov	r3, #0
 2681 0c1c 7B61     		str	r3, [r7, #20]
 2682 0c1e 4FF00003 		mov	r3, #0
 2683 0c22 BB60     		str	r3, [r7, #8]
1987:../src/stm32f30x_usart.c ****   ITStatus bitstatus = RESET;
 2684              		.loc 1 1987 0
 2685 0c24 4FF00003 		mov	r3, #0
 2686 0c28 FB74     		strb	r3, [r7, #19]
1988:../src/stm32f30x_usart.c ****   /* Check the parameters */
1989:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
1990:../src/stm32f30x_usart.c ****   assert_param(IS_USART_GET_IT(USART_IT)); 
1991:../src/stm32f30x_usart.c ****   
1992:../src/stm32f30x_usart.c ****   /* Get the USART register index */
1993:../src/stm32f30x_usart.c ****   usartreg = (((uint16_t)USART_IT) >> 0x08);
 2687              		.loc 1 1993 0
 2688 0c2a 3B68     		ldr	r3, [r7, #0]
 2689 0c2c 9BB2     		uxth	r3, r3
 2690 0c2e 4FEA1323 		lsr	r3, r3, #8
 2691 0c32 9BB2     		uxth	r3, r3
 2692 0c34 BB60     		str	r3, [r7, #8]
1994:../src/stm32f30x_usart.c ****   /* Get the interrupt position */
1995:../src/stm32f30x_usart.c ****   itmask = USART_IT & IT_MASK;
 2693              		.loc 1 1995 0
 2694 0c36 3B68     		ldr	r3, [r7, #0]
 2695 0c38 DBB2     		uxtb	r3, r3
 2696 0c3a 7B61     		str	r3, [r7, #20]
1996:../src/stm32f30x_usart.c ****   itmask = (uint32_t)0x01 << itmask;
 2697              		.loc 1 1996 0
 2698 0c3c 7B69     		ldr	r3, [r7, #20]
 2699 0c3e 4FF00102 		mov	r2, #1
 2700 0c42 02FA03F3 		lsl	r3, r2, r3
 2701 0c46 7B61     		str	r3, [r7, #20]
1997:../src/stm32f30x_usart.c ****   
1998:../src/stm32f30x_usart.c ****   if (usartreg == 0x01) /* The IT  is in CR1 register */
 2702              		.loc 1 1998 0
 2703 0c48 BB68     		ldr	r3, [r7, #8]
 2704 0c4a 012B     		cmp	r3, #1
 2705 0c4c 05D1     		bne	.L111
1999:../src/stm32f30x_usart.c ****   {
2000:../src/stm32f30x_usart.c ****     itmask &= USARTx->CR1;
 2706              		.loc 1 2000 0
 2707 0c4e 7B68     		ldr	r3, [r7, #4]
 2708 0c50 1B68     		ldr	r3, [r3, #0]
 2709 0c52 7A69     		ldr	r2, [r7, #20]
 2710 0c54 1340     		ands	r3, r3, r2
 2711 0c56 7B61     		str	r3, [r7, #20]
 2712 0c58 0DE0     		b	.L112
 2713              	.L111:
2001:../src/stm32f30x_usart.c ****   }
2002:../src/stm32f30x_usart.c ****   else if (usartreg == 0x02) /* The IT  is in CR2 register */
 2714              		.loc 1 2002 0
 2715 0c5a BB68     		ldr	r3, [r7, #8]
 2716 0c5c 022B     		cmp	r3, #2
 2717 0c5e 05D1     		bne	.L113
2003:../src/stm32f30x_usart.c ****   {
2004:../src/stm32f30x_usart.c ****     itmask &= USARTx->CR2;
 2718              		.loc 1 2004 0
 2719 0c60 7B68     		ldr	r3, [r7, #4]
 2720 0c62 5B68     		ldr	r3, [r3, #4]
 2721 0c64 7A69     		ldr	r2, [r7, #20]
 2722 0c66 1340     		ands	r3, r3, r2
 2723 0c68 7B61     		str	r3, [r7, #20]
 2724 0c6a 04E0     		b	.L112
 2725              	.L113:
2005:../src/stm32f30x_usart.c ****   }
2006:../src/stm32f30x_usart.c ****   else /* The IT  is in CR3 register */
2007:../src/stm32f30x_usart.c ****   {
2008:../src/stm32f30x_usart.c ****     itmask &= USARTx->CR3;
 2726              		.loc 1 2008 0
 2727 0c6c 7B68     		ldr	r3, [r7, #4]
 2728 0c6e 9B68     		ldr	r3, [r3, #8]
 2729 0c70 7A69     		ldr	r2, [r7, #20]
 2730 0c72 1340     		ands	r3, r3, r2
 2731 0c74 7B61     		str	r3, [r7, #20]
 2732              	.L112:
2009:../src/stm32f30x_usart.c ****   }
2010:../src/stm32f30x_usart.c ****   
2011:../src/stm32f30x_usart.c ****   bitpos = USART_IT >> 0x10;
 2733              		.loc 1 2011 0
 2734 0c76 3B68     		ldr	r3, [r7, #0]
 2735 0c78 4FEA1343 		lsr	r3, r3, #16
 2736 0c7c FB60     		str	r3, [r7, #12]
2012:../src/stm32f30x_usart.c ****   bitpos = (uint32_t)0x01 << bitpos;
 2737              		.loc 1 2012 0
 2738 0c7e FB68     		ldr	r3, [r7, #12]
 2739 0c80 4FF00102 		mov	r2, #1
 2740 0c84 02FA03F3 		lsl	r3, r2, r3
 2741 0c88 FB60     		str	r3, [r7, #12]
2013:../src/stm32f30x_usart.c ****   bitpos &= USARTx->ISR;
 2742              		.loc 1 2013 0
 2743 0c8a 7B68     		ldr	r3, [r7, #4]
 2744 0c8c DB69     		ldr	r3, [r3, #28]
 2745 0c8e FA68     		ldr	r2, [r7, #12]
 2746 0c90 1340     		ands	r3, r3, r2
 2747 0c92 FB60     		str	r3, [r7, #12]
2014:../src/stm32f30x_usart.c ****   if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 2748              		.loc 1 2014 0
 2749 0c94 7B69     		ldr	r3, [r7, #20]
 2750 0c96 002B     		cmp	r3, #0
 2751 0c98 06D0     		beq	.L114
 2752              		.loc 1 2014 0 is_stmt 0 discriminator 1
 2753 0c9a FB68     		ldr	r3, [r7, #12]
 2754 0c9c 002B     		cmp	r3, #0
 2755 0c9e 03D0     		beq	.L114
2015:../src/stm32f30x_usart.c ****   {
2016:../src/stm32f30x_usart.c ****     bitstatus = SET;
 2756              		.loc 1 2016 0 is_stmt 1
 2757 0ca0 4FF00103 		mov	r3, #1
 2758 0ca4 FB74     		strb	r3, [r7, #19]
 2759 0ca6 02E0     		b	.L115
 2760              	.L114:
2017:../src/stm32f30x_usart.c ****   }
2018:../src/stm32f30x_usart.c ****   else
2019:../src/stm32f30x_usart.c ****   {
2020:../src/stm32f30x_usart.c ****     bitstatus = RESET;
 2761              		.loc 1 2020 0
 2762 0ca8 4FF00003 		mov	r3, #0
 2763 0cac FB74     		strb	r3, [r7, #19]
 2764              	.L115:
2021:../src/stm32f30x_usart.c ****   }
2022:../src/stm32f30x_usart.c ****   
2023:../src/stm32f30x_usart.c ****   return bitstatus;  
 2765              		.loc 1 2023 0
 2766 0cae FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
2024:../src/stm32f30x_usart.c **** }
 2767              		.loc 1 2024 0
 2768 0cb0 1846     		mov	r0, r3
 2769 0cb2 07F11C07 		add	r7, r7, #28
 2770 0cb6 BD46     		mov	sp, r7
 2771 0cb8 80BC     		pop	{r7}
 2772 0cba 7047     		bx	lr
 2773              		.cfi_endproc
 2774              	.LFE158:
 2776              		.align	2
 2777              		.global	USART_ClearITPendingBit
 2778              		.thumb
 2779              		.thumb_func
 2781              	USART_ClearITPendingBit:
 2782              	.LFB159:
2025:../src/stm32f30x_usart.c **** 
2026:../src/stm32f30x_usart.c **** /**
2027:../src/stm32f30x_usart.c ****   * @brief  Clears the USARTx's interrupt pending bits.
2028:../src/stm32f30x_usart.c ****   * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
2029:../src/stm32f30x_usart.c ****   *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
2030:../src/stm32f30x_usart.c ****   * @param  USART_IT: specifies the interrupt pending bit to clear.
2031:../src/stm32f30x_usart.c ****   *         This parameter can be one of the following values:
2032:../src/stm32f30x_usart.c ****   *         @arg USART_IT_WU:  Wake up interrupt.
2033:../src/stm32f30x_usart.c ****   *         @arg USART_IT_CM:  Character match interrupt.
2034:../src/stm32f30x_usart.c ****   *         @arg USART_IT_EOB:  End of block interrupt.
2035:../src/stm32f30x_usart.c ****   *         @arg USART_IT_RTO:  Receive time out interrupt.
2036:../src/stm32f30x_usart.c ****   *         @arg USART_IT_CTS:  CTS change interrupt.
2037:../src/stm32f30x_usart.c ****   *         @arg USART_IT_LBD:  LIN Break detection interrupt.
2038:../src/stm32f30x_usart.c ****   *         @arg USART_IT_TC:  Transmission complete interrupt.
2039:../src/stm32f30x_usart.c ****   *         @arg USART_IT_IDLE:  IDLE line detected interrupt.
2040:../src/stm32f30x_usart.c ****   *         @arg USART_IT_ORE:  OverRun Error interrupt.
2041:../src/stm32f30x_usart.c ****   *         @arg USART_IT_NE:  Noise Error interrupt.
2042:../src/stm32f30x_usart.c ****   *         @arg USART_IT_FE:  Framing Error interrupt.
2043:../src/stm32f30x_usart.c ****   *         @arg USART_IT_PE:  Parity Error interrupt.
2044:../src/stm32f30x_usart.c ****   * @note
2045:../src/stm32f30x_usart.c ****   *   - RXNE pending bit is cleared by a read to the USART_RDR register 
2046:../src/stm32f30x_usart.c ****   *     (USART_ReceiveData()) or by writing 1 to the RXFRQ in the register USART_RQR
2047:../src/stm32f30x_usart.c ****   *     (USART_RequestCmd()).
2048:../src/stm32f30x_usart.c ****   *   - TC pending bit can be also cleared by software sequence: a read 
2049:../src/stm32f30x_usart.c ****   *     operation to USART_SR register (USART_GetITStatus()) followed by a write 
2050:../src/stm32f30x_usart.c ****   *     operation to USART_TDR register (USART_SendData()).
2051:../src/stm32f30x_usart.c ****   *   - TXE pending bit is cleared by a write to the USART_TDR register 
2052:../src/stm32f30x_usart.c ****   *     (USART_SendData()) or by writing 1 to the TXFRQ in the register USART_RQR
2053:../src/stm32f30x_usart.c ****   *     (USART_RequestCmd()).
2054:../src/stm32f30x_usart.c ****   * @retval None
2055:../src/stm32f30x_usart.c ****   */
2056:../src/stm32f30x_usart.c **** void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint32_t USART_IT)
2057:../src/stm32f30x_usart.c **** {
 2783              		.loc 1 2057 0
 2784              		.cfi_startproc
 2785              		@ args = 0, pretend = 0, frame = 16
 2786              		@ frame_needed = 1, uses_anonymous_args = 0
 2787              		@ link register save eliminated.
 2788 0cbc 80B4     		push	{r7}
 2789              	.LCFI144:
 2790              		.cfi_def_cfa_offset 4
 2791              		.cfi_offset 7, -4
 2792 0cbe 85B0     		sub	sp, sp, #20
 2793              	.LCFI145:
 2794              		.cfi_def_cfa_offset 24
 2795 0cc0 00AF     		add	r7, sp, #0
 2796              	.LCFI146:
 2797              		.cfi_def_cfa_register 7
 2798 0cc2 7860     		str	r0, [r7, #4]
 2799 0cc4 3960     		str	r1, [r7, #0]
2058:../src/stm32f30x_usart.c ****   uint32_t bitpos = 0, itmask = 0;
 2800              		.loc 1 2058 0
 2801 0cc6 4FF00003 		mov	r3, #0
 2802 0cca FB60     		str	r3, [r7, #12]
 2803 0ccc 4FF00003 		mov	r3, #0
 2804 0cd0 BB60     		str	r3, [r7, #8]
2059:../src/stm32f30x_usart.c ****   /* Check the parameters */
2060:../src/stm32f30x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
2061:../src/stm32f30x_usart.c ****   assert_param(IS_USART_CLEAR_IT(USART_IT)); 
2062:../src/stm32f30x_usart.c ****   
2063:../src/stm32f30x_usart.c ****   bitpos = USART_IT >> 0x10;
 2805              		.loc 1 2063 0
 2806 0cd2 3B68     		ldr	r3, [r7, #0]
 2807 0cd4 4FEA1343 		lsr	r3, r3, #16
 2808 0cd8 FB60     		str	r3, [r7, #12]
2064:../src/stm32f30x_usart.c ****   itmask = ((uint32_t)0x01 << (uint32_t)bitpos);
 2809              		.loc 1 2064 0
 2810 0cda FB68     		ldr	r3, [r7, #12]
 2811 0cdc 4FF00102 		mov	r2, #1
 2812 0ce0 02FA03F3 		lsl	r3, r2, r3
 2813 0ce4 BB60     		str	r3, [r7, #8]
2065:../src/stm32f30x_usart.c ****   USARTx->ICR = (uint32_t)itmask;
 2814              		.loc 1 2065 0
 2815 0ce6 7B68     		ldr	r3, [r7, #4]
 2816 0ce8 BA68     		ldr	r2, [r7, #8]
 2817 0cea 1A62     		str	r2, [r3, #32]
2066:../src/stm32f30x_usart.c **** }
 2818              		.loc 1 2066 0
 2819 0cec 07F11407 		add	r7, r7, #20
 2820 0cf0 BD46     		mov	sp, r7
 2821 0cf2 80BC     		pop	{r7}
 2822 0cf4 7047     		bx	lr
 2823              		.cfi_endproc
 2824              	.LFE159:
 2826              	.Letext0:
 2827              		.file 2 "/home/aghosh01/gcc-arm-none-eabi-4_7-2012q4/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../.
 2828              		.file 3 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x.h"
 2829              		.file 4 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x_rcc.h"
 2830              		.file 5 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x_usart.h"
 2831              		.file 6 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f30x_usart.c
     /tmp/ccD2FEyW.s:19     .text:00000000 $t
     /tmp/ccD2FEyW.s:24     .text:00000000 USART_DeInit
     /tmp/ccD2FEyW.s:134    .text:000000d8 USART_Init
     /tmp/ccD2FEyW.s:368    .text:00000268 USART_StructInit
     /tmp/ccD2FEyW.s:423    .text:000002ac USART_ClockInit
     /tmp/ccD2FEyW.s:489    .text:000002f8 USART_ClockStructInit
     /tmp/ccD2FEyW.s:536    .text:0000032c USART_Cmd
     /tmp/ccD2FEyW.s:588    .text:00000364 USART_DirectionModeCmd
     /tmp/ccD2FEyW.s:644    .text:000003a0 USART_OverSampling8Cmd
     /tmp/ccD2FEyW.s:696    .text:000003d8 USART_OneBitMethodCmd
     /tmp/ccD2FEyW.s:748    .text:00000410 USART_MSBFirstCmd
     /tmp/ccD2FEyW.s:800    .text:00000448 USART_DataInvCmd
     /tmp/ccD2FEyW.s:852    .text:00000480 USART_InvPinCmd
     /tmp/ccD2FEyW.s:908    .text:000004bc USART_SWAPPinCmd
     /tmp/ccD2FEyW.s:960    .text:000004f4 USART_ReceiverTimeOutCmd
     /tmp/ccD2FEyW.s:1012   .text:0000052c USART_SetReceiverTimeOut
     /tmp/ccD2FEyW.s:1057   .text:00000558 USART_SetPrescaler
     /tmp/ccD2FEyW.s:1108   .text:00000590 USART_STOPModeCmd
     /tmp/ccD2FEyW.s:1160   .text:000005c8 USART_StopModeWakeUpSourceConfig
     /tmp/ccD2FEyW.s:1205   .text:000005f4 USART_AutoBaudRateCmd
     /tmp/ccD2FEyW.s:1257   .text:0000062c USART_AutoBaudRateConfig
     /tmp/ccD2FEyW.s:1302   .text:00000658 USART_SendData
     /tmp/ccD2FEyW.s:1342   .text:00000680 USART_ReceiveData
     /tmp/ccD2FEyW.s:1381   .text:000006a4 USART_SetAddress
     /tmp/ccD2FEyW.s:1428   .text:000006d8 USART_MuteModeCmd
     /tmp/ccD2FEyW.s:1480   .text:00000710 USART_MuteModeWakeUpConfig
     /tmp/ccD2FEyW.s:1525   .text:0000073c USART_AddressDetectionConfig
     /tmp/ccD2FEyW.s:1570   .text:00000768 USART_LINBreakDetectLengthConfig
     /tmp/ccD2FEyW.s:1615   .text:00000794 USART_LINCmd
     /tmp/ccD2FEyW.s:1667   .text:000007cc USART_HalfDuplexCmd
     /tmp/ccD2FEyW.s:1719   .text:00000804 USART_SetGuardTime
     /tmp/ccD2FEyW.s:1772   .text:00000840 USART_SmartCardCmd
     /tmp/ccD2FEyW.s:1824   .text:00000878 USART_SmartCardNACKCmd
     /tmp/ccD2FEyW.s:1876   .text:000008b0 USART_SetAutoRetryCount
     /tmp/ccD2FEyW.s:1923   .text:000008e4 USART_SetBlockLength
     /tmp/ccD2FEyW.s:1970   .text:00000918 USART_IrDAConfig
     /tmp/ccD2FEyW.s:2015   .text:00000944 USART_IrDACmd
     /tmp/ccD2FEyW.s:2067   .text:0000097c USART_DECmd
     /tmp/ccD2FEyW.s:2119   .text:000009b4 USART_DEPolarityConfig
     /tmp/ccD2FEyW.s:2164   .text:000009e0 USART_SetDEAssertionTime
     /tmp/ccD2FEyW.s:2210   .text:00000a10 USART_SetDEDeassertionTime
     /tmp/ccD2FEyW.s:2256   .text:00000a40 USART_DMACmd
     /tmp/ccD2FEyW.s:2312   .text:00000a7c USART_DMAReceptionErrorConfig
     /tmp/ccD2FEyW.s:2357   .text:00000aa8 USART_ITConfig
     /tmp/ccD2FEyW.s:2460   .text:00000b3c USART_RequestCmd
     /tmp/ccD2FEyW.s:2523   .text:00000b88 USART_OverrunDetectionConfig
     /tmp/ccD2FEyW.s:2568   .text:00000bb4 USART_GetFlagStatus
     /tmp/ccD2FEyW.s:2622   .text:00000bec USART_ClearFlag
     /tmp/ccD2FEyW.s:2658   .text:00000c08 USART_GetITStatus
     /tmp/ccD2FEyW.s:2781   .text:00000cbc USART_ClearITPendingBit
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.323dce8664331a0daf4a2675e107c70c
                           .group:00000000 wm4.stm32f30x.h.56.6f19c65e98e3319a61449cb2b2455af5
                           .group:00000000 wm4.core_cm4.h.32.1434cd257ff5806b1b03cd32ab0641e9
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.core_cmInstr.h.25.d8165482ef3061013a2fc83e2d85f3d9
                           .group:00000000 wm4.core_cm4_simd.h.29.013e5bcf58dba2d27c60184174208e07
                           .group:00000000 wm4.core_cm4.h.155.cf7c793e178943e1bbf613f1b21cd51a
                           .group:00000000 wm4.stm32f30x.h.294.d8a54360eca16e4157694b52a095202d
                           .group:00000000 wm4.stm32f30x_adc.h.130.cbebad91f78fb87381fe0860eea6104e
                           .group:00000000 wm4.stm32f30x_can.h.50.8b8f5d301152c422a6e50622b33ef620
                           .group:00000000 wm4.stm32f30x_crc.h.54.66d4c5e565e18566aebd9abfd4bcd4b0
                           .group:00000000 wm4.stm32f30x_comp.h.91.06ae44150aaaa82c077b71df8db3541a
                           .group:00000000 wm4.stm32f30x_dac.h.49.b1b5b26e4ca241dbe67fa16dc86a615f
                           .group:00000000 wm4.stm32f30x_dbgmcu.h.53.b238a263ce6a2cc83f610cc35302a38b
                           .group:00000000 wm4.stm32f30x_dma.h.96.d7a2ddd10023e12781aa8ff5ac15d212
                           .group:00000000 wm4.stm32f30x_exti.h.60.8ca0809491a21dec6fc69cf7471e2bab
                           .group:00000000 wm4.stm32f30x_flash.h.70.32613455dfe7328932f786a224daac23
                           .group:00000000 wm4.stm32f30x_gpio.h.50.408e1f6250246e4cc28221970909d34c
                           .group:00000000 wm4.stm32f30x_syscfg.h.58.4cadeb4ec8e47d36b972bbb6b96b7161
                           .group:00000000 wm4.stm32f30x_i2c.h.86.3d51d4edc0e3b9ee9aae045ccbb7739a
                           .group:00000000 wm4.stm32f30x_iwdg.h.59.467d704fb073a015941f19b50fa6470a
                           .group:00000000 wm4.stm32f30x_opamp.h.75.704e2e5e2aab039de307aaa2dcc99fa5
                           .group:00000000 wm4.stm32f30x_pwr.h.59.5c85acff2a3e3c5085b2140c06025cfc
                           .group:00000000 wm4.stm32f30x_rcc.h.79.5ba7cac1e74879861a72556c25322aa4
                           .group:00000000 wm4.stm32f30x_rtc.h.133.d184e08ff40bda44db4bed94f9633384
                           .group:00000000 wm4.stm32f30x_spi.h.119.4d21ec94ec14f3553a127e61c0a9874f
                           .group:00000000 wm4.stm32f30x_tim.h.175.d4a93cff2e7924577147254e501271b6
                           .group:00000000 wm4.stm32f30x_wwdg.h.58.4688eee61a2709866472b4b4c07d9275
                           .group:00000000 wm4.stm32f30x_misc.h.113.6a52e4fe7c3825a3ab05990f30dddf92
                           .group:00000000 wm4.stm32f30x_usart.h.110.c89016273702821ff4f9fe43881f70b5

UNDEFINED SYMBOLS
RCC_APB2PeriphResetCmd
RCC_APB1PeriphResetCmd
RCC_GetClocksFreq
