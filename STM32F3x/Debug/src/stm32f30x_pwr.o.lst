   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 6
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"stm32f30x_pwr.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.align	2
  21              		.global	PWR_DeInit
  22              		.thumb
  23              		.thumb_func
  25              	PWR_DeInit:
  26              	.LFB111:
  27              		.file 1 "../src/stm32f30x_pwr.c"
   1:../src/stm32f30x_pwr.c **** /**
   2:../src/stm32f30x_pwr.c ****   ******************************************************************************
   3:../src/stm32f30x_pwr.c ****   * @file    stm32f30x_pwr.c
   4:../src/stm32f30x_pwr.c ****   * @author  MCD Application Team
   5:../src/stm32f30x_pwr.c ****   * @version V1.0.1
   6:../src/stm32f30x_pwr.c ****   * @date    23-October-2012
   7:../src/stm32f30x_pwr.c ****   * @brief   This file provides firmware functions to manage the following 
   8:../src/stm32f30x_pwr.c ****   *          functionalities of the Power Controller (PWR) peripheral:           
   9:../src/stm32f30x_pwr.c ****   *           + Backup Domain Access
  10:../src/stm32f30x_pwr.c ****   *           + PVD configuration
  11:../src/stm32f30x_pwr.c ****   *           + WakeUp pins configuration
  12:../src/stm32f30x_pwr.c ****   *           + Low Power modes configuration
  13:../src/stm32f30x_pwr.c ****   *           + Flags management
  14:../src/stm32f30x_pwr.c ****   *               
  15:../src/stm32f30x_pwr.c ****   ******************************************************************************
  16:../src/stm32f30x_pwr.c ****   * @attention
  17:../src/stm32f30x_pwr.c ****   *
  18:../src/stm32f30x_pwr.c ****   * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
  19:../src/stm32f30x_pwr.c ****   *
  20:../src/stm32f30x_pwr.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  21:../src/stm32f30x_pwr.c ****   * You may not use this file except in compliance with the License.
  22:../src/stm32f30x_pwr.c ****   * You may obtain a copy of the License at:
  23:../src/stm32f30x_pwr.c ****   *
  24:../src/stm32f30x_pwr.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  25:../src/stm32f30x_pwr.c ****   *
  26:../src/stm32f30x_pwr.c ****   * Unless required by applicable law or agreed to in writing, software 
  27:../src/stm32f30x_pwr.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  28:../src/stm32f30x_pwr.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  29:../src/stm32f30x_pwr.c ****   * See the License for the specific language governing permissions and
  30:../src/stm32f30x_pwr.c ****   * limitations under the License.
  31:../src/stm32f30x_pwr.c ****   *
  32:../src/stm32f30x_pwr.c ****   ******************************************************************************
  33:../src/stm32f30x_pwr.c ****   */
  34:../src/stm32f30x_pwr.c **** 
  35:../src/stm32f30x_pwr.c **** /* Includes ------------------------------------------------------------------*/
  36:../src/stm32f30x_pwr.c **** #include "stm32f30x_pwr.h"
  37:../src/stm32f30x_pwr.c **** #include "stm32f30x_rcc.h"
  38:../src/stm32f30x_pwr.c **** 
  39:../src/stm32f30x_pwr.c **** /** @addtogroup STM32F30x_StdPeriph_Driver
  40:../src/stm32f30x_pwr.c ****   * @{
  41:../src/stm32f30x_pwr.c ****   */
  42:../src/stm32f30x_pwr.c **** 
  43:../src/stm32f30x_pwr.c **** /** @defgroup PWR 
  44:../src/stm32f30x_pwr.c ****   * @brief PWR driver modules
  45:../src/stm32f30x_pwr.c ****   * @{
  46:../src/stm32f30x_pwr.c ****   */ 
  47:../src/stm32f30x_pwr.c **** 
  48:../src/stm32f30x_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  49:../src/stm32f30x_pwr.c **** /* Private define ------------------------------------------------------------*/
  50:../src/stm32f30x_pwr.c **** /* --------- PWR registers bit address in the alias region ---------- */
  51:../src/stm32f30x_pwr.c **** #define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
  52:../src/stm32f30x_pwr.c **** 
  53:../src/stm32f30x_pwr.c **** /* --- CR Register ---*/
  54:../src/stm32f30x_pwr.c **** 
  55:../src/stm32f30x_pwr.c **** /* Alias word address of DBP bit */
  56:../src/stm32f30x_pwr.c **** #define CR_OFFSET                (PWR_OFFSET + 0x00)
  57:../src/stm32f30x_pwr.c **** #define DBP_BitNumber            0x08
  58:../src/stm32f30x_pwr.c **** #define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
  59:../src/stm32f30x_pwr.c **** 
  60:../src/stm32f30x_pwr.c **** /* Alias word address of PVDE bit */
  61:../src/stm32f30x_pwr.c **** #define PVDE_BitNumber           0x04
  62:../src/stm32f30x_pwr.c **** #define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
  63:../src/stm32f30x_pwr.c **** 
  64:../src/stm32f30x_pwr.c **** /* ------------------ PWR registers bit mask ------------------------ */
  65:../src/stm32f30x_pwr.c **** 
  66:../src/stm32f30x_pwr.c **** /* CR register bit mask */
  67:../src/stm32f30x_pwr.c **** #define CR_DS_MASK               ((uint32_t)0xFFFFFFFC)
  68:../src/stm32f30x_pwr.c **** #define CR_PLS_MASK              ((uint32_t)0xFFFFFF1F)
  69:../src/stm32f30x_pwr.c **** 
  70:../src/stm32f30x_pwr.c **** /* Private macro -------------------------------------------------------------*/
  71:../src/stm32f30x_pwr.c **** /* Private variables ---------------------------------------------------------*/
  72:../src/stm32f30x_pwr.c **** /* Private function prototypes -----------------------------------------------*/
  73:../src/stm32f30x_pwr.c **** /* Private functions ---------------------------------------------------------*/
  74:../src/stm32f30x_pwr.c **** 
  75:../src/stm32f30x_pwr.c **** /** @defgroup PWR_Private_Functions
  76:../src/stm32f30x_pwr.c ****   * @{
  77:../src/stm32f30x_pwr.c ****   */
  78:../src/stm32f30x_pwr.c **** 
  79:../src/stm32f30x_pwr.c **** /** @defgroup PWR_Group1 Backup Domain Access function 
  80:../src/stm32f30x_pwr.c ****  *  @brief   Backup Domain Access function
  81:../src/stm32f30x_pwr.c ****  *
  82:../src/stm32f30x_pwr.c **** @verbatim
  83:../src/stm32f30x_pwr.c ****   ==============================================================================
  84:../src/stm32f30x_pwr.c ****                    ##### Backup Domain Access function #####
  85:../src/stm32f30x_pwr.c ****   ==============================================================================
  86:../src/stm32f30x_pwr.c **** 
  87:../src/stm32f30x_pwr.c ****     [..] After reset, the Backup Domain Registers (RCC BDCR Register, RTC registers
  88:../src/stm32f30x_pwr.c ****          and RTC backup registers) are protected against possible stray write accesses.
  89:../src/stm32f30x_pwr.c ****     [..] To enable access to Backup domain use the PWR_BackupAccessCmd(ENABLE) function.
  90:../src/stm32f30x_pwr.c **** 
  91:../src/stm32f30x_pwr.c **** @endverbatim
  92:../src/stm32f30x_pwr.c ****   * @{
  93:../src/stm32f30x_pwr.c ****   */
  94:../src/stm32f30x_pwr.c **** 
  95:../src/stm32f30x_pwr.c **** /**
  96:../src/stm32f30x_pwr.c ****   * @brief  Deinitializes the PWR peripheral registers to their default reset values.
  97:../src/stm32f30x_pwr.c ****   * @param  None
  98:../src/stm32f30x_pwr.c ****   * @retval None
  99:../src/stm32f30x_pwr.c ****   */
 100:../src/stm32f30x_pwr.c **** void PWR_DeInit(void)
 101:../src/stm32f30x_pwr.c **** {
  28              		.loc 1 101 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 1, uses_anonymous_args = 0
  32 0000 80B5     		push	{r7, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 7, -8
  36              		.cfi_offset 14, -4
  37 0002 00AF     		add	r7, sp, #0
  38              	.LCFI1:
  39              		.cfi_def_cfa_register 7
 102:../src/stm32f30x_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
  40              		.loc 1 102 0
  41 0004 4FF08050 		mov	r0, #268435456
  42 0008 4FF00101 		mov	r1, #1
  43 000c FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 103:../src/stm32f30x_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
  44              		.loc 1 103 0
  45 0010 4FF08050 		mov	r0, #268435456
  46 0014 4FF00001 		mov	r1, #0
  47 0018 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 104:../src/stm32f30x_pwr.c **** }
  48              		.loc 1 104 0
  49 001c 80BD     		pop	{r7, pc}
  50              		.cfi_endproc
  51              	.LFE111:
  53 001e 00BF     		.align	2
  54              		.global	PWR_BackupAccessCmd
  55              		.thumb
  56              		.thumb_func
  58              	PWR_BackupAccessCmd:
  59              	.LFB112:
 105:../src/stm32f30x_pwr.c **** 
 106:../src/stm32f30x_pwr.c **** /**
 107:../src/stm32f30x_pwr.c ****   * @brief  Enables or disables access to the RTC and backup registers.
 108:../src/stm32f30x_pwr.c ****   * @note   If the HSE divided by 32 is used as the RTC clock, the 
 109:../src/stm32f30x_pwr.c ****   *         Backup Domain Access should be kept enabled.
 110:../src/stm32f30x_pwr.c ****   * @param  NewState: new state of the access to the RTC and backup registers.
 111:../src/stm32f30x_pwr.c ****   *         This parameter can be: ENABLE or DISABLE.
 112:../src/stm32f30x_pwr.c ****   * @retval None
 113:../src/stm32f30x_pwr.c ****   */
 114:../src/stm32f30x_pwr.c **** void PWR_BackupAccessCmd(FunctionalState NewState)
 115:../src/stm32f30x_pwr.c **** {
  60              		.loc 1 115 0
  61              		.cfi_startproc
  62              		@ args = 0, pretend = 0, frame = 8
  63              		@ frame_needed = 1, uses_anonymous_args = 0
  64              		@ link register save eliminated.
  65 0020 80B4     		push	{r7}
  66              	.LCFI2:
  67              		.cfi_def_cfa_offset 4
  68              		.cfi_offset 7, -4
  69 0022 83B0     		sub	sp, sp, #12
  70              	.LCFI3:
  71              		.cfi_def_cfa_offset 16
  72 0024 00AF     		add	r7, sp, #0
  73              	.LCFI4:
  74              		.cfi_def_cfa_register 7
  75 0026 0346     		mov	r3, r0
  76 0028 FB71     		strb	r3, [r7, #7]
 116:../src/stm32f30x_pwr.c ****   /* Check the parameters */
 117:../src/stm32f30x_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 118:../src/stm32f30x_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
  77              		.loc 1 118 0
  78 002a 4FF02003 		mov	r3, #32
  79 002e C4F20E23 		movt	r3, 16910
  80 0032 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
  81 0034 1A60     		str	r2, [r3, #0]
 119:../src/stm32f30x_pwr.c **** }
  82              		.loc 1 119 0
  83 0036 07F10C07 		add	r7, r7, #12
  84 003a BD46     		mov	sp, r7
  85 003c 80BC     		pop	{r7}
  86 003e 7047     		bx	lr
  87              		.cfi_endproc
  88              	.LFE112:
  90              		.align	2
  91              		.global	PWR_PVDLevelConfig
  92              		.thumb
  93              		.thumb_func
  95              	PWR_PVDLevelConfig:
  96              	.LFB113:
 120:../src/stm32f30x_pwr.c **** 
 121:../src/stm32f30x_pwr.c **** /**
 122:../src/stm32f30x_pwr.c ****   * @}
 123:../src/stm32f30x_pwr.c ****   */
 124:../src/stm32f30x_pwr.c **** 
 125:../src/stm32f30x_pwr.c **** /** @defgroup PWR_Group2 PVD configuration functions
 126:../src/stm32f30x_pwr.c ****  *  @brief   PVD configuration functions 
 127:../src/stm32f30x_pwr.c ****  *
 128:../src/stm32f30x_pwr.c **** @verbatim   
 129:../src/stm32f30x_pwr.c ****  ===============================================================================
 130:../src/stm32f30x_pwr.c ****                     ##### PVD configuration functions #####
 131:../src/stm32f30x_pwr.c ****   ==============================================================================
 132:../src/stm32f30x_pwr.c ****   [..]
 133:../src/stm32f30x_pwr.c ****   (+) The PVD is used to monitor the VDD power supply by comparing it to a threshold
 134:../src/stm32f30x_pwr.c ****       selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
 135:../src/stm32f30x_pwr.c ****   (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower than the 
 136:../src/stm32f30x_pwr.c ****       PVD threshold. This event is internally connected to the EXTI line16
 137:../src/stm32f30x_pwr.c ****       and can generate an interrupt if enabled through the EXTI registers.
 138:../src/stm32f30x_pwr.c ****   (+) The PVD is stopped in Standby mode.
 139:../src/stm32f30x_pwr.c **** 
 140:../src/stm32f30x_pwr.c **** @endverbatim
 141:../src/stm32f30x_pwr.c ****   * @{
 142:../src/stm32f30x_pwr.c ****   */
 143:../src/stm32f30x_pwr.c **** 
 144:../src/stm32f30x_pwr.c **** /**
 145:../src/stm32f30x_pwr.c ****   * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
 146:../src/stm32f30x_pwr.c ****   * @param  PWR_PVDLevel: specifies the PVD detection level
 147:../src/stm32f30x_pwr.c ****   *         This parameter can be one of the following values:
 148:../src/stm32f30x_pwr.c ****   *             @arg PWR_PVDLevel_0: PVD detection level set to 2.18V
 149:../src/stm32f30x_pwr.c ****   *             @arg PWR_PVDLevel_1: PVD detection level set to 2.28V
 150:../src/stm32f30x_pwr.c ****   *             @arg PWR_PVDLevel_2: PVD detection level set to 2.38V
 151:../src/stm32f30x_pwr.c ****   *             @arg PWR_PVDLevel_3: PVD detection level set to 2.48V
 152:../src/stm32f30x_pwr.c ****   *             @arg PWR_PVDLevel_4: PVD detection level set to 2.58V
 153:../src/stm32f30x_pwr.c ****   *             @arg PWR_PVDLevel_5: PVD detection level set to 2.68V
 154:../src/stm32f30x_pwr.c ****   *             @arg PWR_PVDLevel_6: PVD detection level set to 2.78V
 155:../src/stm32f30x_pwr.c ****   *             @arg PWR_PVDLevel_7: PVD detection level set to 2.88V
 156:../src/stm32f30x_pwr.c ****   * @retval None
 157:../src/stm32f30x_pwr.c ****   */
 158:../src/stm32f30x_pwr.c **** void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
 159:../src/stm32f30x_pwr.c **** {
  97              		.loc 1 159 0
  98              		.cfi_startproc
  99              		@ args = 0, pretend = 0, frame = 16
 100              		@ frame_needed = 1, uses_anonymous_args = 0
 101              		@ link register save eliminated.
 102 0040 80B4     		push	{r7}
 103              	.LCFI5:
 104              		.cfi_def_cfa_offset 4
 105              		.cfi_offset 7, -4
 106 0042 85B0     		sub	sp, sp, #20
 107              	.LCFI6:
 108              		.cfi_def_cfa_offset 24
 109 0044 00AF     		add	r7, sp, #0
 110              	.LCFI7:
 111              		.cfi_def_cfa_register 7
 112 0046 7860     		str	r0, [r7, #4]
 160:../src/stm32f30x_pwr.c ****   uint32_t tmpreg = 0;
 113              		.loc 1 160 0
 114 0048 4FF00003 		mov	r3, #0
 115 004c FB60     		str	r3, [r7, #12]
 161:../src/stm32f30x_pwr.c ****   
 162:../src/stm32f30x_pwr.c ****   /* Check the parameters */
 163:../src/stm32f30x_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
 164:../src/stm32f30x_pwr.c ****   
 165:../src/stm32f30x_pwr.c ****   tmpreg = PWR->CR;
 116              		.loc 1 165 0
 117 004e 4FF4E043 		mov	r3, #28672
 118 0052 C4F20003 		movt	r3, 16384
 119 0056 1B68     		ldr	r3, [r3, #0]
 120 0058 FB60     		str	r3, [r7, #12]
 166:../src/stm32f30x_pwr.c ****   
 167:../src/stm32f30x_pwr.c ****   /* Clear PLS[7:5] bits */
 168:../src/stm32f30x_pwr.c ****   tmpreg &= CR_PLS_MASK;
 121              		.loc 1 168 0
 122 005a FB68     		ldr	r3, [r7, #12]
 123 005c 23F0E003 		bic	r3, r3, #224
 124 0060 FB60     		str	r3, [r7, #12]
 169:../src/stm32f30x_pwr.c ****   
 170:../src/stm32f30x_pwr.c ****   /* Set PLS[7:5] bits according to PWR_PVDLevel value */
 171:../src/stm32f30x_pwr.c ****   tmpreg |= PWR_PVDLevel;
 125              		.loc 1 171 0
 126 0062 FA68     		ldr	r2, [r7, #12]
 127 0064 7B68     		ldr	r3, [r7, #4]
 128 0066 1343     		orrs	r3, r3, r2
 129 0068 FB60     		str	r3, [r7, #12]
 172:../src/stm32f30x_pwr.c ****   
 173:../src/stm32f30x_pwr.c ****   /* Store the new value */
 174:../src/stm32f30x_pwr.c ****   PWR->CR = tmpreg;
 130              		.loc 1 174 0
 131 006a 4FF4E043 		mov	r3, #28672
 132 006e C4F20003 		movt	r3, 16384
 133 0072 FA68     		ldr	r2, [r7, #12]
 134 0074 1A60     		str	r2, [r3, #0]
 175:../src/stm32f30x_pwr.c **** }
 135              		.loc 1 175 0
 136 0076 07F11407 		add	r7, r7, #20
 137 007a BD46     		mov	sp, r7
 138 007c 80BC     		pop	{r7}
 139 007e 7047     		bx	lr
 140              		.cfi_endproc
 141              	.LFE113:
 143              		.align	2
 144              		.global	PWR_PVDCmd
 145              		.thumb
 146              		.thumb_func
 148              	PWR_PVDCmd:
 149              	.LFB114:
 176:../src/stm32f30x_pwr.c **** 
 177:../src/stm32f30x_pwr.c **** /**
 178:../src/stm32f30x_pwr.c ****   * @brief  Enables or disables the Power Voltage Detector(PVD).
 179:../src/stm32f30x_pwr.c ****   * @param  NewState: new state of the PVD.
 180:../src/stm32f30x_pwr.c ****   *         This parameter can be: ENABLE or DISABLE.
 181:../src/stm32f30x_pwr.c ****   * @retval None
 182:../src/stm32f30x_pwr.c ****   */
 183:../src/stm32f30x_pwr.c **** void PWR_PVDCmd(FunctionalState NewState)
 184:../src/stm32f30x_pwr.c **** {
 150              		.loc 1 184 0
 151              		.cfi_startproc
 152              		@ args = 0, pretend = 0, frame = 8
 153              		@ frame_needed = 1, uses_anonymous_args = 0
 154              		@ link register save eliminated.
 155 0080 80B4     		push	{r7}
 156              	.LCFI8:
 157              		.cfi_def_cfa_offset 4
 158              		.cfi_offset 7, -4
 159 0082 83B0     		sub	sp, sp, #12
 160              	.LCFI9:
 161              		.cfi_def_cfa_offset 16
 162 0084 00AF     		add	r7, sp, #0
 163              	.LCFI10:
 164              		.cfi_def_cfa_register 7
 165 0086 0346     		mov	r3, r0
 166 0088 FB71     		strb	r3, [r7, #7]
 185:../src/stm32f30x_pwr.c ****   /* Check the parameters */
 186:../src/stm32f30x_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 187:../src/stm32f30x_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
 167              		.loc 1 187 0
 168 008a 4FF01003 		mov	r3, #16
 169 008e C4F20E23 		movt	r3, 16910
 170 0092 FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 171 0094 1A60     		str	r2, [r3, #0]
 188:../src/stm32f30x_pwr.c **** }
 172              		.loc 1 188 0
 173 0096 07F10C07 		add	r7, r7, #12
 174 009a BD46     		mov	sp, r7
 175 009c 80BC     		pop	{r7}
 176 009e 7047     		bx	lr
 177              		.cfi_endproc
 178              	.LFE114:
 180              		.align	2
 181              		.global	PWR_WakeUpPinCmd
 182              		.thumb
 183              		.thumb_func
 185              	PWR_WakeUpPinCmd:
 186              	.LFB115:
 189:../src/stm32f30x_pwr.c **** 
 190:../src/stm32f30x_pwr.c **** /**
 191:../src/stm32f30x_pwr.c ****   * @}
 192:../src/stm32f30x_pwr.c ****   */
 193:../src/stm32f30x_pwr.c **** 
 194:../src/stm32f30x_pwr.c **** /** @defgroup PWR_Group3 WakeUp pins configuration functions
 195:../src/stm32f30x_pwr.c ****  *  @brief   WakeUp pins configuration functions 
 196:../src/stm32f30x_pwr.c ****  *
 197:../src/stm32f30x_pwr.c **** @verbatim   
 198:../src/stm32f30x_pwr.c ****  ===============================================================================
 199:../src/stm32f30x_pwr.c ****               ##### WakeUp pins configuration functions #####
 200:../src/stm32f30x_pwr.c ****  ===============================================================================  
 201:../src/stm32f30x_pwr.c ****     [..]
 202:../src/stm32f30x_pwr.c ****     (+) WakeUp pins are used to wakeup the system from Standby mode. These pins are 
 203:../src/stm32f30x_pwr.c ****         forced in input pull down configuration and are active on rising edges.
 204:../src/stm32f30x_pwr.c ****     (+) There are three WakeUp pins: WakeUp Pin 1 on PA.00, WakeUp Pin 2 on PC.13 and
 205:../src/stm32f30x_pwr.c ****         WakeUp Pin 3 on PE.06.
 206:../src/stm32f30x_pwr.c **** 
 207:../src/stm32f30x_pwr.c **** @endverbatim
 208:../src/stm32f30x_pwr.c ****   * @{
 209:../src/stm32f30x_pwr.c ****   */
 210:../src/stm32f30x_pwr.c **** 
 211:../src/stm32f30x_pwr.c **** /**
 212:../src/stm32f30x_pwr.c ****   * @brief  Enables or disables the WakeUp Pin functionality.
 213:../src/stm32f30x_pwr.c ****   * @param  PWR_WakeUpPin: specifies the WakeUpPin.
 214:../src/stm32f30x_pwr.c ****   *         This parameter can be: PWR_WakeUpPin_1, PWR_WakeUpPin_2 or PWR_WakeUpPin_3.
 215:../src/stm32f30x_pwr.c ****   * @param  NewState: new state of the WakeUp Pin functionality.
 216:../src/stm32f30x_pwr.c ****   *         This parameter can be: ENABLE or DISABLE.
 217:../src/stm32f30x_pwr.c ****   * @retval None
 218:../src/stm32f30x_pwr.c ****   */
 219:../src/stm32f30x_pwr.c **** void PWR_WakeUpPinCmd(uint32_t PWR_WakeUpPin, FunctionalState NewState)
 220:../src/stm32f30x_pwr.c **** {  
 187              		.loc 1 220 0
 188              		.cfi_startproc
 189              		@ args = 0, pretend = 0, frame = 8
 190              		@ frame_needed = 1, uses_anonymous_args = 0
 191              		@ link register save eliminated.
 192 00a0 80B4     		push	{r7}
 193              	.LCFI11:
 194              		.cfi_def_cfa_offset 4
 195              		.cfi_offset 7, -4
 196 00a2 83B0     		sub	sp, sp, #12
 197              	.LCFI12:
 198              		.cfi_def_cfa_offset 16
 199 00a4 00AF     		add	r7, sp, #0
 200              	.LCFI13:
 201              		.cfi_def_cfa_register 7
 202 00a6 7860     		str	r0, [r7, #4]
 203 00a8 0B46     		mov	r3, r1
 204 00aa FB70     		strb	r3, [r7, #3]
 221:../src/stm32f30x_pwr.c ****   /* Check the parameters */
 222:../src/stm32f30x_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(PWR_WakeUpPin));  
 223:../src/stm32f30x_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 224:../src/stm32f30x_pwr.c **** 
 225:../src/stm32f30x_pwr.c ****   if (NewState != DISABLE)
 205              		.loc 1 225 0
 206 00ac FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 207 00ae 002B     		cmp	r3, #0
 208 00b0 0CD0     		beq	.L6
 226:../src/stm32f30x_pwr.c ****   {
 227:../src/stm32f30x_pwr.c ****     /* Enable the EWUPx pin */
 228:../src/stm32f30x_pwr.c ****     PWR->CSR |= PWR_WakeUpPin;
 209              		.loc 1 228 0
 210 00b2 4FF4E043 		mov	r3, #28672
 211 00b6 C4F20003 		movt	r3, 16384
 212 00ba 4FF4E042 		mov	r2, #28672
 213 00be C4F20002 		movt	r2, 16384
 214 00c2 5168     		ldr	r1, [r2, #4]
 215 00c4 7A68     		ldr	r2, [r7, #4]
 216 00c6 0A43     		orrs	r2, r2, r1
 217 00c8 5A60     		str	r2, [r3, #4]
 218 00ca 0DE0     		b	.L5
 219              	.L6:
 229:../src/stm32f30x_pwr.c ****   }
 230:../src/stm32f30x_pwr.c ****   else
 231:../src/stm32f30x_pwr.c ****   {
 232:../src/stm32f30x_pwr.c ****     /* Disable the EWUPx pin */
 233:../src/stm32f30x_pwr.c ****     PWR->CSR &= ~PWR_WakeUpPin;
 220              		.loc 1 233 0
 221 00cc 4FF4E043 		mov	r3, #28672
 222 00d0 C4F20003 		movt	r3, 16384
 223 00d4 4FF4E042 		mov	r2, #28672
 224 00d8 C4F20002 		movt	r2, 16384
 225 00dc 5168     		ldr	r1, [r2, #4]
 226 00de 7A68     		ldr	r2, [r7, #4]
 227 00e0 6FEA0202 		mvn	r2, r2
 228 00e4 0A40     		ands	r2, r2, r1
 229 00e6 5A60     		str	r2, [r3, #4]
 230              	.L5:
 234:../src/stm32f30x_pwr.c ****   }
 235:../src/stm32f30x_pwr.c **** }
 231              		.loc 1 235 0
 232 00e8 07F10C07 		add	r7, r7, #12
 233 00ec BD46     		mov	sp, r7
 234 00ee 80BC     		pop	{r7}
 235 00f0 7047     		bx	lr
 236              		.cfi_endproc
 237              	.LFE115:
 239 00f2 00BF     		.align	2
 240              		.global	PWR_EnterSleepMode
 241              		.thumb
 242              		.thumb_func
 244              	PWR_EnterSleepMode:
 245              	.LFB116:
 236:../src/stm32f30x_pwr.c **** 
 237:../src/stm32f30x_pwr.c **** /**
 238:../src/stm32f30x_pwr.c ****   * @}
 239:../src/stm32f30x_pwr.c ****   */
 240:../src/stm32f30x_pwr.c **** 
 241:../src/stm32f30x_pwr.c **** 
 242:../src/stm32f30x_pwr.c **** /** @defgroup PWR_Group4 Low Power modes configuration functions
 243:../src/stm32f30x_pwr.c ****  *  @brief   Low Power modes configuration functions 
 244:../src/stm32f30x_pwr.c ****  *
 245:../src/stm32f30x_pwr.c **** @verbatim   
 246:../src/stm32f30x_pwr.c ****  ===============================================================================
 247:../src/stm32f30x_pwr.c ****               ##### Low Power modes configuration functions #####
 248:../src/stm32f30x_pwr.c ****   ==============================================================================
 249:../src/stm32f30x_pwr.c **** 
 250:../src/stm32f30x_pwr.c ****     [..] The devices feature three low-power modes:
 251:../src/stm32f30x_pwr.c ****     (+) Sleep mode: Cortex-M4 core stopped, peripherals kept running.
 252:../src/stm32f30x_pwr.c ****     (+) Stop mode: all clocks are stopped, regulator running, regulator in low power mode
 253:../src/stm32f30x_pwr.c ****     (+) Standby mode: VCORE domain powered off
 254:../src/stm32f30x_pwr.c **** 
 255:../src/stm32f30x_pwr.c ****   *** Sleep mode *** 
 256:../src/stm32f30x_pwr.c ****   ==================
 257:../src/stm32f30x_pwr.c ****   [..] 
 258:../src/stm32f30x_pwr.c ****     (+) Entry:
 259:../src/stm32f30x_pwr.c ****         (++) The Sleep mode is entered by executing the WFE() or WFI() instructions.
 260:../src/stm32f30x_pwr.c ****     (+) Exit:
 261:../src/stm32f30x_pwr.c ****         (++) Any peripheral interrupt acknowledged by the nested vectored interrupt 
 262:../src/stm32f30x_pwr.c ****              controller (NVIC) can wake up the device from Sleep mode.
 263:../src/stm32f30x_pwr.c **** 
 264:../src/stm32f30x_pwr.c ****   *** Stop mode *** 
 265:../src/stm32f30x_pwr.c ****   =================
 266:../src/stm32f30x_pwr.c ****   [..] In Stop mode, all clocks in the VCORE domain are stopped, the PLL, the HSI,
 267:../src/stm32f30x_pwr.c ****        and the HSE RC oscillators are disabled. Internal SRAM and register 
 268:../src/stm32f30x_pwr.c ****        contents are preserved.
 269:../src/stm32f30x_pwr.c ****        The voltage regulator can be configured either in normal or low-power mode.
 270:../src/stm32f30x_pwr.c **** 
 271:../src/stm32f30x_pwr.c ****     (+) Entry:
 272:../src/stm32f30x_pwr.c ****         (++) The Stop mode is entered using the PWR_EnterSTOPMode(PWR_Regulator_LowPower,) 
 273:../src/stm32f30x_pwr.c ****              function with regulator in LowPower or with Regulator ON.
 274:../src/stm32f30x_pwr.c ****     (+) Exit:
 275:../src/stm32f30x_pwr.c ****         (++) Any EXTI Line (Internal or External) configured in Interrupt/Event mode
 276:../src/stm32f30x_pwr.c ****              or any internal IPs (I2C or UASRT) wakeup event.
 277:../src/stm32f30x_pwr.c **** 
 278:../src/stm32f30x_pwr.c ****   *** Standby mode *** 
 279:../src/stm32f30x_pwr.c ****   ====================
 280:../src/stm32f30x_pwr.c ****   [..] The Standby mode allows to achieve the lowest power consumption. It is based 
 281:../src/stm32f30x_pwr.c ****        on the Cortex-M4 deepsleep mode, with the voltage regulator disabled. 
 282:../src/stm32f30x_pwr.c ****        The VCORE domain is consequently powered off. The PLL, the HSI, and the HSE 
 283:../src/stm32f30x_pwr.c ****        oscillator are also switched off. SRAM and register 
 284:../src/stm32f30x_pwr.c ****        contents are lost except for the Backup domain (RTC registers, RTC backup 
 285:../src/stm32f30x_pwr.c ****        registers and Standby circuitry).
 286:../src/stm32f30x_pwr.c ****    
 287:../src/stm32f30x_pwr.c ****   [..] The voltage regulator is OFF.
 288:../src/stm32f30x_pwr.c **** 
 289:../src/stm32f30x_pwr.c ****     (+) Entry:
 290:../src/stm32f30x_pwr.c ****         (++) The Standby mode is entered using the PWR_EnterSTANDBYMode() function.
 291:../src/stm32f30x_pwr.c ****     (+) Exit:
 292:../src/stm32f30x_pwr.c ****         (++) WKUP pin rising edge, RTC alarm (Alarm A and Alarm B), RTC wakeup,
 293:../src/stm32f30x_pwr.c ****              tamper event, time-stamp event, external reset in NRST pin, IWDG reset.
 294:../src/stm32f30x_pwr.c **** 
 295:../src/stm32f30x_pwr.c ****   *** Auto-wakeup (AWU) from low-power mode *** 
 296:../src/stm32f30x_pwr.c ****   =============================================
 297:../src/stm32f30x_pwr.c ****   [..] The MCU can be woken up from low-power mode by an RTC Alarm event, a tamper 
 298:../src/stm32f30x_pwr.c ****        event, a time-stamp event, or a comparator event, without depending on an 
 299:../src/stm32f30x_pwr.c ****        external interrupt (Auto-wakeup mode).
 300:../src/stm32f30x_pwr.c **** 
 301:../src/stm32f30x_pwr.c ****     (+) RTC auto-wakeup (AWU) from the Stop mode
 302:../src/stm32f30x_pwr.c ****         (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to:
 303:../src/stm32f30x_pwr.c ****              (+++) Configure the EXTI Line 17 to be sensitive to rising edges (Interrupt 
 304:../src/stm32f30x_pwr.c ****                    or Event modes) using the EXTI_Init() function.
 305:../src/stm32f30x_pwr.c ****              (+++) Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
 306:../src/stm32f30x_pwr.c ****              (+++) Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
 307:../src/stm32f30x_pwr.c ****                    and RTC_AlarmCmd() functions.
 308:../src/stm32f30x_pwr.c ****         (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it 
 309:../src/stm32f30x_pwr.c ****              is necessary to:
 310:../src/stm32f30x_pwr.c ****              (+++) Configure the EXTI Line 19 to be sensitive to rising edges (Interrupt 
 311:../src/stm32f30x_pwr.c ****                    or Event modes) using the EXTI_Init() function.
 312:../src/stm32f30x_pwr.c ****              (+++) Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
 313:../src/stm32f30x_pwr.c ****                    function.
 314:../src/stm32f30x_pwr.c ****              (+++) Configure the RTC to detect the tamper or time stamp event using the
 315:../src/stm32f30x_pwr.c ****                    RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
 316:../src/stm32f30x_pwr.c ****                    functions.
 317:../src/stm32f30x_pwr.c **** 
 318:../src/stm32f30x_pwr.c ****     (+) RTC auto-wakeup (AWU) from the Standby mode
 319:../src/stm32f30x_pwr.c ****         (++) To wake up from the Standby mode with an RTC alarm event, it is necessary to:
 320:../src/stm32f30x_pwr.c ****              (+++) Enable the RTC Alarm Interrupt using the RTC_ITConfig() function.
 321:../src/stm32f30x_pwr.c ****              (+++) Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
 322:../src/stm32f30x_pwr.c ****                    and RTC_AlarmCmd() functions.
 323:../src/stm32f30x_pwr.c ****         (++) To wake up from the Standby mode with an RTC Tamper or time stamp event, it 
 324:../src/stm32f30x_pwr.c ****              is necessary to:
 325:../src/stm32f30x_pwr.c ****              (+++) Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
 326:../src/stm32f30x_pwr.c ****                    function.
 327:../src/stm32f30x_pwr.c ****              (+++) Configure the RTC to detect the tamper or time stamp event using the
 328:../src/stm32f30x_pwr.c ****                    RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
 329:../src/stm32f30x_pwr.c ****                    functions.
 330:../src/stm32f30x_pwr.c **** 
 331:../src/stm32f30x_pwr.c ****     (+) Comparator auto-wakeup (AWU) from the Stop mode
 332:../src/stm32f30x_pwr.c ****         (++) To wake up from the Stop mode with a comparator wakeup event, it is necessary to:
 333:../src/stm32f30x_pwr.c ****              (+++) Configure the correspondant comparator EXTI Line to be sensitive to 
 334:../src/stm32f30x_pwr.c ****                    the selected edges (falling, rising or falling and rising) 
 335:../src/stm32f30x_pwr.c ****                    (Interrupt or Event modes) using the EXTI_Init() function.
 336:../src/stm32f30x_pwr.c ****              (+++) Configure the comparator to generate the event.
 337:../src/stm32f30x_pwr.c **** 
 338:../src/stm32f30x_pwr.c **** @endverbatim
 339:../src/stm32f30x_pwr.c ****   * @{
 340:../src/stm32f30x_pwr.c ****   */
 341:../src/stm32f30x_pwr.c **** 
 342:../src/stm32f30x_pwr.c **** /**
 343:../src/stm32f30x_pwr.c ****   * @brief  Enters Sleep mode.
 344:../src/stm32f30x_pwr.c ****   * @note   In Sleep mode, all I/O pins keep the same state as in Run mode.                 
 345:../src/stm32f30x_pwr.c ****   * @param  PWR_SLEEPEntry: specifies if SLEEP mode in entered with WFI or WFE instruction.
 346:../src/stm32f30x_pwr.c ****   *         This parameter can be one of the following values:
 347:../src/stm32f30x_pwr.c ****   *             @arg PWR_SLEEPEntry_WFI: enter SLEEP mode with WFI instruction
 348:../src/stm32f30x_pwr.c ****   *             @arg PWR_SLEEPEntry_WFE: enter SLEEP mode with WFE instruction
 349:../src/stm32f30x_pwr.c ****   * @retval None
 350:../src/stm32f30x_pwr.c ****   */
 351:../src/stm32f30x_pwr.c **** void PWR_EnterSleepMode(uint8_t PWR_SLEEPEntry)
 352:../src/stm32f30x_pwr.c **** {
 246              		.loc 1 352 0
 247              		.cfi_startproc
 248              		@ args = 0, pretend = 0, frame = 8
 249              		@ frame_needed = 1, uses_anonymous_args = 0
 250              		@ link register save eliminated.
 251 00f4 80B4     		push	{r7}
 252              	.LCFI14:
 253              		.cfi_def_cfa_offset 4
 254              		.cfi_offset 7, -4
 255 00f6 83B0     		sub	sp, sp, #12
 256              	.LCFI15:
 257              		.cfi_def_cfa_offset 16
 258 00f8 00AF     		add	r7, sp, #0
 259              	.LCFI16:
 260              		.cfi_def_cfa_register 7
 261 00fa 0346     		mov	r3, r0
 262 00fc FB71     		strb	r3, [r7, #7]
 353:../src/stm32f30x_pwr.c ****   /* Check the parameters */
 354:../src/stm32f30x_pwr.c ****   assert_param(IS_PWR_SLEEP_ENTRY(PWR_SLEEPEntry));
 355:../src/stm32f30x_pwr.c ****   
 356:../src/stm32f30x_pwr.c ****   /* Clear SLEEPDEEP bit of Cortex System Control Register */
 357:../src/stm32f30x_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
 263              		.loc 1 357 0
 264 00fe 4FF46D43 		mov	r3, #60672
 265 0102 CEF20003 		movt	r3, 57344
 266 0106 4FF46D42 		mov	r2, #60672
 267 010a CEF20002 		movt	r2, 57344
 268 010e 1269     		ldr	r2, [r2, #16]
 269 0110 22F00402 		bic	r2, r2, #4
 270 0114 1A61     		str	r2, [r3, #16]
 358:../src/stm32f30x_pwr.c ****   
 359:../src/stm32f30x_pwr.c ****   /* Select SLEEP mode entry -------------------------------------------------*/
 360:../src/stm32f30x_pwr.c ****   if(PWR_SLEEPEntry == PWR_SLEEPEntry_WFI)
 271              		.loc 1 360 0
 272 0116 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 273 0118 012B     		cmp	r3, #1
 274 011a 01D1     		bne	.L9
 275              	.LBB12:
 276              	.LBB13:
 277              		.file 2 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h"
   1:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /**************************************************************************//**
   2:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * @file     core_cmInstr.h
   3:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * @brief    CMSIS Cortex-M Core Instruction Access Header File
   4:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * @version  V3.00
   5:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * @date     07. February 2012
   6:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  *
   7:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * @note
   8:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
   9:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  *
  10:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * @par
  11:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * ARM Limited (ARM) is supplying this software for use with Cortex-M
  12:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * processor based microcontrollers.  This file can be freely distributed
  13:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * within development tools that are supporting such ARM based processors.
  14:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  *
  15:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * @par
  16:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
  17:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
  18:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
  19:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
  20:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
  21:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  *
  22:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  ******************************************************************************/
  23:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  24:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #ifndef __CORE_CMINSTR_H
  25:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __CORE_CMINSTR_H
  26:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  27:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  28:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /* ##########################  Core Instruction Access  ######################### */
  29:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
  30:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****   Access to dedicated instructions
  31:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****   @{
  32:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** */
  33:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  34:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
  35:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /* ARM armcc specific functions */
  36:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  37:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #if (__ARMCC_VERSION < 400677)
  38:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****   #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
  39:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #endif
  40:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  41:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  42:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  No Operation
  43:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  44:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
  45:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
  46:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __NOP                             __nop
  47:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  48:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  49:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Wait For Interrupt
  50:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  51:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
  52:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     until one of a number of events occurs.
  53:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
  54:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __WFI                             __wfi
  55:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  56:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  57:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Wait For Event
  58:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  59:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
  60:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
  61:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
  62:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __WFE                             __wfe
  63:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  64:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  65:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Send Event
  66:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  67:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     Send Event is a hint instruction. It causes an event to be signaled to the CPU.
  68:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
  69:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __SEV                             __sev
  70:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  71:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  72:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Instruction Synchronization Barrier
  73:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  74:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     Instruction Synchronization Barrier flushes the pipeline in the processor,
  75:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     so that all instructions following the ISB are fetched from cache or
  76:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     memory, after the instruction has been completed.
  77:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
  78:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __ISB()                           __isb(0xF)
  79:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  80:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  81:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Data Synchronization Barrier
  82:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  83:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function acts as a special kind of Data Memory Barrier.
  84:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     It completes when all explicit memory accesses before this instruction complete.
  85:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
  86:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __DSB()                           __dsb(0xF)
  87:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  88:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  89:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Data Memory Barrier
  90:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  91:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function ensures the apparent order of the explicit memory operations before
  92:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     and after the instruction, without ensuring their completion.
  93:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
  94:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __DMB()                           __dmb(0xF)
  95:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  96:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  97:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Reverse byte order (32 bit)
  98:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
  99:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function reverses the byte order in integer value.
 100:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 101:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]    value  Value to reverse
 102:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return               Reversed value
 103:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 104:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __REV                             __rev
 105:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 106:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 107:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Reverse byte order (16 bit)
 108:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 109:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function reverses the byte order in two unsigned short values.
 110:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 111:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]    value  Value to reverse
 112:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return               Reversed value
 113:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 114:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** __attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
 115:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** {
 116:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****   rev16 r0, r0
 117:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****   bx lr
 118:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** }
 119:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 120:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 121:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Reverse byte order in signed short value
 122:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 123:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function reverses the byte order in a signed short value with sign extension to integer.
 124:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 125:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]    value  Value to reverse
 126:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return               Reversed value
 127:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 128:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** __attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
 129:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** {
 130:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****   revsh r0, r0
 131:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****   bx lr
 132:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** }
 133:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 134:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 135:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Rotate Right in unsigned value (32 bit)
 136:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 137:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function Rotate Right (immediate) provides the value of the contents of a register rotated
 138:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 139:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]    value  Value to rotate
 140:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]    value  Number of Bits to rotate
 141:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return               Rotated value
 142:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 143:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __ROR                             __ror
 144:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 145:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 146:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #if       (__CORTEX_M >= 0x03)
 147:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 148:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Reverse bit order of value
 149:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 150:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function reverses the bit order of the given value.
 151:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 152:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]    value  Value to reverse
 153:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return               Reversed value
 154:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 155:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __RBIT                            __rbit
 156:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 157:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 158:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  LDR Exclusive (8 bit)
 159:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 160:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function performs a exclusive LDR command for 8 bit value.
 161:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 162:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 163:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return             value of type uint8_t at (*ptr)
 164:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 165:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
 166:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 167:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 168:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  LDR Exclusive (16 bit)
 169:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 170:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function performs a exclusive LDR command for 16 bit values.
 171:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 172:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 173:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return        value of type uint16_t at (*ptr)
 174:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 175:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
 176:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 177:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 178:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  LDR Exclusive (32 bit)
 179:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 180:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function performs a exclusive LDR command for 32 bit values.
 181:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 182:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 183:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return        value of type uint32_t at (*ptr)
 184:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 185:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
 186:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 187:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 188:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  STR Exclusive (8 bit)
 189:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 190:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function performs a exclusive STR command for 8 bit values.
 191:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 192:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]  value  Value to store
 193:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 194:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return          0  Function succeeded
 195:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return          1  Function failed
 196:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 197:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __STREXB(value, ptr)              __strex(value, ptr)
 198:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 199:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 200:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  STR Exclusive (16 bit)
 201:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 202:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function performs a exclusive STR command for 16 bit values.
 203:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 204:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]  value  Value to store
 205:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 206:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return          0  Function succeeded
 207:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return          1  Function failed
 208:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 209:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __STREXH(value, ptr)              __strex(value, ptr)
 210:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 211:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 212:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  STR Exclusive (32 bit)
 213:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 214:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function performs a exclusive STR command for 32 bit values.
 215:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 216:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]  value  Value to store
 217:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 218:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return          0  Function succeeded
 219:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return          1  Function failed
 220:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 221:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __STREXW(value, ptr)              __strex(value, ptr)
 222:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 223:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 224:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Remove the exclusive lock
 225:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 226:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function removes the exclusive lock which is created by LDREX.
 227:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 228:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 229:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __CLREX                           __clrex
 230:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 231:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 232:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Signed Saturate
 233:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 234:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function saturates a signed value.
 235:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 236:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 237:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (1..32)
 238:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return             Saturated value
 239:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 240:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __SSAT                            __ssat
 241:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 242:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 243:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Unsigned Saturate
 244:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 245:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function saturates an unsigned value.
 246:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 247:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 248:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (0..31)
 249:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return             Saturated value
 250:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 251:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __USAT                            __usat
 252:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 253:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 254:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Count leading zeros
 255:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 256:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     This function counts the number of leading zeros of a data value.
 257:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 258:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \param [in]  value  Value to count the leading zeros
 259:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     \return             number of leading zeros in value
 260:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 261:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #define __CLZ                             __clz
 262:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 263:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #endif /* (__CORTEX_M >= 0x03) */
 264:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 265:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 266:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 267:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
 268:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /* IAR iccarm specific functions */
 269:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 270:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #include <cmsis_iar.h>
 271:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 272:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 273:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
 274:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /* TI CCS specific functions */
 275:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 276:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #include <cmsis_ccs.h>
 277:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 278:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 279:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** #elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
 280:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /* GNU gcc specific functions */
 281:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 282:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  No Operation
 283:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 284:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
 285:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 286:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
 287:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** {
 288:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****   __ASM volatile ("nop");
 289:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** }
 290:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 291:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 292:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Wait For Interrupt
 293:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 294:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
 295:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     until one of a number of events occurs.
 296:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 297:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
 298:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** {
 299:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****   __ASM volatile ("wfi");
 278              		.loc 2 299 0
 279              	@ 299 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h" 1
 280 011c 30BF     		wfi
 281              	@ 0 "" 2
 282              		.thumb
 283 011e 00E0     		b	.L8
 284              	.L9:
 285              	.LBE13:
 286              	.LBE12:
 287              	.LBB14:
 288              	.LBB15:
 300:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** }
 301:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 302:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 303:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** /** \brief  Wait For Event
 304:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** 
 305:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
 306:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
 307:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****  */
 308:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
 309:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h **** {
 310:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****   __ASM volatile ("wfe");
 289              		.loc 2 310 0
 290              	@ 310 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h" 1
 291 0120 20BF     		wfe
 292              	@ 0 "" 2
 293              		.thumb
 294              	.L8:
 295              	.LBE15:
 296              	.LBE14:
 361:../src/stm32f30x_pwr.c ****   {   
 362:../src/stm32f30x_pwr.c ****     /* Request Wait For Interrupt */
 363:../src/stm32f30x_pwr.c ****     __WFI();
 364:../src/stm32f30x_pwr.c ****   }
 365:../src/stm32f30x_pwr.c ****   else
 366:../src/stm32f30x_pwr.c ****   {
 367:../src/stm32f30x_pwr.c ****     /* Request Wait For Event */
 368:../src/stm32f30x_pwr.c ****     __WFE();
 369:../src/stm32f30x_pwr.c ****   }
 370:../src/stm32f30x_pwr.c **** }
 297              		.loc 1 370 0
 298 0122 07F10C07 		add	r7, r7, #12
 299 0126 BD46     		mov	sp, r7
 300 0128 80BC     		pop	{r7}
 301 012a 7047     		bx	lr
 302              		.cfi_endproc
 303              	.LFE116:
 305              		.align	2
 306              		.global	PWR_EnterSTOPMode
 307              		.thumb
 308              		.thumb_func
 310              	PWR_EnterSTOPMode:
 311              	.LFB117:
 371:../src/stm32f30x_pwr.c **** 
 372:../src/stm32f30x_pwr.c **** /**
 373:../src/stm32f30x_pwr.c ****   * @brief  Enters STOP mode.
 374:../src/stm32f30x_pwr.c ****   * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
 375:../src/stm32f30x_pwr.c ****   * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
 376:../src/stm32f30x_pwr.c ****   *         the HSI RC oscillator is selected as system clock.
 377:../src/stm32f30x_pwr.c ****   * @note   When the voltage regulator operates in low power mode, an additional 
 378:../src/stm32f30x_pwr.c ****   *         startup delay is incurred when waking up from Stop mode. 
 379:../src/stm32f30x_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption 
 380:../src/stm32f30x_pwr.c ****   *         is higher although the startup time is reduced.
 381:../src/stm32f30x_pwr.c ****   * @param  PWR_Regulator: specifies the regulator state in STOP mode.
 382:../src/stm32f30x_pwr.c ****   *         This parameter can be one of the following values:
 383:../src/stm32f30x_pwr.c ****   *             @arg PWR_Regulator_ON: STOP mode with regulator ON
 384:../src/stm32f30x_pwr.c ****   *             @arg PWR_Regulator_LowPower: STOP mode with regulator in low power mode
 385:../src/stm32f30x_pwr.c ****   * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
 386:../src/stm32f30x_pwr.c ****   *         This parameter can be one of the following values:
 387:../src/stm32f30x_pwr.c ****   *             @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
 388:../src/stm32f30x_pwr.c ****   *             @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
 389:../src/stm32f30x_pwr.c ****   * @retval None
 390:../src/stm32f30x_pwr.c ****   */
 391:../src/stm32f30x_pwr.c **** void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
 392:../src/stm32f30x_pwr.c **** {
 312              		.loc 1 392 0
 313              		.cfi_startproc
 314              		@ args = 0, pretend = 0, frame = 16
 315              		@ frame_needed = 1, uses_anonymous_args = 0
 316              		@ link register save eliminated.
 317 012c 80B4     		push	{r7}
 318              	.LCFI17:
 319              		.cfi_def_cfa_offset 4
 320              		.cfi_offset 7, -4
 321 012e 85B0     		sub	sp, sp, #20
 322              	.LCFI18:
 323              		.cfi_def_cfa_offset 24
 324 0130 00AF     		add	r7, sp, #0
 325              	.LCFI19:
 326              		.cfi_def_cfa_register 7
 327 0132 7860     		str	r0, [r7, #4]
 328 0134 0B46     		mov	r3, r1
 329 0136 FB70     		strb	r3, [r7, #3]
 393:../src/stm32f30x_pwr.c ****   uint32_t tmpreg = 0;
 330              		.loc 1 393 0
 331 0138 4FF00003 		mov	r3, #0
 332 013c FB60     		str	r3, [r7, #12]
 394:../src/stm32f30x_pwr.c ****   
 395:../src/stm32f30x_pwr.c ****   /* Check the parameters */
 396:../src/stm32f30x_pwr.c ****   assert_param(IS_PWR_REGULATOR(PWR_Regulator));
 397:../src/stm32f30x_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
 398:../src/stm32f30x_pwr.c ****   
 399:../src/stm32f30x_pwr.c ****   /* Select the regulator state in STOP mode ---------------------------------*/
 400:../src/stm32f30x_pwr.c ****   tmpreg = PWR->CR;
 333              		.loc 1 400 0
 334 013e 4FF4E043 		mov	r3, #28672
 335 0142 C4F20003 		movt	r3, 16384
 336 0146 1B68     		ldr	r3, [r3, #0]
 337 0148 FB60     		str	r3, [r7, #12]
 401:../src/stm32f30x_pwr.c ****   /* Clear PDDS and LPDSR bits */
 402:../src/stm32f30x_pwr.c ****   tmpreg &= CR_DS_MASK;
 338              		.loc 1 402 0
 339 014a FB68     		ldr	r3, [r7, #12]
 340 014c 23F00303 		bic	r3, r3, #3
 341 0150 FB60     		str	r3, [r7, #12]
 403:../src/stm32f30x_pwr.c ****   
 404:../src/stm32f30x_pwr.c ****   /* Set LPDSR bit according to PWR_Regulator value */
 405:../src/stm32f30x_pwr.c ****   tmpreg |= PWR_Regulator;
 342              		.loc 1 405 0
 343 0152 FA68     		ldr	r2, [r7, #12]
 344 0154 7B68     		ldr	r3, [r7, #4]
 345 0156 1343     		orrs	r3, r3, r2
 346 0158 FB60     		str	r3, [r7, #12]
 406:../src/stm32f30x_pwr.c ****   
 407:../src/stm32f30x_pwr.c ****   /* Store the new value */
 408:../src/stm32f30x_pwr.c ****   PWR->CR = tmpreg;
 347              		.loc 1 408 0
 348 015a 4FF4E043 		mov	r3, #28672
 349 015e C4F20003 		movt	r3, 16384
 350 0162 FA68     		ldr	r2, [r7, #12]
 351 0164 1A60     		str	r2, [r3, #0]
 409:../src/stm32f30x_pwr.c ****   
 410:../src/stm32f30x_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 411:../src/stm32f30x_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 352              		.loc 1 411 0
 353 0166 4FF46D43 		mov	r3, #60672
 354 016a CEF20003 		movt	r3, 57344
 355 016e 4FF46D42 		mov	r2, #60672
 356 0172 CEF20002 		movt	r2, 57344
 357 0176 1269     		ldr	r2, [r2, #16]
 358 0178 42F00402 		orr	r2, r2, #4
 359 017c 1A61     		str	r2, [r3, #16]
 412:../src/stm32f30x_pwr.c ****   
 413:../src/stm32f30x_pwr.c ****   /* Select STOP mode entry --------------------------------------------------*/
 414:../src/stm32f30x_pwr.c ****   if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 360              		.loc 1 414 0
 361 017e FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 362 0180 012B     		cmp	r3, #1
 363 0182 01D1     		bne	.L12
 364              	.LBB16:
 365              	.LBB17:
 299:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****   __ASM volatile ("wfi");
 366              		.loc 2 299 0
 367              	@ 299 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h" 1
 368 0184 30BF     		wfi
 369              	@ 0 "" 2
 370              		.thumb
 371 0186 00E0     		b	.L13
 372              	.L12:
 373              	.LBE17:
 374              	.LBE16:
 375              	.LBB18:
 376              	.LBB19:
 377              		.loc 2 310 0
 378              	@ 310 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h" 1
 379 0188 20BF     		wfe
 380              	@ 0 "" 2
 381              		.thumb
 382              	.L13:
 383              	.LBE19:
 384              	.LBE18:
 415:../src/stm32f30x_pwr.c ****   {   
 416:../src/stm32f30x_pwr.c ****     /* Request Wait For Interrupt */
 417:../src/stm32f30x_pwr.c ****     __WFI();
 418:../src/stm32f30x_pwr.c ****   }
 419:../src/stm32f30x_pwr.c ****   else
 420:../src/stm32f30x_pwr.c ****   {
 421:../src/stm32f30x_pwr.c ****     /* Request Wait For Event */
 422:../src/stm32f30x_pwr.c ****     __WFE();
 423:../src/stm32f30x_pwr.c ****   }
 424:../src/stm32f30x_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 425:../src/stm32f30x_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
 385              		.loc 1 425 0
 386 018a 4FF46D43 		mov	r3, #60672
 387 018e CEF20003 		movt	r3, 57344
 388 0192 4FF46D42 		mov	r2, #60672
 389 0196 CEF20002 		movt	r2, 57344
 390 019a 1269     		ldr	r2, [r2, #16]
 391 019c 22F00402 		bic	r2, r2, #4
 392 01a0 1A61     		str	r2, [r3, #16]
 426:../src/stm32f30x_pwr.c **** }
 393              		.loc 1 426 0
 394 01a2 07F11407 		add	r7, r7, #20
 395 01a6 BD46     		mov	sp, r7
 396 01a8 80BC     		pop	{r7}
 397 01aa 7047     		bx	lr
 398              		.cfi_endproc
 399              	.LFE117:
 401              		.align	2
 402              		.global	PWR_EnterSTANDBYMode
 403              		.thumb
 404              		.thumb_func
 406              	PWR_EnterSTANDBYMode:
 407              	.LFB118:
 427:../src/stm32f30x_pwr.c **** 
 428:../src/stm32f30x_pwr.c **** /**
 429:../src/stm32f30x_pwr.c ****   * @brief  Enters STANDBY mode.
 430:../src/stm32f30x_pwr.c ****   * @note   In Standby mode, all I/O pins are high impedance except for:
 431:../src/stm32f30x_pwr.c ****   * @note     Reset pad (still available) 
 432:../src/stm32f30x_pwr.c ****   * @note     RTC_AF1 pin (PC13) if configured for Wakeup pin 2 (WKUP2), tamper, 
 433:../src/stm32f30x_pwr.c ****   *           time-stamp, RTC Alarm out, or RTC clock calibration out.
 434:../src/stm32f30x_pwr.c ****   * @note     WKUP pin 1 (PA0) and WKUP pin 3 (PE6), if enabled.       
 435:../src/stm32f30x_pwr.c ****   * @param  None
 436:../src/stm32f30x_pwr.c ****   * @retval None
 437:../src/stm32f30x_pwr.c ****   */
 438:../src/stm32f30x_pwr.c **** void PWR_EnterSTANDBYMode(void)
 439:../src/stm32f30x_pwr.c **** {
 408              		.loc 1 439 0
 409              		.cfi_startproc
 410              		@ args = 0, pretend = 0, frame = 0
 411              		@ frame_needed = 1, uses_anonymous_args = 0
 412              		@ link register save eliminated.
 413 01ac 80B4     		push	{r7}
 414              	.LCFI20:
 415              		.cfi_def_cfa_offset 4
 416              		.cfi_offset 7, -4
 417 01ae 00AF     		add	r7, sp, #0
 418              	.LCFI21:
 419              		.cfi_def_cfa_register 7
 440:../src/stm32f30x_pwr.c ****   /* Clear Wakeup flag */
 441:../src/stm32f30x_pwr.c ****   PWR->CR |= PWR_CR_CWUF;
 420              		.loc 1 441 0
 421 01b0 4FF4E043 		mov	r3, #28672
 422 01b4 C4F20003 		movt	r3, 16384
 423 01b8 4FF4E042 		mov	r2, #28672
 424 01bc C4F20002 		movt	r2, 16384
 425 01c0 1268     		ldr	r2, [r2, #0]
 426 01c2 42F00402 		orr	r2, r2, #4
 427 01c6 1A60     		str	r2, [r3, #0]
 442:../src/stm32f30x_pwr.c ****   
 443:../src/stm32f30x_pwr.c ****   /* Select STANDBY mode */
 444:../src/stm32f30x_pwr.c ****   PWR->CR |= PWR_CR_PDDS;
 428              		.loc 1 444 0
 429 01c8 4FF4E043 		mov	r3, #28672
 430 01cc C4F20003 		movt	r3, 16384
 431 01d0 4FF4E042 		mov	r2, #28672
 432 01d4 C4F20002 		movt	r2, 16384
 433 01d8 1268     		ldr	r2, [r2, #0]
 434 01da 42F00202 		orr	r2, r2, #2
 435 01de 1A60     		str	r2, [r3, #0]
 445:../src/stm32f30x_pwr.c ****   
 446:../src/stm32f30x_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 447:../src/stm32f30x_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 436              		.loc 1 447 0
 437 01e0 4FF46D43 		mov	r3, #60672
 438 01e4 CEF20003 		movt	r3, 57344
 439 01e8 4FF46D42 		mov	r2, #60672
 440 01ec CEF20002 		movt	r2, 57344
 441 01f0 1269     		ldr	r2, [r2, #16]
 442 01f2 42F00402 		orr	r2, r2, #4
 443 01f6 1A61     		str	r2, [r3, #16]
 444              	.LBB20:
 445              	.LBB21:
 299:/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h ****   __ASM volatile ("wfi");
 446              		.loc 2 299 0
 447              	@ 299 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cmInstr.h" 1
 448 01f8 30BF     		wfi
 449              	@ 0 "" 2
 450              		.thumb
 451              	.LBE21:
 452              	.LBE20:
 448:../src/stm32f30x_pwr.c ****   
 449:../src/stm32f30x_pwr.c **** /* This option is used to ensure that store operations are completed */
 450:../src/stm32f30x_pwr.c **** #if defined ( __CC_ARM   )
 451:../src/stm32f30x_pwr.c ****   __force_stores();
 452:../src/stm32f30x_pwr.c **** #endif
 453:../src/stm32f30x_pwr.c ****   /* Request Wait For Interrupt */
 454:../src/stm32f30x_pwr.c ****   __WFI();
 455:../src/stm32f30x_pwr.c **** }
 453              		.loc 1 455 0
 454 01fa BD46     		mov	sp, r7
 455 01fc 80BC     		pop	{r7}
 456 01fe 7047     		bx	lr
 457              		.cfi_endproc
 458              	.LFE118:
 460              		.align	2
 461              		.global	PWR_GetFlagStatus
 462              		.thumb
 463              		.thumb_func
 465              	PWR_GetFlagStatus:
 466              	.LFB119:
 456:../src/stm32f30x_pwr.c **** 
 457:../src/stm32f30x_pwr.c **** /**
 458:../src/stm32f30x_pwr.c ****   * @}
 459:../src/stm32f30x_pwr.c ****   */
 460:../src/stm32f30x_pwr.c **** 
 461:../src/stm32f30x_pwr.c **** /** @defgroup PWR_Group5 Flags management functions
 462:../src/stm32f30x_pwr.c ****  *  @brief   Flags management functions 
 463:../src/stm32f30x_pwr.c ****  *
 464:../src/stm32f30x_pwr.c **** @verbatim   
 465:../src/stm32f30x_pwr.c ****  ===============================================================================
 466:../src/stm32f30x_pwr.c ****                     ##### Flags management functions #####
 467:../src/stm32f30x_pwr.c ****  ===============================================================================  
 468:../src/stm32f30x_pwr.c **** 
 469:../src/stm32f30x_pwr.c **** @endverbatim
 470:../src/stm32f30x_pwr.c ****   * @{
 471:../src/stm32f30x_pwr.c ****   */
 472:../src/stm32f30x_pwr.c **** 
 473:../src/stm32f30x_pwr.c **** /**
 474:../src/stm32f30x_pwr.c ****   * @brief  Checks whether the specified PWR flag is set or not.
 475:../src/stm32f30x_pwr.c ****   * @param  PWR_FLAG: specifies the flag to check.
 476:../src/stm32f30x_pwr.c ****   *   This parameter can be one of the following values:
 477:../src/stm32f30x_pwr.c ****   *     @arg PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event 
 478:../src/stm32f30x_pwr.c ****   *       was received from the WKUP pin or from the RTC alarm (Alarm A or Alarm B), 
 479:../src/stm32f30x_pwr.c ****   *       RTC Tamper event, RTC TimeStamp event or RTC Wakeup.
 480:../src/stm32f30x_pwr.c ****   *     @arg PWR_FLAG_SB: StandBy flag. This flag indicates that the system was
 481:../src/stm32f30x_pwr.c ****   *                       resumed from StandBy mode.    
 482:../src/stm32f30x_pwr.c ****   *     @arg PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled 
 483:../src/stm32f30x_pwr.c ****   *       by the PWR_PVDCmd() function.
 484:../src/stm32f30x_pwr.c ****   *     @arg PWR_FLAG_VREFINTRDY: Internal Voltage Reference Ready flag. This 
 485:../src/stm32f30x_pwr.c ****   *       flag indicates the state of the internal voltage reference, VREFINT.
 486:../src/stm32f30x_pwr.c ****   * @retval The new state of PWR_FLAG (SET or RESET).
 487:../src/stm32f30x_pwr.c ****   */
 488:../src/stm32f30x_pwr.c **** FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
 489:../src/stm32f30x_pwr.c **** {
 467              		.loc 1 489 0
 468              		.cfi_startproc
 469              		@ args = 0, pretend = 0, frame = 16
 470              		@ frame_needed = 1, uses_anonymous_args = 0
 471              		@ link register save eliminated.
 472 0200 80B4     		push	{r7}
 473              	.LCFI22:
 474              		.cfi_def_cfa_offset 4
 475              		.cfi_offset 7, -4
 476 0202 85B0     		sub	sp, sp, #20
 477              	.LCFI23:
 478              		.cfi_def_cfa_offset 24
 479 0204 00AF     		add	r7, sp, #0
 480              	.LCFI24:
 481              		.cfi_def_cfa_register 7
 482 0206 7860     		str	r0, [r7, #4]
 490:../src/stm32f30x_pwr.c ****   FlagStatus bitstatus = RESET;
 483              		.loc 1 490 0
 484 0208 4FF00003 		mov	r3, #0
 485 020c FB73     		strb	r3, [r7, #15]
 491:../src/stm32f30x_pwr.c ****   /* Check the parameters */
 492:../src/stm32f30x_pwr.c ****   assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
 493:../src/stm32f30x_pwr.c ****   
 494:../src/stm32f30x_pwr.c ****   if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 486              		.loc 1 494 0
 487 020e 4FF4E043 		mov	r3, #28672
 488 0212 C4F20003 		movt	r3, 16384
 489 0216 5A68     		ldr	r2, [r3, #4]
 490 0218 7B68     		ldr	r3, [r7, #4]
 491 021a 1340     		ands	r3, r3, r2
 492 021c 002B     		cmp	r3, #0
 493 021e 03D0     		beq	.L16
 495:../src/stm32f30x_pwr.c ****   {
 496:../src/stm32f30x_pwr.c ****     bitstatus = SET;
 494              		.loc 1 496 0
 495 0220 4FF00103 		mov	r3, #1
 496 0224 FB73     		strb	r3, [r7, #15]
 497 0226 02E0     		b	.L17
 498              	.L16:
 497:../src/stm32f30x_pwr.c ****   }
 498:../src/stm32f30x_pwr.c ****   else
 499:../src/stm32f30x_pwr.c ****   {
 500:../src/stm32f30x_pwr.c ****     bitstatus = RESET;
 499              		.loc 1 500 0
 500 0228 4FF00003 		mov	r3, #0
 501 022c FB73     		strb	r3, [r7, #15]
 502              	.L17:
 501:../src/stm32f30x_pwr.c ****   }
 502:../src/stm32f30x_pwr.c ****   /* Return the flag status */
 503:../src/stm32f30x_pwr.c ****   return bitstatus;
 503              		.loc 1 503 0
 504 022e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 504:../src/stm32f30x_pwr.c **** }
 505              		.loc 1 504 0
 506 0230 1846     		mov	r0, r3
 507 0232 07F11407 		add	r7, r7, #20
 508 0236 BD46     		mov	sp, r7
 509 0238 80BC     		pop	{r7}
 510 023a 7047     		bx	lr
 511              		.cfi_endproc
 512              	.LFE119:
 514              		.align	2
 515              		.global	PWR_ClearFlag
 516              		.thumb
 517              		.thumb_func
 519              	PWR_ClearFlag:
 520              	.LFB120:
 505:../src/stm32f30x_pwr.c **** 
 506:../src/stm32f30x_pwr.c **** /**
 507:../src/stm32f30x_pwr.c ****   * @brief  Clears the PWR's pending flags.
 508:../src/stm32f30x_pwr.c ****   * @param  PWR_FLAG: specifies the flag to clear.
 509:../src/stm32f30x_pwr.c ****   *   This parameter can be one of the following values:
 510:../src/stm32f30x_pwr.c ****   *     @arg PWR_FLAG_WU: Wake Up flag
 511:../src/stm32f30x_pwr.c ****   *     @arg PWR_FLAG_SB: StandBy flag
 512:../src/stm32f30x_pwr.c ****   * @retval None
 513:../src/stm32f30x_pwr.c ****   */
 514:../src/stm32f30x_pwr.c **** void PWR_ClearFlag(uint32_t PWR_FLAG)
 515:../src/stm32f30x_pwr.c **** {
 521              		.loc 1 515 0
 522              		.cfi_startproc
 523              		@ args = 0, pretend = 0, frame = 8
 524              		@ frame_needed = 1, uses_anonymous_args = 0
 525              		@ link register save eliminated.
 526 023c 80B4     		push	{r7}
 527              	.LCFI25:
 528              		.cfi_def_cfa_offset 4
 529              		.cfi_offset 7, -4
 530 023e 83B0     		sub	sp, sp, #12
 531              	.LCFI26:
 532              		.cfi_def_cfa_offset 16
 533 0240 00AF     		add	r7, sp, #0
 534              	.LCFI27:
 535              		.cfi_def_cfa_register 7
 536 0242 7860     		str	r0, [r7, #4]
 516:../src/stm32f30x_pwr.c ****   /* Check the parameters */
 517:../src/stm32f30x_pwr.c ****   assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
 518:../src/stm32f30x_pwr.c ****          
 519:../src/stm32f30x_pwr.c ****   PWR->CR |=  PWR_FLAG << 2;
 537              		.loc 1 519 0
 538 0244 4FF4E043 		mov	r3, #28672
 539 0248 C4F20003 		movt	r3, 16384
 540 024c 4FF4E042 		mov	r2, #28672
 541 0250 C4F20002 		movt	r2, 16384
 542 0254 1168     		ldr	r1, [r2, #0]
 543 0256 7A68     		ldr	r2, [r7, #4]
 544 0258 4FEA8202 		lsl	r2, r2, #2
 545 025c 0A43     		orrs	r2, r2, r1
 546 025e 1A60     		str	r2, [r3, #0]
 520:../src/stm32f30x_pwr.c **** }
 547              		.loc 1 520 0
 548 0260 07F10C07 		add	r7, r7, #12
 549 0264 BD46     		mov	sp, r7
 550 0266 80BC     		pop	{r7}
 551 0268 7047     		bx	lr
 552              		.cfi_endproc
 553              	.LFE120:
 555              	.Letext0:
 556              		.file 3 "/home/aghosh01/gcc-arm-none-eabi-4_7-2012q4/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../.
 557              		.file 4 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cm4.h"
 558              		.file 5 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f30x_pwr.c
     /tmp/cctugU3C.s:20     .text:00000000 $t
     /tmp/cctugU3C.s:25     .text:00000000 PWR_DeInit
     /tmp/cctugU3C.s:58     .text:00000020 PWR_BackupAccessCmd
     /tmp/cctugU3C.s:95     .text:00000040 PWR_PVDLevelConfig
     /tmp/cctugU3C.s:148    .text:00000080 PWR_PVDCmd
     /tmp/cctugU3C.s:185    .text:000000a0 PWR_WakeUpPinCmd
     /tmp/cctugU3C.s:244    .text:000000f4 PWR_EnterSleepMode
     /tmp/cctugU3C.s:310    .text:0000012c PWR_EnterSTOPMode
     /tmp/cctugU3C.s:406    .text:000001ac PWR_EnterSTANDBYMode
     /tmp/cctugU3C.s:465    .text:00000200 PWR_GetFlagStatus
     /tmp/cctugU3C.s:519    .text:0000023c PWR_ClearFlag
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.743cd71370ebc432b539c5dba7924ecc
                           .group:00000000 wm4.stm32f30x.h.56.6f19c65e98e3319a61449cb2b2455af5
                           .group:00000000 wm4.core_cm4.h.32.1434cd257ff5806b1b03cd32ab0641e9
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.core_cmInstr.h.25.d8165482ef3061013a2fc83e2d85f3d9
                           .group:00000000 wm4.core_cm4_simd.h.29.013e5bcf58dba2d27c60184174208e07
                           .group:00000000 wm4.core_cm4.h.155.cf7c793e178943e1bbf613f1b21cd51a
                           .group:00000000 wm4.stm32f30x.h.294.d8a54360eca16e4157694b52a095202d
                           .group:00000000 wm4.stm32f30x_adc.h.130.cbebad91f78fb87381fe0860eea6104e
                           .group:00000000 wm4.stm32f30x_can.h.50.8b8f5d301152c422a6e50622b33ef620
                           .group:00000000 wm4.stm32f30x_crc.h.54.66d4c5e565e18566aebd9abfd4bcd4b0
                           .group:00000000 wm4.stm32f30x_comp.h.91.06ae44150aaaa82c077b71df8db3541a
                           .group:00000000 wm4.stm32f30x_dac.h.49.b1b5b26e4ca241dbe67fa16dc86a615f
                           .group:00000000 wm4.stm32f30x_dbgmcu.h.53.b238a263ce6a2cc83f610cc35302a38b
                           .group:00000000 wm4.stm32f30x_dma.h.96.d7a2ddd10023e12781aa8ff5ac15d212
                           .group:00000000 wm4.stm32f30x_exti.h.60.8ca0809491a21dec6fc69cf7471e2bab
                           .group:00000000 wm4.stm32f30x_flash.h.70.32613455dfe7328932f786a224daac23
                           .group:00000000 wm4.stm32f30x_gpio.h.50.408e1f6250246e4cc28221970909d34c
                           .group:00000000 wm4.stm32f30x_syscfg.h.58.4cadeb4ec8e47d36b972bbb6b96b7161
                           .group:00000000 wm4.stm32f30x_i2c.h.86.3d51d4edc0e3b9ee9aae045ccbb7739a
                           .group:00000000 wm4.stm32f30x_iwdg.h.59.467d704fb073a015941f19b50fa6470a
                           .group:00000000 wm4.stm32f30x_opamp.h.75.704e2e5e2aab039de307aaa2dcc99fa5
                           .group:00000000 wm4.stm32f30x_rcc.h.79.5ba7cac1e74879861a72556c25322aa4
                           .group:00000000 wm4.stm32f30x_rtc.h.133.d184e08ff40bda44db4bed94f9633384
                           .group:00000000 wm4.stm32f30x_spi.h.119.4d21ec94ec14f3553a127e61c0a9874f
                           .group:00000000 wm4.stm32f30x_tim.h.175.d4a93cff2e7924577147254e501271b6
                           .group:00000000 wm4.stm32f30x_usart.h.110.c89016273702821ff4f9fe43881f70b5
                           .group:00000000 wm4.stm32f30x_wwdg.h.58.4688eee61a2709866472b4b4c07d9275
                           .group:00000000 wm4.stm32f30x_misc.h.113.6a52e4fe7c3825a3ab05990f30dddf92
                           .group:00000000 wm4.stm32f30x_pwr.h.59.5c85acff2a3e3c5085b2140c06025cfc

UNDEFINED SYMBOLS
RCC_APB1PeriphResetCmd
