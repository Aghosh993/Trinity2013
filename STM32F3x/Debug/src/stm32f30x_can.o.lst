   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"stm32f30x_can.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.align	2
  20              		.global	CAN_DeInit
  21              		.thumb
  22              		.thumb_func
  24              	CAN_DeInit:
  25              	.LFB111:
  26              		.file 1 "../src/stm32f30x_can.c"
   1:../src/stm32f30x_can.c **** /**
   2:../src/stm32f30x_can.c ****   ******************************************************************************
   3:../src/stm32f30x_can.c ****   * @file    stm32f30x_can.c
   4:../src/stm32f30x_can.c ****   * @author  MCD Application Team
   5:../src/stm32f30x_can.c ****   * @version V1.0.1
   6:../src/stm32f30x_can.c ****   * @date    23-October-2012
   7:../src/stm32f30x_can.c ****   * @brief   This file provides firmware functions to manage the following 
   8:../src/stm32f30x_can.c ****   *          functionalities of the Controller area network (CAN) peripheral:           
   9:../src/stm32f30x_can.c ****   *           + Initialization and Configuration 
  10:../src/stm32f30x_can.c ****   *           + CAN Frames Transmission 
  11:../src/stm32f30x_can.c ****   *           + CAN Frames Reception    
  12:../src/stm32f30x_can.c ****   *           + Operation modes switch  
  13:../src/stm32f30x_can.c ****   *           + Error management          
  14:../src/stm32f30x_can.c ****   *           + Interrupts and flags        
  15:../src/stm32f30x_can.c ****   *         
  16:../src/stm32f30x_can.c ****   @verbatim
  17:../src/stm32f30x_can.c ****                                
  18:../src/stm32f30x_can.c ****  ===============================================================================      
  19:../src/stm32f30x_can.c ****                       ##### How to use this driver #####
  20:../src/stm32f30x_can.c ****  ===============================================================================                
  21:../src/stm32f30x_can.c ****     [..]
  22:../src/stm32f30x_can.c ****     (#) Enable the CAN controller interface clock using 
  23:../src/stm32f30x_can.c ****         RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE);      
  24:../src/stm32f30x_can.c ****     (#) CAN pins configuration:
  25:../src/stm32f30x_can.c ****         (++) Enable the clock for the CAN GPIOs using the following function:
  26:../src/stm32f30x_can.c ****              RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOx, ENABLE);   
  27:../src/stm32f30x_can.c ****         (++) Connect the involved CAN pins to AF9 using the following function 
  28:../src/stm32f30x_can.c ****              GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_CANx); 
  29:../src/stm32f30x_can.c ****         (++) Configure these CAN pins in alternate function mode by calling
  30:../src/stm32f30x_can.c ****              the function  GPIO_Init();
  31:../src/stm32f30x_can.c ****     (#) Initialise and configure the CAN using CAN_Init() and 
  32:../src/stm32f30x_can.c ****         CAN_FilterInit() functions.   
  33:../src/stm32f30x_can.c ****     (#) Transmit the desired CAN frame using CAN_Transmit() function.
  34:../src/stm32f30x_can.c ****     (#) Check the transmission of a CAN frame using CAN_TransmitStatus() function.
  35:../src/stm32f30x_can.c ****     (#) Cancel the transmission of a CAN frame using CAN_CancelTransmit() function.  
  36:../src/stm32f30x_can.c ****     (#) Receive a CAN frame using CAN_Recieve() function.
  37:../src/stm32f30x_can.c ****     (#) Release the receive FIFOs using CAN_FIFORelease() function.
  38:../src/stm32f30x_can.c ****     (#) Return the number of pending received frames using CAN_MessagePending() function.          
  39:../src/stm32f30x_can.c ****     (#) To control CAN events you can use one of the following two methods:
  40:../src/stm32f30x_can.c ****         (++) Check on CAN flags using the CAN_GetFlagStatus() function.  
  41:../src/stm32f30x_can.c ****         (++) Use CAN interrupts through the function CAN_ITConfig() at initialization 
  42:../src/stm32f30x_can.c ****              phase and CAN_GetITStatus() function into interrupt routines to check 
  43:../src/stm32f30x_can.c ****              if the event has occurred or not.
  44:../src/stm32f30x_can.c ****              After checking on a flag you should clear it using CAN_ClearFlag()
  45:../src/stm32f30x_can.c ****              function. And after checking on an interrupt event you should clear it 
  46:../src/stm32f30x_can.c ****              using CAN_ClearITPendingBit() function.            
  47:../src/stm32f30x_can.c ****                  
  48:../src/stm32f30x_can.c ****   @endverbatim
  49:../src/stm32f30x_can.c ****   *       
  50:../src/stm32f30x_can.c ****   ******************************************************************************
  51:../src/stm32f30x_can.c ****   * @attention
  52:../src/stm32f30x_can.c ****   *
  53:../src/stm32f30x_can.c ****   * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
  54:../src/stm32f30x_can.c ****   *
  55:../src/stm32f30x_can.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  56:../src/stm32f30x_can.c ****   * You may not use this file except in compliance with the License.
  57:../src/stm32f30x_can.c ****   * You may obtain a copy of the License at:
  58:../src/stm32f30x_can.c ****   *
  59:../src/stm32f30x_can.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  60:../src/stm32f30x_can.c ****   *
  61:../src/stm32f30x_can.c ****   * Unless required by applicable law or agreed to in writing, software 
  62:../src/stm32f30x_can.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  63:../src/stm32f30x_can.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  64:../src/stm32f30x_can.c ****   * See the License for the specific language governing permissions and
  65:../src/stm32f30x_can.c ****   * limitations under the License.
  66:../src/stm32f30x_can.c ****   *
  67:../src/stm32f30x_can.c ****   ******************************************************************************
  68:../src/stm32f30x_can.c ****   */
  69:../src/stm32f30x_can.c **** 
  70:../src/stm32f30x_can.c **** /* Includes ------------------------------------------------------------------*/
  71:../src/stm32f30x_can.c **** #include "stm32f30x_can.h"
  72:../src/stm32f30x_can.c **** #include "stm32f30x_rcc.h"
  73:../src/stm32f30x_can.c **** 
  74:../src/stm32f30x_can.c **** /** @addtogroup STM32F30x_StdPeriph_Driver
  75:../src/stm32f30x_can.c ****   * @{
  76:../src/stm32f30x_can.c ****   */
  77:../src/stm32f30x_can.c **** 
  78:../src/stm32f30x_can.c **** /** @defgroup CAN 
  79:../src/stm32f30x_can.c ****   * @brief CAN driver modules
  80:../src/stm32f30x_can.c ****   * @{
  81:../src/stm32f30x_can.c ****   */ 
  82:../src/stm32f30x_can.c **** /* Private typedef -----------------------------------------------------------*/
  83:../src/stm32f30x_can.c **** /* Private define ------------------------------------------------------------*/
  84:../src/stm32f30x_can.c **** 
  85:../src/stm32f30x_can.c **** /* CAN Master Control Register bits */
  86:../src/stm32f30x_can.c **** #define MCR_DBF           ((uint32_t)0x00010000) /* software master reset */
  87:../src/stm32f30x_can.c **** 
  88:../src/stm32f30x_can.c **** /* CAN Mailbox Transmit Request */
  89:../src/stm32f30x_can.c **** #define TMIDxR_TXRQ       ((uint32_t)0x00000001) /* Transmit mailbox request */
  90:../src/stm32f30x_can.c **** 
  91:../src/stm32f30x_can.c **** /* CAN Filter Master Register bits */
  92:../src/stm32f30x_can.c **** #define FMR_FINIT         ((uint32_t)0x00000001) /* Filter init mode */
  93:../src/stm32f30x_can.c **** 
  94:../src/stm32f30x_can.c **** /* Time out for INAK bit */
  95:../src/stm32f30x_can.c **** #define INAK_TIMEOUT      ((uint32_t)0x00FFFFFF)
  96:../src/stm32f30x_can.c **** /* Time out for SLAK bit */
  97:../src/stm32f30x_can.c **** #define SLAK_TIMEOUT      ((uint32_t)0x00FFFFFF)
  98:../src/stm32f30x_can.c **** 
  99:../src/stm32f30x_can.c **** /* Flags in TSR register */
 100:../src/stm32f30x_can.c **** #define CAN_FLAGS_TSR     ((uint32_t)0x08000000) 
 101:../src/stm32f30x_can.c **** /* Flags in RF1R register */
 102:../src/stm32f30x_can.c **** #define CAN_FLAGS_RF1R    ((uint32_t)0x04000000) 
 103:../src/stm32f30x_can.c **** /* Flags in RF0R register */
 104:../src/stm32f30x_can.c **** #define CAN_FLAGS_RF0R    ((uint32_t)0x02000000) 
 105:../src/stm32f30x_can.c **** /* Flags in MSR register */
 106:../src/stm32f30x_can.c **** #define CAN_FLAGS_MSR     ((uint32_t)0x01000000) 
 107:../src/stm32f30x_can.c **** /* Flags in ESR register */
 108:../src/stm32f30x_can.c **** #define CAN_FLAGS_ESR     ((uint32_t)0x00F00000) 
 109:../src/stm32f30x_can.c **** 
 110:../src/stm32f30x_can.c **** /* Mailboxes definition */
 111:../src/stm32f30x_can.c **** #define CAN_TXMAILBOX_0   ((uint8_t)0x00)
 112:../src/stm32f30x_can.c **** #define CAN_TXMAILBOX_1   ((uint8_t)0x01)
 113:../src/stm32f30x_can.c **** #define CAN_TXMAILBOX_2   ((uint8_t)0x02) 
 114:../src/stm32f30x_can.c **** 
 115:../src/stm32f30x_can.c **** #define CAN_MODE_MASK     ((uint32_t) 0x00000003)
 116:../src/stm32f30x_can.c **** 
 117:../src/stm32f30x_can.c **** /* Private macro -------------------------------------------------------------*/
 118:../src/stm32f30x_can.c **** /* Private variables ---------------------------------------------------------*/
 119:../src/stm32f30x_can.c **** /* Private function prototypes -----------------------------------------------*/
 120:../src/stm32f30x_can.c **** /* Private functions ---------------------------------------------------------*/
 121:../src/stm32f30x_can.c **** static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
 122:../src/stm32f30x_can.c **** 
 123:../src/stm32f30x_can.c **** /** @defgroup CAN_Private_Functions
 124:../src/stm32f30x_can.c ****   * @{
 125:../src/stm32f30x_can.c ****   */
 126:../src/stm32f30x_can.c **** 
 127:../src/stm32f30x_can.c **** /** @defgroup CAN_Group1 Initialization and Configuration functions
 128:../src/stm32f30x_can.c ****  *  @brief    Initialization and Configuration functions 
 129:../src/stm32f30x_can.c ****  *
 130:../src/stm32f30x_can.c **** @verbatim    
 131:../src/stm32f30x_can.c ****  ===============================================================================
 132:../src/stm32f30x_can.c ****               ##### Initialization and Configuration functions #####
 133:../src/stm32f30x_can.c ****  ===============================================================================  
 134:../src/stm32f30x_can.c ****     [..] This section provides functions allowing to: 
 135:../src/stm32f30x_can.c ****          (+) Initialize the CAN peripherals : Prescaler, operating mode, the maximum 
 136:../src/stm32f30x_can.c ****              number of time quanta to perform resynchronization, the number of time 
 137:../src/stm32f30x_can.c ****              quanta in Bit Segment 1 and 2 and many other modes. 
 138:../src/stm32f30x_can.c ****          (+) Configure the CAN reception filter.                                      
 139:../src/stm32f30x_can.c ****          (+) Select the start bank filter for slave CAN.
 140:../src/stm32f30x_can.c ****          (+) Enable or disable the Debug Freeze mode for CAN.
 141:../src/stm32f30x_can.c ****          (+) Enable or disable the CAN Time Trigger Operation communication mode.
 142:../src/stm32f30x_can.c ****    
 143:../src/stm32f30x_can.c **** @endverbatim
 144:../src/stm32f30x_can.c ****   * @{
 145:../src/stm32f30x_can.c ****   */
 146:../src/stm32f30x_can.c ****   
 147:../src/stm32f30x_can.c **** /**
 148:../src/stm32f30x_can.c ****   * @brief  Deinitializes the CAN peripheral registers to their default reset values.
 149:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 to select the CAN1 peripheral.
 150:../src/stm32f30x_can.c ****   * @retval None.
 151:../src/stm32f30x_can.c ****   */
 152:../src/stm32f30x_can.c **** void CAN_DeInit(CAN_TypeDef* CANx)
 153:../src/stm32f30x_can.c **** {
  27              		.loc 1 153 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31 0000 80B5     		push	{r7, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  36 0002 82B0     		sub	sp, sp, #8
  37              	.LCFI1:
  38              		.cfi_def_cfa_offset 16
  39 0004 00AF     		add	r7, sp, #0
  40              	.LCFI2:
  41              		.cfi_def_cfa_register 7
  42 0006 7860     		str	r0, [r7, #4]
 154:../src/stm32f30x_can.c ****   /* Check the parameters */
 155:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 156:../src/stm32f30x_can.c ****  
 157:../src/stm32f30x_can.c ****   /* Enable CAN1 reset state */
 158:../src/stm32f30x_can.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
  43              		.loc 1 158 0
  44 0008 4FF00070 		mov	r0, #33554432
  45 000c 4FF00101 		mov	r1, #1
  46 0010 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 159:../src/stm32f30x_can.c ****   /* Release CAN1 from reset state */
 160:../src/stm32f30x_can.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
  47              		.loc 1 160 0
  48 0014 4FF00070 		mov	r0, #33554432
  49 0018 4FF00001 		mov	r1, #0
  50 001c FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 161:../src/stm32f30x_can.c **** }
  51              		.loc 1 161 0
  52 0020 07F10807 		add	r7, r7, #8
  53 0024 BD46     		mov	sp, r7
  54 0026 80BD     		pop	{r7, pc}
  55              		.cfi_endproc
  56              	.LFE111:
  58              		.align	2
  59              		.global	CAN_Init
  60              		.thumb
  61              		.thumb_func
  63              	CAN_Init:
  64              	.LFB112:
 162:../src/stm32f30x_can.c **** 
 163:../src/stm32f30x_can.c **** /**
 164:../src/stm32f30x_can.c ****   * @brief  Initializes the CAN peripheral according to the specified
 165:../src/stm32f30x_can.c ****   *         parameters in the CAN_InitStruct.
 166:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 to select the CAN1 peripheral.
 167:../src/stm32f30x_can.c ****   * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that contains
 168:../src/stm32f30x_can.c ****   *         the configuration information for the CAN peripheral.
 169:../src/stm32f30x_can.c ****   * @retval Constant indicates initialization succeed which will be 
 170:../src/stm32f30x_can.c ****   *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
 171:../src/stm32f30x_can.c ****   */
 172:../src/stm32f30x_can.c **** uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
 173:../src/stm32f30x_can.c **** {
  65              		.loc 1 173 0
  66              		.cfi_startproc
  67              		@ args = 0, pretend = 0, frame = 16
  68              		@ frame_needed = 1, uses_anonymous_args = 0
  69              		@ link register save eliminated.
  70 0028 80B4     		push	{r7}
  71              	.LCFI3:
  72              		.cfi_def_cfa_offset 4
  73              		.cfi_offset 7, -4
  74 002a 85B0     		sub	sp, sp, #20
  75              	.LCFI4:
  76              		.cfi_def_cfa_offset 24
  77 002c 00AF     		add	r7, sp, #0
  78              	.LCFI5:
  79              		.cfi_def_cfa_register 7
  80 002e 7860     		str	r0, [r7, #4]
  81 0030 3960     		str	r1, [r7, #0]
 174:../src/stm32f30x_can.c ****   uint8_t InitStatus = CAN_InitStatus_Failed;
  82              		.loc 1 174 0
  83 0032 4FF00003 		mov	r3, #0
  84 0036 FB73     		strb	r3, [r7, #15]
 175:../src/stm32f30x_can.c ****   __IO uint32_t wait_ack = 0x00000000;
  85              		.loc 1 175 0
  86 0038 4FF00003 		mov	r3, #0
  87 003c BB60     		str	r3, [r7, #8]
 176:../src/stm32f30x_can.c ****   /* Check the parameters */
 177:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 178:../src/stm32f30x_can.c ****   assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
 179:../src/stm32f30x_can.c ****   assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
 180:../src/stm32f30x_can.c ****   assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
 181:../src/stm32f30x_can.c ****   assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
 182:../src/stm32f30x_can.c ****   assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
 183:../src/stm32f30x_can.c ****   assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
 184:../src/stm32f30x_can.c ****   assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
 185:../src/stm32f30x_can.c ****   assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
 186:../src/stm32f30x_can.c ****   assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
 187:../src/stm32f30x_can.c ****   assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
 188:../src/stm32f30x_can.c ****   assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
 189:../src/stm32f30x_can.c **** 
 190:../src/stm32f30x_can.c ****   /* Exit from sleep mode */
 191:../src/stm32f30x_can.c ****   CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
  88              		.loc 1 191 0
  89 003e 7B68     		ldr	r3, [r7, #4]
  90 0040 1B68     		ldr	r3, [r3, #0]
  91 0042 23F00202 		bic	r2, r3, #2
  92 0046 7B68     		ldr	r3, [r7, #4]
  93 0048 1A60     		str	r2, [r3, #0]
 192:../src/stm32f30x_can.c **** 
 193:../src/stm32f30x_can.c ****   /* Request initialisation */
 194:../src/stm32f30x_can.c ****   CANx->MCR |= CAN_MCR_INRQ ;
  94              		.loc 1 194 0
  95 004a 7B68     		ldr	r3, [r7, #4]
  96 004c 1B68     		ldr	r3, [r3, #0]
  97 004e 43F00102 		orr	r2, r3, #1
  98 0052 7B68     		ldr	r3, [r7, #4]
  99 0054 1A60     		str	r2, [r3, #0]
 195:../src/stm32f30x_can.c **** 
 196:../src/stm32f30x_can.c ****   /* Wait the acknowledge */
 197:../src/stm32f30x_can.c ****   while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 100              		.loc 1 197 0
 101 0056 03E0     		b	.L3
 102              	.L5:
 198:../src/stm32f30x_can.c ****   {
 199:../src/stm32f30x_can.c ****     wait_ack++;
 103              		.loc 1 199 0
 104 0058 BB68     		ldr	r3, [r7, #8]
 105 005a 03F10103 		add	r3, r3, #1
 106 005e BB60     		str	r3, [r7, #8]
 107              	.L3:
 197:../src/stm32f30x_can.c ****   while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 108              		.loc 1 197 0 discriminator 1
 109 0060 7B68     		ldr	r3, [r7, #4]
 110 0062 5B68     		ldr	r3, [r3, #4]
 111 0064 03F00103 		and	r3, r3, #1
 112 0068 002B     		cmp	r3, #0
 113 006a 04D1     		bne	.L4
 197:../src/stm32f30x_can.c ****   while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 114              		.loc 1 197 0 is_stmt 0 discriminator 2
 115 006c BA68     		ldr	r2, [r7, #8]
 116 006e 6FF07F43 		mvn	r3, #-16777216
 117 0072 9A42     		cmp	r2, r3
 118 0074 F0D1     		bne	.L5
 119              	.L4:
 200:../src/stm32f30x_can.c ****   }
 201:../src/stm32f30x_can.c **** 
 202:../src/stm32f30x_can.c ****   /* Check acknowledge */
 203:../src/stm32f30x_can.c ****   if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 120              		.loc 1 203 0 is_stmt 1
 121 0076 7B68     		ldr	r3, [r7, #4]
 122 0078 5B68     		ldr	r3, [r3, #4]
 123 007a 03F00103 		and	r3, r3, #1
 124 007e 002B     		cmp	r3, #0
 125 0080 03D1     		bne	.L6
 204:../src/stm32f30x_can.c ****   {
 205:../src/stm32f30x_can.c ****     InitStatus = CAN_InitStatus_Failed;
 126              		.loc 1 205 0
 127 0082 4FF00003 		mov	r3, #0
 128 0086 FB73     		strb	r3, [r7, #15]
 129 0088 A5E0     		b	.L7
 130              	.L6:
 206:../src/stm32f30x_can.c ****   }
 207:../src/stm32f30x_can.c ****   else 
 208:../src/stm32f30x_can.c ****   {
 209:../src/stm32f30x_can.c ****     /* Set the time triggered communication mode */
 210:../src/stm32f30x_can.c ****     if (CAN_InitStruct->CAN_TTCM == ENABLE)
 131              		.loc 1 210 0
 132 008a 3B68     		ldr	r3, [r7, #0]
 133 008c 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 134 008e 012B     		cmp	r3, #1
 135 0090 06D1     		bne	.L8
 211:../src/stm32f30x_can.c ****     {
 212:../src/stm32f30x_can.c ****       CANx->MCR |= CAN_MCR_TTCM;
 136              		.loc 1 212 0
 137 0092 7B68     		ldr	r3, [r7, #4]
 138 0094 1B68     		ldr	r3, [r3, #0]
 139 0096 43F08002 		orr	r2, r3, #128
 140 009a 7B68     		ldr	r3, [r7, #4]
 141 009c 1A60     		str	r2, [r3, #0]
 142 009e 05E0     		b	.L9
 143              	.L8:
 213:../src/stm32f30x_can.c ****     }
 214:../src/stm32f30x_can.c ****     else
 215:../src/stm32f30x_can.c ****     {
 216:../src/stm32f30x_can.c ****       CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
 144              		.loc 1 216 0
 145 00a0 7B68     		ldr	r3, [r7, #4]
 146 00a2 1B68     		ldr	r3, [r3, #0]
 147 00a4 23F08002 		bic	r2, r3, #128
 148 00a8 7B68     		ldr	r3, [r7, #4]
 149 00aa 1A60     		str	r2, [r3, #0]
 150              	.L9:
 217:../src/stm32f30x_can.c ****     }
 218:../src/stm32f30x_can.c **** 
 219:../src/stm32f30x_can.c ****     /* Set the automatic bus-off management */
 220:../src/stm32f30x_can.c ****     if (CAN_InitStruct->CAN_ABOM == ENABLE)
 151              		.loc 1 220 0
 152 00ac 3B68     		ldr	r3, [r7, #0]
 153 00ae DB79     		ldrb	r3, [r3, #7]	@ zero_extendqisi2
 154 00b0 012B     		cmp	r3, #1
 155 00b2 06D1     		bne	.L10
 221:../src/stm32f30x_can.c ****     {
 222:../src/stm32f30x_can.c ****       CANx->MCR |= CAN_MCR_ABOM;
 156              		.loc 1 222 0
 157 00b4 7B68     		ldr	r3, [r7, #4]
 158 00b6 1B68     		ldr	r3, [r3, #0]
 159 00b8 43F04002 		orr	r2, r3, #64
 160 00bc 7B68     		ldr	r3, [r7, #4]
 161 00be 1A60     		str	r2, [r3, #0]
 162 00c0 05E0     		b	.L11
 163              	.L10:
 223:../src/stm32f30x_can.c ****     }
 224:../src/stm32f30x_can.c ****     else
 225:../src/stm32f30x_can.c ****     {
 226:../src/stm32f30x_can.c ****       CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
 164              		.loc 1 226 0
 165 00c2 7B68     		ldr	r3, [r7, #4]
 166 00c4 1B68     		ldr	r3, [r3, #0]
 167 00c6 23F04002 		bic	r2, r3, #64
 168 00ca 7B68     		ldr	r3, [r7, #4]
 169 00cc 1A60     		str	r2, [r3, #0]
 170              	.L11:
 227:../src/stm32f30x_can.c ****     }
 228:../src/stm32f30x_can.c **** 
 229:../src/stm32f30x_can.c ****     /* Set the automatic wake-up mode */
 230:../src/stm32f30x_can.c ****     if (CAN_InitStruct->CAN_AWUM == ENABLE)
 171              		.loc 1 230 0
 172 00ce 3B68     		ldr	r3, [r7, #0]
 173 00d0 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 174 00d2 012B     		cmp	r3, #1
 175 00d4 06D1     		bne	.L12
 231:../src/stm32f30x_can.c ****     {
 232:../src/stm32f30x_can.c ****       CANx->MCR |= CAN_MCR_AWUM;
 176              		.loc 1 232 0
 177 00d6 7B68     		ldr	r3, [r7, #4]
 178 00d8 1B68     		ldr	r3, [r3, #0]
 179 00da 43F02002 		orr	r2, r3, #32
 180 00de 7B68     		ldr	r3, [r7, #4]
 181 00e0 1A60     		str	r2, [r3, #0]
 182 00e2 05E0     		b	.L13
 183              	.L12:
 233:../src/stm32f30x_can.c ****     }
 234:../src/stm32f30x_can.c ****     else
 235:../src/stm32f30x_can.c ****     {
 236:../src/stm32f30x_can.c ****       CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
 184              		.loc 1 236 0
 185 00e4 7B68     		ldr	r3, [r7, #4]
 186 00e6 1B68     		ldr	r3, [r3, #0]
 187 00e8 23F02002 		bic	r2, r3, #32
 188 00ec 7B68     		ldr	r3, [r7, #4]
 189 00ee 1A60     		str	r2, [r3, #0]
 190              	.L13:
 237:../src/stm32f30x_can.c ****     }
 238:../src/stm32f30x_can.c **** 
 239:../src/stm32f30x_can.c ****     /* Set the no automatic retransmission */
 240:../src/stm32f30x_can.c ****     if (CAN_InitStruct->CAN_NART == ENABLE)
 191              		.loc 1 240 0
 192 00f0 3B68     		ldr	r3, [r7, #0]
 193 00f2 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 194 00f4 012B     		cmp	r3, #1
 195 00f6 06D1     		bne	.L14
 241:../src/stm32f30x_can.c ****     {
 242:../src/stm32f30x_can.c ****       CANx->MCR |= CAN_MCR_NART;
 196              		.loc 1 242 0
 197 00f8 7B68     		ldr	r3, [r7, #4]
 198 00fa 1B68     		ldr	r3, [r3, #0]
 199 00fc 43F01002 		orr	r2, r3, #16
 200 0100 7B68     		ldr	r3, [r7, #4]
 201 0102 1A60     		str	r2, [r3, #0]
 202 0104 05E0     		b	.L15
 203              	.L14:
 243:../src/stm32f30x_can.c ****     }
 244:../src/stm32f30x_can.c ****     else
 245:../src/stm32f30x_can.c ****     {
 246:../src/stm32f30x_can.c ****       CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
 204              		.loc 1 246 0
 205 0106 7B68     		ldr	r3, [r7, #4]
 206 0108 1B68     		ldr	r3, [r3, #0]
 207 010a 23F01002 		bic	r2, r3, #16
 208 010e 7B68     		ldr	r3, [r7, #4]
 209 0110 1A60     		str	r2, [r3, #0]
 210              	.L15:
 247:../src/stm32f30x_can.c ****     }
 248:../src/stm32f30x_can.c **** 
 249:../src/stm32f30x_can.c ****     /* Set the receive FIFO locked mode */
 250:../src/stm32f30x_can.c ****     if (CAN_InitStruct->CAN_RFLM == ENABLE)
 211              		.loc 1 250 0
 212 0112 3B68     		ldr	r3, [r7, #0]
 213 0114 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 214 0116 012B     		cmp	r3, #1
 215 0118 06D1     		bne	.L16
 251:../src/stm32f30x_can.c ****     {
 252:../src/stm32f30x_can.c ****       CANx->MCR |= CAN_MCR_RFLM;
 216              		.loc 1 252 0
 217 011a 7B68     		ldr	r3, [r7, #4]
 218 011c 1B68     		ldr	r3, [r3, #0]
 219 011e 43F00802 		orr	r2, r3, #8
 220 0122 7B68     		ldr	r3, [r7, #4]
 221 0124 1A60     		str	r2, [r3, #0]
 222 0126 05E0     		b	.L17
 223              	.L16:
 253:../src/stm32f30x_can.c ****     }
 254:../src/stm32f30x_can.c ****     else
 255:../src/stm32f30x_can.c ****     {
 256:../src/stm32f30x_can.c ****       CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
 224              		.loc 1 256 0
 225 0128 7B68     		ldr	r3, [r7, #4]
 226 012a 1B68     		ldr	r3, [r3, #0]
 227 012c 23F00802 		bic	r2, r3, #8
 228 0130 7B68     		ldr	r3, [r7, #4]
 229 0132 1A60     		str	r2, [r3, #0]
 230              	.L17:
 257:../src/stm32f30x_can.c ****     }
 258:../src/stm32f30x_can.c **** 
 259:../src/stm32f30x_can.c ****     /* Set the transmit FIFO priority */
 260:../src/stm32f30x_can.c ****     if (CAN_InitStruct->CAN_TXFP == ENABLE)
 231              		.loc 1 260 0
 232 0134 3B68     		ldr	r3, [r7, #0]
 233 0136 DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 234 0138 012B     		cmp	r3, #1
 235 013a 06D1     		bne	.L18
 261:../src/stm32f30x_can.c ****     {
 262:../src/stm32f30x_can.c ****       CANx->MCR |= CAN_MCR_TXFP;
 236              		.loc 1 262 0
 237 013c 7B68     		ldr	r3, [r7, #4]
 238 013e 1B68     		ldr	r3, [r3, #0]
 239 0140 43F00402 		orr	r2, r3, #4
 240 0144 7B68     		ldr	r3, [r7, #4]
 241 0146 1A60     		str	r2, [r3, #0]
 242 0148 05E0     		b	.L19
 243              	.L18:
 263:../src/stm32f30x_can.c ****     }
 264:../src/stm32f30x_can.c ****     else
 265:../src/stm32f30x_can.c ****     {
 266:../src/stm32f30x_can.c ****       CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
 244              		.loc 1 266 0
 245 014a 7B68     		ldr	r3, [r7, #4]
 246 014c 1B68     		ldr	r3, [r3, #0]
 247 014e 23F00402 		bic	r2, r3, #4
 248 0152 7B68     		ldr	r3, [r7, #4]
 249 0154 1A60     		str	r2, [r3, #0]
 250              	.L19:
 267:../src/stm32f30x_can.c ****     }
 268:../src/stm32f30x_can.c **** 
 269:../src/stm32f30x_can.c ****     /* Set the bit timing register */
 270:../src/stm32f30x_can.c ****     CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
 251              		.loc 1 270 0
 252 0156 3B68     		ldr	r3, [r7, #0]
 253 0158 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 254 015a 4FEA8372 		lsl	r2, r3, #30
 271:../src/stm32f30x_can.c ****                 ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
 255              		.loc 1 271 0
 256 015e 3B68     		ldr	r3, [r7, #0]
 257 0160 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 258 0162 4FEA0363 		lsl	r3, r3, #24
 270:../src/stm32f30x_can.c ****     CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
 259              		.loc 1 270 0
 260 0166 1A43     		orrs	r2, r2, r3
 272:../src/stm32f30x_can.c ****                 ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
 261              		.loc 1 272 0
 262 0168 3B68     		ldr	r3, [r7, #0]
 263 016a 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 264 016c 4FEA0343 		lsl	r3, r3, #16
 271:../src/stm32f30x_can.c ****                 ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
 265              		.loc 1 271 0
 266 0170 1A43     		orrs	r2, r2, r3
 273:../src/stm32f30x_can.c ****                 ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
 267              		.loc 1 273 0
 268 0172 3B68     		ldr	r3, [r7, #0]
 269 0174 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 270 0176 4FEA0353 		lsl	r3, r3, #20
 272:../src/stm32f30x_can.c ****                 ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
 271              		.loc 1 272 0
 272 017a 1A43     		orrs	r2, r2, r3
 274:../src/stm32f30x_can.c ****                ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
 273              		.loc 1 274 0
 274 017c 3B68     		ldr	r3, [r7, #0]
 275 017e 1B88     		ldrh	r3, [r3, #0]
 276 0180 03F1FF33 		add	r3, r3, #-1
 273:../src/stm32f30x_can.c ****                 ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
 277              		.loc 1 273 0
 278 0184 1A43     		orrs	r2, r2, r3
 270:../src/stm32f30x_can.c ****     CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
 279              		.loc 1 270 0
 280 0186 7B68     		ldr	r3, [r7, #4]
 281 0188 DA61     		str	r2, [r3, #28]
 275:../src/stm32f30x_can.c **** 
 276:../src/stm32f30x_can.c ****     /* Request leave initialisation */
 277:../src/stm32f30x_can.c ****     CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
 282              		.loc 1 277 0
 283 018a 7B68     		ldr	r3, [r7, #4]
 284 018c 1B68     		ldr	r3, [r3, #0]
 285 018e 23F00102 		bic	r2, r3, #1
 286 0192 7B68     		ldr	r3, [r7, #4]
 287 0194 1A60     		str	r2, [r3, #0]
 278:../src/stm32f30x_can.c **** 
 279:../src/stm32f30x_can.c ****    /* Wait the acknowledge */
 280:../src/stm32f30x_can.c ****    wait_ack = 0;
 288              		.loc 1 280 0
 289 0196 4FF00003 		mov	r3, #0
 290 019a BB60     		str	r3, [r7, #8]
 281:../src/stm32f30x_can.c **** 
 282:../src/stm32f30x_can.c ****    while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 291              		.loc 1 282 0
 292 019c 03E0     		b	.L20
 293              	.L22:
 283:../src/stm32f30x_can.c ****    {
 284:../src/stm32f30x_can.c ****      wait_ack++;
 294              		.loc 1 284 0
 295 019e BB68     		ldr	r3, [r7, #8]
 296 01a0 03F10103 		add	r3, r3, #1
 297 01a4 BB60     		str	r3, [r7, #8]
 298              	.L20:
 282:../src/stm32f30x_can.c ****    while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 299              		.loc 1 282 0 discriminator 1
 300 01a6 7B68     		ldr	r3, [r7, #4]
 301 01a8 5B68     		ldr	r3, [r3, #4]
 302 01aa 03F00103 		and	r3, r3, #1
 303 01ae 002B     		cmp	r3, #0
 304 01b0 04D0     		beq	.L21
 282:../src/stm32f30x_can.c ****    while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 305              		.loc 1 282 0 is_stmt 0 discriminator 2
 306 01b2 BA68     		ldr	r2, [r7, #8]
 307 01b4 6FF07F43 		mvn	r3, #-16777216
 308 01b8 9A42     		cmp	r2, r3
 309 01ba F0D1     		bne	.L22
 310              	.L21:
 285:../src/stm32f30x_can.c ****    }
 286:../src/stm32f30x_can.c **** 
 287:../src/stm32f30x_can.c ****     /* ...and check acknowledged */
 288:../src/stm32f30x_can.c ****     if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 311              		.loc 1 288 0 is_stmt 1
 312 01bc 7B68     		ldr	r3, [r7, #4]
 313 01be 5B68     		ldr	r3, [r3, #4]
 314 01c0 03F00103 		and	r3, r3, #1
 315 01c4 002B     		cmp	r3, #0
 316 01c6 03D0     		beq	.L23
 289:../src/stm32f30x_can.c ****     {
 290:../src/stm32f30x_can.c ****       InitStatus = CAN_InitStatus_Failed;
 317              		.loc 1 290 0
 318 01c8 4FF00003 		mov	r3, #0
 319 01cc FB73     		strb	r3, [r7, #15]
 320 01ce 02E0     		b	.L7
 321              	.L23:
 291:../src/stm32f30x_can.c ****     }
 292:../src/stm32f30x_can.c ****     else
 293:../src/stm32f30x_can.c ****     {
 294:../src/stm32f30x_can.c ****       InitStatus = CAN_InitStatus_Success ;
 322              		.loc 1 294 0
 323 01d0 4FF00103 		mov	r3, #1
 324 01d4 FB73     		strb	r3, [r7, #15]
 325              	.L7:
 295:../src/stm32f30x_can.c ****     }
 296:../src/stm32f30x_can.c ****   }
 297:../src/stm32f30x_can.c **** 
 298:../src/stm32f30x_can.c ****   /* At this step, return the status of initialization */
 299:../src/stm32f30x_can.c ****   return InitStatus;
 326              		.loc 1 299 0
 327 01d6 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 300:../src/stm32f30x_can.c **** }
 328              		.loc 1 300 0
 329 01d8 1846     		mov	r0, r3
 330 01da 07F11407 		add	r7, r7, #20
 331 01de BD46     		mov	sp, r7
 332 01e0 80BC     		pop	{r7}
 333 01e2 7047     		bx	lr
 334              		.cfi_endproc
 335              	.LFE112:
 337              		.align	2
 338              		.global	CAN_FilterInit
 339              		.thumb
 340              		.thumb_func
 342              	CAN_FilterInit:
 343              	.LFB113:
 301:../src/stm32f30x_can.c **** 
 302:../src/stm32f30x_can.c **** /**
 303:../src/stm32f30x_can.c ****   * @brief  Configures the CAN reception filter according to the specified
 304:../src/stm32f30x_can.c ****   *         parameters in the CAN_FilterInitStruct.
 305:../src/stm32f30x_can.c ****   * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
 306:../src/stm32f30x_can.c ****   *         contains the configuration information.
 307:../src/stm32f30x_can.c ****   * @retval None
 308:../src/stm32f30x_can.c ****   */
 309:../src/stm32f30x_can.c **** void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
 310:../src/stm32f30x_can.c **** {
 344              		.loc 1 310 0
 345              		.cfi_startproc
 346              		@ args = 0, pretend = 0, frame = 16
 347              		@ frame_needed = 1, uses_anonymous_args = 0
 348              		@ link register save eliminated.
 349 01e4 80B4     		push	{r7}
 350              	.LCFI6:
 351              		.cfi_def_cfa_offset 4
 352              		.cfi_offset 7, -4
 353 01e6 85B0     		sub	sp, sp, #20
 354              	.LCFI7:
 355              		.cfi_def_cfa_offset 24
 356 01e8 00AF     		add	r7, sp, #0
 357              	.LCFI8:
 358              		.cfi_def_cfa_register 7
 359 01ea 7860     		str	r0, [r7, #4]
 311:../src/stm32f30x_can.c ****   uint32_t filter_number_bit_pos = 0;
 360              		.loc 1 311 0
 361 01ec 4FF00003 		mov	r3, #0
 362 01f0 FB60     		str	r3, [r7, #12]
 312:../src/stm32f30x_can.c ****   /* Check the parameters */
 313:../src/stm32f30x_can.c ****   assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
 314:../src/stm32f30x_can.c ****   assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
 315:../src/stm32f30x_can.c ****   assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
 316:../src/stm32f30x_can.c ****   assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
 317:../src/stm32f30x_can.c ****   assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
 318:../src/stm32f30x_can.c **** 
 319:../src/stm32f30x_can.c ****   filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
 363              		.loc 1 319 0
 364 01f2 7B68     		ldr	r3, [r7, #4]
 365 01f4 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 366 01f6 4FF00102 		mov	r2, #1
 367 01fa 02FA03F3 		lsl	r3, r2, r3
 368 01fe FB60     		str	r3, [r7, #12]
 320:../src/stm32f30x_can.c **** 
 321:../src/stm32f30x_can.c ****   /* Initialisation mode for the filter */
 322:../src/stm32f30x_can.c ****   CAN1->FMR |= FMR_FINIT;
 369              		.loc 1 322 0
 370 0200 4FF4C843 		mov	r3, #25600
 371 0204 C4F20003 		movt	r3, 16384
 372 0208 4FF4C842 		mov	r2, #25600
 373 020c C4F20002 		movt	r2, 16384
 374 0210 D2F80022 		ldr	r2, [r2, #512]
 375 0214 42F00102 		orr	r2, r2, #1
 376 0218 C3F80022 		str	r2, [r3, #512]
 323:../src/stm32f30x_can.c **** 
 324:../src/stm32f30x_can.c ****   /* Filter Deactivation */
 325:../src/stm32f30x_can.c ****   CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
 377              		.loc 1 325 0
 378 021c 4FF4C843 		mov	r3, #25600
 379 0220 C4F20003 		movt	r3, 16384
 380 0224 4FF4C842 		mov	r2, #25600
 381 0228 C4F20002 		movt	r2, 16384
 382 022c D2F81C12 		ldr	r1, [r2, #540]
 383 0230 FA68     		ldr	r2, [r7, #12]
 384 0232 6FEA0202 		mvn	r2, r2
 385 0236 0A40     		ands	r2, r2, r1
 386 0238 C3F81C22 		str	r2, [r3, #540]
 326:../src/stm32f30x_can.c **** 
 327:../src/stm32f30x_can.c ****   /* Filter Scale */
 328:../src/stm32f30x_can.c ****   if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
 387              		.loc 1 328 0
 388 023c 7B68     		ldr	r3, [r7, #4]
 389 023e 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 390 0240 002B     		cmp	r3, #0
 391 0242 33D1     		bne	.L26
 329:../src/stm32f30x_can.c ****   {
 330:../src/stm32f30x_can.c ****     /* 16-bit scale for the filter */
 331:../src/stm32f30x_can.c ****     CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
 392              		.loc 1 331 0
 393 0244 4FF4C843 		mov	r3, #25600
 394 0248 C4F20003 		movt	r3, 16384
 395 024c 4FF4C842 		mov	r2, #25600
 396 0250 C4F20002 		movt	r2, 16384
 397 0254 D2F80C12 		ldr	r1, [r2, #524]
 398 0258 FA68     		ldr	r2, [r7, #12]
 399 025a 6FEA0202 		mvn	r2, r2
 400 025e 0A40     		ands	r2, r2, r1
 401 0260 C3F80C22 		str	r2, [r3, #524]
 332:../src/stm32f30x_can.c **** 
 333:../src/stm32f30x_can.c ****     /* First 16-bit identifier and First 16-bit mask */
 334:../src/stm32f30x_can.c ****     /* Or First 16-bit identifier and Second 16-bit identifier */
 335:../src/stm32f30x_can.c ****     CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 402              		.loc 1 335 0
 403 0264 4FF4C843 		mov	r3, #25600
 404 0268 C4F20003 		movt	r3, 16384
 405 026c 7A68     		ldr	r2, [r7, #4]
 406 026e 927A     		ldrb	r2, [r2, #10]	@ zero_extendqisi2
 336:../src/stm32f30x_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
 407              		.loc 1 336 0
 408 0270 7968     		ldr	r1, [r7, #4]
 409 0272 C988     		ldrh	r1, [r1, #6]
 410 0274 4FEA0140 		lsl	r0, r1, #16
 337:../src/stm32f30x_can.c ****         (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
 411              		.loc 1 337 0
 412 0278 7968     		ldr	r1, [r7, #4]
 413 027a 4988     		ldrh	r1, [r1, #2]
 336:../src/stm32f30x_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
 414              		.loc 1 336 0
 415 027c 0143     		orrs	r1, r1, r0
 335:../src/stm32f30x_can.c ****     CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 416              		.loc 1 335 0
 417 027e 02F14802 		add	r2, r2, #72
 418 0282 43F83210 		str	r1, [r3, r2, lsl #3]
 338:../src/stm32f30x_can.c **** 
 339:../src/stm32f30x_can.c ****     /* Second 16-bit identifier and Second 16-bit mask */
 340:../src/stm32f30x_can.c ****     /* Or Third 16-bit identifier and Fourth 16-bit identifier */
 341:../src/stm32f30x_can.c ****     CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 419              		.loc 1 341 0
 420 0286 4FF4C842 		mov	r2, #25600
 421 028a C4F20002 		movt	r2, 16384
 422 028e 7B68     		ldr	r3, [r7, #4]
 423 0290 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 342:../src/stm32f30x_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 424              		.loc 1 342 0
 425 0292 7968     		ldr	r1, [r7, #4]
 426 0294 8988     		ldrh	r1, [r1, #4]
 427 0296 4FEA0140 		lsl	r0, r1, #16
 343:../src/stm32f30x_can.c ****         (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
 428              		.loc 1 343 0
 429 029a 7968     		ldr	r1, [r7, #4]
 430 029c 0988     		ldrh	r1, [r1, #0]
 342:../src/stm32f30x_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 431              		.loc 1 342 0
 432 029e 0143     		orrs	r1, r1, r0
 341:../src/stm32f30x_can.c ****     CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 433              		.loc 1 341 0
 434 02a0 03F14803 		add	r3, r3, #72
 435 02a4 4FEAC303 		lsl	r3, r3, #3
 436 02a8 D318     		adds	r3, r2, r3
 437 02aa 5960     		str	r1, [r3, #4]
 438              	.L26:
 344:../src/stm32f30x_can.c ****   }
 345:../src/stm32f30x_can.c **** 
 346:../src/stm32f30x_can.c ****   if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
 439              		.loc 1 346 0
 440 02ac 7B68     		ldr	r3, [r7, #4]
 441 02ae 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 442 02b0 012B     		cmp	r3, #1
 443 02b2 31D1     		bne	.L27
 347:../src/stm32f30x_can.c ****   {
 348:../src/stm32f30x_can.c ****     /* 32-bit scale for the filter */
 349:../src/stm32f30x_can.c ****     CAN1->FS1R |= filter_number_bit_pos;
 444              		.loc 1 349 0
 445 02b4 4FF4C843 		mov	r3, #25600
 446 02b8 C4F20003 		movt	r3, 16384
 447 02bc 4FF4C842 		mov	r2, #25600
 448 02c0 C4F20002 		movt	r2, 16384
 449 02c4 D2F80C12 		ldr	r1, [r2, #524]
 450 02c8 FA68     		ldr	r2, [r7, #12]
 451 02ca 0A43     		orrs	r2, r2, r1
 452 02cc C3F80C22 		str	r2, [r3, #524]
 350:../src/stm32f30x_can.c ****     /* 32-bit identifier or First 32-bit identifier */
 351:../src/stm32f30x_can.c ****     CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 453              		.loc 1 351 0
 454 02d0 4FF4C843 		mov	r3, #25600
 455 02d4 C4F20003 		movt	r3, 16384
 456 02d8 7A68     		ldr	r2, [r7, #4]
 457 02da 927A     		ldrb	r2, [r2, #10]	@ zero_extendqisi2
 352:../src/stm32f30x_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
 458              		.loc 1 352 0
 459 02dc 7968     		ldr	r1, [r7, #4]
 460 02de 0988     		ldrh	r1, [r1, #0]
 461 02e0 4FEA0140 		lsl	r0, r1, #16
 353:../src/stm32f30x_can.c ****         (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
 462              		.loc 1 353 0
 463 02e4 7968     		ldr	r1, [r7, #4]
 464 02e6 4988     		ldrh	r1, [r1, #2]
 352:../src/stm32f30x_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
 465              		.loc 1 352 0
 466 02e8 0143     		orrs	r1, r1, r0
 351:../src/stm32f30x_can.c ****     CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 467              		.loc 1 351 0
 468 02ea 02F14802 		add	r2, r2, #72
 469 02ee 43F83210 		str	r1, [r3, r2, lsl #3]
 354:../src/stm32f30x_can.c ****     /* 32-bit mask or Second 32-bit identifier */
 355:../src/stm32f30x_can.c ****     CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 470              		.loc 1 355 0
 471 02f2 4FF4C842 		mov	r2, #25600
 472 02f6 C4F20002 		movt	r2, 16384
 473 02fa 7B68     		ldr	r3, [r7, #4]
 474 02fc 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 356:../src/stm32f30x_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 475              		.loc 1 356 0
 476 02fe 7968     		ldr	r1, [r7, #4]
 477 0300 8988     		ldrh	r1, [r1, #4]
 478 0302 4FEA0140 		lsl	r0, r1, #16
 357:../src/stm32f30x_can.c ****         (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
 479              		.loc 1 357 0
 480 0306 7968     		ldr	r1, [r7, #4]
 481 0308 C988     		ldrh	r1, [r1, #6]
 356:../src/stm32f30x_can.c ****        ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 482              		.loc 1 356 0
 483 030a 0143     		orrs	r1, r1, r0
 355:../src/stm32f30x_can.c ****     CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 484              		.loc 1 355 0
 485 030c 03F14803 		add	r3, r3, #72
 486 0310 4FEAC303 		lsl	r3, r3, #3
 487 0314 D318     		adds	r3, r2, r3
 488 0316 5960     		str	r1, [r3, #4]
 489              	.L27:
 358:../src/stm32f30x_can.c ****   }
 359:../src/stm32f30x_can.c **** 
 360:../src/stm32f30x_can.c ****   /* Filter Mode */
 361:../src/stm32f30x_can.c ****   if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
 490              		.loc 1 361 0
 491 0318 7B68     		ldr	r3, [r7, #4]
 492 031a DB7A     		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 493 031c 002B     		cmp	r3, #0
 494 031e 10D1     		bne	.L28
 362:../src/stm32f30x_can.c ****   {
 363:../src/stm32f30x_can.c ****     /*Id/Mask mode for the filter*/
 364:../src/stm32f30x_can.c ****     CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
 495              		.loc 1 364 0
 496 0320 4FF4C843 		mov	r3, #25600
 497 0324 C4F20003 		movt	r3, 16384
 498 0328 4FF4C842 		mov	r2, #25600
 499 032c C4F20002 		movt	r2, 16384
 500 0330 D2F80412 		ldr	r1, [r2, #516]
 501 0334 FA68     		ldr	r2, [r7, #12]
 502 0336 6FEA0202 		mvn	r2, r2
 503 033a 0A40     		ands	r2, r2, r1
 504 033c C3F80422 		str	r2, [r3, #516]
 505 0340 0DE0     		b	.L29
 506              	.L28:
 365:../src/stm32f30x_can.c ****   }
 366:../src/stm32f30x_can.c ****   else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
 367:../src/stm32f30x_can.c ****   {
 368:../src/stm32f30x_can.c ****     /*Identifier list mode for the filter*/
 369:../src/stm32f30x_can.c ****     CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
 507              		.loc 1 369 0
 508 0342 4FF4C843 		mov	r3, #25600
 509 0346 C4F20003 		movt	r3, 16384
 510 034a 4FF4C842 		mov	r2, #25600
 511 034e C4F20002 		movt	r2, 16384
 512 0352 D2F80412 		ldr	r1, [r2, #516]
 513 0356 FA68     		ldr	r2, [r7, #12]
 514 0358 0A43     		orrs	r2, r2, r1
 515 035a C3F80422 		str	r2, [r3, #516]
 516              	.L29:
 370:../src/stm32f30x_can.c ****   }
 371:../src/stm32f30x_can.c **** 
 372:../src/stm32f30x_can.c ****   /* Filter FIFO assignment */
 373:../src/stm32f30x_can.c ****   if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
 517              		.loc 1 373 0
 518 035e 7B68     		ldr	r3, [r7, #4]
 519 0360 1B89     		ldrh	r3, [r3, #8]
 520 0362 002B     		cmp	r3, #0
 521 0364 0FD1     		bne	.L30
 374:../src/stm32f30x_can.c ****   {
 375:../src/stm32f30x_can.c ****     /* FIFO 0 assignation for the filter */
 376:../src/stm32f30x_can.c ****     CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
 522              		.loc 1 376 0
 523 0366 4FF4C843 		mov	r3, #25600
 524 036a C4F20003 		movt	r3, 16384
 525 036e 4FF4C842 		mov	r2, #25600
 526 0372 C4F20002 		movt	r2, 16384
 527 0376 D2F81412 		ldr	r1, [r2, #532]
 528 037a FA68     		ldr	r2, [r7, #12]
 529 037c 6FEA0202 		mvn	r2, r2
 530 0380 0A40     		ands	r2, r2, r1
 531 0382 C3F81422 		str	r2, [r3, #532]
 532              	.L30:
 377:../src/stm32f30x_can.c ****   }
 378:../src/stm32f30x_can.c **** 
 379:../src/stm32f30x_can.c ****   if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
 533              		.loc 1 379 0
 534 0386 7B68     		ldr	r3, [r7, #4]
 535 0388 1B89     		ldrh	r3, [r3, #8]
 536 038a 012B     		cmp	r3, #1
 537 038c 0DD1     		bne	.L31
 380:../src/stm32f30x_can.c ****   {
 381:../src/stm32f30x_can.c ****     /* FIFO 1 assignation for the filter */
 382:../src/stm32f30x_can.c ****     CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
 538              		.loc 1 382 0
 539 038e 4FF4C843 		mov	r3, #25600
 540 0392 C4F20003 		movt	r3, 16384
 541 0396 4FF4C842 		mov	r2, #25600
 542 039a C4F20002 		movt	r2, 16384
 543 039e D2F81412 		ldr	r1, [r2, #532]
 544 03a2 FA68     		ldr	r2, [r7, #12]
 545 03a4 0A43     		orrs	r2, r2, r1
 546 03a6 C3F81422 		str	r2, [r3, #532]
 547              	.L31:
 383:../src/stm32f30x_can.c ****   }
 384:../src/stm32f30x_can.c ****   
 385:../src/stm32f30x_can.c ****   /* Filter activation */
 386:../src/stm32f30x_can.c ****   if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
 548              		.loc 1 386 0
 549 03aa 7B68     		ldr	r3, [r7, #4]
 550 03ac 5B7B     		ldrb	r3, [r3, #13]	@ zero_extendqisi2
 551 03ae 012B     		cmp	r3, #1
 552 03b0 0DD1     		bne	.L32
 387:../src/stm32f30x_can.c ****   {
 388:../src/stm32f30x_can.c ****     CAN1->FA1R |= filter_number_bit_pos;
 553              		.loc 1 388 0
 554 03b2 4FF4C843 		mov	r3, #25600
 555 03b6 C4F20003 		movt	r3, 16384
 556 03ba 4FF4C842 		mov	r2, #25600
 557 03be C4F20002 		movt	r2, 16384
 558 03c2 D2F81C12 		ldr	r1, [r2, #540]
 559 03c6 FA68     		ldr	r2, [r7, #12]
 560 03c8 0A43     		orrs	r2, r2, r1
 561 03ca C3F81C22 		str	r2, [r3, #540]
 562              	.L32:
 389:../src/stm32f30x_can.c ****   }
 390:../src/stm32f30x_can.c **** 
 391:../src/stm32f30x_can.c ****   /* Leave the initialisation mode for the filter */
 392:../src/stm32f30x_can.c ****   CAN1->FMR &= ~FMR_FINIT;
 563              		.loc 1 392 0
 564 03ce 4FF4C843 		mov	r3, #25600
 565 03d2 C4F20003 		movt	r3, 16384
 566 03d6 4FF4C842 		mov	r2, #25600
 567 03da C4F20002 		movt	r2, 16384
 568 03de D2F80022 		ldr	r2, [r2, #512]
 569 03e2 22F00102 		bic	r2, r2, #1
 570 03e6 C3F80022 		str	r2, [r3, #512]
 393:../src/stm32f30x_can.c **** }
 571              		.loc 1 393 0
 572 03ea 07F11407 		add	r7, r7, #20
 573 03ee BD46     		mov	sp, r7
 574 03f0 80BC     		pop	{r7}
 575 03f2 7047     		bx	lr
 576              		.cfi_endproc
 577              	.LFE113:
 579              		.align	2
 580              		.global	CAN_StructInit
 581              		.thumb
 582              		.thumb_func
 584              	CAN_StructInit:
 585              	.LFB114:
 394:../src/stm32f30x_can.c **** 
 395:../src/stm32f30x_can.c **** /**
 396:../src/stm32f30x_can.c ****   * @brief  Fills each CAN_InitStruct member with its default value.
 397:../src/stm32f30x_can.c ****   * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which ill be initialized.
 398:../src/stm32f30x_can.c ****   * @retval None
 399:../src/stm32f30x_can.c ****   */
 400:../src/stm32f30x_can.c **** void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
 401:../src/stm32f30x_can.c **** {
 586              		.loc 1 401 0
 587              		.cfi_startproc
 588              		@ args = 0, pretend = 0, frame = 8
 589              		@ frame_needed = 1, uses_anonymous_args = 0
 590              		@ link register save eliminated.
 591 03f4 80B4     		push	{r7}
 592              	.LCFI9:
 593              		.cfi_def_cfa_offset 4
 594              		.cfi_offset 7, -4
 595 03f6 83B0     		sub	sp, sp, #12
 596              	.LCFI10:
 597              		.cfi_def_cfa_offset 16
 598 03f8 00AF     		add	r7, sp, #0
 599              	.LCFI11:
 600              		.cfi_def_cfa_register 7
 601 03fa 7860     		str	r0, [r7, #4]
 402:../src/stm32f30x_can.c ****   /* Reset CAN init structure parameters values */
 403:../src/stm32f30x_can.c ****   
 404:../src/stm32f30x_can.c ****   /* Initialize the time triggered communication mode */
 405:../src/stm32f30x_can.c ****   CAN_InitStruct->CAN_TTCM = DISABLE;
 602              		.loc 1 405 0
 603 03fc 7B68     		ldr	r3, [r7, #4]
 604 03fe 4FF00002 		mov	r2, #0
 605 0402 9A71     		strb	r2, [r3, #6]
 406:../src/stm32f30x_can.c ****   
 407:../src/stm32f30x_can.c ****   /* Initialize the automatic bus-off management */
 408:../src/stm32f30x_can.c ****   CAN_InitStruct->CAN_ABOM = DISABLE;
 606              		.loc 1 408 0
 607 0404 7B68     		ldr	r3, [r7, #4]
 608 0406 4FF00002 		mov	r2, #0
 609 040a DA71     		strb	r2, [r3, #7]
 409:../src/stm32f30x_can.c ****   
 410:../src/stm32f30x_can.c ****   /* Initialize the automatic wake-up mode */
 411:../src/stm32f30x_can.c ****   CAN_InitStruct->CAN_AWUM = DISABLE;
 610              		.loc 1 411 0
 611 040c 7B68     		ldr	r3, [r7, #4]
 612 040e 4FF00002 		mov	r2, #0
 613 0412 1A72     		strb	r2, [r3, #8]
 412:../src/stm32f30x_can.c ****   
 413:../src/stm32f30x_can.c ****   /* Initialize the no automatic retransmission */
 414:../src/stm32f30x_can.c ****   CAN_InitStruct->CAN_NART = DISABLE;
 614              		.loc 1 414 0
 615 0414 7B68     		ldr	r3, [r7, #4]
 616 0416 4FF00002 		mov	r2, #0
 617 041a 5A72     		strb	r2, [r3, #9]
 415:../src/stm32f30x_can.c ****   
 416:../src/stm32f30x_can.c ****   /* Initialize the receive FIFO locked mode */
 417:../src/stm32f30x_can.c ****   CAN_InitStruct->CAN_RFLM = DISABLE;
 618              		.loc 1 417 0
 619 041c 7B68     		ldr	r3, [r7, #4]
 620 041e 4FF00002 		mov	r2, #0
 621 0422 9A72     		strb	r2, [r3, #10]
 418:../src/stm32f30x_can.c ****   
 419:../src/stm32f30x_can.c ****   /* Initialize the transmit FIFO priority */
 420:../src/stm32f30x_can.c ****   CAN_InitStruct->CAN_TXFP = DISABLE;
 622              		.loc 1 420 0
 623 0424 7B68     		ldr	r3, [r7, #4]
 624 0426 4FF00002 		mov	r2, #0
 625 042a DA72     		strb	r2, [r3, #11]
 421:../src/stm32f30x_can.c ****   
 422:../src/stm32f30x_can.c ****   /* Initialize the CAN_Mode member */
 423:../src/stm32f30x_can.c ****   CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
 626              		.loc 1 423 0
 627 042c 7B68     		ldr	r3, [r7, #4]
 628 042e 4FF00002 		mov	r2, #0
 629 0432 9A70     		strb	r2, [r3, #2]
 424:../src/stm32f30x_can.c ****   
 425:../src/stm32f30x_can.c ****   /* Initialize the CAN_SJW member */
 426:../src/stm32f30x_can.c ****   CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
 630              		.loc 1 426 0
 631 0434 7B68     		ldr	r3, [r7, #4]
 632 0436 4FF00002 		mov	r2, #0
 633 043a DA70     		strb	r2, [r3, #3]
 427:../src/stm32f30x_can.c ****   
 428:../src/stm32f30x_can.c ****   /* Initialize the CAN_BS1 member */
 429:../src/stm32f30x_can.c ****   CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
 634              		.loc 1 429 0
 635 043c 7B68     		ldr	r3, [r7, #4]
 636 043e 4FF00302 		mov	r2, #3
 637 0442 1A71     		strb	r2, [r3, #4]
 430:../src/stm32f30x_can.c ****   
 431:../src/stm32f30x_can.c ****   /* Initialize the CAN_BS2 member */
 432:../src/stm32f30x_can.c ****   CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
 638              		.loc 1 432 0
 639 0444 7B68     		ldr	r3, [r7, #4]
 640 0446 4FF00202 		mov	r2, #2
 641 044a 5A71     		strb	r2, [r3, #5]
 433:../src/stm32f30x_can.c ****   
 434:../src/stm32f30x_can.c ****   /* Initialize the CAN_Prescaler member */
 435:../src/stm32f30x_can.c ****   CAN_InitStruct->CAN_Prescaler = 1;
 642              		.loc 1 435 0
 643 044c 7B68     		ldr	r3, [r7, #4]
 644 044e 4FF00102 		mov	r2, #1
 645 0452 1A80     		strh	r2, [r3, #0]	@ movhi
 436:../src/stm32f30x_can.c **** }
 646              		.loc 1 436 0
 647 0454 07F10C07 		add	r7, r7, #12
 648 0458 BD46     		mov	sp, r7
 649 045a 80BC     		pop	{r7}
 650 045c 7047     		bx	lr
 651              		.cfi_endproc
 652              	.LFE114:
 654 045e 00BF     		.align	2
 655              		.global	CAN_SlaveStartBank
 656              		.thumb
 657              		.thumb_func
 659              	CAN_SlaveStartBank:
 660              	.LFB115:
 437:../src/stm32f30x_can.c **** 
 438:../src/stm32f30x_can.c **** /**
 439:../src/stm32f30x_can.c ****   * @brief  Select the start bank filter for slave CAN.
 440:../src/stm32f30x_can.c ****   * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
 441:../src/stm32f30x_can.c ****   * @retval None
 442:../src/stm32f30x_can.c ****   */
 443:../src/stm32f30x_can.c **** void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
 444:../src/stm32f30x_can.c **** {
 661              		.loc 1 444 0
 662              		.cfi_startproc
 663              		@ args = 0, pretend = 0, frame = 8
 664              		@ frame_needed = 1, uses_anonymous_args = 0
 665              		@ link register save eliminated.
 666 0460 80B4     		push	{r7}
 667              	.LCFI12:
 668              		.cfi_def_cfa_offset 4
 669              		.cfi_offset 7, -4
 670 0462 83B0     		sub	sp, sp, #12
 671              	.LCFI13:
 672              		.cfi_def_cfa_offset 16
 673 0464 00AF     		add	r7, sp, #0
 674              	.LCFI14:
 675              		.cfi_def_cfa_register 7
 676 0466 0346     		mov	r3, r0
 677 0468 FB71     		strb	r3, [r7, #7]
 445:../src/stm32f30x_can.c ****   /* Check the parameters */
 446:../src/stm32f30x_can.c ****   assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
 447:../src/stm32f30x_can.c ****   
 448:../src/stm32f30x_can.c ****   /* Enter Initialisation mode for the filter */
 449:../src/stm32f30x_can.c ****   CAN1->FMR |= FMR_FINIT;
 678              		.loc 1 449 0
 679 046a 4FF4C843 		mov	r3, #25600
 680 046e C4F20003 		movt	r3, 16384
 681 0472 4FF4C842 		mov	r2, #25600
 682 0476 C4F20002 		movt	r2, 16384
 683 047a D2F80022 		ldr	r2, [r2, #512]
 684 047e 42F00102 		orr	r2, r2, #1
 685 0482 C3F80022 		str	r2, [r3, #512]
 450:../src/stm32f30x_can.c ****   
 451:../src/stm32f30x_can.c ****   /* Select the start slave bank */
 452:../src/stm32f30x_can.c ****   CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
 686              		.loc 1 452 0
 687 0486 4FF4C843 		mov	r3, #25600
 688 048a C4F20003 		movt	r3, 16384
 689 048e 4FF4C842 		mov	r2, #25600
 690 0492 C4F20002 		movt	r2, 16384
 691 0496 D2F80022 		ldr	r2, [r2, #512]
 692 049a 22F47C52 		bic	r2, r2, #16128
 693 049e 22F00E02 		bic	r2, r2, #14
 694 04a2 C3F80022 		str	r2, [r3, #512]
 453:../src/stm32f30x_can.c ****   CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
 695              		.loc 1 453 0
 696 04a6 4FF4C843 		mov	r3, #25600
 697 04aa C4F20003 		movt	r3, 16384
 698 04ae 4FF4C842 		mov	r2, #25600
 699 04b2 C4F20002 		movt	r2, 16384
 700 04b6 D2F80012 		ldr	r1, [r2, #512]
 701 04ba FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 702 04bc 4FEA0222 		lsl	r2, r2, #8
 703 04c0 0A43     		orrs	r2, r2, r1
 704 04c2 C3F80022 		str	r2, [r3, #512]
 454:../src/stm32f30x_can.c ****   
 455:../src/stm32f30x_can.c ****   /* Leave Initialisation mode for the filter */
 456:../src/stm32f30x_can.c ****   CAN1->FMR &= ~FMR_FINIT;
 705              		.loc 1 456 0
 706 04c6 4FF4C843 		mov	r3, #25600
 707 04ca C4F20003 		movt	r3, 16384
 708 04ce 4FF4C842 		mov	r2, #25600
 709 04d2 C4F20002 		movt	r2, 16384
 710 04d6 D2F80022 		ldr	r2, [r2, #512]
 711 04da 22F00102 		bic	r2, r2, #1
 712 04de C3F80022 		str	r2, [r3, #512]
 457:../src/stm32f30x_can.c **** }
 713              		.loc 1 457 0
 714 04e2 07F10C07 		add	r7, r7, #12
 715 04e6 BD46     		mov	sp, r7
 716 04e8 80BC     		pop	{r7}
 717 04ea 7047     		bx	lr
 718              		.cfi_endproc
 719              	.LFE115:
 721              		.align	2
 722              		.global	CAN_DBGFreeze
 723              		.thumb
 724              		.thumb_func
 726              	CAN_DBGFreeze:
 727              	.LFB116:
 458:../src/stm32f30x_can.c **** 
 459:../src/stm32f30x_can.c **** /**
 460:../src/stm32f30x_can.c ****   * @brief  Enables or disables the DBG Freeze for CAN.
 461:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
 462:../src/stm32f30x_can.c ****   * @param  NewState: new state of the CAN peripheral. 
 463:../src/stm32f30x_can.c ****   *          This parameter can be: ENABLE (CAN reception/transmission is frozen
 464:../src/stm32f30x_can.c ****   *          during debug. Reception FIFOs can still be accessed/controlled normally) 
 465:../src/stm32f30x_can.c ****   *          or DISABLE (CAN is working during debug).
 466:../src/stm32f30x_can.c ****   * @retval None
 467:../src/stm32f30x_can.c ****   */
 468:../src/stm32f30x_can.c **** void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
 469:../src/stm32f30x_can.c **** {
 728              		.loc 1 469 0
 729              		.cfi_startproc
 730              		@ args = 0, pretend = 0, frame = 8
 731              		@ frame_needed = 1, uses_anonymous_args = 0
 732              		@ link register save eliminated.
 733 04ec 80B4     		push	{r7}
 734              	.LCFI15:
 735              		.cfi_def_cfa_offset 4
 736              		.cfi_offset 7, -4
 737 04ee 83B0     		sub	sp, sp, #12
 738              	.LCFI16:
 739              		.cfi_def_cfa_offset 16
 740 04f0 00AF     		add	r7, sp, #0
 741              	.LCFI17:
 742              		.cfi_def_cfa_register 7
 743 04f2 7860     		str	r0, [r7, #4]
 744 04f4 0B46     		mov	r3, r1
 745 04f6 FB70     		strb	r3, [r7, #3]
 470:../src/stm32f30x_can.c ****   /* Check the parameters */
 471:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 472:../src/stm32f30x_can.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 473:../src/stm32f30x_can.c ****   
 474:../src/stm32f30x_can.c ****   if (NewState != DISABLE)
 746              		.loc 1 474 0
 747 04f8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 748 04fa 002B     		cmp	r3, #0
 749 04fc 06D0     		beq	.L36
 475:../src/stm32f30x_can.c ****   {
 476:../src/stm32f30x_can.c ****     /* Enable Debug Freeze  */
 477:../src/stm32f30x_can.c ****     CANx->MCR |= MCR_DBF;
 750              		.loc 1 477 0
 751 04fe 7B68     		ldr	r3, [r7, #4]
 752 0500 1B68     		ldr	r3, [r3, #0]
 753 0502 43F48032 		orr	r2, r3, #65536
 754 0506 7B68     		ldr	r3, [r7, #4]
 755 0508 1A60     		str	r2, [r3, #0]
 756 050a 05E0     		b	.L35
 757              	.L36:
 478:../src/stm32f30x_can.c ****   }
 479:../src/stm32f30x_can.c ****   else
 480:../src/stm32f30x_can.c ****   {
 481:../src/stm32f30x_can.c ****     /* Disable Debug Freeze */
 482:../src/stm32f30x_can.c ****     CANx->MCR &= ~MCR_DBF;
 758              		.loc 1 482 0
 759 050c 7B68     		ldr	r3, [r7, #4]
 760 050e 1B68     		ldr	r3, [r3, #0]
 761 0510 23F48032 		bic	r2, r3, #65536
 762 0514 7B68     		ldr	r3, [r7, #4]
 763 0516 1A60     		str	r2, [r3, #0]
 764              	.L35:
 483:../src/stm32f30x_can.c ****   }
 484:../src/stm32f30x_can.c **** }
 765              		.loc 1 484 0
 766 0518 07F10C07 		add	r7, r7, #12
 767 051c BD46     		mov	sp, r7
 768 051e 80BC     		pop	{r7}
 769 0520 7047     		bx	lr
 770              		.cfi_endproc
 771              	.LFE116:
 773 0522 00BF     		.align	2
 774              		.global	CAN_TTComModeCmd
 775              		.thumb
 776              		.thumb_func
 778              	CAN_TTComModeCmd:
 779              	.LFB117:
 485:../src/stm32f30x_can.c **** 
 486:../src/stm32f30x_can.c **** /**
 487:../src/stm32f30x_can.c ****   * @brief  Enables or disables the CAN Time TriggerOperation communication mode.
 488:../src/stm32f30x_can.c ****   * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
 489:../src/stm32f30x_can.c ****   *         sent over the CAN bus.  
 490:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
 491:../src/stm32f30x_can.c ****   * @param  NewState: Mode new state. This parameter can be: ENABLE or DISABLE.
 492:../src/stm32f30x_can.c ****   *         When enabled, Time stamp (TIME[15:0]) value is  sent in the last two
 493:../src/stm32f30x_can.c ****   *         data bytes of the 8-byte message: TIME[7:0] in data byte 6 and TIME[15:8] 
 494:../src/stm32f30x_can.c ****   *         in data byte 7. 
 495:../src/stm32f30x_can.c ****   * @retval None
 496:../src/stm32f30x_can.c ****   */
 497:../src/stm32f30x_can.c **** void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
 498:../src/stm32f30x_can.c **** {
 780              		.loc 1 498 0
 781              		.cfi_startproc
 782              		@ args = 0, pretend = 0, frame = 8
 783              		@ frame_needed = 1, uses_anonymous_args = 0
 784              		@ link register save eliminated.
 785 0524 80B4     		push	{r7}
 786              	.LCFI18:
 787              		.cfi_def_cfa_offset 4
 788              		.cfi_offset 7, -4
 789 0526 83B0     		sub	sp, sp, #12
 790              	.LCFI19:
 791              		.cfi_def_cfa_offset 16
 792 0528 00AF     		add	r7, sp, #0
 793              	.LCFI20:
 794              		.cfi_def_cfa_register 7
 795 052a 7860     		str	r0, [r7, #4]
 796 052c 0B46     		mov	r3, r1
 797 052e FB70     		strb	r3, [r7, #3]
 499:../src/stm32f30x_can.c ****   /* Check the parameters */
 500:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 501:../src/stm32f30x_can.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 502:../src/stm32f30x_can.c ****   if (NewState != DISABLE)
 798              		.loc 1 502 0
 799 0530 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 800 0532 002B     		cmp	r3, #0
 801 0534 1ED0     		beq	.L39
 503:../src/stm32f30x_can.c ****   {
 504:../src/stm32f30x_can.c ****     /* Enable the TTCM mode */
 505:../src/stm32f30x_can.c ****     CANx->MCR |= CAN_MCR_TTCM;
 802              		.loc 1 505 0
 803 0536 7B68     		ldr	r3, [r7, #4]
 804 0538 1B68     		ldr	r3, [r3, #0]
 805 053a 43F08002 		orr	r2, r3, #128
 806 053e 7B68     		ldr	r3, [r7, #4]
 807 0540 1A60     		str	r2, [r3, #0]
 506:../src/stm32f30x_can.c **** 
 507:../src/stm32f30x_can.c ****     /* Set TGT bits */
 508:../src/stm32f30x_can.c ****     CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
 808              		.loc 1 508 0
 809 0542 7B68     		ldr	r3, [r7, #4]
 810 0544 D3F88431 		ldr	r3, [r3, #388]
 811 0548 43F48072 		orr	r2, r3, #256
 812 054c 7B68     		ldr	r3, [r7, #4]
 813 054e C3F88421 		str	r2, [r3, #388]
 509:../src/stm32f30x_can.c ****     CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
 814              		.loc 1 509 0
 815 0552 7B68     		ldr	r3, [r7, #4]
 816 0554 D3F89431 		ldr	r3, [r3, #404]
 817 0558 43F48072 		orr	r2, r3, #256
 818 055c 7B68     		ldr	r3, [r7, #4]
 819 055e C3F89421 		str	r2, [r3, #404]
 510:../src/stm32f30x_can.c ****     CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
 820              		.loc 1 510 0
 821 0562 7B68     		ldr	r3, [r7, #4]
 822 0564 D3F8A431 		ldr	r3, [r3, #420]
 823 0568 43F48072 		orr	r2, r3, #256
 824 056c 7B68     		ldr	r3, [r7, #4]
 825 056e C3F8A421 		str	r2, [r3, #420]
 826 0572 1DE0     		b	.L38
 827              	.L39:
 511:../src/stm32f30x_can.c ****   }
 512:../src/stm32f30x_can.c ****   else
 513:../src/stm32f30x_can.c ****   {
 514:../src/stm32f30x_can.c ****     /* Disable the TTCM mode */
 515:../src/stm32f30x_can.c ****     CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
 828              		.loc 1 515 0
 829 0574 7B68     		ldr	r3, [r7, #4]
 830 0576 1B68     		ldr	r3, [r3, #0]
 831 0578 23F08002 		bic	r2, r3, #128
 832 057c 7B68     		ldr	r3, [r7, #4]
 833 057e 1A60     		str	r2, [r3, #0]
 516:../src/stm32f30x_can.c **** 
 517:../src/stm32f30x_can.c ****     /* Reset TGT bits */
 518:../src/stm32f30x_can.c ****     CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
 834              		.loc 1 518 0
 835 0580 7B68     		ldr	r3, [r7, #4]
 836 0582 D3F88431 		ldr	r3, [r3, #388]
 837 0586 23F48072 		bic	r2, r3, #256
 838 058a 7B68     		ldr	r3, [r7, #4]
 839 058c C3F88421 		str	r2, [r3, #388]
 519:../src/stm32f30x_can.c ****     CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
 840              		.loc 1 519 0
 841 0590 7B68     		ldr	r3, [r7, #4]
 842 0592 D3F89431 		ldr	r3, [r3, #404]
 843 0596 23F48072 		bic	r2, r3, #256
 844 059a 7B68     		ldr	r3, [r7, #4]
 845 059c C3F89421 		str	r2, [r3, #404]
 520:../src/stm32f30x_can.c ****     CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
 846              		.loc 1 520 0
 847 05a0 7B68     		ldr	r3, [r7, #4]
 848 05a2 D3F8A431 		ldr	r3, [r3, #420]
 849 05a6 23F48072 		bic	r2, r3, #256
 850 05aa 7B68     		ldr	r3, [r7, #4]
 851 05ac C3F8A421 		str	r2, [r3, #420]
 852              	.L38:
 521:../src/stm32f30x_can.c ****   }
 522:../src/stm32f30x_can.c **** }
 853              		.loc 1 522 0
 854 05b0 07F10C07 		add	r7, r7, #12
 855 05b4 BD46     		mov	sp, r7
 856 05b6 80BC     		pop	{r7}
 857 05b8 7047     		bx	lr
 858              		.cfi_endproc
 859              	.LFE117:
 861 05ba 00BF     		.align	2
 862              		.global	CAN_Transmit
 863              		.thumb
 864              		.thumb_func
 866              	CAN_Transmit:
 867              	.LFB118:
 523:../src/stm32f30x_can.c **** /**
 524:../src/stm32f30x_can.c ****   * @}
 525:../src/stm32f30x_can.c ****   */
 526:../src/stm32f30x_can.c **** 
 527:../src/stm32f30x_can.c **** 
 528:../src/stm32f30x_can.c **** /** @defgroup CAN_Group2 CAN Frames Transmission functions
 529:../src/stm32f30x_can.c ****  *  @brief    CAN Frames Transmission functions 
 530:../src/stm32f30x_can.c ****  *
 531:../src/stm32f30x_can.c **** @verbatim    
 532:../src/stm32f30x_can.c ****  ===============================================================================
 533:../src/stm32f30x_can.c ****                 ##### CAN Frames Transmission functions #####
 534:../src/stm32f30x_can.c ****  ===============================================================================  
 535:../src/stm32f30x_can.c ****     [..] This section provides functions allowing to 
 536:../src/stm32f30x_can.c ****          (+) Initiate and transmit a CAN frame message (if there is an empty mailbox).
 537:../src/stm32f30x_can.c ****          (+) Check the transmission status of a CAN Frame.
 538:../src/stm32f30x_can.c ****          (+) Cancel a transmit request.
 539:../src/stm32f30x_can.c ****    
 540:../src/stm32f30x_can.c **** @endverbatim
 541:../src/stm32f30x_can.c ****   * @{
 542:../src/stm32f30x_can.c ****   */
 543:../src/stm32f30x_can.c **** 
 544:../src/stm32f30x_can.c **** /**
 545:../src/stm32f30x_can.c ****   * @brief  Initiates and transmits a CAN frame message.
 546:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
 547:../src/stm32f30x_can.c ****   * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
 548:../src/stm32f30x_can.c ****   * @retval The number of the mailbox that is used for transmission or
 549:../src/stm32f30x_can.c ****   *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
 550:../src/stm32f30x_can.c ****   */
 551:../src/stm32f30x_can.c **** uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
 552:../src/stm32f30x_can.c **** {
 868              		.loc 1 552 0
 869              		.cfi_startproc
 870              		@ args = 0, pretend = 0, frame = 16
 871              		@ frame_needed = 1, uses_anonymous_args = 0
 872              		@ link register save eliminated.
 873 05bc 80B4     		push	{r7}
 874              	.LCFI21:
 875              		.cfi_def_cfa_offset 4
 876              		.cfi_offset 7, -4
 877 05be 85B0     		sub	sp, sp, #20
 878              	.LCFI22:
 879              		.cfi_def_cfa_offset 24
 880 05c0 00AF     		add	r7, sp, #0
 881              	.LCFI23:
 882              		.cfi_def_cfa_register 7
 883 05c2 7860     		str	r0, [r7, #4]
 884 05c4 3960     		str	r1, [r7, #0]
 553:../src/stm32f30x_can.c ****   uint8_t transmit_mailbox = 0;
 885              		.loc 1 553 0
 886 05c6 4FF00003 		mov	r3, #0
 887 05ca FB73     		strb	r3, [r7, #15]
 554:../src/stm32f30x_can.c ****   /* Check the parameters */
 555:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 556:../src/stm32f30x_can.c ****   assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
 557:../src/stm32f30x_can.c ****   assert_param(IS_CAN_RTR(TxMessage->RTR));
 558:../src/stm32f30x_can.c ****   assert_param(IS_CAN_DLC(TxMessage->DLC));
 559:../src/stm32f30x_can.c **** 
 560:../src/stm32f30x_can.c ****   /* Select one empty transmit mailbox */
 561:../src/stm32f30x_can.c ****   if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
 888              		.loc 1 561 0
 889 05cc 7B68     		ldr	r3, [r7, #4]
 890 05ce 9B68     		ldr	r3, [r3, #8]
 891 05d0 03F08063 		and	r3, r3, #67108864
 892 05d4 002B     		cmp	r3, #0
 893 05d6 03D0     		beq	.L42
 562:../src/stm32f30x_can.c ****   {
 563:../src/stm32f30x_can.c ****     transmit_mailbox = 0;
 894              		.loc 1 563 0
 895 05d8 4FF00003 		mov	r3, #0
 896 05dc FB73     		strb	r3, [r7, #15]
 897 05de 16E0     		b	.L43
 898              	.L42:
 564:../src/stm32f30x_can.c ****   }
 565:../src/stm32f30x_can.c ****   else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
 899              		.loc 1 565 0
 900 05e0 7B68     		ldr	r3, [r7, #4]
 901 05e2 9B68     		ldr	r3, [r3, #8]
 902 05e4 03F00063 		and	r3, r3, #134217728
 903 05e8 002B     		cmp	r3, #0
 904 05ea 03D0     		beq	.L44
 566:../src/stm32f30x_can.c ****   {
 567:../src/stm32f30x_can.c ****     transmit_mailbox = 1;
 905              		.loc 1 567 0
 906 05ec 4FF00103 		mov	r3, #1
 907 05f0 FB73     		strb	r3, [r7, #15]
 908 05f2 0CE0     		b	.L43
 909              	.L44:
 568:../src/stm32f30x_can.c ****   }
 569:../src/stm32f30x_can.c ****   else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
 910              		.loc 1 569 0
 911 05f4 7B68     		ldr	r3, [r7, #4]
 912 05f6 9B68     		ldr	r3, [r3, #8]
 913 05f8 03F08053 		and	r3, r3, #268435456
 914 05fc 002B     		cmp	r3, #0
 915 05fe 03D0     		beq	.L45
 570:../src/stm32f30x_can.c ****   {
 571:../src/stm32f30x_can.c ****     transmit_mailbox = 2;
 916              		.loc 1 571 0
 917 0600 4FF00203 		mov	r3, #2
 918 0604 FB73     		strb	r3, [r7, #15]
 919 0606 02E0     		b	.L43
 920              	.L45:
 572:../src/stm32f30x_can.c ****   }
 573:../src/stm32f30x_can.c ****   else
 574:../src/stm32f30x_can.c ****   {
 575:../src/stm32f30x_can.c ****     transmit_mailbox = CAN_TxStatus_NoMailBox;
 921              		.loc 1 575 0
 922 0608 4FF00403 		mov	r3, #4
 923 060c FB73     		strb	r3, [r7, #15]
 924              	.L43:
 576:../src/stm32f30x_can.c ****   }
 577:../src/stm32f30x_can.c **** 
 578:../src/stm32f30x_can.c ****   if (transmit_mailbox != CAN_TxStatus_NoMailBox)
 925              		.loc 1 578 0
 926 060e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 927 0610 042B     		cmp	r3, #4
 928 0612 00F0BA80 		beq	.L46
 579:../src/stm32f30x_can.c ****   {
 580:../src/stm32f30x_can.c ****     /* Set up the Id */
 581:../src/stm32f30x_can.c ****     CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
 929              		.loc 1 581 0
 930 0616 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 931 0618 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 932 061a 7968     		ldr	r1, [r7, #4]
 933 061c 02F11802 		add	r2, r2, #24
 934 0620 4FEA0212 		lsl	r2, r2, #4
 935 0624 8A18     		adds	r2, r1, r2
 936 0626 1268     		ldr	r2, [r2, #0]
 937 0628 02F00102 		and	r2, r2, #1
 938 062c 7968     		ldr	r1, [r7, #4]
 939 062e 03F11803 		add	r3, r3, #24
 940 0632 4FEA0313 		lsl	r3, r3, #4
 941 0636 CB18     		adds	r3, r1, r3
 942 0638 1A60     		str	r2, [r3, #0]
 582:../src/stm32f30x_can.c ****     if (TxMessage->IDE == CAN_Id_Standard)
 943              		.loc 1 582 0
 944 063a 3B68     		ldr	r3, [r7, #0]
 945 063c 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 946 063e 002B     		cmp	r3, #0
 947 0640 18D1     		bne	.L47
 583:../src/stm32f30x_can.c ****     {
 584:../src/stm32f30x_can.c ****       assert_param(IS_CAN_STDID(TxMessage->StdId));  
 585:../src/stm32f30x_can.c ****       CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
 948              		.loc 1 585 0
 949 0642 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 950 0644 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 951 0646 7968     		ldr	r1, [r7, #4]
 952 0648 02F11802 		add	r2, r2, #24
 953 064c 4FEA0212 		lsl	r2, r2, #4
 954 0650 8A18     		adds	r2, r1, r2
 955 0652 1168     		ldr	r1, [r2, #0]
 956 0654 3A68     		ldr	r2, [r7, #0]
 957 0656 1268     		ldr	r2, [r2, #0]
 958 0658 4FEA4250 		lsl	r0, r2, #21
 586:../src/stm32f30x_can.c ****                                                   TxMessage->RTR);
 959              		.loc 1 586 0
 960 065c 3A68     		ldr	r2, [r7, #0]
 961 065e 527A     		ldrb	r2, [r2, #9]	@ zero_extendqisi2
 585:../src/stm32f30x_can.c ****       CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
 962              		.loc 1 585 0
 963 0660 0243     		orrs	r2, r2, r0
 964 0662 0A43     		orrs	r2, r2, r1
 965 0664 7968     		ldr	r1, [r7, #4]
 966 0666 03F11803 		add	r3, r3, #24
 967 066a 4FEA0313 		lsl	r3, r3, #4
 968 066e CB18     		adds	r3, r1, r3
 969 0670 1A60     		str	r2, [r3, #0]
 970 0672 1AE0     		b	.L48
 971              	.L47:
 587:../src/stm32f30x_can.c ****     }
 588:../src/stm32f30x_can.c ****     else
 589:../src/stm32f30x_can.c ****     {
 590:../src/stm32f30x_can.c ****       assert_param(IS_CAN_EXTID(TxMessage->ExtId));
 591:../src/stm32f30x_can.c ****       CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
 972              		.loc 1 591 0
 973 0674 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 974 0676 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 975 0678 7968     		ldr	r1, [r7, #4]
 976 067a 02F11802 		add	r2, r2, #24
 977 067e 4FEA0212 		lsl	r2, r2, #4
 978 0682 8A18     		adds	r2, r1, r2
 979 0684 1168     		ldr	r1, [r2, #0]
 980 0686 3A68     		ldr	r2, [r7, #0]
 981 0688 5268     		ldr	r2, [r2, #4]
 982 068a 4FEAC200 		lsl	r0, r2, #3
 592:../src/stm32f30x_can.c ****                                                   TxMessage->IDE | \
 983              		.loc 1 592 0
 984 068e 3A68     		ldr	r2, [r7, #0]
 985 0690 127A     		ldrb	r2, [r2, #8]	@ zero_extendqisi2
 591:../src/stm32f30x_can.c ****       CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
 986              		.loc 1 591 0
 987 0692 1043     		orrs	r0, r0, r2
 593:../src/stm32f30x_can.c ****                                                   TxMessage->RTR);
 988              		.loc 1 593 0
 989 0694 3A68     		ldr	r2, [r7, #0]
 990 0696 527A     		ldrb	r2, [r2, #9]	@ zero_extendqisi2
 592:../src/stm32f30x_can.c ****                                                   TxMessage->IDE | \
 991              		.loc 1 592 0
 992 0698 0243     		orrs	r2, r2, r0
 591:../src/stm32f30x_can.c ****       CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
 993              		.loc 1 591 0
 994 069a 0A43     		orrs	r2, r2, r1
 995 069c 7968     		ldr	r1, [r7, #4]
 996 069e 03F11803 		add	r3, r3, #24
 997 06a2 4FEA0313 		lsl	r3, r3, #4
 998 06a6 CB18     		adds	r3, r1, r3
 999 06a8 1A60     		str	r2, [r3, #0]
 1000              	.L48:
 594:../src/stm32f30x_can.c ****     }
 595:../src/stm32f30x_can.c ****     
 596:../src/stm32f30x_can.c ****     /* Set up the DLC */
 597:../src/stm32f30x_can.c ****     TxMessage->DLC &= (uint8_t)0x0000000F;
 1001              		.loc 1 597 0
 1002 06aa 3B68     		ldr	r3, [r7, #0]
 1003 06ac 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 1004 06ae 03F00F03 		and	r3, r3, #15
 1005 06b2 DAB2     		uxtb	r2, r3
 1006 06b4 3B68     		ldr	r3, [r7, #0]
 1007 06b6 9A72     		strb	r2, [r3, #10]
 598:../src/stm32f30x_can.c ****     CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
 1008              		.loc 1 598 0
 1009 06b8 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1010 06ba FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 1011 06bc 7968     		ldr	r1, [r7, #4]
 1012 06be 02F11802 		add	r2, r2, #24
 1013 06c2 4FEA0212 		lsl	r2, r2, #4
 1014 06c6 8A18     		adds	r2, r1, r2
 1015 06c8 5268     		ldr	r2, [r2, #4]
 1016 06ca 22F00F02 		bic	r2, r2, #15
 1017 06ce 7968     		ldr	r1, [r7, #4]
 1018 06d0 03F11803 		add	r3, r3, #24
 1019 06d4 4FEA0313 		lsl	r3, r3, #4
 1020 06d8 CB18     		adds	r3, r1, r3
 1021 06da 5A60     		str	r2, [r3, #4]
 599:../src/stm32f30x_can.c ****     CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
 1022              		.loc 1 599 0
 1023 06dc FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1024 06de FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 1025 06e0 7968     		ldr	r1, [r7, #4]
 1026 06e2 02F11802 		add	r2, r2, #24
 1027 06e6 4FEA0212 		lsl	r2, r2, #4
 1028 06ea 8A18     		adds	r2, r1, r2
 1029 06ec 5168     		ldr	r1, [r2, #4]
 1030 06ee 3A68     		ldr	r2, [r7, #0]
 1031 06f0 927A     		ldrb	r2, [r2, #10]	@ zero_extendqisi2
 1032 06f2 0A43     		orrs	r2, r2, r1
 1033 06f4 7968     		ldr	r1, [r7, #4]
 1034 06f6 03F11803 		add	r3, r3, #24
 1035 06fa 4FEA0313 		lsl	r3, r3, #4
 1036 06fe CB18     		adds	r3, r1, r3
 1037 0700 5A60     		str	r2, [r3, #4]
 600:../src/stm32f30x_can.c **** 
 601:../src/stm32f30x_can.c ****     /* Set up the data field */
 602:../src/stm32f30x_can.c ****     CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
 1038              		.loc 1 602 0
 1039 0702 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1040 0704 3A68     		ldr	r2, [r7, #0]
 1041 0706 927B     		ldrb	r2, [r2, #14]	@ zero_extendqisi2
 1042 0708 4FEA0261 		lsl	r1, r2, #24
 603:../src/stm32f30x_can.c ****                                              ((uint32_t)TxMessage->Data[2] << 16) |
 1043              		.loc 1 603 0
 1044 070c 3A68     		ldr	r2, [r7, #0]
 1045 070e 527B     		ldrb	r2, [r2, #13]	@ zero_extendqisi2
 1046 0710 4FEA0242 		lsl	r2, r2, #16
 602:../src/stm32f30x_can.c ****     CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
 1047              		.loc 1 602 0
 1048 0714 1143     		orrs	r1, r1, r2
 604:../src/stm32f30x_can.c ****                                              ((uint32_t)TxMessage->Data[1] << 8) | 
 1049              		.loc 1 604 0
 1050 0716 3A68     		ldr	r2, [r7, #0]
 1051 0718 127B     		ldrb	r2, [r2, #12]	@ zero_extendqisi2
 1052 071a 4FEA0222 		lsl	r2, r2, #8
 603:../src/stm32f30x_can.c ****                                              ((uint32_t)TxMessage->Data[2] << 16) |
 1053              		.loc 1 603 0
 1054 071e 1143     		orrs	r1, r1, r2
 605:../src/stm32f30x_can.c ****                                              ((uint32_t)TxMessage->Data[0]));
 1055              		.loc 1 605 0
 1056 0720 3A68     		ldr	r2, [r7, #0]
 1057 0722 D27A     		ldrb	r2, [r2, #11]	@ zero_extendqisi2
 604:../src/stm32f30x_can.c ****                                              ((uint32_t)TxMessage->Data[1] << 8) | 
 1058              		.loc 1 604 0
 1059 0724 0A43     		orrs	r2, r2, r1
 602:../src/stm32f30x_can.c ****     CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
 1060              		.loc 1 602 0
 1061 0726 7968     		ldr	r1, [r7, #4]
 1062 0728 4FEA0313 		lsl	r3, r3, #4
 1063 072c CB18     		adds	r3, r1, r3
 1064 072e 03F5C473 		add	r3, r3, #392
 1065 0732 1A60     		str	r2, [r3, #0]
 606:../src/stm32f30x_can.c ****     CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
 1066              		.loc 1 606 0
 1067 0734 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1068 0736 3A68     		ldr	r2, [r7, #0]
 1069 0738 927C     		ldrb	r2, [r2, #18]	@ zero_extendqisi2
 1070 073a 4FEA0261 		lsl	r1, r2, #24
 607:../src/stm32f30x_can.c ****                                              ((uint32_t)TxMessage->Data[6] << 16) |
 1071              		.loc 1 607 0
 1072 073e 3A68     		ldr	r2, [r7, #0]
 1073 0740 527C     		ldrb	r2, [r2, #17]	@ zero_extendqisi2
 1074 0742 4FEA0242 		lsl	r2, r2, #16
 606:../src/stm32f30x_can.c ****     CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
 1075              		.loc 1 606 0
 1076 0746 1143     		orrs	r1, r1, r2
 608:../src/stm32f30x_can.c ****                                              ((uint32_t)TxMessage->Data[5] << 8) |
 1077              		.loc 1 608 0
 1078 0748 3A68     		ldr	r2, [r7, #0]
 1079 074a 127C     		ldrb	r2, [r2, #16]	@ zero_extendqisi2
 1080 074c 4FEA0222 		lsl	r2, r2, #8
 607:../src/stm32f30x_can.c ****                                              ((uint32_t)TxMessage->Data[6] << 16) |
 1081              		.loc 1 607 0
 1082 0750 1143     		orrs	r1, r1, r2
 609:../src/stm32f30x_can.c ****                                              ((uint32_t)TxMessage->Data[4]));
 1083              		.loc 1 609 0
 1084 0752 3A68     		ldr	r2, [r7, #0]
 1085 0754 D27B     		ldrb	r2, [r2, #15]	@ zero_extendqisi2
 608:../src/stm32f30x_can.c ****                                              ((uint32_t)TxMessage->Data[5] << 8) |
 1086              		.loc 1 608 0
 1087 0756 0A43     		orrs	r2, r2, r1
 606:../src/stm32f30x_can.c ****     CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
 1088              		.loc 1 606 0
 1089 0758 7968     		ldr	r1, [r7, #4]
 1090 075a 4FEA0313 		lsl	r3, r3, #4
 1091 075e CB18     		adds	r3, r1, r3
 1092 0760 03F5C473 		add	r3, r3, #392
 1093 0764 5A60     		str	r2, [r3, #4]
 610:../src/stm32f30x_can.c ****     /* Request transmission */
 611:../src/stm32f30x_can.c ****     CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
 1094              		.loc 1 611 0
 1095 0766 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1096 0768 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 1097 076a 7968     		ldr	r1, [r7, #4]
 1098 076c 02F11802 		add	r2, r2, #24
 1099 0770 4FEA0212 		lsl	r2, r2, #4
 1100 0774 8A18     		adds	r2, r1, r2
 1101 0776 1268     		ldr	r2, [r2, #0]
 1102 0778 42F00102 		orr	r2, r2, #1
 1103 077c 7968     		ldr	r1, [r7, #4]
 1104 077e 03F11803 		add	r3, r3, #24
 1105 0782 4FEA0313 		lsl	r3, r3, #4
 1106 0786 CB18     		adds	r3, r1, r3
 1107 0788 1A60     		str	r2, [r3, #0]
 1108              	.L46:
 612:../src/stm32f30x_can.c ****   }
 613:../src/stm32f30x_can.c ****   return transmit_mailbox;
 1109              		.loc 1 613 0
 1110 078a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 614:../src/stm32f30x_can.c **** }
 1111              		.loc 1 614 0
 1112 078c 1846     		mov	r0, r3
 1113 078e 07F11407 		add	r7, r7, #20
 1114 0792 BD46     		mov	sp, r7
 1115 0794 80BC     		pop	{r7}
 1116 0796 7047     		bx	lr
 1117              		.cfi_endproc
 1118              	.LFE118:
 1120              		.align	2
 1121              		.global	CAN_TransmitStatus
 1122              		.thumb
 1123              		.thumb_func
 1125              	CAN_TransmitStatus:
 1126              	.LFB119:
 615:../src/stm32f30x_can.c **** 
 616:../src/stm32f30x_can.c **** /**
 617:../src/stm32f30x_can.c ****   * @brief  Checks the transmission status of a CAN Frame.
 618:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 to select the CAN1 peripheral.
 619:../src/stm32f30x_can.c ****   * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
 620:../src/stm32f30x_can.c ****   * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, 
 621:../src/stm32f30x_can.c ****   *         CAN_TxStatus_Failed in an other case.
 622:../src/stm32f30x_can.c ****   */
 623:../src/stm32f30x_can.c **** uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
 624:../src/stm32f30x_can.c **** {
 1127              		.loc 1 624 0
 1128              		.cfi_startproc
 1129              		@ args = 0, pretend = 0, frame = 16
 1130              		@ frame_needed = 1, uses_anonymous_args = 0
 1131              		@ link register save eliminated.
 1132 0798 80B4     		push	{r7}
 1133              	.LCFI24:
 1134              		.cfi_def_cfa_offset 4
 1135              		.cfi_offset 7, -4
 1136 079a 85B0     		sub	sp, sp, #20
 1137              	.LCFI25:
 1138              		.cfi_def_cfa_offset 24
 1139 079c 00AF     		add	r7, sp, #0
 1140              	.LCFI26:
 1141              		.cfi_def_cfa_register 7
 1142 079e 7860     		str	r0, [r7, #4]
 1143 07a0 0B46     		mov	r3, r1
 1144 07a2 FB70     		strb	r3, [r7, #3]
 625:../src/stm32f30x_can.c ****   uint32_t state = 0;
 1145              		.loc 1 625 0
 1146 07a4 4FF00003 		mov	r3, #0
 1147 07a8 FB60     		str	r3, [r7, #12]
 626:../src/stm32f30x_can.c **** 
 627:../src/stm32f30x_can.c ****   /* Check the parameters */
 628:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 629:../src/stm32f30x_can.c ****   assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
 630:../src/stm32f30x_can.c ****  
 631:../src/stm32f30x_can.c ****   switch (TransmitMailbox)
 1148              		.loc 1 631 0
 1149 07aa FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1150 07ac 012B     		cmp	r3, #1
 1151 07ae 0CD0     		beq	.L53
 1152 07b0 022B     		cmp	r3, #2
 1153 07b2 13D0     		beq	.L54
 1154 07b4 002B     		cmp	r3, #0
 1155 07b6 1AD1     		bne	.L67
 1156              	.L52:
 632:../src/stm32f30x_can.c ****   {
 633:../src/stm32f30x_can.c ****     case (CAN_TXMAILBOX_0): 
 634:../src/stm32f30x_can.c ****       state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
 1157              		.loc 1 634 0
 1158 07b8 7B68     		ldr	r3, [r7, #4]
 1159 07ba 9A68     		ldr	r2, [r3, #8]
 1160 07bc 4FF00303 		mov	r3, #3
 1161 07c0 C0F20043 		movt	r3, 1024
 1162 07c4 1340     		ands	r3, r3, r2
 1163 07c6 FB60     		str	r3, [r7, #12]
 635:../src/stm32f30x_can.c ****       break;
 1164              		.loc 1 635 0
 1165 07c8 15E0     		b	.L55
 1166              	.L53:
 636:../src/stm32f30x_can.c ****     case (CAN_TXMAILBOX_1): 
 637:../src/stm32f30x_can.c ****       state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
 1167              		.loc 1 637 0
 1168 07ca 7B68     		ldr	r3, [r7, #4]
 1169 07cc 9A68     		ldr	r2, [r3, #8]
 1170 07ce 4FF44073 		mov	r3, #768
 1171 07d2 C0F60003 		movt	r3, 2048
 1172 07d6 1340     		ands	r3, r3, r2
 1173 07d8 FB60     		str	r3, [r7, #12]
 638:../src/stm32f30x_can.c ****       break;
 1174              		.loc 1 638 0
 1175 07da 0CE0     		b	.L55
 1176              	.L54:
 639:../src/stm32f30x_can.c ****     case (CAN_TXMAILBOX_2): 
 640:../src/stm32f30x_can.c ****       state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
 1177              		.loc 1 640 0
 1178 07dc 7B68     		ldr	r3, [r7, #4]
 1179 07de 9A68     		ldr	r2, [r3, #8]
 1180 07e0 4FF00003 		mov	r3, #0
 1181 07e4 C1F20303 		movt	r3, 4099
 1182 07e8 1340     		ands	r3, r3, r2
 1183 07ea FB60     		str	r3, [r7, #12]
 641:../src/stm32f30x_can.c ****       break;
 1184              		.loc 1 641 0
 1185 07ec 03E0     		b	.L55
 1186              	.L67:
 642:../src/stm32f30x_can.c ****     default:
 643:../src/stm32f30x_can.c ****       state = CAN_TxStatus_Failed;
 1187              		.loc 1 643 0
 1188 07ee 4FF00003 		mov	r3, #0
 1189 07f2 FB60     		str	r3, [r7, #12]
 644:../src/stm32f30x_can.c ****       break;
 1190              		.loc 1 644 0
 1191 07f4 00BF     		nop
 1192              	.L55:
 645:../src/stm32f30x_can.c ****   }
 646:../src/stm32f30x_can.c ****   switch (state)
 1193              		.loc 1 646 0
 1194 07f6 FB68     		ldr	r3, [r7, #12]
 1195 07f8 4FF48072 		mov	r2, #256
 1196 07fc C0F60002 		movt	r2, 2048
 1197 0800 9342     		cmp	r3, r2
 1198 0802 2FD0     		beq	.L60
 1199 0804 4FF48072 		mov	r2, #256
 1200 0808 C0F60002 		movt	r2, 2048
 1201 080c 9342     		cmp	r3, r2
 1202 080e 0ED8     		bhi	.L64
 1203 0810 4FF00102 		mov	r2, #1
 1204 0814 C0F20042 		movt	r2, 1024
 1205 0818 9342     		cmp	r3, r2
 1206 081a 1FD0     		beq	.L58
 1207 081c 4FF00302 		mov	r2, #3
 1208 0820 C0F20042 		movt	r2, 1024
 1209 0824 9342     		cmp	r3, r2
 1210 0826 25D0     		beq	.L59
 1211 0828 002B     		cmp	r3, #0
 1212 082a 13D0     		beq	.L57
 1213 082c 2EE0     		b	.L56
 1214              	.L64:
 1215 082e 4FF00002 		mov	r2, #0
 1216 0832 C1F20102 		movt	r2, 4097
 1217 0836 9342     		cmp	r3, r2
 1218 0838 18D0     		beq	.L62
 1219 083a 4FF00002 		mov	r2, #0
 1220 083e C1F20302 		movt	r2, 4099
 1221 0842 9342     		cmp	r3, r2
 1222 0844 1ED0     		beq	.L63
 1223 0846 4FF44072 		mov	r2, #768
 1224 084a C0F60002 		movt	r2, 2048
 1225 084e 9342     		cmp	r3, r2
 1226 0850 14D0     		beq	.L61
 1227 0852 1BE0     		b	.L56
 1228              	.L57:
 647:../src/stm32f30x_can.c ****   {
 648:../src/stm32f30x_can.c ****       /* transmit pending  */
 649:../src/stm32f30x_can.c ****     case (0x0): state = CAN_TxStatus_Pending;
 1229              		.loc 1 649 0
 1230 0854 4FF00203 		mov	r3, #2
 1231 0858 FB60     		str	r3, [r7, #12]
 650:../src/stm32f30x_can.c ****       break;
 1232              		.loc 1 650 0
 1233 085a 1BE0     		b	.L65
 1234              	.L58:
 651:../src/stm32f30x_can.c ****       /* transmit failed  */
 652:../src/stm32f30x_can.c ****      case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
 1235              		.loc 1 652 0
 1236 085c 4FF00003 		mov	r3, #0
 1237 0860 FB60     		str	r3, [r7, #12]
 653:../src/stm32f30x_can.c ****       break;
 1238              		.loc 1 653 0
 1239 0862 17E0     		b	.L65
 1240              	.L60:
 654:../src/stm32f30x_can.c ****      case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
 1241              		.loc 1 654 0
 1242 0864 4FF00003 		mov	r3, #0
 1243 0868 FB60     		str	r3, [r7, #12]
 655:../src/stm32f30x_can.c ****       break;
 1244              		.loc 1 655 0
 1245 086a 13E0     		b	.L65
 1246              	.L62:
 656:../src/stm32f30x_can.c ****      case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
 1247              		.loc 1 656 0
 1248 086c 4FF00003 		mov	r3, #0
 1249 0870 FB60     		str	r3, [r7, #12]
 657:../src/stm32f30x_can.c ****       break;
 1250              		.loc 1 657 0
 1251 0872 0FE0     		b	.L65
 1252              	.L59:
 658:../src/stm32f30x_can.c ****       /* transmit succeeded  */
 659:../src/stm32f30x_can.c ****     case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
 1253              		.loc 1 659 0
 1254 0874 4FF00103 		mov	r3, #1
 1255 0878 FB60     		str	r3, [r7, #12]
 660:../src/stm32f30x_can.c ****       break;
 1256              		.loc 1 660 0
 1257 087a 0BE0     		b	.L65
 1258              	.L61:
 661:../src/stm32f30x_can.c ****     case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
 1259              		.loc 1 661 0
 1260 087c 4FF00103 		mov	r3, #1
 1261 0880 FB60     		str	r3, [r7, #12]
 662:../src/stm32f30x_can.c ****       break;
 1262              		.loc 1 662 0
 1263 0882 07E0     		b	.L65
 1264              	.L63:
 663:../src/stm32f30x_can.c ****     case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
 1265              		.loc 1 663 0
 1266 0884 4FF00103 		mov	r3, #1
 1267 0888 FB60     		str	r3, [r7, #12]
 664:../src/stm32f30x_can.c ****       break;
 1268              		.loc 1 664 0
 1269 088a 03E0     		b	.L65
 1270              	.L56:
 665:../src/stm32f30x_can.c ****     default: state = CAN_TxStatus_Failed;
 1271              		.loc 1 665 0
 1272 088c 4FF00003 		mov	r3, #0
 1273 0890 FB60     		str	r3, [r7, #12]
 666:../src/stm32f30x_can.c ****       break;
 1274              		.loc 1 666 0
 1275 0892 00BF     		nop
 1276              	.L65:
 667:../src/stm32f30x_can.c ****   }
 668:../src/stm32f30x_can.c ****   return (uint8_t) state;
 1277              		.loc 1 668 0
 1278 0894 FB68     		ldr	r3, [r7, #12]
 1279 0896 DBB2     		uxtb	r3, r3
 669:../src/stm32f30x_can.c **** }
 1280              		.loc 1 669 0
 1281 0898 1846     		mov	r0, r3
 1282 089a 07F11407 		add	r7, r7, #20
 1283 089e BD46     		mov	sp, r7
 1284 08a0 80BC     		pop	{r7}
 1285 08a2 7047     		bx	lr
 1286              		.cfi_endproc
 1287              	.LFE119:
 1289              		.align	2
 1290              		.global	CAN_CancelTransmit
 1291              		.thumb
 1292              		.thumb_func
 1294              	CAN_CancelTransmit:
 1295              	.LFB120:
 670:../src/stm32f30x_can.c **** 
 671:../src/stm32f30x_can.c **** /**
 672:../src/stm32f30x_can.c ****   * @brief  Cancels a transmit request.
 673:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 to select the CAN1 peripheral.
 674:../src/stm32f30x_can.c ****   * @param  Mailbox: Mailbox number.
 675:../src/stm32f30x_can.c ****   * @retval None
 676:../src/stm32f30x_can.c ****   */
 677:../src/stm32f30x_can.c **** void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
 678:../src/stm32f30x_can.c **** {
 1296              		.loc 1 678 0
 1297              		.cfi_startproc
 1298              		@ args = 0, pretend = 0, frame = 8
 1299              		@ frame_needed = 1, uses_anonymous_args = 0
 1300              		@ link register save eliminated.
 1301 08a4 80B4     		push	{r7}
 1302              	.LCFI27:
 1303              		.cfi_def_cfa_offset 4
 1304              		.cfi_offset 7, -4
 1305 08a6 83B0     		sub	sp, sp, #12
 1306              	.LCFI28:
 1307              		.cfi_def_cfa_offset 16
 1308 08a8 00AF     		add	r7, sp, #0
 1309              	.LCFI29:
 1310              		.cfi_def_cfa_register 7
 1311 08aa 7860     		str	r0, [r7, #4]
 1312 08ac 0B46     		mov	r3, r1
 1313 08ae FB70     		strb	r3, [r7, #3]
 679:../src/stm32f30x_can.c ****   /* Check the parameters */
 680:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 681:../src/stm32f30x_can.c ****   assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
 682:../src/stm32f30x_can.c ****   /* abort transmission */
 683:../src/stm32f30x_can.c ****   switch (Mailbox)
 1314              		.loc 1 683 0
 1315 08b0 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1316 08b2 012B     		cmp	r3, #1
 1317 08b4 0AD0     		beq	.L71
 1318 08b6 022B     		cmp	r3, #2
 1319 08b8 0FD0     		beq	.L72
 1320 08ba 002B     		cmp	r3, #0
 1321 08bc 14D1     		bne	.L74
 1322              	.L70:
 684:../src/stm32f30x_can.c ****   {
 685:../src/stm32f30x_can.c ****     case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
 1323              		.loc 1 685 0
 1324 08be 7B68     		ldr	r3, [r7, #4]
 1325 08c0 9B68     		ldr	r3, [r3, #8]
 1326 08c2 43F08002 		orr	r2, r3, #128
 1327 08c6 7B68     		ldr	r3, [r7, #4]
 1328 08c8 9A60     		str	r2, [r3, #8]
 686:../src/stm32f30x_can.c ****       break;
 1329              		.loc 1 686 0
 1330 08ca 0EE0     		b	.L68
 1331              	.L71:
 687:../src/stm32f30x_can.c ****     case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
 1332              		.loc 1 687 0
 1333 08cc 7B68     		ldr	r3, [r7, #4]
 1334 08ce 9B68     		ldr	r3, [r3, #8]
 1335 08d0 43F40042 		orr	r2, r3, #32768
 1336 08d4 7B68     		ldr	r3, [r7, #4]
 1337 08d6 9A60     		str	r2, [r3, #8]
 688:../src/stm32f30x_can.c ****       break;
 1338              		.loc 1 688 0
 1339 08d8 07E0     		b	.L68
 1340              	.L72:
 689:../src/stm32f30x_can.c ****     case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
 1341              		.loc 1 689 0
 1342 08da 7B68     		ldr	r3, [r7, #4]
 1343 08dc 9B68     		ldr	r3, [r3, #8]
 1344 08de 43F40002 		orr	r2, r3, #8388608
 1345 08e2 7B68     		ldr	r3, [r7, #4]
 1346 08e4 9A60     		str	r2, [r3, #8]
 690:../src/stm32f30x_can.c ****       break;
 1347              		.loc 1 690 0
 1348 08e6 00E0     		b	.L68
 1349              	.L74:
 691:../src/stm32f30x_can.c ****     default:
 692:../src/stm32f30x_can.c ****       break;
 1350              		.loc 1 692 0
 1351 08e8 00BF     		nop
 1352              	.L68:
 693:../src/stm32f30x_can.c ****   }
 694:../src/stm32f30x_can.c **** }
 1353              		.loc 1 694 0
 1354 08ea 07F10C07 		add	r7, r7, #12
 1355 08ee BD46     		mov	sp, r7
 1356 08f0 80BC     		pop	{r7}
 1357 08f2 7047     		bx	lr
 1358              		.cfi_endproc
 1359              	.LFE120:
 1361              		.align	2
 1362              		.global	CAN_Receive
 1363              		.thumb
 1364              		.thumb_func
 1366              	CAN_Receive:
 1367              	.LFB121:
 695:../src/stm32f30x_can.c **** /**
 696:../src/stm32f30x_can.c ****   * @}
 697:../src/stm32f30x_can.c ****   */
 698:../src/stm32f30x_can.c **** 
 699:../src/stm32f30x_can.c **** 
 700:../src/stm32f30x_can.c **** /** @defgroup CAN_Group3 CAN Frames Reception functions
 701:../src/stm32f30x_can.c ****  *  @brief    CAN Frames Reception functions 
 702:../src/stm32f30x_can.c ****  *
 703:../src/stm32f30x_can.c **** @verbatim    
 704:../src/stm32f30x_can.c ****  ===============================================================================
 705:../src/stm32f30x_can.c ****                   ##### CAN Frames Reception functions #####
 706:../src/stm32f30x_can.c ****  ===============================================================================  
 707:../src/stm32f30x_can.c ****     [..] This section provides functions allowing to 
 708:../src/stm32f30x_can.c ****          (+) Receive a correct CAN frame.
 709:../src/stm32f30x_can.c ****          (+) Release a specified receive FIFO (2 FIFOs are available).
 710:../src/stm32f30x_can.c ****          (+) Return the number of the pending received CAN frames.
 711:../src/stm32f30x_can.c ****    
 712:../src/stm32f30x_can.c **** @endverbatim
 713:../src/stm32f30x_can.c ****   * @{
 714:../src/stm32f30x_can.c ****   */
 715:../src/stm32f30x_can.c **** 
 716:../src/stm32f30x_can.c **** /**
 717:../src/stm32f30x_can.c ****   * @brief  Receives a correct CAN frame.
 718:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 to select the CAN1 peripheral.
 719:../src/stm32f30x_can.c ****   * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
 720:../src/stm32f30x_can.c ****   * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
 721:../src/stm32f30x_can.c ****   *         CAN DLC, CAN data and FMI number.
 722:../src/stm32f30x_can.c ****   * @retval None
 723:../src/stm32f30x_can.c ****   */
 724:../src/stm32f30x_can.c **** void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
 725:../src/stm32f30x_can.c **** {
 1368              		.loc 1 725 0
 1369              		.cfi_startproc
 1370              		@ args = 0, pretend = 0, frame = 16
 1371              		@ frame_needed = 1, uses_anonymous_args = 0
 1372              		@ link register save eliminated.
 1373 08f4 80B4     		push	{r7}
 1374              	.LCFI30:
 1375              		.cfi_def_cfa_offset 4
 1376              		.cfi_offset 7, -4
 1377 08f6 85B0     		sub	sp, sp, #20
 1378              	.LCFI31:
 1379              		.cfi_def_cfa_offset 24
 1380 08f8 00AF     		add	r7, sp, #0
 1381              	.LCFI32:
 1382              		.cfi_def_cfa_register 7
 1383 08fa F860     		str	r0, [r7, #12]
 1384 08fc 0B46     		mov	r3, r1
 1385 08fe 7A60     		str	r2, [r7, #4]
 1386 0900 FB72     		strb	r3, [r7, #11]
 726:../src/stm32f30x_can.c ****   /* Check the parameters */
 727:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 728:../src/stm32f30x_can.c ****   assert_param(IS_CAN_FIFO(FIFONumber));
 729:../src/stm32f30x_can.c ****   /* Get the Id */
 730:../src/stm32f30x_can.c ****   RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
 1387              		.loc 1 730 0
 1388 0902 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1389 0904 FA68     		ldr	r2, [r7, #12]
 1390 0906 03F11B03 		add	r3, r3, #27
 1391 090a 4FEA0313 		lsl	r3, r3, #4
 1392 090e D318     		adds	r3, r2, r3
 1393 0910 1B68     		ldr	r3, [r3, #0]
 1394 0912 DBB2     		uxtb	r3, r3
 1395 0914 03F00403 		and	r3, r3, #4
 1396 0918 DAB2     		uxtb	r2, r3
 1397 091a 7B68     		ldr	r3, [r7, #4]
 1398 091c 1A72     		strb	r2, [r3, #8]
 731:../src/stm32f30x_can.c ****   if (RxMessage->IDE == CAN_Id_Standard)
 1399              		.loc 1 731 0
 1400 091e 7B68     		ldr	r3, [r7, #4]
 1401 0920 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 1402 0922 002B     		cmp	r3, #0
 1403 0924 0CD1     		bne	.L76
 732:../src/stm32f30x_can.c ****   {
 733:../src/stm32f30x_can.c ****     RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
 1404              		.loc 1 733 0
 1405 0926 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1406 0928 FA68     		ldr	r2, [r7, #12]
 1407 092a 03F11B03 		add	r3, r3, #27
 1408 092e 4FEA0313 		lsl	r3, r3, #4
 1409 0932 D318     		adds	r3, r2, r3
 1410 0934 1B68     		ldr	r3, [r3, #0]
 1411 0936 4FEA5352 		lsr	r2, r3, #21
 1412 093a 7B68     		ldr	r3, [r7, #4]
 1413 093c 1A60     		str	r2, [r3, #0]
 1414 093e 0BE0     		b	.L77
 1415              	.L76:
 734:../src/stm32f30x_can.c ****   }
 735:../src/stm32f30x_can.c ****   else
 736:../src/stm32f30x_can.c ****   {
 737:../src/stm32f30x_can.c ****     RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
 1416              		.loc 1 737 0
 1417 0940 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1418 0942 FA68     		ldr	r2, [r7, #12]
 1419 0944 03F11B03 		add	r3, r3, #27
 1420 0948 4FEA0313 		lsl	r3, r3, #4
 1421 094c D318     		adds	r3, r2, r3
 1422 094e 1B68     		ldr	r3, [r3, #0]
 1423 0950 4FEAD302 		lsr	r2, r3, #3
 1424 0954 7B68     		ldr	r3, [r7, #4]
 1425 0956 5A60     		str	r2, [r3, #4]
 1426              	.L77:
 738:../src/stm32f30x_can.c ****   }
 739:../src/stm32f30x_can.c ****   
 740:../src/stm32f30x_can.c ****   RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
 1427              		.loc 1 740 0
 1428 0958 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1429 095a FA68     		ldr	r2, [r7, #12]
 1430 095c 03F11B03 		add	r3, r3, #27
 1431 0960 4FEA0313 		lsl	r3, r3, #4
 1432 0964 D318     		adds	r3, r2, r3
 1433 0966 1B68     		ldr	r3, [r3, #0]
 1434 0968 DBB2     		uxtb	r3, r3
 1435 096a 03F00203 		and	r3, r3, #2
 1436 096e DAB2     		uxtb	r2, r3
 1437 0970 7B68     		ldr	r3, [r7, #4]
 1438 0972 5A72     		strb	r2, [r3, #9]
 741:../src/stm32f30x_can.c ****   /* Get the DLC */
 742:../src/stm32f30x_can.c ****   RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
 1439              		.loc 1 742 0
 1440 0974 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1441 0976 FA68     		ldr	r2, [r7, #12]
 1442 0978 03F11B03 		add	r3, r3, #27
 1443 097c 4FEA0313 		lsl	r3, r3, #4
 1444 0980 D318     		adds	r3, r2, r3
 1445 0982 5B68     		ldr	r3, [r3, #4]
 1446 0984 DBB2     		uxtb	r3, r3
 1447 0986 03F00F03 		and	r3, r3, #15
 1448 098a DAB2     		uxtb	r2, r3
 1449 098c 7B68     		ldr	r3, [r7, #4]
 1450 098e 9A72     		strb	r2, [r3, #10]
 743:../src/stm32f30x_can.c ****   /* Get the FMI */
 744:../src/stm32f30x_can.c ****   RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
 1451              		.loc 1 744 0
 1452 0990 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1453 0992 FA68     		ldr	r2, [r7, #12]
 1454 0994 03F11B03 		add	r3, r3, #27
 1455 0998 4FEA0313 		lsl	r3, r3, #4
 1456 099c D318     		adds	r3, r2, r3
 1457 099e 5B68     		ldr	r3, [r3, #4]
 1458 09a0 4FEA1323 		lsr	r3, r3, #8
 1459 09a4 DAB2     		uxtb	r2, r3
 1460 09a6 7B68     		ldr	r3, [r7, #4]
 1461 09a8 DA74     		strb	r2, [r3, #19]
 745:../src/stm32f30x_can.c ****   /* Get the data field */
 746:../src/stm32f30x_can.c ****   RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
 1462              		.loc 1 746 0
 1463 09aa FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1464 09ac FA68     		ldr	r2, [r7, #12]
 1465 09ae 4FEA0313 		lsl	r3, r3, #4
 1466 09b2 D318     		adds	r3, r2, r3
 1467 09b4 03F5DC73 		add	r3, r3, #440
 1468 09b8 1B68     		ldr	r3, [r3, #0]
 1469 09ba DAB2     		uxtb	r2, r3
 1470 09bc 7B68     		ldr	r3, [r7, #4]
 1471 09be DA72     		strb	r2, [r3, #11]
 747:../src/stm32f30x_can.c ****   RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
 1472              		.loc 1 747 0
 1473 09c0 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1474 09c2 FA68     		ldr	r2, [r7, #12]
 1475 09c4 4FEA0313 		lsl	r3, r3, #4
 1476 09c8 D318     		adds	r3, r2, r3
 1477 09ca 03F5DC73 		add	r3, r3, #440
 1478 09ce 1B68     		ldr	r3, [r3, #0]
 1479 09d0 4FEA1323 		lsr	r3, r3, #8
 1480 09d4 DAB2     		uxtb	r2, r3
 1481 09d6 7B68     		ldr	r3, [r7, #4]
 1482 09d8 1A73     		strb	r2, [r3, #12]
 748:../src/stm32f30x_can.c ****   RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
 1483              		.loc 1 748 0
 1484 09da FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1485 09dc FA68     		ldr	r2, [r7, #12]
 1486 09de 4FEA0313 		lsl	r3, r3, #4
 1487 09e2 D318     		adds	r3, r2, r3
 1488 09e4 03F5DC73 		add	r3, r3, #440
 1489 09e8 1B68     		ldr	r3, [r3, #0]
 1490 09ea 4FEA1343 		lsr	r3, r3, #16
 1491 09ee DAB2     		uxtb	r2, r3
 1492 09f0 7B68     		ldr	r3, [r7, #4]
 1493 09f2 5A73     		strb	r2, [r3, #13]
 749:../src/stm32f30x_can.c ****   RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
 1494              		.loc 1 749 0
 1495 09f4 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1496 09f6 FA68     		ldr	r2, [r7, #12]
 1497 09f8 4FEA0313 		lsl	r3, r3, #4
 1498 09fc D318     		adds	r3, r2, r3
 1499 09fe 03F5DC73 		add	r3, r3, #440
 1500 0a02 1B68     		ldr	r3, [r3, #0]
 1501 0a04 4FEA1363 		lsr	r3, r3, #24
 1502 0a08 DAB2     		uxtb	r2, r3
 1503 0a0a 7B68     		ldr	r3, [r7, #4]
 1504 0a0c 9A73     		strb	r2, [r3, #14]
 750:../src/stm32f30x_can.c ****   RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
 1505              		.loc 1 750 0
 1506 0a0e FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1507 0a10 FA68     		ldr	r2, [r7, #12]
 1508 0a12 4FEA0313 		lsl	r3, r3, #4
 1509 0a16 D318     		adds	r3, r2, r3
 1510 0a18 03F5DC73 		add	r3, r3, #440
 1511 0a1c 5B68     		ldr	r3, [r3, #4]
 1512 0a1e DAB2     		uxtb	r2, r3
 1513 0a20 7B68     		ldr	r3, [r7, #4]
 1514 0a22 DA73     		strb	r2, [r3, #15]
 751:../src/stm32f30x_can.c ****   RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
 1515              		.loc 1 751 0
 1516 0a24 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1517 0a26 FA68     		ldr	r2, [r7, #12]
 1518 0a28 4FEA0313 		lsl	r3, r3, #4
 1519 0a2c D318     		adds	r3, r2, r3
 1520 0a2e 03F5DC73 		add	r3, r3, #440
 1521 0a32 5B68     		ldr	r3, [r3, #4]
 1522 0a34 4FEA1323 		lsr	r3, r3, #8
 1523 0a38 DAB2     		uxtb	r2, r3
 1524 0a3a 7B68     		ldr	r3, [r7, #4]
 1525 0a3c 1A74     		strb	r2, [r3, #16]
 752:../src/stm32f30x_can.c ****   RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
 1526              		.loc 1 752 0
 1527 0a3e FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1528 0a40 FA68     		ldr	r2, [r7, #12]
 1529 0a42 4FEA0313 		lsl	r3, r3, #4
 1530 0a46 D318     		adds	r3, r2, r3
 1531 0a48 03F5DC73 		add	r3, r3, #440
 1532 0a4c 5B68     		ldr	r3, [r3, #4]
 1533 0a4e 4FEA1343 		lsr	r3, r3, #16
 1534 0a52 DAB2     		uxtb	r2, r3
 1535 0a54 7B68     		ldr	r3, [r7, #4]
 1536 0a56 5A74     		strb	r2, [r3, #17]
 753:../src/stm32f30x_can.c ****   RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
 1537              		.loc 1 753 0
 1538 0a58 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1539 0a5a FA68     		ldr	r2, [r7, #12]
 1540 0a5c 4FEA0313 		lsl	r3, r3, #4
 1541 0a60 D318     		adds	r3, r2, r3
 1542 0a62 03F5DC73 		add	r3, r3, #440
 1543 0a66 5B68     		ldr	r3, [r3, #4]
 1544 0a68 4FEA1363 		lsr	r3, r3, #24
 1545 0a6c DAB2     		uxtb	r2, r3
 1546 0a6e 7B68     		ldr	r3, [r7, #4]
 1547 0a70 9A74     		strb	r2, [r3, #18]
 754:../src/stm32f30x_can.c ****   /* Release the FIFO */
 755:../src/stm32f30x_can.c ****   /* Release FIFO0 */
 756:../src/stm32f30x_can.c ****   if (FIFONumber == CAN_FIFO0)
 1548              		.loc 1 756 0
 1549 0a72 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1550 0a74 002B     		cmp	r3, #0
 1551 0a76 06D1     		bne	.L78
 757:../src/stm32f30x_can.c ****   {
 758:../src/stm32f30x_can.c ****     CANx->RF0R |= CAN_RF0R_RFOM0;
 1552              		.loc 1 758 0
 1553 0a78 FB68     		ldr	r3, [r7, #12]
 1554 0a7a DB68     		ldr	r3, [r3, #12]
 1555 0a7c 43F02002 		orr	r2, r3, #32
 1556 0a80 FB68     		ldr	r3, [r7, #12]
 1557 0a82 DA60     		str	r2, [r3, #12]
 1558 0a84 05E0     		b	.L75
 1559              	.L78:
 759:../src/stm32f30x_can.c ****   }
 760:../src/stm32f30x_can.c ****   /* Release FIFO1 */
 761:../src/stm32f30x_can.c ****   else /* FIFONumber == CAN_FIFO1 */
 762:../src/stm32f30x_can.c ****   {
 763:../src/stm32f30x_can.c ****     CANx->RF1R |= CAN_RF1R_RFOM1;
 1560              		.loc 1 763 0
 1561 0a86 FB68     		ldr	r3, [r7, #12]
 1562 0a88 1B69     		ldr	r3, [r3, #16]
 1563 0a8a 43F02002 		orr	r2, r3, #32
 1564 0a8e FB68     		ldr	r3, [r7, #12]
 1565 0a90 1A61     		str	r2, [r3, #16]
 1566              	.L75:
 764:../src/stm32f30x_can.c ****   }
 765:../src/stm32f30x_can.c **** }
 1567              		.loc 1 765 0
 1568 0a92 07F11407 		add	r7, r7, #20
 1569 0a96 BD46     		mov	sp, r7
 1570 0a98 80BC     		pop	{r7}
 1571 0a9a 7047     		bx	lr
 1572              		.cfi_endproc
 1573              	.LFE121:
 1575              		.align	2
 1576              		.global	CAN_FIFORelease
 1577              		.thumb
 1578              		.thumb_func
 1580              	CAN_FIFORelease:
 1581              	.LFB122:
 766:../src/stm32f30x_can.c **** 
 767:../src/stm32f30x_can.c **** /**
 768:../src/stm32f30x_can.c ****   * @brief  Releases the specified receive FIFO.
 769:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 to select the CAN1 peripheral.
 770:../src/stm32f30x_can.c ****   * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
 771:../src/stm32f30x_can.c ****   * @retval None
 772:../src/stm32f30x_can.c ****   */
 773:../src/stm32f30x_can.c **** void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
 774:../src/stm32f30x_can.c **** {
 1582              		.loc 1 774 0
 1583              		.cfi_startproc
 1584              		@ args = 0, pretend = 0, frame = 8
 1585              		@ frame_needed = 1, uses_anonymous_args = 0
 1586              		@ link register save eliminated.
 1587 0a9c 80B4     		push	{r7}
 1588              	.LCFI33:
 1589              		.cfi_def_cfa_offset 4
 1590              		.cfi_offset 7, -4
 1591 0a9e 83B0     		sub	sp, sp, #12
 1592              	.LCFI34:
 1593              		.cfi_def_cfa_offset 16
 1594 0aa0 00AF     		add	r7, sp, #0
 1595              	.LCFI35:
 1596              		.cfi_def_cfa_register 7
 1597 0aa2 7860     		str	r0, [r7, #4]
 1598 0aa4 0B46     		mov	r3, r1
 1599 0aa6 FB70     		strb	r3, [r7, #3]
 775:../src/stm32f30x_can.c ****   /* Check the parameters */
 776:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 777:../src/stm32f30x_can.c ****   assert_param(IS_CAN_FIFO(FIFONumber));
 778:../src/stm32f30x_can.c ****   /* Release FIFO0 */
 779:../src/stm32f30x_can.c ****   if (FIFONumber == CAN_FIFO0)
 1600              		.loc 1 779 0
 1601 0aa8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1602 0aaa 002B     		cmp	r3, #0
 1603 0aac 06D1     		bne	.L81
 780:../src/stm32f30x_can.c ****   {
 781:../src/stm32f30x_can.c ****     CANx->RF0R |= CAN_RF0R_RFOM0;
 1604              		.loc 1 781 0
 1605 0aae 7B68     		ldr	r3, [r7, #4]
 1606 0ab0 DB68     		ldr	r3, [r3, #12]
 1607 0ab2 43F02002 		orr	r2, r3, #32
 1608 0ab6 7B68     		ldr	r3, [r7, #4]
 1609 0ab8 DA60     		str	r2, [r3, #12]
 1610 0aba 05E0     		b	.L80
 1611              	.L81:
 782:../src/stm32f30x_can.c ****   }
 783:../src/stm32f30x_can.c ****   /* Release FIFO1 */
 784:../src/stm32f30x_can.c ****   else /* FIFONumber == CAN_FIFO1 */
 785:../src/stm32f30x_can.c ****   {
 786:../src/stm32f30x_can.c ****     CANx->RF1R |= CAN_RF1R_RFOM1;
 1612              		.loc 1 786 0
 1613 0abc 7B68     		ldr	r3, [r7, #4]
 1614 0abe 1B69     		ldr	r3, [r3, #16]
 1615 0ac0 43F02002 		orr	r2, r3, #32
 1616 0ac4 7B68     		ldr	r3, [r7, #4]
 1617 0ac6 1A61     		str	r2, [r3, #16]
 1618              	.L80:
 787:../src/stm32f30x_can.c ****   }
 788:../src/stm32f30x_can.c **** }
 1619              		.loc 1 788 0
 1620 0ac8 07F10C07 		add	r7, r7, #12
 1621 0acc BD46     		mov	sp, r7
 1622 0ace 80BC     		pop	{r7}
 1623 0ad0 7047     		bx	lr
 1624              		.cfi_endproc
 1625              	.LFE122:
 1627 0ad2 00BF     		.align	2
 1628              		.global	CAN_MessagePending
 1629              		.thumb
 1630              		.thumb_func
 1632              	CAN_MessagePending:
 1633              	.LFB123:
 789:../src/stm32f30x_can.c **** 
 790:../src/stm32f30x_can.c **** /**
 791:../src/stm32f30x_can.c ****   * @brief  Returns the number of pending received messages.
 792:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 to select the CAN1 peripheral.
 793:../src/stm32f30x_can.c ****   * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
 794:../src/stm32f30x_can.c ****   * @retval NbMessage : which is the number of pending message.
 795:../src/stm32f30x_can.c ****   */
 796:../src/stm32f30x_can.c **** uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
 797:../src/stm32f30x_can.c **** {
 1634              		.loc 1 797 0
 1635              		.cfi_startproc
 1636              		@ args = 0, pretend = 0, frame = 16
 1637              		@ frame_needed = 1, uses_anonymous_args = 0
 1638              		@ link register save eliminated.
 1639 0ad4 80B4     		push	{r7}
 1640              	.LCFI36:
 1641              		.cfi_def_cfa_offset 4
 1642              		.cfi_offset 7, -4
 1643 0ad6 85B0     		sub	sp, sp, #20
 1644              	.LCFI37:
 1645              		.cfi_def_cfa_offset 24
 1646 0ad8 00AF     		add	r7, sp, #0
 1647              	.LCFI38:
 1648              		.cfi_def_cfa_register 7
 1649 0ada 7860     		str	r0, [r7, #4]
 1650 0adc 0B46     		mov	r3, r1
 1651 0ade FB70     		strb	r3, [r7, #3]
 798:../src/stm32f30x_can.c ****   uint8_t message_pending=0;
 1652              		.loc 1 798 0
 1653 0ae0 4FF00003 		mov	r3, #0
 1654 0ae4 FB73     		strb	r3, [r7, #15]
 799:../src/stm32f30x_can.c ****   /* Check the parameters */
 800:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 801:../src/stm32f30x_can.c ****   assert_param(IS_CAN_FIFO(FIFONumber));
 802:../src/stm32f30x_can.c ****   if (FIFONumber == CAN_FIFO0)
 1655              		.loc 1 802 0
 1656 0ae6 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1657 0ae8 002B     		cmp	r3, #0
 1658 0aea 06D1     		bne	.L84
 803:../src/stm32f30x_can.c ****   {
 804:../src/stm32f30x_can.c ****     message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
 1659              		.loc 1 804 0
 1660 0aec 7B68     		ldr	r3, [r7, #4]
 1661 0aee DB68     		ldr	r3, [r3, #12]
 1662 0af0 DBB2     		uxtb	r3, r3
 1663 0af2 03F00303 		and	r3, r3, #3
 1664 0af6 FB73     		strb	r3, [r7, #15]
 1665 0af8 0CE0     		b	.L85
 1666              	.L84:
 805:../src/stm32f30x_can.c ****   }
 806:../src/stm32f30x_can.c ****   else if (FIFONumber == CAN_FIFO1)
 1667              		.loc 1 806 0
 1668 0afa FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1669 0afc 012B     		cmp	r3, #1
 1670 0afe 06D1     		bne	.L86
 807:../src/stm32f30x_can.c ****   {
 808:../src/stm32f30x_can.c ****     message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
 1671              		.loc 1 808 0
 1672 0b00 7B68     		ldr	r3, [r7, #4]
 1673 0b02 1B69     		ldr	r3, [r3, #16]
 1674 0b04 DBB2     		uxtb	r3, r3
 1675 0b06 03F00303 		and	r3, r3, #3
 1676 0b0a FB73     		strb	r3, [r7, #15]
 1677 0b0c 02E0     		b	.L85
 1678              	.L86:
 809:../src/stm32f30x_can.c ****   }
 810:../src/stm32f30x_can.c ****   else
 811:../src/stm32f30x_can.c ****   {
 812:../src/stm32f30x_can.c ****     message_pending = 0;
 1679              		.loc 1 812 0
 1680 0b0e 4FF00003 		mov	r3, #0
 1681 0b12 FB73     		strb	r3, [r7, #15]
 1682              	.L85:
 813:../src/stm32f30x_can.c ****   }
 814:../src/stm32f30x_can.c ****   return message_pending;
 1683              		.loc 1 814 0
 1684 0b14 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 815:../src/stm32f30x_can.c **** }
 1685              		.loc 1 815 0
 1686 0b16 1846     		mov	r0, r3
 1687 0b18 07F11407 		add	r7, r7, #20
 1688 0b1c BD46     		mov	sp, r7
 1689 0b1e 80BC     		pop	{r7}
 1690 0b20 7047     		bx	lr
 1691              		.cfi_endproc
 1692              	.LFE123:
 1694 0b22 00BF     		.align	2
 1695              		.global	CAN_OperatingModeRequest
 1696              		.thumb
 1697              		.thumb_func
 1699              	CAN_OperatingModeRequest:
 1700              	.LFB124:
 816:../src/stm32f30x_can.c **** /**
 817:../src/stm32f30x_can.c ****   * @}
 818:../src/stm32f30x_can.c ****   */
 819:../src/stm32f30x_can.c **** 
 820:../src/stm32f30x_can.c **** 
 821:../src/stm32f30x_can.c **** /** @defgroup CAN_Group4 CAN Operation modes functions
 822:../src/stm32f30x_can.c ****  *  @brief    CAN Operation modes functions 
 823:../src/stm32f30x_can.c ****  *
 824:../src/stm32f30x_can.c **** @verbatim    
 825:../src/stm32f30x_can.c ****  ===============================================================================
 826:../src/stm32f30x_can.c ****                     ##### CAN Operation modes functions #####
 827:../src/stm32f30x_can.c ****  ===============================================================================  
 828:../src/stm32f30x_can.c ****     [..] This section provides functions allowing to select the CAN Operation modes:
 829:../src/stm32f30x_can.c ****          (+) sleep mode.
 830:../src/stm32f30x_can.c ****          (+) normal mode. 
 831:../src/stm32f30x_can.c ****          (+) initialization mode.
 832:../src/stm32f30x_can.c ****    
 833:../src/stm32f30x_can.c **** @endverbatim
 834:../src/stm32f30x_can.c ****   * @{
 835:../src/stm32f30x_can.c ****   */
 836:../src/stm32f30x_can.c ****   
 837:../src/stm32f30x_can.c ****   
 838:../src/stm32f30x_can.c **** /**
 839:../src/stm32f30x_can.c ****   * @brief  Selects the CAN Operation mode.
 840:../src/stm32f30x_can.c ****   * @param  CAN_OperatingMode: CAN Operating Mode.
 841:../src/stm32f30x_can.c ****   *         This parameter can be one of @ref CAN_OperatingMode_TypeDef enumeration.
 842:../src/stm32f30x_can.c ****   * @retval status of the requested mode which can be: 
 843:../src/stm32f30x_can.c ****   *         - CAN_ModeStatus_Failed:  CAN failed entering the specific mode 
 844:../src/stm32f30x_can.c ****   *         - CAN_ModeStatus_Success: CAN Succeed entering the specific mode 
 845:../src/stm32f30x_can.c ****   */
 846:../src/stm32f30x_can.c **** uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
 847:../src/stm32f30x_can.c **** {
 1701              		.loc 1 847 0
 1702              		.cfi_startproc
 1703              		@ args = 0, pretend = 0, frame = 16
 1704              		@ frame_needed = 1, uses_anonymous_args = 0
 1705              		@ link register save eliminated.
 1706 0b24 80B4     		push	{r7}
 1707              	.LCFI39:
 1708              		.cfi_def_cfa_offset 4
 1709              		.cfi_offset 7, -4
 1710 0b26 85B0     		sub	sp, sp, #20
 1711              	.LCFI40:
 1712              		.cfi_def_cfa_offset 24
 1713 0b28 00AF     		add	r7, sp, #0
 1714              	.LCFI41:
 1715              		.cfi_def_cfa_register 7
 1716 0b2a 7860     		str	r0, [r7, #4]
 1717 0b2c 0B46     		mov	r3, r1
 1718 0b2e FB70     		strb	r3, [r7, #3]
 848:../src/stm32f30x_can.c ****   uint8_t status = CAN_ModeStatus_Failed;
 1719              		.loc 1 848 0
 1720 0b30 4FF00003 		mov	r3, #0
 1721 0b34 FB73     		strb	r3, [r7, #15]
 849:../src/stm32f30x_can.c ****   
 850:../src/stm32f30x_can.c ****   /* Timeout for INAK or also for SLAK bits*/
 851:../src/stm32f30x_can.c ****   uint32_t timeout = INAK_TIMEOUT; 
 1722              		.loc 1 851 0
 1723 0b36 6FF07F43 		mvn	r3, #-16777216
 1724 0b3a BB60     		str	r3, [r7, #8]
 852:../src/stm32f30x_can.c **** 
 853:../src/stm32f30x_can.c ****   /* Check the parameters */
 854:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 855:../src/stm32f30x_can.c ****   assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
 856:../src/stm32f30x_can.c **** 
 857:../src/stm32f30x_can.c ****   if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
 1725              		.loc 1 857 0
 1726 0b3c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1727 0b3e 002B     		cmp	r3, #0
 1728 0b40 23D1     		bne	.L89
 858:../src/stm32f30x_can.c ****   {
 859:../src/stm32f30x_can.c ****     /* Request initialisation */
 860:../src/stm32f30x_can.c ****     CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
 1729              		.loc 1 860 0
 1730 0b42 7B68     		ldr	r3, [r7, #4]
 1731 0b44 1B68     		ldr	r3, [r3, #0]
 1732 0b46 23F00303 		bic	r3, r3, #3
 1733 0b4a 43F00102 		orr	r2, r3, #1
 1734 0b4e 7B68     		ldr	r3, [r7, #4]
 1735 0b50 1A60     		str	r2, [r3, #0]
 861:../src/stm32f30x_can.c **** 
 862:../src/stm32f30x_can.c ****     /* Wait the acknowledge */
 863:../src/stm32f30x_can.c ****     while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
 1736              		.loc 1 863 0
 1737 0b52 03E0     		b	.L90
 1738              	.L92:
 864:../src/stm32f30x_can.c ****     {
 865:../src/stm32f30x_can.c ****       timeout--;
 1739              		.loc 1 865 0
 1740 0b54 BB68     		ldr	r3, [r7, #8]
 1741 0b56 03F1FF33 		add	r3, r3, #-1
 1742 0b5a BB60     		str	r3, [r7, #8]
 1743              	.L90:
 863:../src/stm32f30x_can.c ****     while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
 1744              		.loc 1 863 0 discriminator 1
 1745 0b5c 7B68     		ldr	r3, [r7, #4]
 1746 0b5e 5B68     		ldr	r3, [r3, #4]
 1747 0b60 03F00303 		and	r3, r3, #3
 1748 0b64 012B     		cmp	r3, #1
 1749 0b66 02D0     		beq	.L91
 863:../src/stm32f30x_can.c ****     while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
 1750              		.loc 1 863 0 is_stmt 0 discriminator 2
 1751 0b68 BB68     		ldr	r3, [r7, #8]
 1752 0b6a 002B     		cmp	r3, #0
 1753 0b6c F2D1     		bne	.L92
 1754              	.L91:
 866:../src/stm32f30x_can.c ****     }
 867:../src/stm32f30x_can.c ****     if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
 1755              		.loc 1 867 0 is_stmt 1
 1756 0b6e 7B68     		ldr	r3, [r7, #4]
 1757 0b70 5B68     		ldr	r3, [r3, #4]
 1758 0b72 03F00303 		and	r3, r3, #3
 1759 0b76 012B     		cmp	r3, #1
 1760 0b78 03D0     		beq	.L93
 868:../src/stm32f30x_can.c ****     {
 869:../src/stm32f30x_can.c ****       status = CAN_ModeStatus_Failed;
 1761              		.loc 1 869 0
 1762 0b7a 4FF00003 		mov	r3, #0
 1763 0b7e FB73     		strb	r3, [r7, #15]
 1764 0b80 52E0     		b	.L94
 1765              	.L93:
 870:../src/stm32f30x_can.c ****     }
 871:../src/stm32f30x_can.c ****     else
 872:../src/stm32f30x_can.c ****     {
 873:../src/stm32f30x_can.c ****       status = CAN_ModeStatus_Success;
 1766              		.loc 1 873 0
 1767 0b82 4FF00103 		mov	r3, #1
 1768 0b86 FB73     		strb	r3, [r7, #15]
 1769 0b88 4EE0     		b	.L94
 1770              	.L89:
 874:../src/stm32f30x_can.c ****     }
 875:../src/stm32f30x_can.c ****   }
 876:../src/stm32f30x_can.c ****   else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
 1771              		.loc 1 876 0
 1772 0b8a FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1773 0b8c 012B     		cmp	r3, #1
 1774 0b8e 21D1     		bne	.L95
 877:../src/stm32f30x_can.c ****   {
 878:../src/stm32f30x_can.c ****     /* Request leave initialisation and sleep mode  and enter Normal mode */
 879:../src/stm32f30x_can.c ****     CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
 1775              		.loc 1 879 0
 1776 0b90 7B68     		ldr	r3, [r7, #4]
 1777 0b92 1B68     		ldr	r3, [r3, #0]
 1778 0b94 23F00302 		bic	r2, r3, #3
 1779 0b98 7B68     		ldr	r3, [r7, #4]
 1780 0b9a 1A60     		str	r2, [r3, #0]
 880:../src/stm32f30x_can.c **** 
 881:../src/stm32f30x_can.c ****     /* Wait the acknowledge */
 882:../src/stm32f30x_can.c ****     while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
 1781              		.loc 1 882 0
 1782 0b9c 03E0     		b	.L96
 1783              	.L98:
 883:../src/stm32f30x_can.c ****     {
 884:../src/stm32f30x_can.c ****       timeout--;
 1784              		.loc 1 884 0
 1785 0b9e BB68     		ldr	r3, [r7, #8]
 1786 0ba0 03F1FF33 		add	r3, r3, #-1
 1787 0ba4 BB60     		str	r3, [r7, #8]
 1788              	.L96:
 882:../src/stm32f30x_can.c ****     while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
 1789              		.loc 1 882 0 discriminator 1
 1790 0ba6 7B68     		ldr	r3, [r7, #4]
 1791 0ba8 5B68     		ldr	r3, [r3, #4]
 1792 0baa 03F00303 		and	r3, r3, #3
 1793 0bae 002B     		cmp	r3, #0
 1794 0bb0 02D0     		beq	.L97
 882:../src/stm32f30x_can.c ****     while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
 1795              		.loc 1 882 0 is_stmt 0 discriminator 2
 1796 0bb2 BB68     		ldr	r3, [r7, #8]
 1797 0bb4 002B     		cmp	r3, #0
 1798 0bb6 F2D1     		bne	.L98
 1799              	.L97:
 885:../src/stm32f30x_can.c ****     }
 886:../src/stm32f30x_can.c ****     if ((CANx->MSR & CAN_MODE_MASK) != 0)
 1800              		.loc 1 886 0 is_stmt 1
 1801 0bb8 7B68     		ldr	r3, [r7, #4]
 1802 0bba 5B68     		ldr	r3, [r3, #4]
 1803 0bbc 03F00303 		and	r3, r3, #3
 1804 0bc0 002B     		cmp	r3, #0
 1805 0bc2 03D0     		beq	.L99
 887:../src/stm32f30x_can.c ****     {
 888:../src/stm32f30x_can.c ****       status = CAN_ModeStatus_Failed;
 1806              		.loc 1 888 0
 1807 0bc4 4FF00003 		mov	r3, #0
 1808 0bc8 FB73     		strb	r3, [r7, #15]
 1809 0bca 2DE0     		b	.L94
 1810              	.L99:
 889:../src/stm32f30x_can.c ****     }
 890:../src/stm32f30x_can.c ****     else
 891:../src/stm32f30x_can.c ****     {
 892:../src/stm32f30x_can.c ****       status = CAN_ModeStatus_Success;
 1811              		.loc 1 892 0
 1812 0bcc 4FF00103 		mov	r3, #1
 1813 0bd0 FB73     		strb	r3, [r7, #15]
 1814 0bd2 29E0     		b	.L94
 1815              	.L95:
 893:../src/stm32f30x_can.c ****     }
 894:../src/stm32f30x_can.c ****   }
 895:../src/stm32f30x_can.c ****   else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
 1816              		.loc 1 895 0
 1817 0bd4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1818 0bd6 022B     		cmp	r3, #2
 1819 0bd8 23D1     		bne	.L100
 896:../src/stm32f30x_can.c ****   {
 897:../src/stm32f30x_can.c ****     /* Request Sleep mode */
 898:../src/stm32f30x_can.c ****     CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
 1820              		.loc 1 898 0
 1821 0bda 7B68     		ldr	r3, [r7, #4]
 1822 0bdc 1B68     		ldr	r3, [r3, #0]
 1823 0bde 23F00303 		bic	r3, r3, #3
 1824 0be2 43F00202 		orr	r2, r3, #2
 1825 0be6 7B68     		ldr	r3, [r7, #4]
 1826 0be8 1A60     		str	r2, [r3, #0]
 899:../src/stm32f30x_can.c **** 
 900:../src/stm32f30x_can.c ****     /* Wait the acknowledge */
 901:../src/stm32f30x_can.c ****     while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
 1827              		.loc 1 901 0
 1828 0bea 03E0     		b	.L101
 1829              	.L103:
 902:../src/stm32f30x_can.c ****     {
 903:../src/stm32f30x_can.c ****       timeout--;
 1830              		.loc 1 903 0
 1831 0bec BB68     		ldr	r3, [r7, #8]
 1832 0bee 03F1FF33 		add	r3, r3, #-1
 1833 0bf2 BB60     		str	r3, [r7, #8]
 1834              	.L101:
 901:../src/stm32f30x_can.c ****     while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
 1835              		.loc 1 901 0 discriminator 1
 1836 0bf4 7B68     		ldr	r3, [r7, #4]
 1837 0bf6 5B68     		ldr	r3, [r3, #4]
 1838 0bf8 03F00303 		and	r3, r3, #3
 1839 0bfc 022B     		cmp	r3, #2
 1840 0bfe 02D0     		beq	.L102
 901:../src/stm32f30x_can.c ****     while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
 1841              		.loc 1 901 0 is_stmt 0 discriminator 2
 1842 0c00 BB68     		ldr	r3, [r7, #8]
 1843 0c02 002B     		cmp	r3, #0
 1844 0c04 F2D1     		bne	.L103
 1845              	.L102:
 904:../src/stm32f30x_can.c ****     }
 905:../src/stm32f30x_can.c ****     if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
 1846              		.loc 1 905 0 is_stmt 1
 1847 0c06 7B68     		ldr	r3, [r7, #4]
 1848 0c08 5B68     		ldr	r3, [r3, #4]
 1849 0c0a 03F00303 		and	r3, r3, #3
 1850 0c0e 022B     		cmp	r3, #2
 1851 0c10 03D0     		beq	.L104
 906:../src/stm32f30x_can.c ****     {
 907:../src/stm32f30x_can.c ****       status = CAN_ModeStatus_Failed;
 1852              		.loc 1 907 0
 1853 0c12 4FF00003 		mov	r3, #0
 1854 0c16 FB73     		strb	r3, [r7, #15]
 1855 0c18 06E0     		b	.L94
 1856              	.L104:
 908:../src/stm32f30x_can.c ****     }
 909:../src/stm32f30x_can.c ****     else
 910:../src/stm32f30x_can.c ****     {
 911:../src/stm32f30x_can.c ****       status = CAN_ModeStatus_Success;
 1857              		.loc 1 911 0
 1858 0c1a 4FF00103 		mov	r3, #1
 1859 0c1e FB73     		strb	r3, [r7, #15]
 1860 0c20 02E0     		b	.L94
 1861              	.L100:
 912:../src/stm32f30x_can.c ****     }
 913:../src/stm32f30x_can.c ****   }
 914:../src/stm32f30x_can.c ****   else
 915:../src/stm32f30x_can.c ****   {
 916:../src/stm32f30x_can.c ****     status = CAN_ModeStatus_Failed;
 1862              		.loc 1 916 0
 1863 0c22 4FF00003 		mov	r3, #0
 1864 0c26 FB73     		strb	r3, [r7, #15]
 1865              	.L94:
 917:../src/stm32f30x_can.c ****   }
 918:../src/stm32f30x_can.c **** 
 919:../src/stm32f30x_can.c ****   return  (uint8_t) status;
 1866              		.loc 1 919 0
 1867 0c28 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 920:../src/stm32f30x_can.c **** }
 1868              		.loc 1 920 0
 1869 0c2a 1846     		mov	r0, r3
 1870 0c2c 07F11407 		add	r7, r7, #20
 1871 0c30 BD46     		mov	sp, r7
 1872 0c32 80BC     		pop	{r7}
 1873 0c34 7047     		bx	lr
 1874              		.cfi_endproc
 1875              	.LFE124:
 1877 0c36 00BF     		.align	2
 1878              		.global	CAN_Sleep
 1879              		.thumb
 1880              		.thumb_func
 1882              	CAN_Sleep:
 1883              	.LFB125:
 921:../src/stm32f30x_can.c **** 
 922:../src/stm32f30x_can.c **** /**
 923:../src/stm32f30x_can.c ****   * @brief  Enters the Sleep (low power) mode.
 924:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 to select the CAN1 peripheral.
 925:../src/stm32f30x_can.c ****   * @retval CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed otherwise.
 926:../src/stm32f30x_can.c ****   */
 927:../src/stm32f30x_can.c **** uint8_t CAN_Sleep(CAN_TypeDef* CANx)
 928:../src/stm32f30x_can.c **** {
 1884              		.loc 1 928 0
 1885              		.cfi_startproc
 1886              		@ args = 0, pretend = 0, frame = 16
 1887              		@ frame_needed = 1, uses_anonymous_args = 0
 1888              		@ link register save eliminated.
 1889 0c38 80B4     		push	{r7}
 1890              	.LCFI42:
 1891              		.cfi_def_cfa_offset 4
 1892              		.cfi_offset 7, -4
 1893 0c3a 85B0     		sub	sp, sp, #20
 1894              	.LCFI43:
 1895              		.cfi_def_cfa_offset 24
 1896 0c3c 00AF     		add	r7, sp, #0
 1897              	.LCFI44:
 1898              		.cfi_def_cfa_register 7
 1899 0c3e 7860     		str	r0, [r7, #4]
 929:../src/stm32f30x_can.c ****   uint8_t sleepstatus = CAN_Sleep_Failed;
 1900              		.loc 1 929 0
 1901 0c40 4FF00003 		mov	r3, #0
 1902 0c44 FB73     		strb	r3, [r7, #15]
 930:../src/stm32f30x_can.c ****   
 931:../src/stm32f30x_can.c ****   /* Check the parameters */
 932:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 933:../src/stm32f30x_can.c ****     
 934:../src/stm32f30x_can.c ****   /* Request Sleep mode */
 935:../src/stm32f30x_can.c ****    CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
 1903              		.loc 1 935 0
 1904 0c46 7B68     		ldr	r3, [r7, #4]
 1905 0c48 1B68     		ldr	r3, [r3, #0]
 1906 0c4a 23F00303 		bic	r3, r3, #3
 1907 0c4e 43F00202 		orr	r2, r3, #2
 1908 0c52 7B68     		ldr	r3, [r7, #4]
 1909 0c54 1A60     		str	r2, [r3, #0]
 936:../src/stm32f30x_can.c ****    
 937:../src/stm32f30x_can.c ****   /* Sleep mode status */
 938:../src/stm32f30x_can.c ****   if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
 1910              		.loc 1 938 0
 1911 0c56 7B68     		ldr	r3, [r7, #4]
 1912 0c58 5B68     		ldr	r3, [r3, #4]
 1913 0c5a 03F00303 		and	r3, r3, #3
 1914 0c5e 022B     		cmp	r3, #2
 1915 0c60 02D1     		bne	.L107
 939:../src/stm32f30x_can.c ****   {
 940:../src/stm32f30x_can.c ****     /* Sleep mode not entered */
 941:../src/stm32f30x_can.c ****     sleepstatus =  CAN_Sleep_Ok;
 1916              		.loc 1 941 0
 1917 0c62 4FF00103 		mov	r3, #1
 1918 0c66 FB73     		strb	r3, [r7, #15]
 1919              	.L107:
 942:../src/stm32f30x_can.c ****   }
 943:../src/stm32f30x_can.c ****   /* return sleep mode status */
 944:../src/stm32f30x_can.c ****    return (uint8_t)sleepstatus;
 1920              		.loc 1 944 0
 1921 0c68 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 945:../src/stm32f30x_can.c **** }
 1922              		.loc 1 945 0
 1923 0c6a 1846     		mov	r0, r3
 1924 0c6c 07F11407 		add	r7, r7, #20
 1925 0c70 BD46     		mov	sp, r7
 1926 0c72 80BC     		pop	{r7}
 1927 0c74 7047     		bx	lr
 1928              		.cfi_endproc
 1929              	.LFE125:
 1931 0c76 00BF     		.align	2
 1932              		.global	CAN_WakeUp
 1933              		.thumb
 1934              		.thumb_func
 1936              	CAN_WakeUp:
 1937              	.LFB126:
 946:../src/stm32f30x_can.c **** 
 947:../src/stm32f30x_can.c **** /**
 948:../src/stm32f30x_can.c ****   * @brief  Wakes up the CAN peripheral from sleep mode .
 949:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 to select the CAN1 peripheral.
 950:../src/stm32f30x_can.c ****   * @retval CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed otherwise.
 951:../src/stm32f30x_can.c ****   */
 952:../src/stm32f30x_can.c **** uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
 953:../src/stm32f30x_can.c **** {
 1938              		.loc 1 953 0
 1939              		.cfi_startproc
 1940              		@ args = 0, pretend = 0, frame = 16
 1941              		@ frame_needed = 1, uses_anonymous_args = 0
 1942              		@ link register save eliminated.
 1943 0c78 80B4     		push	{r7}
 1944              	.LCFI45:
 1945              		.cfi_def_cfa_offset 4
 1946              		.cfi_offset 7, -4
 1947 0c7a 85B0     		sub	sp, sp, #20
 1948              	.LCFI46:
 1949              		.cfi_def_cfa_offset 24
 1950 0c7c 00AF     		add	r7, sp, #0
 1951              	.LCFI47:
 1952              		.cfi_def_cfa_register 7
 1953 0c7e 7860     		str	r0, [r7, #4]
 954:../src/stm32f30x_can.c ****   uint32_t wait_slak = SLAK_TIMEOUT;
 1954              		.loc 1 954 0
 1955 0c80 6FF07F43 		mvn	r3, #-16777216
 1956 0c84 FB60     		str	r3, [r7, #12]
 955:../src/stm32f30x_can.c ****   uint8_t wakeupstatus = CAN_WakeUp_Failed;
 1957              		.loc 1 955 0
 1958 0c86 4FF00003 		mov	r3, #0
 1959 0c8a FB72     		strb	r3, [r7, #11]
 956:../src/stm32f30x_can.c ****   
 957:../src/stm32f30x_can.c ****   /* Check the parameters */
 958:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
 959:../src/stm32f30x_can.c ****     
 960:../src/stm32f30x_can.c ****   /* Wake up request */
 961:../src/stm32f30x_can.c ****   CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
 1960              		.loc 1 961 0
 1961 0c8c 7B68     		ldr	r3, [r7, #4]
 1962 0c8e 1B68     		ldr	r3, [r3, #0]
 1963 0c90 23F00202 		bic	r2, r3, #2
 1964 0c94 7B68     		ldr	r3, [r7, #4]
 1965 0c96 1A60     		str	r2, [r3, #0]
 962:../src/stm32f30x_can.c ****     
 963:../src/stm32f30x_can.c ****   /* Sleep mode status */
 964:../src/stm32f30x_can.c ****   while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
 1966              		.loc 1 964 0
 1967 0c98 03E0     		b	.L110
 1968              	.L112:
 965:../src/stm32f30x_can.c ****   {
 966:../src/stm32f30x_can.c ****    wait_slak--;
 1969              		.loc 1 966 0
 1970 0c9a FB68     		ldr	r3, [r7, #12]
 1971 0c9c 03F1FF33 		add	r3, r3, #-1
 1972 0ca0 FB60     		str	r3, [r7, #12]
 1973              	.L110:
 964:../src/stm32f30x_can.c ****   while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
 1974              		.loc 1 964 0 discriminator 1
 1975 0ca2 7B68     		ldr	r3, [r7, #4]
 1976 0ca4 5B68     		ldr	r3, [r3, #4]
 1977 0ca6 03F00203 		and	r3, r3, #2
 1978 0caa 002B     		cmp	r3, #0
 1979 0cac 02D0     		beq	.L111
 964:../src/stm32f30x_can.c ****   while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
 1980              		.loc 1 964 0 is_stmt 0 discriminator 2
 1981 0cae FB68     		ldr	r3, [r7, #12]
 1982 0cb0 002B     		cmp	r3, #0
 1983 0cb2 F2D1     		bne	.L112
 1984              	.L111:
 967:../src/stm32f30x_can.c ****   }
 968:../src/stm32f30x_can.c ****   if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
 1985              		.loc 1 968 0 is_stmt 1
 1986 0cb4 7B68     		ldr	r3, [r7, #4]
 1987 0cb6 5B68     		ldr	r3, [r3, #4]
 1988 0cb8 03F00203 		and	r3, r3, #2
 1989 0cbc 002B     		cmp	r3, #0
 1990 0cbe 02D1     		bne	.L113
 969:../src/stm32f30x_can.c ****   {
 970:../src/stm32f30x_can.c ****    /* wake up done : Sleep mode exited */
 971:../src/stm32f30x_can.c ****     wakeupstatus = CAN_WakeUp_Ok;
 1991              		.loc 1 971 0
 1992 0cc0 4FF00103 		mov	r3, #1
 1993 0cc4 FB72     		strb	r3, [r7, #11]
 1994              	.L113:
 972:../src/stm32f30x_can.c ****   }
 973:../src/stm32f30x_can.c ****   /* return wakeup status */
 974:../src/stm32f30x_can.c ****   return (uint8_t)wakeupstatus;
 1995              		.loc 1 974 0
 1996 0cc6 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 975:../src/stm32f30x_can.c **** }
 1997              		.loc 1 975 0
 1998 0cc8 1846     		mov	r0, r3
 1999 0cca 07F11407 		add	r7, r7, #20
 2000 0cce BD46     		mov	sp, r7
 2001 0cd0 80BC     		pop	{r7}
 2002 0cd2 7047     		bx	lr
 2003              		.cfi_endproc
 2004              	.LFE126:
 2006              		.align	2
 2007              		.global	CAN_GetLastErrorCode
 2008              		.thumb
 2009              		.thumb_func
 2011              	CAN_GetLastErrorCode:
 2012              	.LFB127:
 976:../src/stm32f30x_can.c **** /**
 977:../src/stm32f30x_can.c ****   * @}
 978:../src/stm32f30x_can.c ****   */
 979:../src/stm32f30x_can.c **** 
 980:../src/stm32f30x_can.c **** 
 981:../src/stm32f30x_can.c **** /** @defgroup CAN_Group5 CAN Bus Error management functions
 982:../src/stm32f30x_can.c ****  *  @brief    CAN Bus Error management functions 
 983:../src/stm32f30x_can.c ****  *
 984:../src/stm32f30x_can.c **** @verbatim    
 985:../src/stm32f30x_can.c ****  ===============================================================================
 986:../src/stm32f30x_can.c ****                   ##### CAN Bus Error management functions #####
 987:../src/stm32f30x_can.c ****  ===============================================================================  
 988:../src/stm32f30x_can.c ****     [..] This section provides functions allowing to 
 989:../src/stm32f30x_can.c ****          (+) Return the CANx's last error code (LEC).
 990:../src/stm32f30x_can.c ****          (+) Return the CANx Receive Error Counter (REC).
 991:../src/stm32f30x_can.c ****          (+) Return the LSB of the 9-bit CANx Transmit Error Counter(TEC).
 992:../src/stm32f30x_can.c ****     [..]
 993:../src/stm32f30x_can.c ****          (@) If TEC is greater than 255, The CAN is in bus-off state.
 994:../src/stm32f30x_can.c ****          (@) If REC or TEC are greater than 96, an Error warning flag occurs.
 995:../src/stm32f30x_can.c ****          (@) If REC or TEC are greater than 127, an Error Passive Flag occurs.
 996:../src/stm32f30x_can.c ****                         
 997:../src/stm32f30x_can.c **** @endverbatim
 998:../src/stm32f30x_can.c ****   * @{
 999:../src/stm32f30x_can.c ****   */
1000:../src/stm32f30x_can.c ****   
1001:../src/stm32f30x_can.c **** /**
1002:../src/stm32f30x_can.c ****   * @brief  Returns the CANx's last error code (LEC).
1003:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 to select the CAN1 peripheral.
1004:../src/stm32f30x_can.c ****   * @retval Error code: 
1005:../src/stm32f30x_can.c ****   *          - CAN_ERRORCODE_NoErr: No Error  
1006:../src/stm32f30x_can.c ****   *          - CAN_ERRORCODE_StuffErr: Stuff Error
1007:../src/stm32f30x_can.c ****   *          - CAN_ERRORCODE_FormErr: Form Error
1008:../src/stm32f30x_can.c ****   *          - CAN_ERRORCODE_ACKErr : Acknowledgment Error
1009:../src/stm32f30x_can.c ****   *          - CAN_ERRORCODE_BitRecessiveErr: Bit Recessive Error
1010:../src/stm32f30x_can.c ****   *          - CAN_ERRORCODE_BitDominantErr: Bit Dominant Error
1011:../src/stm32f30x_can.c ****   *          - CAN_ERRORCODE_CRCErr: CRC Error
1012:../src/stm32f30x_can.c ****   *          - CAN_ERRORCODE_SoftwareSetErr: Software Set Error  
1013:../src/stm32f30x_can.c ****   */
1014:../src/stm32f30x_can.c **** uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
1015:../src/stm32f30x_can.c **** {
 2013              		.loc 1 1015 0
 2014              		.cfi_startproc
 2015              		@ args = 0, pretend = 0, frame = 16
 2016              		@ frame_needed = 1, uses_anonymous_args = 0
 2017              		@ link register save eliminated.
 2018 0cd4 80B4     		push	{r7}
 2019              	.LCFI48:
 2020              		.cfi_def_cfa_offset 4
 2021              		.cfi_offset 7, -4
 2022 0cd6 85B0     		sub	sp, sp, #20
 2023              	.LCFI49:
 2024              		.cfi_def_cfa_offset 24
 2025 0cd8 00AF     		add	r7, sp, #0
 2026              	.LCFI50:
 2027              		.cfi_def_cfa_register 7
 2028 0cda 7860     		str	r0, [r7, #4]
1016:../src/stm32f30x_can.c ****   uint8_t errorcode=0;
 2029              		.loc 1 1016 0
 2030 0cdc 4FF00003 		mov	r3, #0
 2031 0ce0 FB73     		strb	r3, [r7, #15]
1017:../src/stm32f30x_can.c ****   
1018:../src/stm32f30x_can.c ****   /* Check the parameters */
1019:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1020:../src/stm32f30x_can.c ****   
1021:../src/stm32f30x_can.c ****   /* Get the error code*/
1022:../src/stm32f30x_can.c ****   errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
 2032              		.loc 1 1022 0
 2033 0ce2 7B68     		ldr	r3, [r7, #4]
 2034 0ce4 9B69     		ldr	r3, [r3, #24]
 2035 0ce6 DBB2     		uxtb	r3, r3
 2036 0ce8 03F07003 		and	r3, r3, #112
 2037 0cec FB73     		strb	r3, [r7, #15]
1023:../src/stm32f30x_can.c ****   
1024:../src/stm32f30x_can.c ****   /* Return the error code*/
1025:../src/stm32f30x_can.c ****   return errorcode;
 2038              		.loc 1 1025 0
 2039 0cee FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1026:../src/stm32f30x_can.c **** }
 2040              		.loc 1 1026 0
 2041 0cf0 1846     		mov	r0, r3
 2042 0cf2 07F11407 		add	r7, r7, #20
 2043 0cf6 BD46     		mov	sp, r7
 2044 0cf8 80BC     		pop	{r7}
 2045 0cfa 7047     		bx	lr
 2046              		.cfi_endproc
 2047              	.LFE127:
 2049              		.align	2
 2050              		.global	CAN_GetReceiveErrorCounter
 2051              		.thumb
 2052              		.thumb_func
 2054              	CAN_GetReceiveErrorCounter:
 2055              	.LFB128:
1027:../src/stm32f30x_can.c **** 
1028:../src/stm32f30x_can.c **** /**
1029:../src/stm32f30x_can.c ****   * @brief  Returns the CANx Receive Error Counter (REC).
1030:../src/stm32f30x_can.c ****   * @note   In case of an error during reception, this counter is incremented 
1031:../src/stm32f30x_can.c ****   *         by 1 or by 8 depending on the error condition as defined by the CAN 
1032:../src/stm32f30x_can.c ****   *         standard. After every successful reception, the counter is 
1033:../src/stm32f30x_can.c ****   *         decremented by 1 or reset to 120 if its value was higher than 128. 
1034:../src/stm32f30x_can.c ****   *         When the counter value exceeds 127, the CAN controller enters the 
1035:../src/stm32f30x_can.c ****   *         error passive state.  
1036:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
1037:../src/stm32f30x_can.c ****   * @retval CAN Receive Error Counter. 
1038:../src/stm32f30x_can.c ****   */
1039:../src/stm32f30x_can.c **** uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
1040:../src/stm32f30x_can.c **** {
 2056              		.loc 1 1040 0
 2057              		.cfi_startproc
 2058              		@ args = 0, pretend = 0, frame = 16
 2059              		@ frame_needed = 1, uses_anonymous_args = 0
 2060              		@ link register save eliminated.
 2061 0cfc 80B4     		push	{r7}
 2062              	.LCFI51:
 2063              		.cfi_def_cfa_offset 4
 2064              		.cfi_offset 7, -4
 2065 0cfe 85B0     		sub	sp, sp, #20
 2066              	.LCFI52:
 2067              		.cfi_def_cfa_offset 24
 2068 0d00 00AF     		add	r7, sp, #0
 2069              	.LCFI53:
 2070              		.cfi_def_cfa_register 7
 2071 0d02 7860     		str	r0, [r7, #4]
1041:../src/stm32f30x_can.c ****   uint8_t counter=0;
 2072              		.loc 1 1041 0
 2073 0d04 4FF00003 		mov	r3, #0
 2074 0d08 FB73     		strb	r3, [r7, #15]
1042:../src/stm32f30x_can.c ****   
1043:../src/stm32f30x_can.c ****   /* Check the parameters */
1044:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1045:../src/stm32f30x_can.c ****   
1046:../src/stm32f30x_can.c ****   /* Get the Receive Error Counter*/
1047:../src/stm32f30x_can.c ****   counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
 2075              		.loc 1 1047 0
 2076 0d0a 7B68     		ldr	r3, [r7, #4]
 2077 0d0c 9B69     		ldr	r3, [r3, #24]
 2078 0d0e 4FEA1363 		lsr	r3, r3, #24
 2079 0d12 FB73     		strb	r3, [r7, #15]
1048:../src/stm32f30x_can.c ****   
1049:../src/stm32f30x_can.c ****   /* Return the Receive Error Counter*/
1050:../src/stm32f30x_can.c ****   return counter;
 2080              		.loc 1 1050 0
 2081 0d14 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1051:../src/stm32f30x_can.c **** }
 2082              		.loc 1 1051 0
 2083 0d16 1846     		mov	r0, r3
 2084 0d18 07F11407 		add	r7, r7, #20
 2085 0d1c BD46     		mov	sp, r7
 2086 0d1e 80BC     		pop	{r7}
 2087 0d20 7047     		bx	lr
 2088              		.cfi_endproc
 2089              	.LFE128:
 2091 0d22 00BF     		.align	2
 2092              		.global	CAN_GetLSBTransmitErrorCounter
 2093              		.thumb
 2094              		.thumb_func
 2096              	CAN_GetLSBTransmitErrorCounter:
 2097              	.LFB129:
1052:../src/stm32f30x_can.c **** 
1053:../src/stm32f30x_can.c **** 
1054:../src/stm32f30x_can.c **** /**
1055:../src/stm32f30x_can.c ****   * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
1056:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
1057:../src/stm32f30x_can.c ****   * @retval LSB of the 9-bit CAN Transmit Error Counter. 
1058:../src/stm32f30x_can.c ****   */
1059:../src/stm32f30x_can.c **** uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
1060:../src/stm32f30x_can.c **** {
 2098              		.loc 1 1060 0
 2099              		.cfi_startproc
 2100              		@ args = 0, pretend = 0, frame = 16
 2101              		@ frame_needed = 1, uses_anonymous_args = 0
 2102              		@ link register save eliminated.
 2103 0d24 80B4     		push	{r7}
 2104              	.LCFI54:
 2105              		.cfi_def_cfa_offset 4
 2106              		.cfi_offset 7, -4
 2107 0d26 85B0     		sub	sp, sp, #20
 2108              	.LCFI55:
 2109              		.cfi_def_cfa_offset 24
 2110 0d28 00AF     		add	r7, sp, #0
 2111              	.LCFI56:
 2112              		.cfi_def_cfa_register 7
 2113 0d2a 7860     		str	r0, [r7, #4]
1061:../src/stm32f30x_can.c ****   uint8_t counter=0;
 2114              		.loc 1 1061 0
 2115 0d2c 4FF00003 		mov	r3, #0
 2116 0d30 FB73     		strb	r3, [r7, #15]
1062:../src/stm32f30x_can.c ****   
1063:../src/stm32f30x_can.c ****   /* Check the parameters */
1064:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1065:../src/stm32f30x_can.c ****   
1066:../src/stm32f30x_can.c ****   /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
1067:../src/stm32f30x_can.c ****   counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
 2117              		.loc 1 1067 0
 2118 0d32 7B68     		ldr	r3, [r7, #4]
 2119 0d34 9B69     		ldr	r3, [r3, #24]
 2120 0d36 03F47F03 		and	r3, r3, #16711680
 2121 0d3a 4FEA1343 		lsr	r3, r3, #16
 2122 0d3e FB73     		strb	r3, [r7, #15]
1068:../src/stm32f30x_can.c ****   
1069:../src/stm32f30x_can.c ****   /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
1070:../src/stm32f30x_can.c ****   return counter;
 2123              		.loc 1 1070 0
 2124 0d40 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1071:../src/stm32f30x_can.c **** }
 2125              		.loc 1 1071 0
 2126 0d42 1846     		mov	r0, r3
 2127 0d44 07F11407 		add	r7, r7, #20
 2128 0d48 BD46     		mov	sp, r7
 2129 0d4a 80BC     		pop	{r7}
 2130 0d4c 7047     		bx	lr
 2131              		.cfi_endproc
 2132              	.LFE129:
 2134 0d4e 00BF     		.align	2
 2135              		.global	CAN_ITConfig
 2136              		.thumb
 2137              		.thumb_func
 2139              	CAN_ITConfig:
 2140              	.LFB130:
1072:../src/stm32f30x_can.c **** /**
1073:../src/stm32f30x_can.c ****   * @}
1074:../src/stm32f30x_can.c ****   */
1075:../src/stm32f30x_can.c **** 
1076:../src/stm32f30x_can.c **** /** @defgroup CAN_Group6 Interrupts and flags management functions
1077:../src/stm32f30x_can.c ****  *  @brief   Interrupts and flags management functions
1078:../src/stm32f30x_can.c ****  *
1079:../src/stm32f30x_can.c **** @verbatim   
1080:../src/stm32f30x_can.c ****  ===============================================================================
1081:../src/stm32f30x_can.c ****               ##### Interrupts and flags management functions #####
1082:../src/stm32f30x_can.c ****  ===============================================================================  
1083:../src/stm32f30x_can.c ****     [..] This section provides functions allowing to configure the CAN Interrupts 
1084:../src/stm32f30x_can.c ****          and to get the status and clear flags and Interrupts pending bits.
1085:../src/stm32f30x_can.c ****     [..] The CAN provides 14 Interrupts sources and 15 Flags:
1086:../src/stm32f30x_can.c ****    
1087:../src/stm32f30x_can.c ****   *** Flags ***
1088:../src/stm32f30x_can.c ****   =============
1089:../src/stm32f30x_can.c ****     [..] The 15 flags can be divided on 4 groups: 
1090:../src/stm32f30x_can.c ****          (+) Transmit Flags:
1091:../src/stm32f30x_can.c ****              (++) CAN_FLAG_RQCP0. 
1092:../src/stm32f30x_can.c ****              (++) CAN_FLAG_RQCP1. 
1093:../src/stm32f30x_can.c ****              (++) CAN_FLAG_RQCP2: Request completed MailBoxes 0, 1 and 2  Flags
1094:../src/stm32f30x_can.c ****                   Set when when the last request (transmit or abort) has 
1095:../src/stm32f30x_can.c ****                   been performed. 
1096:../src/stm32f30x_can.c ****          (+) Receive Flags:
1097:../src/stm32f30x_can.c ****              (++) CAN_FLAG_FMP0.
1098:../src/stm32f30x_can.c ****              (++) CAN_FLAG_FMP1: FIFO 0 and 1 Message Pending Flags; 
1099:../src/stm32f30x_can.c ****                   Set to signal that messages are pending in the receive FIFO.
1100:../src/stm32f30x_can.c ****                   These Flags are cleared only by hardware. 
1101:../src/stm32f30x_can.c ****              (++) CAN_FLAG_FF0.
1102:../src/stm32f30x_can.c ****              (++) CAN_FLAG_FF1: FIFO 0 and 1 Full Flags; 
1103:../src/stm32f30x_can.c ****                   Set when three messages are stored in the selected FIFO.                        
1104:../src/stm32f30x_can.c ****              (++) CAN_FLAG_FOV0.              
1105:../src/stm32f30x_can.c ****              (++) CAN_FLAG_FOV1: FIFO 0 and 1 Overrun Flags; 
1106:../src/stm32f30x_can.c ****                   Set when a new message has been received and passed the filter 
1107:../src/stm32f30x_can.c ****                   while the FIFO was full.         
1108:../src/stm32f30x_can.c ****          (+) Operating Mode Flags: 
1109:../src/stm32f30x_can.c ****              (++) CAN_FLAG_WKU: Wake up Flag; 
1110:../src/stm32f30x_can.c ****                   Set to signal that a SOF bit has been detected while the CAN 
1111:../src/stm32f30x_can.c ****                   hardware was in Sleep mode. 
1112:../src/stm32f30x_can.c ****              (++) CAN_FLAG_SLAK: Sleep acknowledge Flag;
1113:../src/stm32f30x_can.c ****                   Set to signal that the CAN has entered Sleep Mode. 
1114:../src/stm32f30x_can.c ****          (+) Error Flags:  
1115:../src/stm32f30x_can.c ****              (++) CAN_FLAG_EWG: Error Warning Flag;
1116:../src/stm32f30x_can.c ****                   Set when the warning limit has been reached (Receive Error Counter 
1117:../src/stm32f30x_can.c ****                   or Transmit Error Counter greater than 96). 
1118:../src/stm32f30x_can.c ****                   This Flag is cleared only by hardware.
1119:../src/stm32f30x_can.c ****              (++) CAN_FLAG_EPV: Error Passive Flag;
1120:../src/stm32f30x_can.c ****                   Set when the Error Passive limit has been reached (Receive Error 
1121:../src/stm32f30x_can.c ****                   Counter or Transmit Error Counter greater than 127).
1122:../src/stm32f30x_can.c ****                   This Flag is cleared only by hardware.
1123:../src/stm32f30x_can.c ****              (++) CAN_FLAG_BOF: Bus-Off Flag;
1124:../src/stm32f30x_can.c ****                   Set when CAN enters the bus-off state. The bus-off state is 
1125:../src/stm32f30x_can.c ****                   entered on TEC overflow, greater than 255.
1126:../src/stm32f30x_can.c ****                   This Flag is cleared only by hardware.
1127:../src/stm32f30x_can.c ****              (++) CAN_FLAG_LEC: Last error code Flag;
1128:../src/stm32f30x_can.c ****                   Set If a message has been transferred (reception or transmission) 
1129:../src/stm32f30x_can.c ****                   with error, and the error code is hold.                      
1130:../src/stm32f30x_can.c ****   
1131:../src/stm32f30x_can.c ****   *** Interrupts ***
1132:../src/stm32f30x_can.c ****   ==================
1133:../src/stm32f30x_can.c ****     [..] The 14 interrupts can be divided on 4 groups: 
1134:../src/stm32f30x_can.c ****          (+) Transmit interrupt:   
1135:../src/stm32f30x_can.c ****              (++) CAN_IT_TME: Transmit mailbox empty Interrupt;
1136:../src/stm32f30x_can.c ****                   If enabled, this interrupt source is pending when no transmit 
1137:../src/stm32f30x_can.c ****                   request are pending for Tx mailboxes.      
1138:../src/stm32f30x_can.c ****          (+) Receive Interrupts:   
1139:../src/stm32f30x_can.c ****              (++) CAN_IT_FMP0.
1140:../src/stm32f30x_can.c ****              (++) CAN_IT_FMP1: FIFO 0 and FIFO1 message pending Interrupts;
1141:../src/stm32f30x_can.c ****                   If enabled, these interrupt sources are pending when messages 
1142:../src/stm32f30x_can.c ****                   are pending in the receive FIFO.
1143:../src/stm32f30x_can.c ****                   The corresponding interrupt pending bits are cleared only by hardware.
1144:../src/stm32f30x_can.c ****              (++) CAN_IT_FF0.              
1145:../src/stm32f30x_can.c ****              (++) CAN_IT_FF1: FIFO 0 and FIFO1 full Interrupts;
1146:../src/stm32f30x_can.c ****                   If enabled, these interrupt sources are pending when three messages 
1147:../src/stm32f30x_can.c ****                   are stored in the selected FIFO.
1148:../src/stm32f30x_can.c ****              (++) CAN_IT_FOV0.        
1149:../src/stm32f30x_can.c ****              (++) CAN_IT_FOV1: FIFO 0 and FIFO1 overrun Interrupts;        
1150:../src/stm32f30x_can.c ****                   If enabled, these interrupt sources are pending when a new message 
1151:../src/stm32f30x_can.c ****                   has been received and passed the filter while the FIFO was full.
1152:../src/stm32f30x_can.c ****          (+) Operating Mode Interrupts:    
1153:../src/stm32f30x_can.c ****              (++) CAN_IT_WKU: Wake-up Interrupt;
1154:../src/stm32f30x_can.c ****                   If enabled, this interrupt source is pending when a SOF bit has 
1155:../src/stm32f30x_can.c ****                   been detected while the CAN hardware was in Sleep mode.
1156:../src/stm32f30x_can.c ****              (++) CAN_IT_SLK: Sleep acknowledge Interrupt:
1157:../src/stm32f30x_can.c ****                   If enabled, this interrupt source is pending when the CAN has 
1158:../src/stm32f30x_can.c ****                   entered Sleep Mode.       
1159:../src/stm32f30x_can.c ****          (+) Error Interrupts:     
1160:../src/stm32f30x_can.c ****              (++) CAN_IT_EWG: Error warning Interrupt; 
1161:../src/stm32f30x_can.c ****                   If enabled, this interrupt source is pending when the warning limit 
1162:../src/stm32f30x_can.c ****                   has been reached (Receive Error Counter or Transmit Error Counter=96). 
1163:../src/stm32f30x_can.c ****              (++) CAN_IT_EPV: Error passive Interrupt;        
1164:../src/stm32f30x_can.c ****                   If enabled, this interrupt source is pending when the Error Passive 
1165:../src/stm32f30x_can.c ****                   limit has been reached (Receive Error Counter or Transmit Error Counter>127).
1166:../src/stm32f30x_can.c ****              (++) CAN_IT_BOF: Bus-off Interrupt;
1167:../src/stm32f30x_can.c ****                   If enabled, this interrupt source is pending when CAN enters 
1168:../src/stm32f30x_can.c ****                   the bus-off state. The bus-off state is entered on TEC overflow, 
1169:../src/stm32f30x_can.c ****                   greater than 255.
1170:../src/stm32f30x_can.c ****                   This Flag is cleared only by hardware.
1171:../src/stm32f30x_can.c ****              (++) CAN_IT_LEC: Last error code Interrupt;        
1172:../src/stm32f30x_can.c ****                   If enabled, this interrupt source is pending when a message has 
1173:../src/stm32f30x_can.c ****                   been transferred (reception or transmission) with error and the 
1174:../src/stm32f30x_can.c ****                   error code is hold.
1175:../src/stm32f30x_can.c ****              (++) CAN_IT_ERR: Error Interrupt;
1176:../src/stm32f30x_can.c ****                   If enabled, this interrupt source is pending when an error condition 
1177:../src/stm32f30x_can.c ****                   is pending.      
1178:../src/stm32f30x_can.c ****     [..] Managing the CAN controller events: 
1179:../src/stm32f30x_can.c ****          The user should identify which mode will be used in his application to manage 
1180:../src/stm32f30x_can.c ****          the CAN controller events: Polling mode or Interrupt mode.
1181:../src/stm32f30x_can.c ****          (+) In the Polling Mode it is advised to use the following functions:
1182:../src/stm32f30x_can.c ****              (++) CAN_GetFlagStatus() : to check if flags events occur. 
1183:../src/stm32f30x_can.c ****              (++) CAN_ClearFlag()     : to clear the flags events.
1184:../src/stm32f30x_can.c ****          (+) In the Interrupt Mode it is advised to use the following functions:
1185:../src/stm32f30x_can.c ****              (++) CAN_ITConfig()       : to enable or disable the interrupt source.
1186:../src/stm32f30x_can.c ****              (++) CAN_GetITStatus()    : to check if Interrupt occurs.
1187:../src/stm32f30x_can.c ****              (++) CAN_ClearITPendingBit() : to clear the Interrupt pending Bit 
1188:../src/stm32f30x_can.c ****                   (corresponding Flag).
1189:../src/stm32f30x_can.c ****                   This function has no impact on CAN_IT_FMP0 and CAN_IT_FMP1 Interrupts 
1190:../src/stm32f30x_can.c ****                   pending bits since there are cleared only by hardware. 
1191:../src/stm32f30x_can.c ****   
1192:../src/stm32f30x_can.c **** @endverbatim
1193:../src/stm32f30x_can.c ****   * @{
1194:../src/stm32f30x_can.c ****   */ 
1195:../src/stm32f30x_can.c **** /**
1196:../src/stm32f30x_can.c ****   * @brief  Enables or disables the specified CANx interrupts.
1197:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
1198:../src/stm32f30x_can.c ****   * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
1199:../src/stm32f30x_can.c ****   *          This parameter can be: 
1200:../src/stm32f30x_can.c ****   *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
1201:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
1202:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
1203:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
1204:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
1205:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
1206:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
1207:../src/stm32f30x_can.c ****   *            @arg CAN_IT_WKU: Wake-up Interrupt
1208:../src/stm32f30x_can.c ****   *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
1209:../src/stm32f30x_can.c ****   *            @arg CAN_IT_EWG: Error warning Interrupt
1210:../src/stm32f30x_can.c ****   *            @arg CAN_IT_EPV: Error passive Interrupt
1211:../src/stm32f30x_can.c ****   *            @arg CAN_IT_BOF: Bus-off Interrupt  
1212:../src/stm32f30x_can.c ****   *            @arg CAN_IT_LEC: Last error code Interrupt
1213:../src/stm32f30x_can.c ****   *            @arg CAN_IT_ERR: Error Interrupt
1214:../src/stm32f30x_can.c ****   * @param  NewState: new state of the CAN interrupts.
1215:../src/stm32f30x_can.c ****   *          This parameter can be: ENABLE or DISABLE.
1216:../src/stm32f30x_can.c ****   * @retval None
1217:../src/stm32f30x_can.c ****   */
1218:../src/stm32f30x_can.c **** void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
1219:../src/stm32f30x_can.c **** {
 2141              		.loc 1 1219 0
 2142              		.cfi_startproc
 2143              		@ args = 0, pretend = 0, frame = 16
 2144              		@ frame_needed = 1, uses_anonymous_args = 0
 2145              		@ link register save eliminated.
 2146 0d50 80B4     		push	{r7}
 2147              	.LCFI57:
 2148              		.cfi_def_cfa_offset 4
 2149              		.cfi_offset 7, -4
 2150 0d52 85B0     		sub	sp, sp, #20
 2151              	.LCFI58:
 2152              		.cfi_def_cfa_offset 24
 2153 0d54 00AF     		add	r7, sp, #0
 2154              	.LCFI59:
 2155              		.cfi_def_cfa_register 7
 2156 0d56 F860     		str	r0, [r7, #12]
 2157 0d58 B960     		str	r1, [r7, #8]
 2158 0d5a 1346     		mov	r3, r2
 2159 0d5c FB71     		strb	r3, [r7, #7]
1220:../src/stm32f30x_can.c ****   /* Check the parameters */
1221:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1222:../src/stm32f30x_can.c ****   assert_param(IS_CAN_IT(CAN_IT));
1223:../src/stm32f30x_can.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1224:../src/stm32f30x_can.c **** 
1225:../src/stm32f30x_can.c ****   if (NewState != DISABLE)
 2160              		.loc 1 1225 0
 2161 0d5e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2162 0d60 002B     		cmp	r3, #0
 2163 0d62 06D0     		beq	.L122
1226:../src/stm32f30x_can.c ****   {
1227:../src/stm32f30x_can.c ****     /* Enable the selected CANx interrupt */
1228:../src/stm32f30x_can.c ****     CANx->IER |= CAN_IT;
 2164              		.loc 1 1228 0
 2165 0d64 FB68     		ldr	r3, [r7, #12]
 2166 0d66 5A69     		ldr	r2, [r3, #20]
 2167 0d68 BB68     		ldr	r3, [r7, #8]
 2168 0d6a 1A43     		orrs	r2, r2, r3
 2169 0d6c FB68     		ldr	r3, [r7, #12]
 2170 0d6e 5A61     		str	r2, [r3, #20]
 2171 0d70 07E0     		b	.L121
 2172              	.L122:
1229:../src/stm32f30x_can.c ****   }
1230:../src/stm32f30x_can.c ****   else
1231:../src/stm32f30x_can.c ****   {
1232:../src/stm32f30x_can.c ****     /* Disable the selected CANx interrupt */
1233:../src/stm32f30x_can.c ****     CANx->IER &= ~CAN_IT;
 2173              		.loc 1 1233 0
 2174 0d72 FB68     		ldr	r3, [r7, #12]
 2175 0d74 5A69     		ldr	r2, [r3, #20]
 2176 0d76 BB68     		ldr	r3, [r7, #8]
 2177 0d78 6FEA0303 		mvn	r3, r3
 2178 0d7c 1A40     		ands	r2, r2, r3
 2179 0d7e FB68     		ldr	r3, [r7, #12]
 2180 0d80 5A61     		str	r2, [r3, #20]
 2181              	.L121:
1234:../src/stm32f30x_can.c ****   }
1235:../src/stm32f30x_can.c **** }
 2182              		.loc 1 1235 0
 2183 0d82 07F11407 		add	r7, r7, #20
 2184 0d86 BD46     		mov	sp, r7
 2185 0d88 80BC     		pop	{r7}
 2186 0d8a 7047     		bx	lr
 2187              		.cfi_endproc
 2188              	.LFE130:
 2190              		.align	2
 2191              		.global	CAN_GetFlagStatus
 2192              		.thumb
 2193              		.thumb_func
 2195              	CAN_GetFlagStatus:
 2196              	.LFB131:
1236:../src/stm32f30x_can.c **** /**
1237:../src/stm32f30x_can.c ****   * @brief  Checks whether the specified CAN flag is set or not.
1238:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
1239:../src/stm32f30x_can.c ****   * @param  CAN_FLAG: specifies the flag to check.
1240:../src/stm32f30x_can.c ****   *          This parameter can be one of the following values:
1241:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
1242:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
1243:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag
1244:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag   
1245:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
1246:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag 
1247:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag   
1248:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
1249:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
1250:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_WKU: Wake up Flag
1251:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag 
1252:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_EWG: Error Warning Flag
1253:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_EPV: Error Passive Flag  
1254:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_BOF: Bus-Off Flag    
1255:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_LEC: Last error code Flag      
1256:../src/stm32f30x_can.c ****   * @retval The new state of CAN_FLAG (SET or RESET).
1257:../src/stm32f30x_can.c ****   */
1258:../src/stm32f30x_can.c **** FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
1259:../src/stm32f30x_can.c **** {
 2197              		.loc 1 1259 0
 2198              		.cfi_startproc
 2199              		@ args = 0, pretend = 0, frame = 16
 2200              		@ frame_needed = 1, uses_anonymous_args = 0
 2201              		@ link register save eliminated.
 2202 0d8c 80B4     		push	{r7}
 2203              	.LCFI60:
 2204              		.cfi_def_cfa_offset 4
 2205              		.cfi_offset 7, -4
 2206 0d8e 85B0     		sub	sp, sp, #20
 2207              	.LCFI61:
 2208              		.cfi_def_cfa_offset 24
 2209 0d90 00AF     		add	r7, sp, #0
 2210              	.LCFI62:
 2211              		.cfi_def_cfa_register 7
 2212 0d92 7860     		str	r0, [r7, #4]
 2213 0d94 3960     		str	r1, [r7, #0]
1260:../src/stm32f30x_can.c ****   FlagStatus bitstatus = RESET;
 2214              		.loc 1 1260 0
 2215 0d96 4FF00003 		mov	r3, #0
 2216 0d9a FB73     		strb	r3, [r7, #15]
1261:../src/stm32f30x_can.c ****   
1262:../src/stm32f30x_can.c ****   /* Check the parameters */
1263:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1264:../src/stm32f30x_can.c ****   assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
1265:../src/stm32f30x_can.c ****   
1266:../src/stm32f30x_can.c **** 
1267:../src/stm32f30x_can.c ****   if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
 2217              		.loc 1 1267 0
 2218 0d9c 3B68     		ldr	r3, [r7, #0]
 2219 0d9e 03F47003 		and	r3, r3, #15728640
 2220 0da2 002B     		cmp	r3, #0
 2221 0da4 11D0     		beq	.L125
1268:../src/stm32f30x_can.c ****   { 
1269:../src/stm32f30x_can.c ****     /* Check the status of the specified CAN flag */
1270:../src/stm32f30x_can.c ****     if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 2222              		.loc 1 1270 0
 2223 0da6 7B68     		ldr	r3, [r7, #4]
 2224 0da8 9A69     		ldr	r2, [r3, #24]
 2225 0daa 3B68     		ldr	r3, [r7, #0]
 2226 0dac 1340     		ands	r3, r3, r2
 2227 0dae 23F07F43 		bic	r3, r3, #-16777216
 2228 0db2 23F47003 		bic	r3, r3, #15728640
 2229 0db6 002B     		cmp	r3, #0
 2230 0db8 03D0     		beq	.L126
1271:../src/stm32f30x_can.c ****     { 
1272:../src/stm32f30x_can.c ****       /* CAN_FLAG is set */
1273:../src/stm32f30x_can.c ****       bitstatus = SET;
 2231              		.loc 1 1273 0
 2232 0dba 4FF00103 		mov	r3, #1
 2233 0dbe FB73     		strb	r3, [r7, #15]
 2234 0dc0 59E0     		b	.L127
 2235              	.L126:
1274:../src/stm32f30x_can.c ****     }
1275:../src/stm32f30x_can.c ****     else
1276:../src/stm32f30x_can.c ****     { 
1277:../src/stm32f30x_can.c ****       /* CAN_FLAG is reset */
1278:../src/stm32f30x_can.c ****       bitstatus = RESET;
 2236              		.loc 1 1278 0
 2237 0dc2 4FF00003 		mov	r3, #0
 2238 0dc6 FB73     		strb	r3, [r7, #15]
 2239 0dc8 55E0     		b	.L127
 2240              	.L125:
1279:../src/stm32f30x_can.c ****     }
1280:../src/stm32f30x_can.c ****   }
1281:../src/stm32f30x_can.c ****   else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
 2241              		.loc 1 1281 0
 2242 0dca 3B68     		ldr	r3, [r7, #0]
 2243 0dcc 03F08073 		and	r3, r3, #16777216
 2244 0dd0 002B     		cmp	r3, #0
 2245 0dd2 11D0     		beq	.L128
1282:../src/stm32f30x_can.c ****   { 
1283:../src/stm32f30x_can.c ****     /* Check the status of the specified CAN flag */
1284:../src/stm32f30x_can.c ****     if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 2246              		.loc 1 1284 0
 2247 0dd4 7B68     		ldr	r3, [r7, #4]
 2248 0dd6 5A68     		ldr	r2, [r3, #4]
 2249 0dd8 3B68     		ldr	r3, [r7, #0]
 2250 0dda 1340     		ands	r3, r3, r2
 2251 0ddc 23F07F43 		bic	r3, r3, #-16777216
 2252 0de0 23F47003 		bic	r3, r3, #15728640
 2253 0de4 002B     		cmp	r3, #0
 2254 0de6 03D0     		beq	.L129
1285:../src/stm32f30x_can.c ****     { 
1286:../src/stm32f30x_can.c ****       /* CAN_FLAG is set */
1287:../src/stm32f30x_can.c ****       bitstatus = SET;
 2255              		.loc 1 1287 0
 2256 0de8 4FF00103 		mov	r3, #1
 2257 0dec FB73     		strb	r3, [r7, #15]
 2258 0dee 42E0     		b	.L127
 2259              	.L129:
1288:../src/stm32f30x_can.c ****     }
1289:../src/stm32f30x_can.c ****     else
1290:../src/stm32f30x_can.c ****     { 
1291:../src/stm32f30x_can.c ****       /* CAN_FLAG is reset */
1292:../src/stm32f30x_can.c ****       bitstatus = RESET;
 2260              		.loc 1 1292 0
 2261 0df0 4FF00003 		mov	r3, #0
 2262 0df4 FB73     		strb	r3, [r7, #15]
 2263 0df6 3EE0     		b	.L127
 2264              	.L128:
1293:../src/stm32f30x_can.c ****     }
1294:../src/stm32f30x_can.c ****   }
1295:../src/stm32f30x_can.c ****   else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
 2265              		.loc 1 1295 0
 2266 0df8 3B68     		ldr	r3, [r7, #0]
 2267 0dfa 03F00063 		and	r3, r3, #134217728
 2268 0dfe 002B     		cmp	r3, #0
 2269 0e00 11D0     		beq	.L130
1296:../src/stm32f30x_can.c ****   { 
1297:../src/stm32f30x_can.c ****     /* Check the status of the specified CAN flag */
1298:../src/stm32f30x_can.c ****     if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 2270              		.loc 1 1298 0
 2271 0e02 7B68     		ldr	r3, [r7, #4]
 2272 0e04 9A68     		ldr	r2, [r3, #8]
 2273 0e06 3B68     		ldr	r3, [r7, #0]
 2274 0e08 1340     		ands	r3, r3, r2
 2275 0e0a 23F07F43 		bic	r3, r3, #-16777216
 2276 0e0e 23F47003 		bic	r3, r3, #15728640
 2277 0e12 002B     		cmp	r3, #0
 2278 0e14 03D0     		beq	.L131
1299:../src/stm32f30x_can.c ****     { 
1300:../src/stm32f30x_can.c ****       /* CAN_FLAG is set */
1301:../src/stm32f30x_can.c ****       bitstatus = SET;
 2279              		.loc 1 1301 0
 2280 0e16 4FF00103 		mov	r3, #1
 2281 0e1a FB73     		strb	r3, [r7, #15]
 2282 0e1c 2BE0     		b	.L127
 2283              	.L131:
1302:../src/stm32f30x_can.c ****     }
1303:../src/stm32f30x_can.c ****     else
1304:../src/stm32f30x_can.c ****     { 
1305:../src/stm32f30x_can.c ****       /* CAN_FLAG is reset */
1306:../src/stm32f30x_can.c ****       bitstatus = RESET;
 2284              		.loc 1 1306 0
 2285 0e1e 4FF00003 		mov	r3, #0
 2286 0e22 FB73     		strb	r3, [r7, #15]
 2287 0e24 27E0     		b	.L127
 2288              	.L130:
1307:../src/stm32f30x_can.c ****     }
1308:../src/stm32f30x_can.c ****   }
1309:../src/stm32f30x_can.c ****   else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
 2289              		.loc 1 1309 0
 2290 0e26 3B68     		ldr	r3, [r7, #0]
 2291 0e28 03F00073 		and	r3, r3, #33554432
 2292 0e2c 002B     		cmp	r3, #0
 2293 0e2e 11D0     		beq	.L132
1310:../src/stm32f30x_can.c ****   { 
1311:../src/stm32f30x_can.c ****     /* Check the status of the specified CAN flag */
1312:../src/stm32f30x_can.c ****     if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 2294              		.loc 1 1312 0
 2295 0e30 7B68     		ldr	r3, [r7, #4]
 2296 0e32 DA68     		ldr	r2, [r3, #12]
 2297 0e34 3B68     		ldr	r3, [r7, #0]
 2298 0e36 1340     		ands	r3, r3, r2
 2299 0e38 23F07F43 		bic	r3, r3, #-16777216
 2300 0e3c 23F47003 		bic	r3, r3, #15728640
 2301 0e40 002B     		cmp	r3, #0
 2302 0e42 03D0     		beq	.L133
1313:../src/stm32f30x_can.c ****     { 
1314:../src/stm32f30x_can.c ****       /* CAN_FLAG is set */
1315:../src/stm32f30x_can.c ****       bitstatus = SET;
 2303              		.loc 1 1315 0
 2304 0e44 4FF00103 		mov	r3, #1
 2305 0e48 FB73     		strb	r3, [r7, #15]
 2306 0e4a 14E0     		b	.L127
 2307              	.L133:
1316:../src/stm32f30x_can.c ****     }
1317:../src/stm32f30x_can.c ****     else
1318:../src/stm32f30x_can.c ****     { 
1319:../src/stm32f30x_can.c ****       /* CAN_FLAG is reset */
1320:../src/stm32f30x_can.c ****       bitstatus = RESET;
 2308              		.loc 1 1320 0
 2309 0e4c 4FF00003 		mov	r3, #0
 2310 0e50 FB73     		strb	r3, [r7, #15]
 2311 0e52 10E0     		b	.L127
 2312              	.L132:
1321:../src/stm32f30x_can.c ****     }
1322:../src/stm32f30x_can.c ****   }
1323:../src/stm32f30x_can.c ****   else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
1324:../src/stm32f30x_can.c ****   { 
1325:../src/stm32f30x_can.c ****     /* Check the status of the specified CAN flag */
1326:../src/stm32f30x_can.c ****     if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 2313              		.loc 1 1326 0
 2314 0e54 7B68     		ldr	r3, [r7, #4]
 2315 0e56 1A69     		ldr	r2, [r3, #16]
 2316 0e58 3B68     		ldr	r3, [r7, #0]
 2317 0e5a 1340     		ands	r3, r3, r2
 2318 0e5c 23F07F43 		bic	r3, r3, #-16777216
 2319 0e60 23F47003 		bic	r3, r3, #15728640
 2320 0e64 002B     		cmp	r3, #0
 2321 0e66 03D0     		beq	.L134
1327:../src/stm32f30x_can.c ****     { 
1328:../src/stm32f30x_can.c ****       /* CAN_FLAG is set */
1329:../src/stm32f30x_can.c ****       bitstatus = SET;
 2322              		.loc 1 1329 0
 2323 0e68 4FF00103 		mov	r3, #1
 2324 0e6c FB73     		strb	r3, [r7, #15]
 2325 0e6e 02E0     		b	.L127
 2326              	.L134:
1330:../src/stm32f30x_can.c ****     }
1331:../src/stm32f30x_can.c ****     else
1332:../src/stm32f30x_can.c ****     { 
1333:../src/stm32f30x_can.c ****       /* CAN_FLAG is reset */
1334:../src/stm32f30x_can.c ****       bitstatus = RESET;
 2327              		.loc 1 1334 0
 2328 0e70 4FF00003 		mov	r3, #0
 2329 0e74 FB73     		strb	r3, [r7, #15]
 2330              	.L127:
1335:../src/stm32f30x_can.c ****     }
1336:../src/stm32f30x_can.c ****   }
1337:../src/stm32f30x_can.c ****   /* Return the CAN_FLAG status */
1338:../src/stm32f30x_can.c ****   return  bitstatus;
 2331              		.loc 1 1338 0
 2332 0e76 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1339:../src/stm32f30x_can.c **** }
 2333              		.loc 1 1339 0
 2334 0e78 1846     		mov	r0, r3
 2335 0e7a 07F11407 		add	r7, r7, #20
 2336 0e7e BD46     		mov	sp, r7
 2337 0e80 80BC     		pop	{r7}
 2338 0e82 7047     		bx	lr
 2339              		.cfi_endproc
 2340              	.LFE131:
 2342              		.align	2
 2343              		.global	CAN_ClearFlag
 2344              		.thumb
 2345              		.thumb_func
 2347              	CAN_ClearFlag:
 2348              	.LFB132:
1340:../src/stm32f30x_can.c **** 
1341:../src/stm32f30x_can.c **** /**
1342:../src/stm32f30x_can.c ****   * @brief  Clears the CAN's pending flags.
1343:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
1344:../src/stm32f30x_can.c ****   * @param  CAN_FLAG: specifies the flag to clear.
1345:../src/stm32f30x_can.c ****   *          This parameter can be one of the following values:
1346:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
1347:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
1348:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag 
1349:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
1350:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag  
1351:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
1352:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
1353:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_WKU: Wake up Flag
1354:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag    
1355:../src/stm32f30x_can.c ****   *            @arg CAN_FLAG_LEC: Last error code Flag        
1356:../src/stm32f30x_can.c ****   * @retval None
1357:../src/stm32f30x_can.c ****   */
1358:../src/stm32f30x_can.c **** void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
1359:../src/stm32f30x_can.c **** {
 2349              		.loc 1 1359 0
 2350              		.cfi_startproc
 2351              		@ args = 0, pretend = 0, frame = 16
 2352              		@ frame_needed = 1, uses_anonymous_args = 0
 2353              		@ link register save eliminated.
 2354 0e84 80B4     		push	{r7}
 2355              	.LCFI63:
 2356              		.cfi_def_cfa_offset 4
 2357              		.cfi_offset 7, -4
 2358 0e86 85B0     		sub	sp, sp, #20
 2359              	.LCFI64:
 2360              		.cfi_def_cfa_offset 24
 2361 0e88 00AF     		add	r7, sp, #0
 2362              	.LCFI65:
 2363              		.cfi_def_cfa_register 7
 2364 0e8a 7860     		str	r0, [r7, #4]
 2365 0e8c 3960     		str	r1, [r7, #0]
1360:../src/stm32f30x_can.c ****   uint32_t flagtmp=0;
 2366              		.loc 1 1360 0
 2367 0e8e 4FF00003 		mov	r3, #0
 2368 0e92 FB60     		str	r3, [r7, #12]
1361:../src/stm32f30x_can.c ****   /* Check the parameters */
1362:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1363:../src/stm32f30x_can.c ****   assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
1364:../src/stm32f30x_can.c ****   
1365:../src/stm32f30x_can.c ****   if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
 2369              		.loc 1 1365 0
 2370 0e94 3A68     		ldr	r2, [r7, #0]
 2371 0e96 4FF07003 		mov	r3, #112
 2372 0e9a C3F2F003 		movt	r3, 12528
 2373 0e9e 9A42     		cmp	r2, r3
 2374 0ea0 04D1     		bne	.L137
1366:../src/stm32f30x_can.c ****   {
1367:../src/stm32f30x_can.c ****     /* Clear the selected CAN flags */
1368:../src/stm32f30x_can.c ****     CANx->ESR = (uint32_t)RESET;
 2375              		.loc 1 1368 0
 2376 0ea2 7B68     		ldr	r3, [r7, #4]
 2377 0ea4 4FF00002 		mov	r2, #0
 2378 0ea8 9A61     		str	r2, [r3, #24]
 2379 0eaa 23E0     		b	.L136
 2380              	.L137:
1369:../src/stm32f30x_can.c ****   }
1370:../src/stm32f30x_can.c ****   else /* MSR or TSR or RF0R or RF1R */
1371:../src/stm32f30x_can.c ****   {
1372:../src/stm32f30x_can.c ****     flagtmp = CAN_FLAG & 0x000FFFFF;
 2381              		.loc 1 1372 0
 2382 0eac 3B68     		ldr	r3, [r7, #0]
 2383 0eae 23F07F43 		bic	r3, r3, #-16777216
 2384 0eb2 23F47003 		bic	r3, r3, #15728640
 2385 0eb6 FB60     		str	r3, [r7, #12]
1373:../src/stm32f30x_can.c **** 
1374:../src/stm32f30x_can.c ****     if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
 2386              		.loc 1 1374 0
 2387 0eb8 3B68     		ldr	r3, [r7, #0]
 2388 0eba 03F00073 		and	r3, r3, #33554432
 2389 0ebe 002B     		cmp	r3, #0
 2390 0ec0 03D0     		beq	.L139
1375:../src/stm32f30x_can.c ****     {
1376:../src/stm32f30x_can.c ****       /* Receive Flags */
1377:../src/stm32f30x_can.c ****       CANx->RF0R = (uint32_t)(flagtmp);
 2391              		.loc 1 1377 0
 2392 0ec2 7B68     		ldr	r3, [r7, #4]
 2393 0ec4 FA68     		ldr	r2, [r7, #12]
 2394 0ec6 DA60     		str	r2, [r3, #12]
 2395 0ec8 14E0     		b	.L136
 2396              	.L139:
1378:../src/stm32f30x_can.c ****     }
1379:../src/stm32f30x_can.c ****     else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
 2397              		.loc 1 1379 0
 2398 0eca 3B68     		ldr	r3, [r7, #0]
 2399 0ecc 03F08063 		and	r3, r3, #67108864
 2400 0ed0 002B     		cmp	r3, #0
 2401 0ed2 03D0     		beq	.L140
1380:../src/stm32f30x_can.c ****     {
1381:../src/stm32f30x_can.c ****       /* Receive Flags */
1382:../src/stm32f30x_can.c ****       CANx->RF1R = (uint32_t)(flagtmp);
 2402              		.loc 1 1382 0
 2403 0ed4 7B68     		ldr	r3, [r7, #4]
 2404 0ed6 FA68     		ldr	r2, [r7, #12]
 2405 0ed8 1A61     		str	r2, [r3, #16]
 2406 0eda 0BE0     		b	.L136
 2407              	.L140:
1383:../src/stm32f30x_can.c ****     }
1384:../src/stm32f30x_can.c ****     else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
 2408              		.loc 1 1384 0
 2409 0edc 3B68     		ldr	r3, [r7, #0]
 2410 0ede 03F00063 		and	r3, r3, #134217728
 2411 0ee2 002B     		cmp	r3, #0
 2412 0ee4 03D0     		beq	.L141
1385:../src/stm32f30x_can.c ****     {
1386:../src/stm32f30x_can.c ****       /* Transmit Flags */
1387:../src/stm32f30x_can.c ****       CANx->TSR = (uint32_t)(flagtmp);
 2413              		.loc 1 1387 0
 2414 0ee6 7B68     		ldr	r3, [r7, #4]
 2415 0ee8 FA68     		ldr	r2, [r7, #12]
 2416 0eea 9A60     		str	r2, [r3, #8]
 2417 0eec 02E0     		b	.L136
 2418              	.L141:
1388:../src/stm32f30x_can.c ****     }
1389:../src/stm32f30x_can.c ****     else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
1390:../src/stm32f30x_can.c ****     {
1391:../src/stm32f30x_can.c ****       /* Operating mode Flags */
1392:../src/stm32f30x_can.c ****       CANx->MSR = (uint32_t)(flagtmp);
 2419              		.loc 1 1392 0
 2420 0eee 7B68     		ldr	r3, [r7, #4]
 2421 0ef0 FA68     		ldr	r2, [r7, #12]
 2422 0ef2 5A60     		str	r2, [r3, #4]
 2423              	.L136:
1393:../src/stm32f30x_can.c ****     }
1394:../src/stm32f30x_can.c ****   }
1395:../src/stm32f30x_can.c **** }
 2424              		.loc 1 1395 0
 2425 0ef4 07F11407 		add	r7, r7, #20
 2426 0ef8 BD46     		mov	sp, r7
 2427 0efa 80BC     		pop	{r7}
 2428 0efc 7047     		bx	lr
 2429              		.cfi_endproc
 2430              	.LFE132:
 2432 0efe 00BF     		.align	2
 2433              		.global	CAN_GetITStatus
 2434              		.thumb
 2435              		.thumb_func
 2437              	CAN_GetITStatus:
 2438              	.LFB133:
1396:../src/stm32f30x_can.c **** 
1397:../src/stm32f30x_can.c **** /**
1398:../src/stm32f30x_can.c ****   * @brief  Checks whether the specified CANx interrupt has occurred or not.
1399:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
1400:../src/stm32f30x_can.c ****   * @param  CAN_IT: specifies the CAN interrupt source to check.
1401:../src/stm32f30x_can.c ****   *          This parameter can be one of the following values:
1402:../src/stm32f30x_can.c ****   *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
1403:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
1404:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
1405:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
1406:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
1407:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
1408:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
1409:../src/stm32f30x_can.c ****   *            @arg CAN_IT_WKU: Wake-up Interrupt
1410:../src/stm32f30x_can.c ****   *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
1411:../src/stm32f30x_can.c ****   *            @arg CAN_IT_EWG: Error warning Interrupt
1412:../src/stm32f30x_can.c ****   *            @arg CAN_IT_EPV: Error passive Interrupt
1413:../src/stm32f30x_can.c ****   *            @arg CAN_IT_BOF: Bus-off Interrupt  
1414:../src/stm32f30x_can.c ****   *            @arg CAN_IT_LEC: Last error code Interrupt
1415:../src/stm32f30x_can.c ****   *            @arg CAN_IT_ERR: Error Interrupt
1416:../src/stm32f30x_can.c ****   * @retval The current state of CAN_IT (SET or RESET).
1417:../src/stm32f30x_can.c ****   */
1418:../src/stm32f30x_can.c **** ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
1419:../src/stm32f30x_can.c **** {
 2439              		.loc 1 1419 0
 2440              		.cfi_startproc
 2441              		@ args = 0, pretend = 0, frame = 16
 2442              		@ frame_needed = 1, uses_anonymous_args = 0
 2443 0f00 80B5     		push	{r7, lr}
 2444              	.LCFI66:
 2445              		.cfi_def_cfa_offset 8
 2446              		.cfi_offset 7, -8
 2447              		.cfi_offset 14, -4
 2448 0f02 84B0     		sub	sp, sp, #16
 2449              	.LCFI67:
 2450              		.cfi_def_cfa_offset 24
 2451 0f04 00AF     		add	r7, sp, #0
 2452              	.LCFI68:
 2453              		.cfi_def_cfa_register 7
 2454 0f06 7860     		str	r0, [r7, #4]
 2455 0f08 3960     		str	r1, [r7, #0]
1420:../src/stm32f30x_can.c ****   ITStatus itstatus = RESET;
 2456              		.loc 1 1420 0
 2457 0f0a 4FF00003 		mov	r3, #0
 2458 0f0e FB73     		strb	r3, [r7, #15]
1421:../src/stm32f30x_can.c ****   /* Check the parameters */
1422:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1423:../src/stm32f30x_can.c ****   assert_param(IS_CAN_IT(CAN_IT));
1424:../src/stm32f30x_can.c ****   
1425:../src/stm32f30x_can.c ****   /* check the interrupt enable bit */
1426:../src/stm32f30x_can.c ****  if((CANx->IER & CAN_IT) != RESET)
 2459              		.loc 1 1426 0
 2460 0f10 7B68     		ldr	r3, [r7, #4]
 2461 0f12 5A69     		ldr	r2, [r3, #20]
 2462 0f14 3B68     		ldr	r3, [r7, #0]
 2463 0f16 1340     		ands	r3, r3, r2
 2464 0f18 002B     		cmp	r3, #0
 2465 0f1a 00F0C480 		beq	.L143
1427:../src/stm32f30x_can.c ****  {
1428:../src/stm32f30x_can.c ****    /* in case the Interrupt is enabled, .... */
1429:../src/stm32f30x_can.c ****     switch (CAN_IT)
 2466              		.loc 1 1429 0
 2467 0f1e 3B68     		ldr	r3, [r7, #0]
 2468 0f20 402B     		cmp	r3, #64
 2469 0f22 6BD0     		beq	.L151
 2470 0f24 402B     		cmp	r3, #64
 2471 0f26 0FD8     		bhi	.L159
 2472 0f28 042B     		cmp	r3, #4
 2473 0f2a 3FD0     		beq	.L147
 2474 0f2c 042B     		cmp	r3, #4
 2475 0f2e 04D8     		bhi	.L160
 2476 0f30 012B     		cmp	r3, #1
 2477 0f32 25D0     		beq	.L145
 2478 0f34 022B     		cmp	r3, #2
 2479 0f36 2FD0     		beq	.L146
 2480 0f38 B1E0     		b	.L144
 2481              	.L160:
 2482 0f3a 102B     		cmp	r3, #16
 2483 0f3c 4AD0     		beq	.L149
 2484 0f3e 202B     		cmp	r3, #32
 2485 0f40 52D0     		beq	.L150
 2486 0f42 082B     		cmp	r3, #8
 2487 0f44 3CD0     		beq	.L148
 2488 0f46 AAE0     		b	.L144
 2489              	.L159:
 2490 0f48 B3F5006F 		cmp	r3, #2048
 2491 0f4c 00F09280 		beq	.L155
 2492 0f50 B3F5006F 		cmp	r3, #2048
 2493 0f54 09D8     		bhi	.L161
 2494 0f56 B3F5007F 		cmp	r3, #512
 2495 0f5a 77D0     		beq	.L153
 2496 0f5c B3F5806F 		cmp	r3, #1024
 2497 0f60 7ED0     		beq	.L154
 2498 0f62 B3F5807F 		cmp	r3, #256
 2499 0f66 67D0     		beq	.L152
 2500 0f68 99E0     		b	.L144
 2501              	.L161:
 2502 0f6a B3F5803F 		cmp	r3, #65536
 2503 0f6e 4FD0     		beq	.L157
 2504 0f70 B3F5003F 		cmp	r3, #131072
 2505 0f74 56D0     		beq	.L158
 2506 0f76 B3F5004F 		cmp	r3, #32768
 2507 0f7a 00F08580 		beq	.L156
 2508 0f7e 8EE0     		b	.L144
 2509              	.L145:
1430:../src/stm32f30x_can.c ****     {
1431:../src/stm32f30x_can.c ****       case CAN_IT_TME:
1432:../src/stm32f30x_can.c ****         /* Check CAN_TSR_RQCPx bits */
1433:../src/stm32f30x_can.c ****         itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
 2510              		.loc 1 1433 0
 2511 0f80 7B68     		ldr	r3, [r7, #4]
 2512 0f82 9B68     		ldr	r3, [r3, #8]
 2513 0f84 1846     		mov	r0, r3
 2514 0f86 40F20111 		movw	r1, #257
 2515 0f8a C0F20101 		movt	r1, 1
 2516 0f8e 00F011F9 		bl	CheckITStatus
 2517 0f92 0346     		mov	r3, r0
 2518 0f94 FB73     		strb	r3, [r7, #15]
1434:../src/stm32f30x_can.c ****         break;
 2519              		.loc 1 1434 0
 2520 0f96 89E0     		b	.L163
 2521              	.L146:
1435:../src/stm32f30x_can.c ****       case CAN_IT_FMP0:
1436:../src/stm32f30x_can.c ****         /* Check CAN_RF0R_FMP0 bit */
1437:../src/stm32f30x_can.c ****         itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
 2522              		.loc 1 1437 0
 2523 0f98 7B68     		ldr	r3, [r7, #4]
 2524 0f9a DB68     		ldr	r3, [r3, #12]
 2525 0f9c 1846     		mov	r0, r3
 2526 0f9e 4FF00301 		mov	r1, #3
 2527 0fa2 00F007F9 		bl	CheckITStatus
 2528 0fa6 0346     		mov	r3, r0
 2529 0fa8 FB73     		strb	r3, [r7, #15]
1438:../src/stm32f30x_can.c ****         break;
 2530              		.loc 1 1438 0
 2531 0faa 7FE0     		b	.L163
 2532              	.L147:
1439:../src/stm32f30x_can.c ****       case CAN_IT_FF0:
1440:../src/stm32f30x_can.c ****         /* Check CAN_RF0R_FULL0 bit */
1441:../src/stm32f30x_can.c ****         itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
 2533              		.loc 1 1441 0
 2534 0fac 7B68     		ldr	r3, [r7, #4]
 2535 0fae DB68     		ldr	r3, [r3, #12]
 2536 0fb0 1846     		mov	r0, r3
 2537 0fb2 4FF00801 		mov	r1, #8
 2538 0fb6 00F0FDF8 		bl	CheckITStatus
 2539 0fba 0346     		mov	r3, r0
 2540 0fbc FB73     		strb	r3, [r7, #15]
1442:../src/stm32f30x_can.c ****         break;
 2541              		.loc 1 1442 0
 2542 0fbe 75E0     		b	.L163
 2543              	.L148:
1443:../src/stm32f30x_can.c ****       case CAN_IT_FOV0:
1444:../src/stm32f30x_can.c ****         /* Check CAN_RF0R_FOVR0 bit */
1445:../src/stm32f30x_can.c ****         itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
 2544              		.loc 1 1445 0
 2545 0fc0 7B68     		ldr	r3, [r7, #4]
 2546 0fc2 DB68     		ldr	r3, [r3, #12]
 2547 0fc4 1846     		mov	r0, r3
 2548 0fc6 4FF01001 		mov	r1, #16
 2549 0fca 00F0F3F8 		bl	CheckITStatus
 2550 0fce 0346     		mov	r3, r0
 2551 0fd0 FB73     		strb	r3, [r7, #15]
1446:../src/stm32f30x_can.c ****         break;
 2552              		.loc 1 1446 0
 2553 0fd2 6BE0     		b	.L163
 2554              	.L149:
1447:../src/stm32f30x_can.c ****       case CAN_IT_FMP1:
1448:../src/stm32f30x_can.c ****         /* Check CAN_RF1R_FMP1 bit */
1449:../src/stm32f30x_can.c ****         itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
 2555              		.loc 1 1449 0
 2556 0fd4 7B68     		ldr	r3, [r7, #4]
 2557 0fd6 1B69     		ldr	r3, [r3, #16]
 2558 0fd8 1846     		mov	r0, r3
 2559 0fda 4FF00301 		mov	r1, #3
 2560 0fde 00F0E9F8 		bl	CheckITStatus
 2561 0fe2 0346     		mov	r3, r0
 2562 0fe4 FB73     		strb	r3, [r7, #15]
1450:../src/stm32f30x_can.c ****         break;
 2563              		.loc 1 1450 0
 2564 0fe6 61E0     		b	.L163
 2565              	.L150:
1451:../src/stm32f30x_can.c ****       case CAN_IT_FF1:
1452:../src/stm32f30x_can.c ****         /* Check CAN_RF1R_FULL1 bit */
1453:../src/stm32f30x_can.c ****         itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
 2566              		.loc 1 1453 0
 2567 0fe8 7B68     		ldr	r3, [r7, #4]
 2568 0fea 1B69     		ldr	r3, [r3, #16]
 2569 0fec 1846     		mov	r0, r3
 2570 0fee 4FF00801 		mov	r1, #8
 2571 0ff2 00F0DFF8 		bl	CheckITStatus
 2572 0ff6 0346     		mov	r3, r0
 2573 0ff8 FB73     		strb	r3, [r7, #15]
1454:../src/stm32f30x_can.c ****         break;
 2574              		.loc 1 1454 0
 2575 0ffa 57E0     		b	.L163
 2576              	.L151:
1455:../src/stm32f30x_can.c ****       case CAN_IT_FOV1:
1456:../src/stm32f30x_can.c ****         /* Check CAN_RF1R_FOVR1 bit */
1457:../src/stm32f30x_can.c ****         itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
 2577              		.loc 1 1457 0
 2578 0ffc 7B68     		ldr	r3, [r7, #4]
 2579 0ffe 1B69     		ldr	r3, [r3, #16]
 2580 1000 1846     		mov	r0, r3
 2581 1002 4FF01001 		mov	r1, #16
 2582 1006 00F0D5F8 		bl	CheckITStatus
 2583 100a 0346     		mov	r3, r0
 2584 100c FB73     		strb	r3, [r7, #15]
1458:../src/stm32f30x_can.c ****         break;
 2585              		.loc 1 1458 0
 2586 100e 4DE0     		b	.L163
 2587              	.L157:
1459:../src/stm32f30x_can.c ****       case CAN_IT_WKU:
1460:../src/stm32f30x_can.c ****         /* Check CAN_MSR_WKUI bit */
1461:../src/stm32f30x_can.c ****         itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
 2588              		.loc 1 1461 0
 2589 1010 7B68     		ldr	r3, [r7, #4]
 2590 1012 5B68     		ldr	r3, [r3, #4]
 2591 1014 1846     		mov	r0, r3
 2592 1016 4FF00801 		mov	r1, #8
 2593 101a 00F0CBF8 		bl	CheckITStatus
 2594 101e 0346     		mov	r3, r0
 2595 1020 FB73     		strb	r3, [r7, #15]
1462:../src/stm32f30x_can.c ****         break;
 2596              		.loc 1 1462 0
 2597 1022 43E0     		b	.L163
 2598              	.L158:
1463:../src/stm32f30x_can.c ****       case CAN_IT_SLK:
1464:../src/stm32f30x_can.c ****         /* Check CAN_MSR_SLAKI bit */
1465:../src/stm32f30x_can.c ****         itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
 2599              		.loc 1 1465 0
 2600 1024 7B68     		ldr	r3, [r7, #4]
 2601 1026 5B68     		ldr	r3, [r3, #4]
 2602 1028 1846     		mov	r0, r3
 2603 102a 4FF01001 		mov	r1, #16
 2604 102e 00F0C1F8 		bl	CheckITStatus
 2605 1032 0346     		mov	r3, r0
 2606 1034 FB73     		strb	r3, [r7, #15]
1466:../src/stm32f30x_can.c ****         break;
 2607              		.loc 1 1466 0
 2608 1036 39E0     		b	.L163
 2609              	.L152:
1467:../src/stm32f30x_can.c ****       case CAN_IT_EWG:
1468:../src/stm32f30x_can.c ****         /* Check CAN_ESR_EWGF bit */
1469:../src/stm32f30x_can.c ****         itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
 2610              		.loc 1 1469 0
 2611 1038 7B68     		ldr	r3, [r7, #4]
 2612 103a 9B69     		ldr	r3, [r3, #24]
 2613 103c 1846     		mov	r0, r3
 2614 103e 4FF00101 		mov	r1, #1
 2615 1042 00F0B7F8 		bl	CheckITStatus
 2616 1046 0346     		mov	r3, r0
 2617 1048 FB73     		strb	r3, [r7, #15]
1470:../src/stm32f30x_can.c ****         break;
 2618              		.loc 1 1470 0
 2619 104a 2FE0     		b	.L163
 2620              	.L153:
1471:../src/stm32f30x_can.c ****       case CAN_IT_EPV:
1472:../src/stm32f30x_can.c ****         /* Check CAN_ESR_EPVF bit */
1473:../src/stm32f30x_can.c ****         itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
 2621              		.loc 1 1473 0
 2622 104c 7B68     		ldr	r3, [r7, #4]
 2623 104e 9B69     		ldr	r3, [r3, #24]
 2624 1050 1846     		mov	r0, r3
 2625 1052 4FF00201 		mov	r1, #2
 2626 1056 00F0ADF8 		bl	CheckITStatus
 2627 105a 0346     		mov	r3, r0
 2628 105c FB73     		strb	r3, [r7, #15]
1474:../src/stm32f30x_can.c ****         break;
 2629              		.loc 1 1474 0
 2630 105e 25E0     		b	.L163
 2631              	.L154:
1475:../src/stm32f30x_can.c ****       case CAN_IT_BOF:
1476:../src/stm32f30x_can.c ****         /* Check CAN_ESR_BOFF bit */
1477:../src/stm32f30x_can.c ****         itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
 2632              		.loc 1 1477 0
 2633 1060 7B68     		ldr	r3, [r7, #4]
 2634 1062 9B69     		ldr	r3, [r3, #24]
 2635 1064 1846     		mov	r0, r3
 2636 1066 4FF00401 		mov	r1, #4
 2637 106a 00F0A3F8 		bl	CheckITStatus
 2638 106e 0346     		mov	r3, r0
 2639 1070 FB73     		strb	r3, [r7, #15]
1478:../src/stm32f30x_can.c ****         break;
 2640              		.loc 1 1478 0
 2641 1072 1BE0     		b	.L163
 2642              	.L155:
1479:../src/stm32f30x_can.c ****       case CAN_IT_LEC:
1480:../src/stm32f30x_can.c ****         /* Check CAN_ESR_LEC bit */
1481:../src/stm32f30x_can.c ****         itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
 2643              		.loc 1 1481 0
 2644 1074 7B68     		ldr	r3, [r7, #4]
 2645 1076 9B69     		ldr	r3, [r3, #24]
 2646 1078 1846     		mov	r0, r3
 2647 107a 4FF07001 		mov	r1, #112
 2648 107e 00F099F8 		bl	CheckITStatus
 2649 1082 0346     		mov	r3, r0
 2650 1084 FB73     		strb	r3, [r7, #15]
1482:../src/stm32f30x_can.c ****         break;
 2651              		.loc 1 1482 0
 2652 1086 11E0     		b	.L163
 2653              	.L156:
1483:../src/stm32f30x_can.c ****       case CAN_IT_ERR:
1484:../src/stm32f30x_can.c ****         /* Check CAN_MSR_ERRI bit */ 
1485:../src/stm32f30x_can.c ****         itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
 2654              		.loc 1 1485 0
 2655 1088 7B68     		ldr	r3, [r7, #4]
 2656 108a 5B68     		ldr	r3, [r3, #4]
 2657 108c 1846     		mov	r0, r3
 2658 108e 4FF00401 		mov	r1, #4
 2659 1092 00F08FF8 		bl	CheckITStatus
 2660 1096 0346     		mov	r3, r0
 2661 1098 FB73     		strb	r3, [r7, #15]
1486:../src/stm32f30x_can.c ****         break;
 2662              		.loc 1 1486 0
 2663 109a 00BF     		nop
 2664 109c 06E0     		b	.L163
 2665              	.L144:
1487:../src/stm32f30x_can.c ****       default:
1488:../src/stm32f30x_can.c ****         /* in case of error, return RESET */
1489:../src/stm32f30x_can.c ****         itstatus = RESET;
 2666              		.loc 1 1489 0
 2667 109e 4FF00003 		mov	r3, #0
 2668 10a2 FB73     		strb	r3, [r7, #15]
1490:../src/stm32f30x_can.c ****         break;
 2669              		.loc 1 1490 0
 2670 10a4 02E0     		b	.L163
 2671              	.L143:
1491:../src/stm32f30x_can.c ****     }
1492:../src/stm32f30x_can.c ****   }
1493:../src/stm32f30x_can.c ****   else
1494:../src/stm32f30x_can.c ****   {
1495:../src/stm32f30x_can.c ****    /* in case the Interrupt is not enabled, return RESET */
1496:../src/stm32f30x_can.c ****     itstatus  = RESET;
 2672              		.loc 1 1496 0
 2673 10a6 4FF00003 		mov	r3, #0
 2674 10aa FB73     		strb	r3, [r7, #15]
 2675              	.L163:
1497:../src/stm32f30x_can.c ****   }
1498:../src/stm32f30x_can.c ****   
1499:../src/stm32f30x_can.c ****   /* Return the CAN_IT status */
1500:../src/stm32f30x_can.c ****   return  itstatus;
 2676              		.loc 1 1500 0
 2677 10ac FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1501:../src/stm32f30x_can.c **** }
 2678              		.loc 1 1501 0
 2679 10ae 1846     		mov	r0, r3
 2680 10b0 07F11007 		add	r7, r7, #16
 2681 10b4 BD46     		mov	sp, r7
 2682 10b6 80BD     		pop	{r7, pc}
 2683              		.cfi_endproc
 2684              	.LFE133:
 2686              		.align	2
 2687              		.global	CAN_ClearITPendingBit
 2688              		.thumb
 2689              		.thumb_func
 2691              	CAN_ClearITPendingBit:
 2692              	.LFB134:
1502:../src/stm32f30x_can.c **** 
1503:../src/stm32f30x_can.c **** /**
1504:../src/stm32f30x_can.c ****   * @brief  Clears the CANx's interrupt pending bits.
1505:../src/stm32f30x_can.c ****   * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
1506:../src/stm32f30x_can.c ****   * @param  CAN_IT: specifies the interrupt pending bit to clear.
1507:../src/stm32f30x_can.c ****   *          This parameter can be one of the following values:
1508:../src/stm32f30x_can.c ****   *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt
1509:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
1510:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
1511:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
1512:../src/stm32f30x_can.c ****   *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
1513:../src/stm32f30x_can.c ****   *            @arg CAN_IT_WKU: Wake-up Interrupt
1514:../src/stm32f30x_can.c ****   *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
1515:../src/stm32f30x_can.c ****   *            @arg CAN_IT_EWG: Error warning Interrupt
1516:../src/stm32f30x_can.c ****   *            @arg CAN_IT_EPV: Error passive Interrupt
1517:../src/stm32f30x_can.c ****   *            @arg CAN_IT_BOF: Bus-off Interrupt  
1518:../src/stm32f30x_can.c ****   *            @arg CAN_IT_LEC: Last error code Interrupt
1519:../src/stm32f30x_can.c ****   *            @arg CAN_IT_ERR: Error Interrupt 
1520:../src/stm32f30x_can.c ****   * @retval None
1521:../src/stm32f30x_can.c ****   */
1522:../src/stm32f30x_can.c **** void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
1523:../src/stm32f30x_can.c **** {
 2693              		.loc 1 1523 0
 2694              		.cfi_startproc
 2695              		@ args = 0, pretend = 0, frame = 8
 2696              		@ frame_needed = 1, uses_anonymous_args = 0
 2697              		@ link register save eliminated.
 2698 10b8 80B4     		push	{r7}
 2699              	.LCFI69:
 2700              		.cfi_def_cfa_offset 4
 2701              		.cfi_offset 7, -4
 2702 10ba 83B0     		sub	sp, sp, #12
 2703              	.LCFI70:
 2704              		.cfi_def_cfa_offset 16
 2705 10bc 00AF     		add	r7, sp, #0
 2706              	.LCFI71:
 2707              		.cfi_def_cfa_register 7
 2708 10be 7860     		str	r0, [r7, #4]
 2709 10c0 3960     		str	r1, [r7, #0]
1524:../src/stm32f30x_can.c ****   /* Check the parameters */
1525:../src/stm32f30x_can.c ****   assert_param(IS_CAN_ALL_PERIPH(CANx));
1526:../src/stm32f30x_can.c ****   assert_param(IS_CAN_CLEAR_IT(CAN_IT));
1527:../src/stm32f30x_can.c **** 
1528:../src/stm32f30x_can.c ****   switch (CAN_IT)
 2710              		.loc 1 1528 0
 2711 10c2 3B68     		ldr	r3, [r7, #0]
 2712 10c4 B3F5807F 		cmp	r3, #256
 2713 10c8 4CD0     		beq	.L172
 2714 10ca B3F5807F 		cmp	r3, #256
 2715 10ce 0DD8     		bhi	.L179
 2716 10d0 082B     		cmp	r3, #8
 2717 10d2 2ED0     		beq	.L169
 2718 10d4 082B     		cmp	r3, #8
 2719 10d6 04D8     		bhi	.L180
 2720 10d8 012B     		cmp	r3, #1
 2721 10da 1ED0     		beq	.L167
 2722 10dc 042B     		cmp	r3, #4
 2723 10de 23D0     		beq	.L168
 2724 10e0 61E0     		b	.L166
 2725              	.L180:
 2726 10e2 202B     		cmp	r3, #32
 2727 10e4 2AD0     		beq	.L170
 2728 10e6 402B     		cmp	r3, #64
 2729 10e8 2DD0     		beq	.L171
 2730 10ea 5CE0     		b	.L166
 2731              	.L179:
 2732 10ec B3F5006F 		cmp	r3, #2048
 2733 10f0 47D0     		beq	.L175
 2734 10f2 B3F5006F 		cmp	r3, #2048
 2735 10f6 06D8     		bhi	.L181
 2736 10f8 B3F5007F 		cmp	r3, #512
 2737 10fc 37D0     		beq	.L173
 2738 10fe B3F5806F 		cmp	r3, #1024
 2739 1102 39D0     		beq	.L174
 2740 1104 4FE0     		b	.L166
 2741              	.L181:
 2742 1106 B3F5803F 		cmp	r3, #65536
 2743 110a 21D0     		beq	.L177
 2744 110c B3F5003F 		cmp	r3, #131072
 2745 1110 23D0     		beq	.L178
 2746 1112 B3F5004F 		cmp	r3, #32768
 2747 1116 3DD0     		beq	.L176
 2748 1118 45E0     		b	.L166
 2749              	.L167:
1529:../src/stm32f30x_can.c ****   {
1530:../src/stm32f30x_can.c ****     case CAN_IT_TME:
1531:../src/stm32f30x_can.c ****       /* Clear CAN_TSR_RQCPx (rc_w1)*/
1532:../src/stm32f30x_can.c ****       CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
 2750              		.loc 1 1532 0
 2751 111a 7A68     		ldr	r2, [r7, #4]
 2752 111c 40F20113 		movw	r3, #257
 2753 1120 C0F20103 		movt	r3, 1
 2754 1124 9360     		str	r3, [r2, #8]
1533:../src/stm32f30x_can.c ****       break;
 2755              		.loc 1 1533 0
 2756 1126 3FE0     		b	.L165
 2757              	.L168:
1534:../src/stm32f30x_can.c ****     case CAN_IT_FF0:
1535:../src/stm32f30x_can.c ****       /* Clear CAN_RF0R_FULL0 (rc_w1)*/
1536:../src/stm32f30x_can.c ****       CANx->RF0R = CAN_RF0R_FULL0; 
 2758              		.loc 1 1536 0
 2759 1128 7B68     		ldr	r3, [r7, #4]
 2760 112a 4FF00802 		mov	r2, #8
 2761 112e DA60     		str	r2, [r3, #12]
1537:../src/stm32f30x_can.c ****       break;
 2762              		.loc 1 1537 0
 2763 1130 3AE0     		b	.L165
 2764              	.L169:
1538:../src/stm32f30x_can.c ****     case CAN_IT_FOV0:
1539:../src/stm32f30x_can.c ****       /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
1540:../src/stm32f30x_can.c ****       CANx->RF0R = CAN_RF0R_FOVR0; 
 2765              		.loc 1 1540 0
 2766 1132 7B68     		ldr	r3, [r7, #4]
 2767 1134 4FF01002 		mov	r2, #16
 2768 1138 DA60     		str	r2, [r3, #12]
1541:../src/stm32f30x_can.c ****       break;
 2769              		.loc 1 1541 0
 2770 113a 35E0     		b	.L165
 2771              	.L170:
1542:../src/stm32f30x_can.c ****     case CAN_IT_FF1:
1543:../src/stm32f30x_can.c ****       /* Clear CAN_RF1R_FULL1 (rc_w1)*/
1544:../src/stm32f30x_can.c ****       CANx->RF1R = CAN_RF1R_FULL1;  
 2772              		.loc 1 1544 0
 2773 113c 7B68     		ldr	r3, [r7, #4]
 2774 113e 4FF00802 		mov	r2, #8
 2775 1142 1A61     		str	r2, [r3, #16]
1545:../src/stm32f30x_can.c ****       break;
 2776              		.loc 1 1545 0
 2777 1144 30E0     		b	.L165
 2778              	.L171:
1546:../src/stm32f30x_can.c ****     case CAN_IT_FOV1:
1547:../src/stm32f30x_can.c ****       /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
1548:../src/stm32f30x_can.c ****       CANx->RF1R = CAN_RF1R_FOVR1; 
 2779              		.loc 1 1548 0
 2780 1146 7B68     		ldr	r3, [r7, #4]
 2781 1148 4FF01002 		mov	r2, #16
 2782 114c 1A61     		str	r2, [r3, #16]
1549:../src/stm32f30x_can.c ****       break;
 2783              		.loc 1 1549 0
 2784 114e 2BE0     		b	.L165
 2785              	.L177:
1550:../src/stm32f30x_can.c ****     case CAN_IT_WKU:
1551:../src/stm32f30x_can.c ****       /* Clear CAN_MSR_WKUI (rc_w1)*/
1552:../src/stm32f30x_can.c ****       CANx->MSR = CAN_MSR_WKUI;  
 2786              		.loc 1 1552 0
 2787 1150 7B68     		ldr	r3, [r7, #4]
 2788 1152 4FF00802 		mov	r2, #8
 2789 1156 5A60     		str	r2, [r3, #4]
1553:../src/stm32f30x_can.c ****       break;
 2790              		.loc 1 1553 0
 2791 1158 26E0     		b	.L165
 2792              	.L178:
1554:../src/stm32f30x_can.c ****     case CAN_IT_SLK:
1555:../src/stm32f30x_can.c ****       /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
1556:../src/stm32f30x_can.c ****       CANx->MSR = CAN_MSR_SLAKI;   
 2793              		.loc 1 1556 0
 2794 115a 7B68     		ldr	r3, [r7, #4]
 2795 115c 4FF01002 		mov	r2, #16
 2796 1160 5A60     		str	r2, [r3, #4]
1557:../src/stm32f30x_can.c ****       break;
 2797              		.loc 1 1557 0
 2798 1162 21E0     		b	.L165
 2799              	.L172:
1558:../src/stm32f30x_can.c ****     case CAN_IT_EWG:
1559:../src/stm32f30x_can.c ****       /* Clear CAN_MSR_ERRI (rc_w1) */
1560:../src/stm32f30x_can.c ****       CANx->MSR = CAN_MSR_ERRI;
 2800              		.loc 1 1560 0
 2801 1164 7B68     		ldr	r3, [r7, #4]
 2802 1166 4FF00402 		mov	r2, #4
 2803 116a 5A60     		str	r2, [r3, #4]
1561:../src/stm32f30x_can.c ****        /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
1562:../src/stm32f30x_can.c ****       break;
 2804              		.loc 1 1562 0
 2805 116c 1CE0     		b	.L165
 2806              	.L173:
1563:../src/stm32f30x_can.c ****     case CAN_IT_EPV:
1564:../src/stm32f30x_can.c ****       /* Clear CAN_MSR_ERRI (rc_w1) */
1565:../src/stm32f30x_can.c ****       CANx->MSR = CAN_MSR_ERRI; 
 2807              		.loc 1 1565 0
 2808 116e 7B68     		ldr	r3, [r7, #4]
 2809 1170 4FF00402 		mov	r2, #4
 2810 1174 5A60     		str	r2, [r3, #4]
1566:../src/stm32f30x_can.c ****        /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
1567:../src/stm32f30x_can.c ****       break;
 2811              		.loc 1 1567 0
 2812 1176 17E0     		b	.L165
 2813              	.L174:
1568:../src/stm32f30x_can.c ****     case CAN_IT_BOF:
1569:../src/stm32f30x_can.c ****       /* Clear CAN_MSR_ERRI (rc_w1) */ 
1570:../src/stm32f30x_can.c ****       CANx->MSR = CAN_MSR_ERRI; 
 2814              		.loc 1 1570 0
 2815 1178 7B68     		ldr	r3, [r7, #4]
 2816 117a 4FF00402 		mov	r2, #4
 2817 117e 5A60     		str	r2, [r3, #4]
1571:../src/stm32f30x_can.c ****        /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
1572:../src/stm32f30x_can.c ****        break;
 2818              		.loc 1 1572 0
 2819 1180 12E0     		b	.L165
 2820              	.L175:
1573:../src/stm32f30x_can.c ****     case CAN_IT_LEC:
1574:../src/stm32f30x_can.c ****       /*  Clear LEC bits */
1575:../src/stm32f30x_can.c ****       CANx->ESR = RESET; 
 2821              		.loc 1 1575 0
 2822 1182 7B68     		ldr	r3, [r7, #4]
 2823 1184 4FF00002 		mov	r2, #0
 2824 1188 9A61     		str	r2, [r3, #24]
1576:../src/stm32f30x_can.c ****       /* Clear CAN_MSR_ERRI (rc_w1) */
1577:../src/stm32f30x_can.c ****       CANx->MSR = CAN_MSR_ERRI; 
 2825              		.loc 1 1577 0
 2826 118a 7B68     		ldr	r3, [r7, #4]
 2827 118c 4FF00402 		mov	r2, #4
 2828 1190 5A60     		str	r2, [r3, #4]
1578:../src/stm32f30x_can.c ****       break;
 2829              		.loc 1 1578 0
 2830 1192 09E0     		b	.L165
 2831              	.L176:
1579:../src/stm32f30x_can.c ****     case CAN_IT_ERR:
1580:../src/stm32f30x_can.c ****       /*Clear LEC bits */
1581:../src/stm32f30x_can.c ****       CANx->ESR = RESET; 
 2832              		.loc 1 1581 0
 2833 1194 7B68     		ldr	r3, [r7, #4]
 2834 1196 4FF00002 		mov	r2, #0
 2835 119a 9A61     		str	r2, [r3, #24]
1582:../src/stm32f30x_can.c ****       /* Clear CAN_MSR_ERRI (rc_w1) */
1583:../src/stm32f30x_can.c ****       CANx->MSR = CAN_MSR_ERRI; 
 2836              		.loc 1 1583 0
 2837 119c 7B68     		ldr	r3, [r7, #4]
 2838 119e 4FF00402 		mov	r2, #4
 2839 11a2 5A60     		str	r2, [r3, #4]
1584:../src/stm32f30x_can.c ****        /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
1585:../src/stm32f30x_can.c ****        break;
 2840              		.loc 1 1585 0
 2841 11a4 00E0     		b	.L165
 2842              	.L166:
1586:../src/stm32f30x_can.c ****     default:
1587:../src/stm32f30x_can.c ****        break;
 2843              		.loc 1 1587 0
 2844 11a6 00BF     		nop
 2845              	.L165:
1588:../src/stm32f30x_can.c ****    }
1589:../src/stm32f30x_can.c **** }
 2846              		.loc 1 1589 0
 2847 11a8 07F10C07 		add	r7, r7, #12
 2848 11ac BD46     		mov	sp, r7
 2849 11ae 80BC     		pop	{r7}
 2850 11b0 7047     		bx	lr
 2851              		.cfi_endproc
 2852              	.LFE134:
 2854 11b2 00BF     		.align	2
 2855              		.thumb
 2856              		.thumb_func
 2858              	CheckITStatus:
 2859              	.LFB135:
1590:../src/stm32f30x_can.c ****  /**
1591:../src/stm32f30x_can.c ****   * @}
1592:../src/stm32f30x_can.c ****   */
1593:../src/stm32f30x_can.c **** 
1594:../src/stm32f30x_can.c **** /**
1595:../src/stm32f30x_can.c ****   * @brief  Checks whether the CAN interrupt has occurred or not.
1596:../src/stm32f30x_can.c ****   * @param  CAN_Reg: specifies the CAN interrupt register to check.
1597:../src/stm32f30x_can.c ****   * @param  It_Bit: specifies the interrupt source bit to check.
1598:../src/stm32f30x_can.c ****   * @retval The new state of the CAN Interrupt (SET or RESET).
1599:../src/stm32f30x_can.c ****   */
1600:../src/stm32f30x_can.c **** static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
1601:../src/stm32f30x_can.c **** {
 2860              		.loc 1 1601 0
 2861              		.cfi_startproc
 2862              		@ args = 0, pretend = 0, frame = 16
 2863              		@ frame_needed = 1, uses_anonymous_args = 0
 2864              		@ link register save eliminated.
 2865 11b4 80B4     		push	{r7}
 2866              	.LCFI72:
 2867              		.cfi_def_cfa_offset 4
 2868              		.cfi_offset 7, -4
 2869 11b6 85B0     		sub	sp, sp, #20
 2870              	.LCFI73:
 2871              		.cfi_def_cfa_offset 24
 2872 11b8 00AF     		add	r7, sp, #0
 2873              	.LCFI74:
 2874              		.cfi_def_cfa_register 7
 2875 11ba 7860     		str	r0, [r7, #4]
 2876 11bc 3960     		str	r1, [r7, #0]
1602:../src/stm32f30x_can.c ****   ITStatus pendingbitstatus = RESET;
 2877              		.loc 1 1602 0
 2878 11be 4FF00003 		mov	r3, #0
 2879 11c2 FB73     		strb	r3, [r7, #15]
1603:../src/stm32f30x_can.c ****   
1604:../src/stm32f30x_can.c ****   if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
 2880              		.loc 1 1604 0
 2881 11c4 7A68     		ldr	r2, [r7, #4]
 2882 11c6 3B68     		ldr	r3, [r7, #0]
 2883 11c8 1340     		ands	r3, r3, r2
 2884 11ca 002B     		cmp	r3, #0
 2885 11cc 03D0     		beq	.L184
1605:../src/stm32f30x_can.c ****   {
1606:../src/stm32f30x_can.c ****     /* CAN_IT is set */
1607:../src/stm32f30x_can.c ****     pendingbitstatus = SET;
 2886              		.loc 1 1607 0
 2887 11ce 4FF00103 		mov	r3, #1
 2888 11d2 FB73     		strb	r3, [r7, #15]
 2889 11d4 02E0     		b	.L185
 2890              	.L184:
1608:../src/stm32f30x_can.c ****   }
1609:../src/stm32f30x_can.c ****   else
1610:../src/stm32f30x_can.c ****   {
1611:../src/stm32f30x_can.c ****     /* CAN_IT is reset */
1612:../src/stm32f30x_can.c ****     pendingbitstatus = RESET;
 2891              		.loc 1 1612 0
 2892 11d6 4FF00003 		mov	r3, #0
 2893 11da FB73     		strb	r3, [r7, #15]
 2894              	.L185:
1613:../src/stm32f30x_can.c ****   }
1614:../src/stm32f30x_can.c ****   return pendingbitstatus;
 2895              		.loc 1 1614 0
 2896 11dc FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1615:../src/stm32f30x_can.c **** }
 2897              		.loc 1 1615 0
 2898 11de 1846     		mov	r0, r3
 2899 11e0 07F11407 		add	r7, r7, #20
 2900 11e4 BD46     		mov	sp, r7
 2901 11e6 80BC     		pop	{r7}
 2902 11e8 7047     		bx	lr
 2903              		.cfi_endproc
 2904              	.LFE135:
 2906              	.Letext0:
 2907              		.file 2 "/home/aghosh01/gcc-arm-none-eabi-4_7-2012q4/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../.
 2908              		.file 3 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x.h"
 2909              		.file 4 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x_can.h"
 2910              		.file 5 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f30x_can.c
     /tmp/ccGdzckP.s:19     .text:00000000 $t
     /tmp/ccGdzckP.s:24     .text:00000000 CAN_DeInit
     /tmp/ccGdzckP.s:63     .text:00000028 CAN_Init
     /tmp/ccGdzckP.s:342    .text:000001e4 CAN_FilterInit
     /tmp/ccGdzckP.s:584    .text:000003f4 CAN_StructInit
     /tmp/ccGdzckP.s:659    .text:00000460 CAN_SlaveStartBank
     /tmp/ccGdzckP.s:726    .text:000004ec CAN_DBGFreeze
     /tmp/ccGdzckP.s:778    .text:00000524 CAN_TTComModeCmd
     /tmp/ccGdzckP.s:866    .text:000005bc CAN_Transmit
     /tmp/ccGdzckP.s:1125   .text:00000798 CAN_TransmitStatus
     /tmp/ccGdzckP.s:1294   .text:000008a4 CAN_CancelTransmit
     /tmp/ccGdzckP.s:1366   .text:000008f4 CAN_Receive
     /tmp/ccGdzckP.s:1580   .text:00000a9c CAN_FIFORelease
     /tmp/ccGdzckP.s:1632   .text:00000ad4 CAN_MessagePending
     /tmp/ccGdzckP.s:1699   .text:00000b24 CAN_OperatingModeRequest
     /tmp/ccGdzckP.s:1882   .text:00000c38 CAN_Sleep
     /tmp/ccGdzckP.s:1936   .text:00000c78 CAN_WakeUp
     /tmp/ccGdzckP.s:2011   .text:00000cd4 CAN_GetLastErrorCode
     /tmp/ccGdzckP.s:2054   .text:00000cfc CAN_GetReceiveErrorCounter
     /tmp/ccGdzckP.s:2096   .text:00000d24 CAN_GetLSBTransmitErrorCounter
     /tmp/ccGdzckP.s:2139   .text:00000d50 CAN_ITConfig
     /tmp/ccGdzckP.s:2195   .text:00000d8c CAN_GetFlagStatus
     /tmp/ccGdzckP.s:2347   .text:00000e84 CAN_ClearFlag
     /tmp/ccGdzckP.s:2437   .text:00000f00 CAN_GetITStatus
     /tmp/ccGdzckP.s:2858   .text:000011b4 CheckITStatus
     /tmp/ccGdzckP.s:2691   .text:000010b8 CAN_ClearITPendingBit
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.323dce8664331a0daf4a2675e107c70c
                           .group:00000000 wm4.stm32f30x.h.56.6f19c65e98e3319a61449cb2b2455af5
                           .group:00000000 wm4.core_cm4.h.32.1434cd257ff5806b1b03cd32ab0641e9
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.core_cmInstr.h.25.d8165482ef3061013a2fc83e2d85f3d9
                           .group:00000000 wm4.core_cm4_simd.h.29.013e5bcf58dba2d27c60184174208e07
                           .group:00000000 wm4.core_cm4.h.155.cf7c793e178943e1bbf613f1b21cd51a
                           .group:00000000 wm4.stm32f30x.h.294.d8a54360eca16e4157694b52a095202d
                           .group:00000000 wm4.stm32f30x_adc.h.130.cbebad91f78fb87381fe0860eea6104e
                           .group:00000000 wm4.stm32f30x_crc.h.54.66d4c5e565e18566aebd9abfd4bcd4b0
                           .group:00000000 wm4.stm32f30x_comp.h.91.06ae44150aaaa82c077b71df8db3541a
                           .group:00000000 wm4.stm32f30x_dac.h.49.b1b5b26e4ca241dbe67fa16dc86a615f
                           .group:00000000 wm4.stm32f30x_dbgmcu.h.53.b238a263ce6a2cc83f610cc35302a38b
                           .group:00000000 wm4.stm32f30x_dma.h.96.d7a2ddd10023e12781aa8ff5ac15d212
                           .group:00000000 wm4.stm32f30x_exti.h.60.8ca0809491a21dec6fc69cf7471e2bab
                           .group:00000000 wm4.stm32f30x_flash.h.70.32613455dfe7328932f786a224daac23
                           .group:00000000 wm4.stm32f30x_gpio.h.50.408e1f6250246e4cc28221970909d34c
                           .group:00000000 wm4.stm32f30x_syscfg.h.58.4cadeb4ec8e47d36b972bbb6b96b7161
                           .group:00000000 wm4.stm32f30x_i2c.h.86.3d51d4edc0e3b9ee9aae045ccbb7739a
                           .group:00000000 wm4.stm32f30x_iwdg.h.59.467d704fb073a015941f19b50fa6470a
                           .group:00000000 wm4.stm32f30x_opamp.h.75.704e2e5e2aab039de307aaa2dcc99fa5
                           .group:00000000 wm4.stm32f30x_pwr.h.59.5c85acff2a3e3c5085b2140c06025cfc
                           .group:00000000 wm4.stm32f30x_rcc.h.79.5ba7cac1e74879861a72556c25322aa4
                           .group:00000000 wm4.stm32f30x_rtc.h.133.d184e08ff40bda44db4bed94f9633384
                           .group:00000000 wm4.stm32f30x_spi.h.119.4d21ec94ec14f3553a127e61c0a9874f
                           .group:00000000 wm4.stm32f30x_tim.h.175.d4a93cff2e7924577147254e501271b6
                           .group:00000000 wm4.stm32f30x_usart.h.110.c89016273702821ff4f9fe43881f70b5
                           .group:00000000 wm4.stm32f30x_wwdg.h.58.4688eee61a2709866472b4b4c07d9275
                           .group:00000000 wm4.stm32f30x_misc.h.113.6a52e4fe7c3825a3ab05990f30dddf92
                           .group:00000000 wm4.stm32f30x_can.h.50.8b8f5d301152c422a6e50622b33ef620

UNDEFINED SYMBOLS
RCC_APB1PeriphResetCmd
