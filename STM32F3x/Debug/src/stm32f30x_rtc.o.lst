   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 6
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.file	"stm32f30x_rtc.c"
  17              		.text
  18              	.Ltext0:
  19              		.cfi_sections	.debug_frame
  20              		.align	2
  21              		.global	RTC_DeInit
  22              		.thumb
  23              		.thumb_func
  25              	RTC_DeInit:
  26              	.LFB111:
  27              		.file 1 "../src/stm32f30x_rtc.c"
   1:../src/stm32f30x_rtc.c **** /**
   2:../src/stm32f30x_rtc.c ****   ******************************************************************************
   3:../src/stm32f30x_rtc.c ****   * @file    stm32f30x_rtc.c
   4:../src/stm32f30x_rtc.c ****   * @author  MCD Application Team
   5:../src/stm32f30x_rtc.c ****   * @version V1.0.1
   6:../src/stm32f30x_rtc.c ****   * @date    23-October-2012
   7:../src/stm32f30x_rtc.c ****   * @brief   This file provides firmware functions to manage the following 
   8:../src/stm32f30x_rtc.c ****   *          functionalities of the Real-Time Clock (RTC) peripheral:
   9:../src/stm32f30x_rtc.c ****   *           + Initialization
  10:../src/stm32f30x_rtc.c ****   *           + Calendar (Time and Date) configuration
  11:../src/stm32f30x_rtc.c ****   *           + Alarms (Alarm A and Alarm B) configuration
  12:../src/stm32f30x_rtc.c ****   *           + WakeUp Timer configuration
  13:../src/stm32f30x_rtc.c ****   *           + Daylight Saving configuration
  14:../src/stm32f30x_rtc.c ****   *           + Output pin Configuration
  15:../src/stm32f30x_rtc.c ****   *           + Smooth digital Calibration configuration
  16:../src/stm32f30x_rtc.c ****   *           + TimeStamp configuration
  17:../src/stm32f30x_rtc.c ****   *           + Tampers configuration
  18:../src/stm32f30x_rtc.c ****   *           + Backup Data Registers configuration
  19:../src/stm32f30x_rtc.c ****   *           + Output Type Config configuration
  20:../src/stm32f30x_rtc.c ****   *           + Shift control synchronisation  
  21:../src/stm32f30x_rtc.c ****   *           + Interrupts and flags management       
  22:../src/stm32f30x_rtc.c ****   *                     
  23:../src/stm32f30x_rtc.c ****   @verbatim
  24:../src/stm32f30x_rtc.c ****        
  25:../src/stm32f30x_rtc.c ****  ===============================================================================     
  26:../src/stm32f30x_rtc.c ****                           ##### RTC Operating Condition #####
  27:../src/stm32f30x_rtc.c ****  ===============================================================================
  28:../src/stm32f30x_rtc.c ****     [..] The real-time clock (RTC) and the RTC backup registers can be powered
  29:../src/stm32f30x_rtc.c ****          from the VBAT voltage when the main VDD supply is powered off.
  30:../src/stm32f30x_rtc.c ****          To retain the content of the RTC backup registers and supply the RTC 
  31:../src/stm32f30x_rtc.c ****          when VDD is turned off, VBAT pin can be connected to an optional
  32:../src/stm32f30x_rtc.c ****          standby voltage supplied by a battery or by another source.
  33:../src/stm32f30x_rtc.c ****   
  34:../src/stm32f30x_rtc.c ****     [..] To allow the RTC to operate even when the main digital supply (VDD) 
  35:../src/stm32f30x_rtc.c ****          is turned off, the VBAT pin powers the following blocks:
  36:../src/stm32f30x_rtc.c ****            (#) The RTC
  37:../src/stm32f30x_rtc.c ****            (#) The LSE oscillator
  38:../src/stm32f30x_rtc.c ****            (#) PC13 to PC15 I/Os (when available)
  39:../src/stm32f30x_rtc.c ****   
  40:../src/stm32f30x_rtc.c ****     [..] When the backup domain is supplied by VDD (analog switch connected 
  41:../src/stm32f30x_rtc.c ****          to VDD), the following functions are available:
  42:../src/stm32f30x_rtc.c ****            (#) PC14 and PC15 can be used as either GPIO or LSE pins
  43:../src/stm32f30x_rtc.c ****            (#) PC13 can be used as a GPIO or as the RTC_AF pin
  44:../src/stm32f30x_rtc.c ****   
  45:../src/stm32f30x_rtc.c ****     [..] When the backup domain is supplied by VBAT (analog switch connected 
  46:../src/stm32f30x_rtc.c ****          to VBAT because VDD is not present), the following functions are available:
  47:../src/stm32f30x_rtc.c ****            (#) PC14 and PC15 can be used as LSE pins only
  48:../src/stm32f30x_rtc.c ****            (#) PC13 can be used as the RTC_AF pin 
  49:../src/stm32f30x_rtc.c **** 
  50:../src/stm32f30x_rtc.c ****                         ##### Backup Domain Reset #####
  51:../src/stm32f30x_rtc.c ****  ===============================================================================
  52:../src/stm32f30x_rtc.c ****     [..] The backup domain reset sets all RTC registers and the RCC_BDCR 
  53:../src/stm32f30x_rtc.c ****          register to their reset values. 
  54:../src/stm32f30x_rtc.c ****          A backup domain reset is generated when one of the following events
  55:../src/stm32f30x_rtc.c ****          occurs:
  56:../src/stm32f30x_rtc.c ****            (#) Software reset, triggered by setting the BDRST bit in the 
  57:../src/stm32f30x_rtc.c ****                RCC Backup domain control register (RCC_BDCR). You can use the
  58:../src/stm32f30x_rtc.c ****                RCC_BackupResetCmd().
  59:../src/stm32f30x_rtc.c ****            (#) VDD or VBAT power on, if both supplies have previously been
  60:../src/stm32f30x_rtc.c ****                powered off.
  61:../src/stm32f30x_rtc.c ****                          
  62:../src/stm32f30x_rtc.c ****                         ##### Backup Domain Access #####
  63:../src/stm32f30x_rtc.c ****  ===============================================================================
  64:../src/stm32f30x_rtc.c ****     [..] After reset, the backup domain (RTC registers and RTC backup data 
  65:../src/stm32f30x_rtc.c ****          registers) is protected against possible unwanted write accesses. 
  66:../src/stm32f30x_rtc.c ****     [..] To enable access to the Backup Domain and RTC registers, proceed as follows:
  67:../src/stm32f30x_rtc.c ****          (#) Enable the Power Controller (PWR) APB1 interface clock using the
  68:../src/stm32f30x_rtc.c ****              RCC_APB1PeriphClockCmd() function.
  69:../src/stm32f30x_rtc.c ****          (#) Enable access to Backup domain using the PWR_BackupAccessCmd() function.
  70:../src/stm32f30x_rtc.c ****          (#) Select the RTC clock source using the RCC_RTCCLKConfig() function.
  71:../src/stm32f30x_rtc.c ****          (#) Enable RTC Clock using the RCC_RTCCLKCmd() function.
  72:../src/stm32f30x_rtc.c ****               
  73:../src/stm32f30x_rtc.c ****                          ##### How to use this driver #####
  74:../src/stm32f30x_rtc.c ****  ===============================================================================
  75:../src/stm32f30x_rtc.c ****     [..]     
  76:../src/stm32f30x_rtc.c ****         (+) Enable the backup domain access (see description in the section above)
  77:../src/stm32f30x_rtc.c ****          (+) Configure the RTC Prescaler (Asynchronous and Synchronous) and
  78:../src/stm32f30x_rtc.c ****              RTC hour format using the RTC_Init() function.
  79:../src/stm32f30x_rtc.c ****                 
  80:../src/stm32f30x_rtc.c ****     *** Time and Date configuration ***
  81:../src/stm32f30x_rtc.c ****     ===================================    
  82:../src/stm32f30x_rtc.c ****     [..]     
  83:../src/stm32f30x_rtc.c ****          (+) To configure the RTC Calendar (Time and Date) use the RTC_SetTime()
  84:../src/stm32f30x_rtc.c ****              and RTC_SetDate() functions.
  85:../src/stm32f30x_rtc.c ****          (+) To read the RTC Calendar, use the RTC_GetTime() and RTC_GetDate()
  86:../src/stm32f30x_rtc.c ****              functions.
  87:../src/stm32f30x_rtc.c ****          (+) To read the RTC subsecond, use the RTC_GetSubSecond() function.
  88:../src/stm32f30x_rtc.c ****          (+) Use the RTC_DayLightSavingConfig() function to add or sub one
  89:../src/stm32f30x_rtc.c ****              hour to the RTC Calendar.    
  90:../src/stm32f30x_rtc.c ****                 
  91:../src/stm32f30x_rtc.c ****     *** Alarm configuration ***
  92:../src/stm32f30x_rtc.c ****     ===========================    
  93:../src/stm32f30x_rtc.c ****     [..]
  94:../src/stm32f30x_rtc.c ****          (+) To configure the RTC Alarm use the RTC_SetAlarm() function.
  95:../src/stm32f30x_rtc.c ****          (+) Enable the selected RTC Alarm using the RTC_AlarmCmd() function.
  96:../src/stm32f30x_rtc.c ****          (+) To read the RTC Alarm, use the RTC_GetAlarm() function.
  97:../src/stm32f30x_rtc.c ****          (+) To read the RTC alarm SubSecond, use the RTC_GetAlarmSubSecond() function.
  98:../src/stm32f30x_rtc.c ****               
  99:../src/stm32f30x_rtc.c ****     *** RTC Wakeup configuration ***
 100:../src/stm32f30x_rtc.c ****     ================================    
 101:../src/stm32f30x_rtc.c ****     [..]
 102:../src/stm32f30x_rtc.c ****          (+) Configure the RTC Wakeup Clock source use the RTC_WakeUpClockConfig()
 103:../src/stm32f30x_rtc.c ****              function.
 104:../src/stm32f30x_rtc.c ****          (+) Configure the RTC WakeUp Counter using the RTC_SetWakeUpCounter() 
 105:../src/stm32f30x_rtc.c ****              function  
 106:../src/stm32f30x_rtc.c ****          (+) Enable the RTC WakeUp using the RTC_WakeUpCmd() function  
 107:../src/stm32f30x_rtc.c ****          (+) To read the RTC WakeUp Counter register, use the RTC_GetWakeUpCounter() 
 108:../src/stm32f30x_rtc.c ****              function.
 109:../src/stm32f30x_rtc.c ****                 
 110:../src/stm32f30x_rtc.c ****     *** Outputs configuration ***
 111:../src/stm32f30x_rtc.c ****     =============================  
 112:../src/stm32f30x_rtc.c ****     [..] The RTC has 2 different outputs:
 113:../src/stm32f30x_rtc.c ****          (+) AFO_ALARM: this output is used to manage the RTC Alarm A, Alarm B
 114:../src/stm32f30x_rtc.c ****              and WaKeUp signals.          
 115:../src/stm32f30x_rtc.c ****              To output the selected RTC signal on RTC_AF pin, use the 
 116:../src/stm32f30x_rtc.c ****              RTC_OutputConfig() function.                
 117:../src/stm32f30x_rtc.c ****          (+) AFO_CALIB: this output is 512Hz signal or 1Hz .
 118:../src/stm32f30x_rtc.c ****              To output the RTC Clock on RTC_AF pin, use the RTC_CalibOutputCmd()
 119:../src/stm32f30x_rtc.c ****              function.                
 120:../src/stm32f30x_rtc.c ****                 
 121:../src/stm32f30x_rtc.c ****     *** Smooth digital Calibration configuration ***
 122:../src/stm32f30x_rtc.c ****     ================================================    
 123:../src/stm32f30x_rtc.c ****     [..]
 124:../src/stm32f30x_rtc.c ****          (+) Configure the RTC Original Digital Calibration Value and the corresponding
 125:../src/stm32f30x_rtc.c ****              calibration cycle period (32s,16s and 8s) using the RTC_SmoothCalibConfig() 
 126:../src/stm32f30x_rtc.c ****              function.                                                       
 127:../src/stm32f30x_rtc.c ****                 
 128:../src/stm32f30x_rtc.c ****     *** TimeStamp configuration ***
 129:../src/stm32f30x_rtc.c ****     ===============================    
 130:../src/stm32f30x_rtc.c ****     [..]
 131:../src/stm32f30x_rtc.c ****          (+) Configure the RTC_AF trigger and enables the RTC TimeStamp 
 132:../src/stm32f30x_rtc.c ****              using the RTC_TimeStampCmd() function.
 133:../src/stm32f30x_rtc.c ****          (+) To read the RTC TimeStamp Time and Date register, use the 
 134:../src/stm32f30x_rtc.c ****              RTC_GetTimeStamp() function.
 135:../src/stm32f30x_rtc.c ****          (+) To read the RTC TimeStamp SubSecond register, use the 
 136:../src/stm32f30x_rtc.c ****              RTC_GetTimeStampSubSecond() function.    
 137:../src/stm32f30x_rtc.c **** 
 138:../src/stm32f30x_rtc.c ****     *** Tamper configuration ***
 139:../src/stm32f30x_rtc.c ****     ============================    
 140:../src/stm32f30x_rtc.c ****     [..]
 141:../src/stm32f30x_rtc.c ****          (+) Configure the Tamper filter count using RTC_TamperFilterConfig()
 142:../src/stm32f30x_rtc.c ****              function. 
 143:../src/stm32f30x_rtc.c ****          (+) Configure the RTC Tamper trigger Edge or Level according to the Tamper 
 144:../src/stm32f30x_rtc.c ****              filter (if equal to 0 Edge else Level) value using the RTC_TamperConfig() function.
 145:../src/stm32f30x_rtc.c ****          (+) Configure the Tamper sampling frequency using RTC_TamperSamplingFreqConfig()
 146:../src/stm32f30x_rtc.c ****              function.
 147:../src/stm32f30x_rtc.c ****          (+) Configure the Tamper precharge or discharge duration using 
 148:../src/stm32f30x_rtc.c ****              RTC_TamperPinsPrechargeDuration() function.
 149:../src/stm32f30x_rtc.c ****          (+) Enable the Tamper Pull-UP using RTC_TamperPullUpDisableCmd() function.
 150:../src/stm32f30x_rtc.c ****          (+) Enable the RTC Tamper using the RTC_TamperCmd() function.
 151:../src/stm32f30x_rtc.c ****          (+) Enable the Time stamp on Tamper detection event using  
 152:../src/stm32f30x_rtc.c ****              RTC_TSOnTamperDetecCmd() function.     
 153:../src/stm32f30x_rtc.c **** 
 154:../src/stm32f30x_rtc.c ****     *** Backup Data Registers configuration ***
 155:../src/stm32f30x_rtc.c ****     ===========================================    
 156:../src/stm32f30x_rtc.c ****     [..]
 157:../src/stm32f30x_rtc.c ****          (+) To write to the RTC Backup Data registers, use the RTC_WriteBackupRegister()
 158:../src/stm32f30x_rtc.c ****              function.  
 159:../src/stm32f30x_rtc.c ****          (+) To read the RTC Backup Data registers, use the RTC_ReadBackupRegister()
 160:../src/stm32f30x_rtc.c ****              function.  
 161:../src/stm32f30x_rtc.c ****                                   
 162:../src/stm32f30x_rtc.c ****                          ##### RTC and low power modes #####
 163:../src/stm32f30x_rtc.c ****  =============================================================================== 
 164:../src/stm32f30x_rtc.c ****     [..] The MCU can be woken up from a low power mode by an RTC alternate 
 165:../src/stm32f30x_rtc.c ****          function.
 166:../src/stm32f30x_rtc.c ****     [..] The RTC alternate functions are the RTC alarms (Alarm A and Alarm B), 
 167:../src/stm32f30x_rtc.c ****          RTC wakeup, RTC tamper event detection and RTC time stamp event detection.
 168:../src/stm32f30x_rtc.c ****          These RTC alternate functions can wake up the system from the Stop 
 169:../src/stm32f30x_rtc.c ****          and Standby lowpower modes.
 170:../src/stm32f30x_rtc.c ****          The system can also wake up from low power modes without depending 
 171:../src/stm32f30x_rtc.c ****          on an external interrupt (Auto-wakeup mode), by using the RTC alarm 
 172:../src/stm32f30x_rtc.c ****          or the RTC wakeup events.
 173:../src/stm32f30x_rtc.c ****     [..] The RTC provides a programmable time base for waking up from the 
 174:../src/stm32f30x_rtc.c ****          Stop or Standby mode at regular intervals.
 175:../src/stm32f30x_rtc.c ****          Wakeup from STOP and Standby modes is possible only when the RTC 
 176:../src/stm32f30x_rtc.c ****          clock source is LSE or LSI.
 177:../src/stm32f30x_rtc.c ****            
 178:../src/stm32f30x_rtc.c ****                 ##### Selection of RTC_AF alternate functions #####
 179:../src/stm32f30x_rtc.c ****  ===============================================================================
 180:../src/stm32f30x_rtc.c ****     [..] The RTC_AF pin (PC13) can be used for the following purposes:
 181:../src/stm32f30x_rtc.c ****          (+) Wakeup pin 2 (WKUP2) using the PWR_WakeUpPinCmd() function.
 182:../src/stm32f30x_rtc.c ****          (+) AFO_ALARM output      
 183:../src/stm32f30x_rtc.c ****          (+) AFO_CALIB output
 184:../src/stm32f30x_rtc.c ****          (+) AFI_TAMPER
 185:../src/stm32f30x_rtc.c ****          (+) AFI_TIMESTAMP
 186:../src/stm32f30x_rtc.c ****                          
 187:../src/stm32f30x_rtc.c ****  +------------------------------------------------------------------------------------------+
 188:../src/stm32f30x_rtc.c ****  |     Pin         |RTC ALARM |RTC CALIB |RTC TAMPER |RTC TIMESTAMP |PC13MODE|  PC13VALUE   |
 189:../src/stm32f30x_rtc.c ****  |  configuration  | OUTPUT   | OUTPUT   |  INPUT    |    INPUT     |  bit   |     bit      |
 190:../src/stm32f30x_rtc.c ****  |  and function   | ENABLED  | ENABLED  | ENABLED   |   ENABLED    |        |              |
 191:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 192:../src/stm32f30x_rtc.c ****  |   Alarm out     |          |          |           |              | Don't  |              |
 193:../src/stm32f30x_rtc.c ****  |   output OD     |     1    |Don't care|Don't care | Don't care   | care   |      0       |
 194:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 195:../src/stm32f30x_rtc.c ****  |   Alarm out     |          |          |           |              | Don't  |              |
 196:../src/stm32f30x_rtc.c ****  |   output PP     |     1    |Don't care|Don't care | Don't care   | care   |      1       |
 197:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 198:../src/stm32f30x_rtc.c ****  | Calibration out |          |          |           |              | Don't  |              |
 199:../src/stm32f30x_rtc.c ****  |   output PP     |     0    |    1     |Don't care | Don't care   | care   |  Don't care  |
 200:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 201:../src/stm32f30x_rtc.c ****  |  TAMPER input   |          |          |           |              | Don't  |              |
 202:../src/stm32f30x_rtc.c ****  |   floating      |     0    |    0     |     1     |      0       | care   |  Don't care  |
 203:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 204:../src/stm32f30x_rtc.c ****  |  TIMESTAMP and  |          |          |           |              | Don't  |              |
 205:../src/stm32f30x_rtc.c ****  |  TAMPER input   |     0    |    0     |     1     |      1       | care   |  Don't care  |
 206:../src/stm32f30x_rtc.c ****  |   floating      |          |          |           |              |        |              |
 207:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 208:../src/stm32f30x_rtc.c ****  | TIMESTAMP input |          |          |           |              | Don't  |              |
 209:../src/stm32f30x_rtc.c ****  |    floating     |     0    |    0     |     0     |      1       | care   |  Don't care  |
 210:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 211:../src/stm32f30x_rtc.c ****  |   Output PP     |     0    |    0     |     0     |      0       |   1    | PC13 output  |
 212:../src/stm32f30x_rtc.c ****  |    Forced       |          |          |           |              |        |              |
 213:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 214:../src/stm32f30x_rtc.c ****  |  Wakeup Pin or  |     0    |    0     |     0     |      0       |   0    | Don't care   |
 215:../src/stm32f30x_rtc.c ****  |  Standard GPIO  |          |          |           |              |        |              |
 216:../src/stm32f30x_rtc.c ****  +------------------------------------------------------------------------------------------+
 217:../src/stm32f30x_rtc.c ****     
 218:../src/stm32f30x_rtc.c ****   @endverbatim
 219:../src/stm32f30x_rtc.c ****                       
 220:../src/stm32f30x_rtc.c ****   ******************************************************************************
 221:../src/stm32f30x_rtc.c ****   * @attention
 222:../src/stm32f30x_rtc.c ****   *
 223:../src/stm32f30x_rtc.c ****   * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
 224:../src/stm32f30x_rtc.c ****   *
 225:../src/stm32f30x_rtc.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
 226:../src/stm32f30x_rtc.c ****   * You may not use this file except in compliance with the License.
 227:../src/stm32f30x_rtc.c ****   * You may obtain a copy of the License at:
 228:../src/stm32f30x_rtc.c ****   *
 229:../src/stm32f30x_rtc.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
 230:../src/stm32f30x_rtc.c ****   *
 231:../src/stm32f30x_rtc.c ****   * Unless required by applicable law or agreed to in writing, software 
 232:../src/stm32f30x_rtc.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
 233:../src/stm32f30x_rtc.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 234:../src/stm32f30x_rtc.c ****   * See the License for the specific language governing permissions and
 235:../src/stm32f30x_rtc.c ****   * limitations under the License.
 236:../src/stm32f30x_rtc.c ****   *
 237:../src/stm32f30x_rtc.c ****   ******************************************************************************
 238:../src/stm32f30x_rtc.c ****   */ 
 239:../src/stm32f30x_rtc.c **** 
 240:../src/stm32f30x_rtc.c **** /* Includes ------------------------------------------------------------------*/
 241:../src/stm32f30x_rtc.c **** #include "stm32f30x_rtc.h"
 242:../src/stm32f30x_rtc.c **** #include "stm32f30x_rcc.h"
 243:../src/stm32f30x_rtc.c **** 
 244:../src/stm32f30x_rtc.c **** /** @addtogroup STM32F30x_StdPeriph_Driver
 245:../src/stm32f30x_rtc.c ****   * @{
 246:../src/stm32f30x_rtc.c ****   */
 247:../src/stm32f30x_rtc.c **** 
 248:../src/stm32f30x_rtc.c **** /** @defgroup RTC 
 249:../src/stm32f30x_rtc.c ****   * @brief RTC driver modules
 250:../src/stm32f30x_rtc.c ****   * @{
 251:../src/stm32f30x_rtc.c ****   */
 252:../src/stm32f30x_rtc.c **** 
 253:../src/stm32f30x_rtc.c **** /* Private typedef -----------------------------------------------------------*/
 254:../src/stm32f30x_rtc.c **** /* Private define ------------------------------------------------------------*/
 255:../src/stm32f30x_rtc.c **** 
 256:../src/stm32f30x_rtc.c **** /* Masks Definition */
 257:../src/stm32f30x_rtc.c **** #define RTC_TR_RESERVED_MASK    ((uint32_t)0x007F7F7F)
 258:../src/stm32f30x_rtc.c **** #define RTC_DR_RESERVED_MASK    ((uint32_t)0x00FFFF3F) 
 259:../src/stm32f30x_rtc.c **** #define RTC_INIT_MASK           ((uint32_t)0xFFFFFFFF)  
 260:../src/stm32f30x_rtc.c **** #define RTC_RSF_MASK            ((uint32_t)0xFFFFFF5F)
 261:../src/stm32f30x_rtc.c **** #define RTC_FLAGS_MASK          ((uint32_t)(RTC_FLAG_TSOVF | RTC_FLAG_TSF | RTC_FLAG_WUTF | \
 262:../src/stm32f30x_rtc.c ****                                             RTC_FLAG_ALRBF | RTC_FLAG_ALRAF | RTC_FLAG_INITF | \
 263:../src/stm32f30x_rtc.c ****                                             RTC_FLAG_RSF | RTC_FLAG_INITS | RTC_FLAG_WUTWF | \
 264:../src/stm32f30x_rtc.c ****                                             RTC_FLAG_ALRBWF | RTC_FLAG_ALRAWF | RTC_FLAG_TAMP1F | \
 265:../src/stm32f30x_rtc.c ****                                             RTC_FLAG_TAMP2F | RTC_FLAG_TAMP3F | RTC_FLAG_RECALPF | 
 266:../src/stm32f30x_rtc.c ****                                             RTC_FLAG_SHPF))
 267:../src/stm32f30x_rtc.c **** 
 268:../src/stm32f30x_rtc.c **** #define INITMODE_TIMEOUT         ((uint32_t) 0x00002000)
 269:../src/stm32f30x_rtc.c **** #define SYNCHRO_TIMEOUT          ((uint32_t) 0x00008000)
 270:../src/stm32f30x_rtc.c **** #define RECALPF_TIMEOUT          ((uint32_t) 0x00001000)
 271:../src/stm32f30x_rtc.c **** #define SHPF_TIMEOUT             ((uint32_t) 0x00002000)
 272:../src/stm32f30x_rtc.c **** 
 273:../src/stm32f30x_rtc.c **** /* Private macro -------------------------------------------------------------*/
 274:../src/stm32f30x_rtc.c **** /* Private variables ---------------------------------------------------------*/
 275:../src/stm32f30x_rtc.c **** /* Private function prototypes -----------------------------------------------*/
 276:../src/stm32f30x_rtc.c **** static uint8_t RTC_ByteToBcd2(uint8_t Value);
 277:../src/stm32f30x_rtc.c **** static uint8_t RTC_Bcd2ToByte(uint8_t Value);
 278:../src/stm32f30x_rtc.c **** 
 279:../src/stm32f30x_rtc.c **** /* Private functions ---------------------------------------------------------*/
 280:../src/stm32f30x_rtc.c **** 
 281:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Private_Functions
 282:../src/stm32f30x_rtc.c ****   * @{
 283:../src/stm32f30x_rtc.c ****   */ 
 284:../src/stm32f30x_rtc.c **** 
 285:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group1 Initialization and Configuration functions
 286:../src/stm32f30x_rtc.c ****  *  @brief   Initialization and Configuration functions 
 287:../src/stm32f30x_rtc.c ****  *
 288:../src/stm32f30x_rtc.c **** @verbatim   
 289:../src/stm32f30x_rtc.c ****  ===============================================================================
 290:../src/stm32f30x_rtc.c ****             ##### Initialization and Configuration functions #####
 291:../src/stm32f30x_rtc.c ****  ===============================================================================  
 292:../src/stm32f30x_rtc.c ****     [..] This section provide functions allowing to initialize and configure the RTC
 293:../src/stm32f30x_rtc.c ****          Prescaler (Synchronous and Asynchronous), RTC Hour format, disable RTC registers
 294:../src/stm32f30x_rtc.c ****          Write protection, enter and exit the RTC initialization mode, RTC registers
 295:../src/stm32f30x_rtc.c ****          synchronization check and reference clock detection enable.
 296:../src/stm32f30x_rtc.c ****          (#) The RTC Prescaler is programmed to generate the RTC 1Hz time base. It is
 297:../src/stm32f30x_rtc.c ****              split into 2 programmable prescalers to minimize power consumption.
 298:../src/stm32f30x_rtc.c ****              (++) A 7-bit asynchronous prescaler and A 13-bit synchronous prescaler.
 299:../src/stm32f30x_rtc.c ****              (++) When both prescalers are used, it is recommended to configure the 
 300:../src/stm32f30x_rtc.c ****                   asynchronous prescaler to a high value to minimize consumption.
 301:../src/stm32f30x_rtc.c ****          (#) All RTC registers are Write protected. Writing to the RTC registers
 302:../src/stm32f30x_rtc.c ****              is enabled by writing a key into the Write Protection register, RTC_WPR.
 303:../src/stm32f30x_rtc.c ****          (#) To Configure the RTC Calendar, user application should enter initialization
 304:../src/stm32f30x_rtc.c ****              mode. In this mode, the calendar counter is stopped and its value 
 305:../src/stm32f30x_rtc.c ****              can be updated. When the initialization sequence is complete, the 
 306:../src/stm32f30x_rtc.c ****              calendar restarts counting after 4 RTCCLK cycles.
 307:../src/stm32f30x_rtc.c ****          (#) To read the calendar through the shadow registers after Calendar 
 308:../src/stm32f30x_rtc.c ****              initialization, calendar update or after wakeup from low power modes 
 309:../src/stm32f30x_rtc.c ****              the software must first clear the RSF flag. The software must then 
 310:../src/stm32f30x_rtc.c ****              wait until it is set again before reading the calendar, which means 
 311:../src/stm32f30x_rtc.c ****              that the calendar registers have been correctly copied into the RTC_TR 
 312:../src/stm32f30x_rtc.c ****              and RTC_DR shadow registers. The RTC_WaitForSynchro() function 
 313:../src/stm32f30x_rtc.c ****              implements the above software sequence (RSF clear and RSF check).
 314:../src/stm32f30x_rtc.c **** 
 315:../src/stm32f30x_rtc.c **** @endverbatim
 316:../src/stm32f30x_rtc.c ****   * @{
 317:../src/stm32f30x_rtc.c ****   */
 318:../src/stm32f30x_rtc.c **** 
 319:../src/stm32f30x_rtc.c **** /**
 320:../src/stm32f30x_rtc.c ****   * @brief  Deinitializes the RTC registers to their default reset values.
 321:../src/stm32f30x_rtc.c ****   * @note   This function doesn't reset the RTC Clock source and RTC Backup Data
 322:../src/stm32f30x_rtc.c ****   *         registers.       
 323:../src/stm32f30x_rtc.c ****   * @param  None
 324:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
 325:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC registers are deinitialized
 326:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC registers are not deinitialized
 327:../src/stm32f30x_rtc.c ****   */
 328:../src/stm32f30x_rtc.c **** ErrorStatus RTC_DeInit(void)
 329:../src/stm32f30x_rtc.c **** {
  28              		.loc 1 329 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 16
  31              		@ frame_needed = 1, uses_anonymous_args = 0
  32 0000 80B5     		push	{r7, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 7, -8
  36              		.cfi_offset 14, -4
  37 0002 84B0     		sub	sp, sp, #16
  38              	.LCFI1:
  39              		.cfi_def_cfa_offset 24
  40 0004 00AF     		add	r7, sp, #0
  41              	.LCFI2:
  42              		.cfi_def_cfa_register 7
 330:../src/stm32f30x_rtc.c ****   __IO uint32_t wutcounter = 0x00;
  43              		.loc 1 330 0
  44 0006 4FF00003 		mov	r3, #0
  45 000a 7B60     		str	r3, [r7, #4]
 331:../src/stm32f30x_rtc.c ****   uint32_t wutwfstatus = 0x00;
  46              		.loc 1 331 0
  47 000c 4FF00003 		mov	r3, #0
  48 0010 BB60     		str	r3, [r7, #8]
 332:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
  49              		.loc 1 332 0
  50 0012 4FF00003 		mov	r3, #0
  51 0016 FB73     		strb	r3, [r7, #15]
 333:../src/stm32f30x_rtc.c ****   
 334:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
 335:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
  52              		.loc 1 335 0
  53 0018 4FF42053 		mov	r3, #10240
  54 001c C4F20003 		movt	r3, 16384
  55 0020 4FF0CA02 		mov	r2, #202
  56 0024 5A62     		str	r2, [r3, #36]
 336:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
  57              		.loc 1 336 0
  58 0026 4FF42053 		mov	r3, #10240
  59 002a C4F20003 		movt	r3, 16384
  60 002e 4FF05302 		mov	r2, #83
  61 0032 5A62     		str	r2, [r3, #36]
 337:../src/stm32f30x_rtc.c **** 
 338:../src/stm32f30x_rtc.c ****   /* Set Initialization mode */
 339:../src/stm32f30x_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
  62              		.loc 1 339 0
  63 0034 FFF7FEFF 		bl	RTC_EnterInitMode
  64 0038 0346     		mov	r3, r0
  65 003a 002B     		cmp	r3, #0
  66 003c 03D1     		bne	.L2
 340:../src/stm32f30x_rtc.c ****   {
 341:../src/stm32f30x_rtc.c ****     status = ERROR;
  67              		.loc 1 341 0
  68 003e 4FF00003 		mov	r3, #0
  69 0042 FB73     		strb	r3, [r7, #15]
  70 0044 99E0     		b	.L3
  71              	.L2:
 342:../src/stm32f30x_rtc.c ****   }  
 343:../src/stm32f30x_rtc.c ****   else
 344:../src/stm32f30x_rtc.c ****   {
 345:../src/stm32f30x_rtc.c ****     /* Reset TR, DR and CR registers */
 346:../src/stm32f30x_rtc.c ****     RTC->TR = (uint32_t)0x00000000;
  72              		.loc 1 346 0
  73 0046 4FF42053 		mov	r3, #10240
  74 004a C4F20003 		movt	r3, 16384
  75 004e 4FF00002 		mov	r2, #0
  76 0052 1A60     		str	r2, [r3, #0]
 347:../src/stm32f30x_rtc.c ****     RTC->DR = (uint32_t)0x00002101;
  77              		.loc 1 347 0
  78 0054 4FF42053 		mov	r3, #10240
  79 0058 C4F20003 		movt	r3, 16384
  80 005c 42F20112 		movw	r2, #8449
  81 0060 5A60     		str	r2, [r3, #4]
 348:../src/stm32f30x_rtc.c ****     
 349:../src/stm32f30x_rtc.c ****     /* Reset All CR bits except CR[2:0] */
 350:../src/stm32f30x_rtc.c ****     RTC->CR &= (uint32_t)0x00000007;
  82              		.loc 1 350 0
  83 0062 4FF42053 		mov	r3, #10240
  84 0066 C4F20003 		movt	r3, 16384
  85 006a 4FF42052 		mov	r2, #10240
  86 006e C4F20002 		movt	r2, 16384
  87 0072 9268     		ldr	r2, [r2, #8]
  88 0074 02F00702 		and	r2, r2, #7
  89 0078 9A60     		str	r2, [r3, #8]
  90              	.L5:
 351:../src/stm32f30x_rtc.c ****   
 352:../src/stm32f30x_rtc.c ****     /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
 353:../src/stm32f30x_rtc.c ****     do
 354:../src/stm32f30x_rtc.c ****     {
 355:../src/stm32f30x_rtc.c ****       wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
  91              		.loc 1 355 0 discriminator 1
  92 007a 4FF42053 		mov	r3, #10240
  93 007e C4F20003 		movt	r3, 16384
  94 0082 DB68     		ldr	r3, [r3, #12]
  95 0084 03F00403 		and	r3, r3, #4
  96 0088 BB60     		str	r3, [r7, #8]
 356:../src/stm32f30x_rtc.c ****       wutcounter++;  
  97              		.loc 1 356 0 discriminator 1
  98 008a 7B68     		ldr	r3, [r7, #4]
  99 008c 03F10103 		add	r3, r3, #1
 100 0090 7B60     		str	r3, [r7, #4]
 357:../src/stm32f30x_rtc.c ****     } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 101              		.loc 1 357 0 discriminator 1
 102 0092 7B68     		ldr	r3, [r7, #4]
 103 0094 B3F5005F 		cmp	r3, #8192
 104 0098 02D0     		beq	.L4
 105 009a BB68     		ldr	r3, [r7, #8]
 106 009c 002B     		cmp	r3, #0
 107 009e ECD0     		beq	.L5
 108              	.L4:
 358:../src/stm32f30x_rtc.c ****     
 359:../src/stm32f30x_rtc.c ****     if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 109              		.loc 1 359 0
 110 00a0 4FF42053 		mov	r3, #10240
 111 00a4 C4F20003 		movt	r3, 16384
 112 00a8 DB68     		ldr	r3, [r3, #12]
 113 00aa 03F00403 		and	r3, r3, #4
 114 00ae 002B     		cmp	r3, #0
 115 00b0 03D1     		bne	.L6
 360:../src/stm32f30x_rtc.c ****     {
 361:../src/stm32f30x_rtc.c ****       status = ERROR;
 116              		.loc 1 361 0
 117 00b2 4FF00003 		mov	r3, #0
 118 00b6 FB73     		strb	r3, [r7, #15]
 119 00b8 5FE0     		b	.L3
 120              	.L6:
 362:../src/stm32f30x_rtc.c ****     }
 363:../src/stm32f30x_rtc.c ****     else
 364:../src/stm32f30x_rtc.c ****     {
 365:../src/stm32f30x_rtc.c ****       /* Reset all RTC CR register bits */
 366:../src/stm32f30x_rtc.c ****       RTC->CR        &= (uint32_t)0x00000000;
 121              		.loc 1 366 0
 122 00ba 4FF42053 		mov	r3, #10240
 123 00be C4F20003 		movt	r3, 16384
 124 00c2 9B68     		ldr	r3, [r3, #8]
 125 00c4 4FF42053 		mov	r3, #10240
 126 00c8 C4F20003 		movt	r3, 16384
 127 00cc 4FF00002 		mov	r2, #0
 128 00d0 9A60     		str	r2, [r3, #8]
 367:../src/stm32f30x_rtc.c ****       RTC->WUTR      = (uint32_t)0x0000FFFF;
 129              		.loc 1 367 0
 130 00d2 4FF42053 		mov	r3, #10240
 131 00d6 C4F20003 		movt	r3, 16384
 132 00da 4FF6FF72 		movw	r2, #65535
 133 00de 5A61     		str	r2, [r3, #20]
 368:../src/stm32f30x_rtc.c ****       RTC->PRER      = (uint32_t)0x007F00FF;
 134              		.loc 1 368 0
 135 00e0 4FF42053 		mov	r3, #10240
 136 00e4 C4F20003 		movt	r3, 16384
 137 00e8 4FF0FF02 		mov	r2, #255
 138 00ec C0F27F02 		movt	r2, 127
 139 00f0 1A61     		str	r2, [r3, #16]
 369:../src/stm32f30x_rtc.c ****       RTC->ALRMAR    = (uint32_t)0x00000000;
 140              		.loc 1 369 0
 141 00f2 4FF42053 		mov	r3, #10240
 142 00f6 C4F20003 		movt	r3, 16384
 143 00fa 4FF00002 		mov	r2, #0
 144 00fe DA61     		str	r2, [r3, #28]
 370:../src/stm32f30x_rtc.c ****       RTC->ALRMBR    = (uint32_t)0x00000000;
 145              		.loc 1 370 0
 146 0100 4FF42053 		mov	r3, #10240
 147 0104 C4F20003 		movt	r3, 16384
 148 0108 4FF00002 		mov	r2, #0
 149 010c 1A62     		str	r2, [r3, #32]
 371:../src/stm32f30x_rtc.c ****       RTC->SHIFTR    = (uint32_t)0x00000000;
 150              		.loc 1 371 0
 151 010e 4FF42053 		mov	r3, #10240
 152 0112 C4F20003 		movt	r3, 16384
 153 0116 4FF00002 		mov	r2, #0
 154 011a DA62     		str	r2, [r3, #44]
 372:../src/stm32f30x_rtc.c ****       RTC->CALR       = (uint32_t)0x00000000;
 155              		.loc 1 372 0
 156 011c 4FF42053 		mov	r3, #10240
 157 0120 C4F20003 		movt	r3, 16384
 158 0124 4FF00002 		mov	r2, #0
 159 0128 DA63     		str	r2, [r3, #60]
 373:../src/stm32f30x_rtc.c ****       RTC->ALRMASSR  = (uint32_t)0x00000000;
 160              		.loc 1 373 0
 161 012a 4FF42053 		mov	r3, #10240
 162 012e C4F20003 		movt	r3, 16384
 163 0132 4FF00002 		mov	r2, #0
 164 0136 5A64     		str	r2, [r3, #68]
 374:../src/stm32f30x_rtc.c ****       RTC->ALRMBSSR  = (uint32_t)0x00000000;
 165              		.loc 1 374 0
 166 0138 4FF42053 		mov	r3, #10240
 167 013c C4F20003 		movt	r3, 16384
 168 0140 4FF00002 		mov	r2, #0
 169 0144 9A64     		str	r2, [r3, #72]
 375:../src/stm32f30x_rtc.c **** 
 376:../src/stm32f30x_rtc.c ****       /* Reset ISR register and exit initialization mode */
 377:../src/stm32f30x_rtc.c ****       RTC->ISR = (uint32_t)0x00000000;
 170              		.loc 1 377 0
 171 0146 4FF42053 		mov	r3, #10240
 172 014a C4F20003 		movt	r3, 16384
 173 014e 4FF00002 		mov	r2, #0
 174 0152 DA60     		str	r2, [r3, #12]
 378:../src/stm32f30x_rtc.c ****       
 379:../src/stm32f30x_rtc.c ****       /* Reset Tamper and alternate functions configuration register */
 380:../src/stm32f30x_rtc.c ****       RTC->TAFCR = 0x00000000;
 175              		.loc 1 380 0
 176 0154 4FF42053 		mov	r3, #10240
 177 0158 C4F20003 		movt	r3, 16384
 178 015c 4FF00002 		mov	r2, #0
 179 0160 1A64     		str	r2, [r3, #64]
 381:../src/stm32f30x_rtc.c ****       
 382:../src/stm32f30x_rtc.c ****       /* Wait till the RTC RSF flag is set */
 383:../src/stm32f30x_rtc.c ****       if (RTC_WaitForSynchro() == ERROR)
 180              		.loc 1 383 0
 181 0162 FFF7FEFF 		bl	RTC_WaitForSynchro
 182 0166 0346     		mov	r3, r0
 183 0168 002B     		cmp	r3, #0
 184 016a 03D1     		bne	.L7
 384:../src/stm32f30x_rtc.c ****       {
 385:../src/stm32f30x_rtc.c ****         status = ERROR;
 185              		.loc 1 385 0
 186 016c 4FF00003 		mov	r3, #0
 187 0170 FB73     		strb	r3, [r7, #15]
 188 0172 02E0     		b	.L3
 189              	.L7:
 386:../src/stm32f30x_rtc.c ****       }
 387:../src/stm32f30x_rtc.c ****       else
 388:../src/stm32f30x_rtc.c ****       {
 389:../src/stm32f30x_rtc.c ****         status = SUCCESS;
 190              		.loc 1 389 0
 191 0174 4FF00103 		mov	r3, #1
 192 0178 FB73     		strb	r3, [r7, #15]
 193              	.L3:
 390:../src/stm32f30x_rtc.c ****       }
 391:../src/stm32f30x_rtc.c ****     }
 392:../src/stm32f30x_rtc.c ****   }
 393:../src/stm32f30x_rtc.c ****   
 394:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
 395:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;  
 194              		.loc 1 395 0
 195 017a 4FF42053 		mov	r3, #10240
 196 017e C4F20003 		movt	r3, 16384
 197 0182 4FF0FF02 		mov	r2, #255
 198 0186 5A62     		str	r2, [r3, #36]
 396:../src/stm32f30x_rtc.c ****   
 397:../src/stm32f30x_rtc.c ****   return status;
 199              		.loc 1 397 0
 200 0188 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 398:../src/stm32f30x_rtc.c **** }
 201              		.loc 1 398 0
 202 018a 1846     		mov	r0, r3
 203 018c 07F11007 		add	r7, r7, #16
 204 0190 BD46     		mov	sp, r7
 205 0192 80BD     		pop	{r7, pc}
 206              		.cfi_endproc
 207              	.LFE111:
 209              		.align	2
 210              		.global	RTC_Init
 211              		.thumb
 212              		.thumb_func
 214              	RTC_Init:
 215              	.LFB112:
 399:../src/stm32f30x_rtc.c **** 
 400:../src/stm32f30x_rtc.c **** /**
 401:../src/stm32f30x_rtc.c ****   * @brief  Initializes the RTC registers according to the specified parameters 
 402:../src/stm32f30x_rtc.c ****   *         in RTC_InitStruct.
 403:../src/stm32f30x_rtc.c ****   * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure that contains 
 404:../src/stm32f30x_rtc.c ****   *         the configuration information for the RTC peripheral.
 405:../src/stm32f30x_rtc.c ****   * @note   The RTC Prescaler register is write protected and can be written in 
 406:../src/stm32f30x_rtc.c ****   *         initialization mode only.  
 407:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
 408:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC registers are initialized
 409:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC registers are not initialized  
 410:../src/stm32f30x_rtc.c ****   */
 411:../src/stm32f30x_rtc.c **** ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
 412:../src/stm32f30x_rtc.c **** {
 216              		.loc 1 412 0
 217              		.cfi_startproc
 218              		@ args = 0, pretend = 0, frame = 16
 219              		@ frame_needed = 1, uses_anonymous_args = 0
 220 0194 80B5     		push	{r7, lr}
 221              	.LCFI3:
 222              		.cfi_def_cfa_offset 8
 223              		.cfi_offset 7, -8
 224              		.cfi_offset 14, -4
 225 0196 84B0     		sub	sp, sp, #16
 226              	.LCFI4:
 227              		.cfi_def_cfa_offset 24
 228 0198 00AF     		add	r7, sp, #0
 229              	.LCFI5:
 230              		.cfi_def_cfa_register 7
 231 019a 7860     		str	r0, [r7, #4]
 413:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 232              		.loc 1 413 0
 233 019c 4FF00003 		mov	r3, #0
 234 01a0 FB73     		strb	r3, [r7, #15]
 414:../src/stm32f30x_rtc.c ****   
 415:../src/stm32f30x_rtc.c ****   /* Check the parameters */
 416:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
 417:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
 418:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
 419:../src/stm32f30x_rtc.c **** 
 420:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
 421:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 235              		.loc 1 421 0
 236 01a2 4FF42053 		mov	r3, #10240
 237 01a6 C4F20003 		movt	r3, 16384
 238 01aa 4FF0CA02 		mov	r2, #202
 239 01ae 5A62     		str	r2, [r3, #36]
 422:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 240              		.loc 1 422 0
 241 01b0 4FF42053 		mov	r3, #10240
 242 01b4 C4F20003 		movt	r3, 16384
 243 01b8 4FF05302 		mov	r2, #83
 244 01bc 5A62     		str	r2, [r3, #36]
 423:../src/stm32f30x_rtc.c **** 
 424:../src/stm32f30x_rtc.c ****   /* Set Initialization mode */
 425:../src/stm32f30x_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
 245              		.loc 1 425 0
 246 01be FFF7FEFF 		bl	RTC_EnterInitMode
 247 01c2 0346     		mov	r3, r0
 248 01c4 002B     		cmp	r3, #0
 249 01c6 03D1     		bne	.L10
 426:../src/stm32f30x_rtc.c ****   {
 427:../src/stm32f30x_rtc.c ****     status = ERROR;
 250              		.loc 1 427 0
 251 01c8 4FF00003 		mov	r3, #0
 252 01cc FB73     		strb	r3, [r7, #15]
 253 01ce 33E0     		b	.L11
 254              	.L10:
 428:../src/stm32f30x_rtc.c ****   } 
 429:../src/stm32f30x_rtc.c ****   else
 430:../src/stm32f30x_rtc.c ****   {
 431:../src/stm32f30x_rtc.c ****     /* Clear RTC CR FMT Bit */
 432:../src/stm32f30x_rtc.c ****     RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
 255              		.loc 1 432 0
 256 01d0 4FF42053 		mov	r3, #10240
 257 01d4 C4F20003 		movt	r3, 16384
 258 01d8 4FF42052 		mov	r2, #10240
 259 01dc C4F20002 		movt	r2, 16384
 260 01e0 9268     		ldr	r2, [r2, #8]
 261 01e2 22F04002 		bic	r2, r2, #64
 262 01e6 9A60     		str	r2, [r3, #8]
 433:../src/stm32f30x_rtc.c ****     /* Set RTC_CR register */
 434:../src/stm32f30x_rtc.c ****     RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
 263              		.loc 1 434 0
 264 01e8 4FF42053 		mov	r3, #10240
 265 01ec C4F20003 		movt	r3, 16384
 266 01f0 4FF42052 		mov	r2, #10240
 267 01f4 C4F20002 		movt	r2, 16384
 268 01f8 9168     		ldr	r1, [r2, #8]
 269 01fa 7A68     		ldr	r2, [r7, #4]
 270 01fc 1268     		ldr	r2, [r2, #0]
 271 01fe 0A43     		orrs	r2, r2, r1
 272 0200 9A60     		str	r2, [r3, #8]
 435:../src/stm32f30x_rtc.c ****   
 436:../src/stm32f30x_rtc.c ****     /* Configure the RTC PRER */
 437:../src/stm32f30x_rtc.c ****     RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
 273              		.loc 1 437 0
 274 0202 4FF42053 		mov	r3, #10240
 275 0206 C4F20003 		movt	r3, 16384
 276 020a 7A68     		ldr	r2, [r7, #4]
 277 020c 9268     		ldr	r2, [r2, #8]
 278 020e 1A61     		str	r2, [r3, #16]
 438:../src/stm32f30x_rtc.c ****     RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
 279              		.loc 1 438 0
 280 0210 4FF42053 		mov	r3, #10240
 281 0214 C4F20003 		movt	r3, 16384
 282 0218 4FF42052 		mov	r2, #10240
 283 021c C4F20002 		movt	r2, 16384
 284 0220 1169     		ldr	r1, [r2, #16]
 285 0222 7A68     		ldr	r2, [r7, #4]
 286 0224 5268     		ldr	r2, [r2, #4]
 287 0226 4FEA0242 		lsl	r2, r2, #16
 288 022a 0A43     		orrs	r2, r2, r1
 289 022c 1A61     		str	r2, [r3, #16]
 439:../src/stm32f30x_rtc.c **** 
 440:../src/stm32f30x_rtc.c ****     /* Exit Initialization mode */
 441:../src/stm32f30x_rtc.c ****     RTC_ExitInitMode();
 290              		.loc 1 441 0
 291 022e FFF7FEFF 		bl	RTC_ExitInitMode
 442:../src/stm32f30x_rtc.c **** 
 443:../src/stm32f30x_rtc.c ****     status = SUCCESS;    
 292              		.loc 1 443 0
 293 0232 4FF00103 		mov	r3, #1
 294 0236 FB73     		strb	r3, [r7, #15]
 295              	.L11:
 444:../src/stm32f30x_rtc.c ****   }
 445:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
 446:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF; 
 296              		.loc 1 446 0
 297 0238 4FF42053 		mov	r3, #10240
 298 023c C4F20003 		movt	r3, 16384
 299 0240 4FF0FF02 		mov	r2, #255
 300 0244 5A62     		str	r2, [r3, #36]
 447:../src/stm32f30x_rtc.c ****   
 448:../src/stm32f30x_rtc.c ****   return status;
 301              		.loc 1 448 0
 302 0246 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 449:../src/stm32f30x_rtc.c **** }
 303              		.loc 1 449 0
 304 0248 1846     		mov	r0, r3
 305 024a 07F11007 		add	r7, r7, #16
 306 024e BD46     		mov	sp, r7
 307 0250 80BD     		pop	{r7, pc}
 308              		.cfi_endproc
 309              	.LFE112:
 311 0252 00BF     		.align	2
 312              		.global	RTC_StructInit
 313              		.thumb
 314              		.thumb_func
 316              	RTC_StructInit:
 317              	.LFB113:
 450:../src/stm32f30x_rtc.c **** 
 451:../src/stm32f30x_rtc.c **** /**
 452:../src/stm32f30x_rtc.c ****   * @brief  Fills each RTC_InitStruct member with its default value.
 453:../src/stm32f30x_rtc.c ****   * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
 454:../src/stm32f30x_rtc.c ****   *         initialized.
 455:../src/stm32f30x_rtc.c ****   * @retval None
 456:../src/stm32f30x_rtc.c ****   */
 457:../src/stm32f30x_rtc.c **** void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
 458:../src/stm32f30x_rtc.c **** {
 318              		.loc 1 458 0
 319              		.cfi_startproc
 320              		@ args = 0, pretend = 0, frame = 8
 321              		@ frame_needed = 1, uses_anonymous_args = 0
 322              		@ link register save eliminated.
 323 0254 80B4     		push	{r7}
 324              	.LCFI6:
 325              		.cfi_def_cfa_offset 4
 326              		.cfi_offset 7, -4
 327 0256 83B0     		sub	sp, sp, #12
 328              	.LCFI7:
 329              		.cfi_def_cfa_offset 16
 330 0258 00AF     		add	r7, sp, #0
 331              	.LCFI8:
 332              		.cfi_def_cfa_register 7
 333 025a 7860     		str	r0, [r7, #4]
 459:../src/stm32f30x_rtc.c ****   /* Initialize the RTC_HourFormat member */
 460:../src/stm32f30x_rtc.c ****   RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
 334              		.loc 1 460 0
 335 025c 7B68     		ldr	r3, [r7, #4]
 336 025e 4FF00002 		mov	r2, #0
 337 0262 1A60     		str	r2, [r3, #0]
 461:../src/stm32f30x_rtc.c ****     
 462:../src/stm32f30x_rtc.c ****   /* Initialize the RTC_AsynchPrediv member */
 463:../src/stm32f30x_rtc.c ****   RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
 338              		.loc 1 463 0
 339 0264 7B68     		ldr	r3, [r7, #4]
 340 0266 4FF07F02 		mov	r2, #127
 341 026a 5A60     		str	r2, [r3, #4]
 464:../src/stm32f30x_rtc.c **** 
 465:../src/stm32f30x_rtc.c ****   /* Initialize the RTC_SynchPrediv member */
 466:../src/stm32f30x_rtc.c ****   RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
 342              		.loc 1 466 0
 343 026c 7B68     		ldr	r3, [r7, #4]
 344 026e 4FF0FF02 		mov	r2, #255
 345 0272 9A60     		str	r2, [r3, #8]
 467:../src/stm32f30x_rtc.c **** }
 346              		.loc 1 467 0
 347 0274 07F10C07 		add	r7, r7, #12
 348 0278 BD46     		mov	sp, r7
 349 027a 80BC     		pop	{r7}
 350 027c 7047     		bx	lr
 351              		.cfi_endproc
 352              	.LFE113:
 354 027e 00BF     		.align	2
 355              		.global	RTC_WriteProtectionCmd
 356              		.thumb
 357              		.thumb_func
 359              	RTC_WriteProtectionCmd:
 360              	.LFB114:
 468:../src/stm32f30x_rtc.c **** 
 469:../src/stm32f30x_rtc.c **** /**
 470:../src/stm32f30x_rtc.c ****   * @brief  Enables or disables the RTC registers write protection.
 471:../src/stm32f30x_rtc.c ****   * @note   All the RTC registers are write protected except for RTC_ISR[13:8], 
 472:../src/stm32f30x_rtc.c ****   *         RTC_TAFCR and RTC_BKPxR.
 473:../src/stm32f30x_rtc.c ****   * @note   Writing a wrong key reactivates the write protection.
 474:../src/stm32f30x_rtc.c ****   * @note   The protection mechanism is not affected by system reset.  
 475:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the write protection.
 476:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.
 477:../src/stm32f30x_rtc.c ****   * @retval None
 478:../src/stm32f30x_rtc.c ****   */
 479:../src/stm32f30x_rtc.c **** void RTC_WriteProtectionCmd(FunctionalState NewState)
 480:../src/stm32f30x_rtc.c **** {
 361              		.loc 1 480 0
 362              		.cfi_startproc
 363              		@ args = 0, pretend = 0, frame = 8
 364              		@ frame_needed = 1, uses_anonymous_args = 0
 365              		@ link register save eliminated.
 366 0280 80B4     		push	{r7}
 367              	.LCFI9:
 368              		.cfi_def_cfa_offset 4
 369              		.cfi_offset 7, -4
 370 0282 83B0     		sub	sp, sp, #12
 371              	.LCFI10:
 372              		.cfi_def_cfa_offset 16
 373 0284 00AF     		add	r7, sp, #0
 374              	.LCFI11:
 375              		.cfi_def_cfa_register 7
 376 0286 0346     		mov	r3, r0
 377 0288 FB71     		strb	r3, [r7, #7]
 481:../src/stm32f30x_rtc.c ****   /* Check the parameters */
 482:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 483:../src/stm32f30x_rtc.c ****     
 484:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 378              		.loc 1 484 0
 379 028a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 380 028c 002B     		cmp	r3, #0
 381 028e 07D0     		beq	.L15
 485:../src/stm32f30x_rtc.c ****   {
 486:../src/stm32f30x_rtc.c ****     /* Enable the write protection for RTC registers */
 487:../src/stm32f30x_rtc.c ****     RTC->WPR = 0xFF;   
 382              		.loc 1 487 0
 383 0290 4FF42053 		mov	r3, #10240
 384 0294 C4F20003 		movt	r3, 16384
 385 0298 4FF0FF02 		mov	r2, #255
 386 029c 5A62     		str	r2, [r3, #36]
 387 029e 0DE0     		b	.L14
 388              	.L15:
 488:../src/stm32f30x_rtc.c ****   }
 489:../src/stm32f30x_rtc.c ****   else
 490:../src/stm32f30x_rtc.c ****   {
 491:../src/stm32f30x_rtc.c ****     /* Disable the write protection for RTC registers */
 492:../src/stm32f30x_rtc.c ****     RTC->WPR = 0xCA;
 389              		.loc 1 492 0
 390 02a0 4FF42053 		mov	r3, #10240
 391 02a4 C4F20003 		movt	r3, 16384
 392 02a8 4FF0CA02 		mov	r2, #202
 393 02ac 5A62     		str	r2, [r3, #36]
 493:../src/stm32f30x_rtc.c ****     RTC->WPR = 0x53;    
 394              		.loc 1 493 0
 395 02ae 4FF42053 		mov	r3, #10240
 396 02b2 C4F20003 		movt	r3, 16384
 397 02b6 4FF05302 		mov	r2, #83
 398 02ba 5A62     		str	r2, [r3, #36]
 399              	.L14:
 494:../src/stm32f30x_rtc.c ****   }
 495:../src/stm32f30x_rtc.c **** }
 400              		.loc 1 495 0
 401 02bc 07F10C07 		add	r7, r7, #12
 402 02c0 BD46     		mov	sp, r7
 403 02c2 80BC     		pop	{r7}
 404 02c4 7047     		bx	lr
 405              		.cfi_endproc
 406              	.LFE114:
 408 02c6 00BF     		.align	2
 409              		.global	RTC_EnterInitMode
 410              		.thumb
 411              		.thumb_func
 413              	RTC_EnterInitMode:
 414              	.LFB115:
 496:../src/stm32f30x_rtc.c **** 
 497:../src/stm32f30x_rtc.c **** /**
 498:../src/stm32f30x_rtc.c ****   * @brief  Enters the RTC Initialization mode.
 499:../src/stm32f30x_rtc.c ****   * @note   The RTC Initialization mode is write protected, use the 
 500:../src/stm32f30x_rtc.c ****   *         RTC_WriteProtectionCmd(DISABLE) before calling this function.    
 501:../src/stm32f30x_rtc.c ****   * @param  None
 502:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
 503:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC is in Init mode
 504:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC is not in Init mode  
 505:../src/stm32f30x_rtc.c ****   */
 506:../src/stm32f30x_rtc.c **** ErrorStatus RTC_EnterInitMode(void)
 507:../src/stm32f30x_rtc.c **** {
 415              		.loc 1 507 0
 416              		.cfi_startproc
 417              		@ args = 0, pretend = 0, frame = 16
 418              		@ frame_needed = 1, uses_anonymous_args = 0
 419              		@ link register save eliminated.
 420 02c8 80B4     		push	{r7}
 421              	.LCFI12:
 422              		.cfi_def_cfa_offset 4
 423              		.cfi_offset 7, -4
 424 02ca 85B0     		sub	sp, sp, #20
 425              	.LCFI13:
 426              		.cfi_def_cfa_offset 24
 427 02cc 00AF     		add	r7, sp, #0
 428              	.LCFI14:
 429              		.cfi_def_cfa_register 7
 508:../src/stm32f30x_rtc.c ****   __IO uint32_t initcounter = 0x00;
 430              		.loc 1 508 0
 431 02ce 4FF00003 		mov	r3, #0
 432 02d2 7B60     		str	r3, [r7, #4]
 509:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 433              		.loc 1 509 0
 434 02d4 4FF00003 		mov	r3, #0
 435 02d8 FB73     		strb	r3, [r7, #15]
 510:../src/stm32f30x_rtc.c ****   uint32_t initstatus = 0x00;
 436              		.loc 1 510 0
 437 02da 4FF00003 		mov	r3, #0
 438 02de BB60     		str	r3, [r7, #8]
 511:../src/stm32f30x_rtc.c ****      
 512:../src/stm32f30x_rtc.c ****   /* Check if the Initialization mode is set */
 513:../src/stm32f30x_rtc.c ****   if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 439              		.loc 1 513 0
 440 02e0 4FF42053 		mov	r3, #10240
 441 02e4 C4F20003 		movt	r3, 16384
 442 02e8 DB68     		ldr	r3, [r3, #12]
 443 02ea 03F04003 		and	r3, r3, #64
 444 02ee 002B     		cmp	r3, #0
 445 02f0 2AD1     		bne	.L18
 514:../src/stm32f30x_rtc.c ****   {
 515:../src/stm32f30x_rtc.c ****     /* Set the Initialization mode */
 516:../src/stm32f30x_rtc.c ****     RTC->ISR = (uint32_t)RTC_INIT_MASK;
 446              		.loc 1 516 0
 447 02f2 4FF42053 		mov	r3, #10240
 448 02f6 C4F20003 		movt	r3, 16384
 449 02fa 4FF0FF32 		mov	r2, #-1
 450 02fe DA60     		str	r2, [r3, #12]
 451              	.L20:
 517:../src/stm32f30x_rtc.c ****     
 518:../src/stm32f30x_rtc.c ****     /* Wait till RTC is in INIT state and if Time out is reached exit */
 519:../src/stm32f30x_rtc.c ****     do
 520:../src/stm32f30x_rtc.c ****     {
 521:../src/stm32f30x_rtc.c ****       initstatus = RTC->ISR & RTC_ISR_INITF;
 452              		.loc 1 521 0 discriminator 1
 453 0300 4FF42053 		mov	r3, #10240
 454 0304 C4F20003 		movt	r3, 16384
 455 0308 DB68     		ldr	r3, [r3, #12]
 456 030a 03F04003 		and	r3, r3, #64
 457 030e BB60     		str	r3, [r7, #8]
 522:../src/stm32f30x_rtc.c ****       initcounter++;  
 458              		.loc 1 522 0 discriminator 1
 459 0310 7B68     		ldr	r3, [r7, #4]
 460 0312 03F10103 		add	r3, r3, #1
 461 0316 7B60     		str	r3, [r7, #4]
 523:../src/stm32f30x_rtc.c ****     } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 462              		.loc 1 523 0 discriminator 1
 463 0318 7B68     		ldr	r3, [r7, #4]
 464 031a B3F5005F 		cmp	r3, #8192
 465 031e 02D0     		beq	.L19
 466 0320 BB68     		ldr	r3, [r7, #8]
 467 0322 002B     		cmp	r3, #0
 468 0324 ECD0     		beq	.L20
 469              	.L19:
 524:../src/stm32f30x_rtc.c ****     
 525:../src/stm32f30x_rtc.c ****     if ((RTC->ISR & RTC_ISR_INITF) != RESET)
 470              		.loc 1 525 0
 471 0326 4FF42053 		mov	r3, #10240
 472 032a C4F20003 		movt	r3, 16384
 473 032e DB68     		ldr	r3, [r3, #12]
 474 0330 03F04003 		and	r3, r3, #64
 475 0334 002B     		cmp	r3, #0
 476 0336 03D0     		beq	.L21
 526:../src/stm32f30x_rtc.c ****     {
 527:../src/stm32f30x_rtc.c ****       status = SUCCESS;
 477              		.loc 1 527 0
 478 0338 4FF00103 		mov	r3, #1
 479 033c FB73     		strb	r3, [r7, #15]
 480 033e 06E0     		b	.L22
 481              	.L21:
 528:../src/stm32f30x_rtc.c ****     }
 529:../src/stm32f30x_rtc.c ****     else
 530:../src/stm32f30x_rtc.c ****     {
 531:../src/stm32f30x_rtc.c ****       status = ERROR;
 482              		.loc 1 531 0
 483 0340 4FF00003 		mov	r3, #0
 484 0344 FB73     		strb	r3, [r7, #15]
 485 0346 02E0     		b	.L22
 486              	.L18:
 532:../src/stm32f30x_rtc.c ****     }        
 533:../src/stm32f30x_rtc.c ****   }
 534:../src/stm32f30x_rtc.c ****   else
 535:../src/stm32f30x_rtc.c ****   {
 536:../src/stm32f30x_rtc.c ****     status = SUCCESS;  
 487              		.loc 1 536 0
 488 0348 4FF00103 		mov	r3, #1
 489 034c FB73     		strb	r3, [r7, #15]
 490              	.L22:
 537:../src/stm32f30x_rtc.c ****   } 
 538:../src/stm32f30x_rtc.c ****     
 539:../src/stm32f30x_rtc.c ****   return (status);  
 491              		.loc 1 539 0
 492 034e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 540:../src/stm32f30x_rtc.c **** }
 493              		.loc 1 540 0
 494 0350 1846     		mov	r0, r3
 495 0352 07F11407 		add	r7, r7, #20
 496 0356 BD46     		mov	sp, r7
 497 0358 80BC     		pop	{r7}
 498 035a 7047     		bx	lr
 499              		.cfi_endproc
 500              	.LFE115:
 502              		.align	2
 503              		.global	RTC_ExitInitMode
 504              		.thumb
 505              		.thumb_func
 507              	RTC_ExitInitMode:
 508              	.LFB116:
 541:../src/stm32f30x_rtc.c **** 
 542:../src/stm32f30x_rtc.c **** /**
 543:../src/stm32f30x_rtc.c ****   * @brief  Exits the RTC Initialization mode.
 544:../src/stm32f30x_rtc.c ****   * @note   When the initialization sequence is complete, the calendar restarts 
 545:../src/stm32f30x_rtc.c ****   *         counting after 4 RTCCLK cycles.  
 546:../src/stm32f30x_rtc.c ****   * @note   The RTC Initialization mode is write protected, use the 
 547:../src/stm32f30x_rtc.c ****   *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
 548:../src/stm32f30x_rtc.c ****   * @param  None
 549:../src/stm32f30x_rtc.c ****   * @retval None
 550:../src/stm32f30x_rtc.c ****   */
 551:../src/stm32f30x_rtc.c **** void RTC_ExitInitMode(void)
 552:../src/stm32f30x_rtc.c **** {
 509              		.loc 1 552 0
 510              		.cfi_startproc
 511              		@ args = 0, pretend = 0, frame = 0
 512              		@ frame_needed = 1, uses_anonymous_args = 0
 513              		@ link register save eliminated.
 514 035c 80B4     		push	{r7}
 515              	.LCFI15:
 516              		.cfi_def_cfa_offset 4
 517              		.cfi_offset 7, -4
 518 035e 00AF     		add	r7, sp, #0
 519              	.LCFI16:
 520              		.cfi_def_cfa_register 7
 553:../src/stm32f30x_rtc.c ****   /* Exit Initialization mode */
 554:../src/stm32f30x_rtc.c ****   RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
 521              		.loc 1 554 0
 522 0360 4FF42053 		mov	r3, #10240
 523 0364 C4F20003 		movt	r3, 16384
 524 0368 4FF42052 		mov	r2, #10240
 525 036c C4F20002 		movt	r2, 16384
 526 0370 D268     		ldr	r2, [r2, #12]
 527 0372 22F08002 		bic	r2, r2, #128
 528 0376 DA60     		str	r2, [r3, #12]
 555:../src/stm32f30x_rtc.c **** }
 529              		.loc 1 555 0
 530 0378 BD46     		mov	sp, r7
 531 037a 80BC     		pop	{r7}
 532 037c 7047     		bx	lr
 533              		.cfi_endproc
 534              	.LFE116:
 536 037e 00BF     		.align	2
 537              		.global	RTC_WaitForSynchro
 538              		.thumb
 539              		.thumb_func
 541              	RTC_WaitForSynchro:
 542              	.LFB117:
 556:../src/stm32f30x_rtc.c **** 
 557:../src/stm32f30x_rtc.c **** /**
 558:../src/stm32f30x_rtc.c ****   * @brief  Waits until the RTC Time and Date registers (RTC_TR and RTC_DR) are 
 559:../src/stm32f30x_rtc.c ****   *         synchronized with RTC APB clock.
 560:../src/stm32f30x_rtc.c ****   * @note   The RTC Resynchronization mode is write protected, use the 
 561:../src/stm32f30x_rtc.c ****   *         RTC_WriteProtectionCmd(DISABLE) before calling this function. 
 562:../src/stm32f30x_rtc.c ****   * @note   To read the calendar through the shadow registers after Calendar 
 563:../src/stm32f30x_rtc.c ****   *         initialization, calendar update or after wakeup from low power modes 
 564:../src/stm32f30x_rtc.c ****   *         the software must first clear the RSF flag. 
 565:../src/stm32f30x_rtc.c ****   *         The software must then wait until it is set again before reading 
 566:../src/stm32f30x_rtc.c ****   *         the calendar, which means that the calendar registers have been 
 567:../src/stm32f30x_rtc.c ****   *         correctly copied into the RTC_TR and RTC_DR shadow registers.   
 568:../src/stm32f30x_rtc.c ****   * @param  None
 569:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
 570:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC registers are synchronised
 571:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC registers are not synchronised
 572:../src/stm32f30x_rtc.c ****   */
 573:../src/stm32f30x_rtc.c **** ErrorStatus RTC_WaitForSynchro(void)
 574:../src/stm32f30x_rtc.c **** {
 543              		.loc 1 574 0
 544              		.cfi_startproc
 545              		@ args = 0, pretend = 0, frame = 16
 546              		@ frame_needed = 1, uses_anonymous_args = 0
 547              		@ link register save eliminated.
 548 0380 80B4     		push	{r7}
 549              	.LCFI17:
 550              		.cfi_def_cfa_offset 4
 551              		.cfi_offset 7, -4
 552 0382 85B0     		sub	sp, sp, #20
 553              	.LCFI18:
 554              		.cfi_def_cfa_offset 24
 555 0384 00AF     		add	r7, sp, #0
 556              	.LCFI19:
 557              		.cfi_def_cfa_register 7
 575:../src/stm32f30x_rtc.c ****   __IO uint32_t synchrocounter = 0;
 558              		.loc 1 575 0
 559 0386 4FF00003 		mov	r3, #0
 560 038a 7B60     		str	r3, [r7, #4]
 576:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 561              		.loc 1 576 0
 562 038c 4FF00003 		mov	r3, #0
 563 0390 FB73     		strb	r3, [r7, #15]
 577:../src/stm32f30x_rtc.c ****   uint32_t synchrostatus = 0x00;
 564              		.loc 1 577 0
 565 0392 4FF00003 		mov	r3, #0
 566 0396 BB60     		str	r3, [r7, #8]
 578:../src/stm32f30x_rtc.c **** 
 579:../src/stm32f30x_rtc.c ****   if ((RTC->CR & RTC_CR_BYPSHAD) != RESET)
 567              		.loc 1 579 0
 568 0398 4FF42053 		mov	r3, #10240
 569 039c C4F20003 		movt	r3, 16384
 570 03a0 9B68     		ldr	r3, [r3, #8]
 571 03a2 03F02003 		and	r3, r3, #32
 572 03a6 002B     		cmp	r3, #0
 573 03a8 03D0     		beq	.L26
 580:../src/stm32f30x_rtc.c ****   {
 581:../src/stm32f30x_rtc.c ****     /* Bypass shadow mode */
 582:../src/stm32f30x_rtc.c ****     status = SUCCESS;
 574              		.loc 1 582 0
 575 03aa 4FF00103 		mov	r3, #1
 576 03ae FB73     		strb	r3, [r7, #15]
 577 03b0 43E0     		b	.L27
 578              	.L26:
 583:../src/stm32f30x_rtc.c ****   }
 584:../src/stm32f30x_rtc.c ****   else
 585:../src/stm32f30x_rtc.c ****   {
 586:../src/stm32f30x_rtc.c ****     /* Disable the write protection for RTC registers */
 587:../src/stm32f30x_rtc.c ****     RTC->WPR = 0xCA;
 579              		.loc 1 587 0
 580 03b2 4FF42053 		mov	r3, #10240
 581 03b6 C4F20003 		movt	r3, 16384
 582 03ba 4FF0CA02 		mov	r2, #202
 583 03be 5A62     		str	r2, [r3, #36]
 588:../src/stm32f30x_rtc.c ****     RTC->WPR = 0x53;
 584              		.loc 1 588 0
 585 03c0 4FF42053 		mov	r3, #10240
 586 03c4 C4F20003 		movt	r3, 16384
 587 03c8 4FF05302 		mov	r2, #83
 588 03cc 5A62     		str	r2, [r3, #36]
 589:../src/stm32f30x_rtc.c ****     
 590:../src/stm32f30x_rtc.c ****     /* Clear RSF flag */
 591:../src/stm32f30x_rtc.c ****     RTC->ISR &= (uint32_t)RTC_RSF_MASK;
 589              		.loc 1 591 0
 590 03ce 4FF42053 		mov	r3, #10240
 591 03d2 C4F20003 		movt	r3, 16384
 592 03d6 4FF42052 		mov	r2, #10240
 593 03da C4F20002 		movt	r2, 16384
 594 03de D268     		ldr	r2, [r2, #12]
 595 03e0 22F0A002 		bic	r2, r2, #160
 596 03e4 DA60     		str	r2, [r3, #12]
 597              	.L29:
 592:../src/stm32f30x_rtc.c ****     
 593:../src/stm32f30x_rtc.c ****     /* Wait the registers to be synchronised */
 594:../src/stm32f30x_rtc.c ****     do
 595:../src/stm32f30x_rtc.c ****     {
 596:../src/stm32f30x_rtc.c ****       synchrostatus = RTC->ISR & RTC_ISR_RSF;
 598              		.loc 1 596 0 discriminator 1
 599 03e6 4FF42053 		mov	r3, #10240
 600 03ea C4F20003 		movt	r3, 16384
 601 03ee DB68     		ldr	r3, [r3, #12]
 602 03f0 03F02003 		and	r3, r3, #32
 603 03f4 BB60     		str	r3, [r7, #8]
 597:../src/stm32f30x_rtc.c ****       synchrocounter++;  
 604              		.loc 1 597 0 discriminator 1
 605 03f6 7B68     		ldr	r3, [r7, #4]
 606 03f8 03F10103 		add	r3, r3, #1
 607 03fc 7B60     		str	r3, [r7, #4]
 598:../src/stm32f30x_rtc.c ****     } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 608              		.loc 1 598 0 discriminator 1
 609 03fe 7B68     		ldr	r3, [r7, #4]
 610 0400 B3F5004F 		cmp	r3, #32768
 611 0404 02D0     		beq	.L28
 612 0406 BB68     		ldr	r3, [r7, #8]
 613 0408 002B     		cmp	r3, #0
 614 040a ECD0     		beq	.L29
 615              	.L28:
 599:../src/stm32f30x_rtc.c ****     
 600:../src/stm32f30x_rtc.c ****     if ((RTC->ISR & RTC_ISR_RSF) != RESET)
 616              		.loc 1 600 0
 617 040c 4FF42053 		mov	r3, #10240
 618 0410 C4F20003 		movt	r3, 16384
 619 0414 DB68     		ldr	r3, [r3, #12]
 620 0416 03F02003 		and	r3, r3, #32
 621 041a 002B     		cmp	r3, #0
 622 041c 03D0     		beq	.L30
 601:../src/stm32f30x_rtc.c ****     {
 602:../src/stm32f30x_rtc.c ****       status = SUCCESS;
 623              		.loc 1 602 0
 624 041e 4FF00103 		mov	r3, #1
 625 0422 FB73     		strb	r3, [r7, #15]
 626 0424 02E0     		b	.L31
 627              	.L30:
 603:../src/stm32f30x_rtc.c ****     }
 604:../src/stm32f30x_rtc.c ****     else
 605:../src/stm32f30x_rtc.c ****     {
 606:../src/stm32f30x_rtc.c ****       status = ERROR;
 628              		.loc 1 606 0
 629 0426 4FF00003 		mov	r3, #0
 630 042a FB73     		strb	r3, [r7, #15]
 631              	.L31:
 607:../src/stm32f30x_rtc.c ****     }
 608:../src/stm32f30x_rtc.c **** 
 609:../src/stm32f30x_rtc.c ****     /* Enable the write protection for RTC registers */
 610:../src/stm32f30x_rtc.c ****     RTC->WPR = 0xFF;
 632              		.loc 1 610 0
 633 042c 4FF42053 		mov	r3, #10240
 634 0430 C4F20003 		movt	r3, 16384
 635 0434 4FF0FF02 		mov	r2, #255
 636 0438 5A62     		str	r2, [r3, #36]
 637              	.L27:
 611:../src/stm32f30x_rtc.c ****   } 
 612:../src/stm32f30x_rtc.c ****   
 613:../src/stm32f30x_rtc.c ****   return (status);
 638              		.loc 1 613 0
 639 043a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 614:../src/stm32f30x_rtc.c **** }
 640              		.loc 1 614 0
 641 043c 1846     		mov	r0, r3
 642 043e 07F11407 		add	r7, r7, #20
 643 0442 BD46     		mov	sp, r7
 644 0444 80BC     		pop	{r7}
 645 0446 7047     		bx	lr
 646              		.cfi_endproc
 647              	.LFE117:
 649              		.align	2
 650              		.global	RTC_RefClockCmd
 651              		.thumb
 652              		.thumb_func
 654              	RTC_RefClockCmd:
 655              	.LFB118:
 615:../src/stm32f30x_rtc.c **** 
 616:../src/stm32f30x_rtc.c **** /**
 617:../src/stm32f30x_rtc.c ****   * @brief  Enables or disables the RTC reference clock detection.
 618:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the RTC reference clock.
 619:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.
 620:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
 621:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC reference clock detection is enabled
 622:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC reference clock detection is disabled  
 623:../src/stm32f30x_rtc.c ****   */
 624:../src/stm32f30x_rtc.c **** ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
 625:../src/stm32f30x_rtc.c **** {
 656              		.loc 1 625 0
 657              		.cfi_startproc
 658              		@ args = 0, pretend = 0, frame = 16
 659              		@ frame_needed = 1, uses_anonymous_args = 0
 660 0448 80B5     		push	{r7, lr}
 661              	.LCFI20:
 662              		.cfi_def_cfa_offset 8
 663              		.cfi_offset 7, -8
 664              		.cfi_offset 14, -4
 665 044a 84B0     		sub	sp, sp, #16
 666              	.LCFI21:
 667              		.cfi_def_cfa_offset 24
 668 044c 00AF     		add	r7, sp, #0
 669              	.LCFI22:
 670              		.cfi_def_cfa_register 7
 671 044e 0346     		mov	r3, r0
 672 0450 FB71     		strb	r3, [r7, #7]
 626:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 673              		.loc 1 626 0
 674 0452 4FF00003 		mov	r3, #0
 675 0456 FB73     		strb	r3, [r7, #15]
 627:../src/stm32f30x_rtc.c **** 
 628:../src/stm32f30x_rtc.c ****   /* Check the parameters */
 629:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 630:../src/stm32f30x_rtc.c **** 
 631:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
 632:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 676              		.loc 1 632 0
 677 0458 4FF42053 		mov	r3, #10240
 678 045c C4F20003 		movt	r3, 16384
 679 0460 4FF0CA02 		mov	r2, #202
 680 0464 5A62     		str	r2, [r3, #36]
 633:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 681              		.loc 1 633 0
 682 0466 4FF42053 		mov	r3, #10240
 683 046a C4F20003 		movt	r3, 16384
 684 046e 4FF05302 		mov	r2, #83
 685 0472 5A62     		str	r2, [r3, #36]
 634:../src/stm32f30x_rtc.c **** 
 635:../src/stm32f30x_rtc.c ****   /* Set Initialization mode */
 636:../src/stm32f30x_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
 686              		.loc 1 636 0
 687 0474 FFF7FEFF 		bl	RTC_EnterInitMode
 688 0478 0346     		mov	r3, r0
 689 047a 002B     		cmp	r3, #0
 690 047c 03D1     		bne	.L34
 637:../src/stm32f30x_rtc.c ****   {
 638:../src/stm32f30x_rtc.c ****     status = ERROR;
 691              		.loc 1 638 0
 692 047e 4FF00003 		mov	r3, #0
 693 0482 FB73     		strb	r3, [r7, #15]
 694 0484 20E0     		b	.L35
 695              	.L34:
 639:../src/stm32f30x_rtc.c ****   }
 640:../src/stm32f30x_rtc.c ****   else
 641:../src/stm32f30x_rtc.c ****   {
 642:../src/stm32f30x_rtc.c ****     if (NewState != DISABLE)
 696              		.loc 1 642 0
 697 0486 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 698 0488 002B     		cmp	r3, #0
 699 048a 0CD0     		beq	.L36
 643:../src/stm32f30x_rtc.c ****     {
 644:../src/stm32f30x_rtc.c ****       /* Enable the RTC reference clock detection */
 645:../src/stm32f30x_rtc.c ****       RTC->CR |= RTC_CR_REFCKON;   
 700              		.loc 1 645 0
 701 048c 4FF42053 		mov	r3, #10240
 702 0490 C4F20003 		movt	r3, 16384
 703 0494 4FF42052 		mov	r2, #10240
 704 0498 C4F20002 		movt	r2, 16384
 705 049c 9268     		ldr	r2, [r2, #8]
 706 049e 42F01002 		orr	r2, r2, #16
 707 04a2 9A60     		str	r2, [r3, #8]
 708 04a4 0BE0     		b	.L37
 709              	.L36:
 646:../src/stm32f30x_rtc.c ****     }
 647:../src/stm32f30x_rtc.c ****     else
 648:../src/stm32f30x_rtc.c ****     {
 649:../src/stm32f30x_rtc.c ****       /* Disable the RTC reference clock detection */
 650:../src/stm32f30x_rtc.c ****       RTC->CR &= ~RTC_CR_REFCKON;    
 710              		.loc 1 650 0
 711 04a6 4FF42053 		mov	r3, #10240
 712 04aa C4F20003 		movt	r3, 16384
 713 04ae 4FF42052 		mov	r2, #10240
 714 04b2 C4F20002 		movt	r2, 16384
 715 04b6 9268     		ldr	r2, [r2, #8]
 716 04b8 22F01002 		bic	r2, r2, #16
 717 04bc 9A60     		str	r2, [r3, #8]
 718              	.L37:
 651:../src/stm32f30x_rtc.c ****     }
 652:../src/stm32f30x_rtc.c ****     /* Exit Initialization mode */
 653:../src/stm32f30x_rtc.c ****     RTC_ExitInitMode();
 719              		.loc 1 653 0
 720 04be FFF7FEFF 		bl	RTC_ExitInitMode
 654:../src/stm32f30x_rtc.c **** 
 655:../src/stm32f30x_rtc.c ****     status = SUCCESS;
 721              		.loc 1 655 0
 722 04c2 4FF00103 		mov	r3, #1
 723 04c6 FB73     		strb	r3, [r7, #15]
 724              	.L35:
 656:../src/stm32f30x_rtc.c ****   }
 657:../src/stm32f30x_rtc.c **** 
 658:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
 659:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 725              		.loc 1 659 0
 726 04c8 4FF42053 		mov	r3, #10240
 727 04cc C4F20003 		movt	r3, 16384
 728 04d0 4FF0FF02 		mov	r2, #255
 729 04d4 5A62     		str	r2, [r3, #36]
 660:../src/stm32f30x_rtc.c **** 
 661:../src/stm32f30x_rtc.c ****   return status;
 730              		.loc 1 661 0
 731 04d6 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 662:../src/stm32f30x_rtc.c **** }
 732              		.loc 1 662 0
 733 04d8 1846     		mov	r0, r3
 734 04da 07F11007 		add	r7, r7, #16
 735 04de BD46     		mov	sp, r7
 736 04e0 80BD     		pop	{r7, pc}
 737              		.cfi_endproc
 738              	.LFE118:
 740 04e2 00BF     		.align	2
 741              		.global	RTC_BypassShadowCmd
 742              		.thumb
 743              		.thumb_func
 745              	RTC_BypassShadowCmd:
 746              	.LFB119:
 663:../src/stm32f30x_rtc.c **** 
 664:../src/stm32f30x_rtc.c **** /**
 665:../src/stm32f30x_rtc.c ****   * @brief  Enables or Disables the Bypass Shadow feature.
 666:../src/stm32f30x_rtc.c ****   * @note   When the Bypass Shadow is enabled the calendar value are taken 
 667:../src/stm32f30x_rtc.c ****   *         directly from the Calendar counter.
 668:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the Bypass Shadow feature.
 669:../src/stm32f30x_rtc.c ****   *         This parameter can be: ENABLE or DISABLE.
 670:../src/stm32f30x_rtc.c ****   * @retval None
 671:../src/stm32f30x_rtc.c **** */
 672:../src/stm32f30x_rtc.c **** void RTC_BypassShadowCmd(FunctionalState NewState)
 673:../src/stm32f30x_rtc.c **** {
 747              		.loc 1 673 0
 748              		.cfi_startproc
 749              		@ args = 0, pretend = 0, frame = 8
 750              		@ frame_needed = 1, uses_anonymous_args = 0
 751              		@ link register save eliminated.
 752 04e4 80B4     		push	{r7}
 753              	.LCFI23:
 754              		.cfi_def_cfa_offset 4
 755              		.cfi_offset 7, -4
 756 04e6 83B0     		sub	sp, sp, #12
 757              	.LCFI24:
 758              		.cfi_def_cfa_offset 16
 759 04e8 00AF     		add	r7, sp, #0
 760              	.LCFI25:
 761              		.cfi_def_cfa_register 7
 762 04ea 0346     		mov	r3, r0
 763 04ec FB71     		strb	r3, [r7, #7]
 674:../src/stm32f30x_rtc.c ****   /* Check the parameters */
 675:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 676:../src/stm32f30x_rtc.c **** 
 677:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
 678:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 764              		.loc 1 678 0
 765 04ee 4FF42053 		mov	r3, #10240
 766 04f2 C4F20003 		movt	r3, 16384
 767 04f6 4FF0CA02 		mov	r2, #202
 768 04fa 5A62     		str	r2, [r3, #36]
 679:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 769              		.loc 1 679 0
 770 04fc 4FF42053 		mov	r3, #10240
 771 0500 C4F20003 		movt	r3, 16384
 772 0504 4FF05302 		mov	r2, #83
 773 0508 5A62     		str	r2, [r3, #36]
 680:../src/stm32f30x_rtc.c ****   
 681:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 774              		.loc 1 681 0
 775 050a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 776 050c 002B     		cmp	r3, #0
 777 050e 0CD0     		beq	.L40
 682:../src/stm32f30x_rtc.c ****   {
 683:../src/stm32f30x_rtc.c ****     /* Set the BYPSHAD bit */
 684:../src/stm32f30x_rtc.c ****     RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
 778              		.loc 1 684 0
 779 0510 4FF42053 		mov	r3, #10240
 780 0514 C4F20003 		movt	r3, 16384
 781 0518 4FF42052 		mov	r2, #10240
 782 051c C4F20002 		movt	r2, 16384
 783 0520 9268     		ldr	r2, [r2, #8]
 784 0522 42F02002 		orr	r2, r2, #32
 785 0526 9A60     		str	r2, [r3, #8]
 786 0528 0BE0     		b	.L41
 787              	.L40:
 685:../src/stm32f30x_rtc.c ****   }
 686:../src/stm32f30x_rtc.c ****   else
 687:../src/stm32f30x_rtc.c ****   {
 688:../src/stm32f30x_rtc.c ****     /* Reset the BYPSHAD bit */
 689:../src/stm32f30x_rtc.c ****     RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
 788              		.loc 1 689 0
 789 052a 4FF42053 		mov	r3, #10240
 790 052e C4F20003 		movt	r3, 16384
 791 0532 4FF42052 		mov	r2, #10240
 792 0536 C4F20002 		movt	r2, 16384
 793 053a 9268     		ldr	r2, [r2, #8]
 794 053c 02F0DF02 		and	r2, r2, #223
 795 0540 9A60     		str	r2, [r3, #8]
 796              	.L41:
 690:../src/stm32f30x_rtc.c ****   }
 691:../src/stm32f30x_rtc.c **** 
 692:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
 693:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 797              		.loc 1 693 0
 798 0542 4FF42053 		mov	r3, #10240
 799 0546 C4F20003 		movt	r3, 16384
 800 054a 4FF0FF02 		mov	r2, #255
 801 054e 5A62     		str	r2, [r3, #36]
 694:../src/stm32f30x_rtc.c **** }
 802              		.loc 1 694 0
 803 0550 07F10C07 		add	r7, r7, #12
 804 0554 BD46     		mov	sp, r7
 805 0556 80BC     		pop	{r7}
 806 0558 7047     		bx	lr
 807              		.cfi_endproc
 808              	.LFE119:
 810 055a 00BF     		.align	2
 811              		.global	RTC_SetTime
 812              		.thumb
 813              		.thumb_func
 815              	RTC_SetTime:
 816              	.LFB120:
 695:../src/stm32f30x_rtc.c **** 
 696:../src/stm32f30x_rtc.c **** /**
 697:../src/stm32f30x_rtc.c ****   * @}
 698:../src/stm32f30x_rtc.c ****   */
 699:../src/stm32f30x_rtc.c **** 
 700:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group2 Time and Date configuration functions
 701:../src/stm32f30x_rtc.c ****  *  @brief   Time and Date configuration functions 
 702:../src/stm32f30x_rtc.c ****  *
 703:../src/stm32f30x_rtc.c **** @verbatim   
 704:../src/stm32f30x_rtc.c ****  ===============================================================================
 705:../src/stm32f30x_rtc.c ****                ##### Time and Date configuration functions #####
 706:../src/stm32f30x_rtc.c ****  ===============================================================================  
 707:../src/stm32f30x_rtc.c ****     [..] This section provide functions allowing to program and read the RTC Calendar
 708:../src/stm32f30x_rtc.c ****          (Time and Date).
 709:../src/stm32f30x_rtc.c **** 
 710:../src/stm32f30x_rtc.c **** @endverbatim
 711:../src/stm32f30x_rtc.c ****   * @{
 712:../src/stm32f30x_rtc.c ****   */
 713:../src/stm32f30x_rtc.c **** 
 714:../src/stm32f30x_rtc.c **** /**
 715:../src/stm32f30x_rtc.c ****   * @brief  Set the RTC current time.
 716:../src/stm32f30x_rtc.c ****   * @param  RTC_Format: specifies the format of the entered parameters.
 717:../src/stm32f30x_rtc.c ****   *   This parameter can be  one of the following values:
 718:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BIN:  Binary data format 
 719:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BCD:  BCD data format
 720:../src/stm32f30x_rtc.c ****   * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that contains 
 721:../src/stm32f30x_rtc.c ****   *                        the time configuration information for the RTC.     
 722:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
 723:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC Time register is configured
 724:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC Time register is not configured
 725:../src/stm32f30x_rtc.c ****   */
 726:../src/stm32f30x_rtc.c **** ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
 727:../src/stm32f30x_rtc.c **** {
 817              		.loc 1 727 0
 818              		.cfi_startproc
 819              		@ args = 0, pretend = 0, frame = 16
 820              		@ frame_needed = 1, uses_anonymous_args = 0
 821 055c 90B5     		push	{r4, r7, lr}
 822              	.LCFI26:
 823              		.cfi_def_cfa_offset 12
 824              		.cfi_offset 4, -12
 825              		.cfi_offset 7, -8
 826              		.cfi_offset 14, -4
 827 055e 85B0     		sub	sp, sp, #20
 828              	.LCFI27:
 829              		.cfi_def_cfa_offset 32
 830 0560 00AF     		add	r7, sp, #0
 831              	.LCFI28:
 832              		.cfi_def_cfa_register 7
 833 0562 7860     		str	r0, [r7, #4]
 834 0564 3960     		str	r1, [r7, #0]
 728:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 835              		.loc 1 728 0
 836 0566 4FF00003 		mov	r3, #0
 837 056a FB60     		str	r3, [r7, #12]
 729:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 838              		.loc 1 729 0
 839 056c 4FF00003 		mov	r3, #0
 840 0570 FB72     		strb	r3, [r7, #11]
 730:../src/stm32f30x_rtc.c ****     
 731:../src/stm32f30x_rtc.c ****   /* Check the parameters */
 732:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
 733:../src/stm32f30x_rtc.c ****   
 734:../src/stm32f30x_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 841              		.loc 1 734 0
 842 0572 7B68     		ldr	r3, [r7, #4]
 843 0574 002B     		cmp	r3, #0
 844 0576 0DD1     		bne	.L43
 735:../src/stm32f30x_rtc.c ****   {
 736:../src/stm32f30x_rtc.c ****     if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 845              		.loc 1 736 0
 846 0578 4FF42053 		mov	r3, #10240
 847 057c C4F20003 		movt	r3, 16384
 848 0580 9B68     		ldr	r3, [r3, #8]
 849 0582 03F04003 		and	r3, r3, #64
 850 0586 002B     		cmp	r3, #0
 851 0588 19D1     		bne	.L44
 737:../src/stm32f30x_rtc.c ****     {
 738:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
 739:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
 740:../src/stm32f30x_rtc.c ****     } 
 741:../src/stm32f30x_rtc.c ****     else
 742:../src/stm32f30x_rtc.c ****     {
 743:../src/stm32f30x_rtc.c ****       RTC_TimeStruct->RTC_H12 = 0x00;
 852              		.loc 1 743 0
 853 058a 3B68     		ldr	r3, [r7, #0]
 854 058c 4FF00002 		mov	r2, #0
 855 0590 DA70     		strb	r2, [r3, #3]
 856 0592 14E0     		b	.L44
 857              	.L43:
 744:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
 745:../src/stm32f30x_rtc.c ****     }
 746:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
 747:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
 748:../src/stm32f30x_rtc.c ****   }
 749:../src/stm32f30x_rtc.c ****   else
 750:../src/stm32f30x_rtc.c ****   {
 751:../src/stm32f30x_rtc.c ****     if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 858              		.loc 1 751 0
 859 0594 4FF42053 		mov	r3, #10240
 860 0598 C4F20003 		movt	r3, 16384
 861 059c 9B68     		ldr	r3, [r3, #8]
 862 059e 03F04003 		and	r3, r3, #64
 863 05a2 002B     		cmp	r3, #0
 864 05a4 07D0     		beq	.L45
 752:../src/stm32f30x_rtc.c ****     {
 753:../src/stm32f30x_rtc.c ****       tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 865              		.loc 1 753 0
 866 05a6 3B68     		ldr	r3, [r7, #0]
 867 05a8 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 868 05aa 1846     		mov	r0, r3
 869 05ac 01F072FA 		bl	RTC_Bcd2ToByte
 870 05b0 0346     		mov	r3, r0
 871 05b2 FB60     		str	r3, [r7, #12]
 872 05b4 03E0     		b	.L44
 873              	.L45:
 754:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR12(tmpreg));
 755:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
 756:../src/stm32f30x_rtc.c ****     } 
 757:../src/stm32f30x_rtc.c ****     else
 758:../src/stm32f30x_rtc.c ****     {
 759:../src/stm32f30x_rtc.c ****       RTC_TimeStruct->RTC_H12 = 0x00;
 874              		.loc 1 759 0
 875 05b6 3B68     		ldr	r3, [r7, #0]
 876 05b8 4FF00002 		mov	r2, #0
 877 05bc DA70     		strb	r2, [r3, #3]
 878              	.L44:
 760:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
 761:../src/stm32f30x_rtc.c ****     }
 762:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
 763:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
 764:../src/stm32f30x_rtc.c ****   }
 765:../src/stm32f30x_rtc.c ****   
 766:../src/stm32f30x_rtc.c ****   /* Check the input parameters format */
 767:../src/stm32f30x_rtc.c ****   if (RTC_Format != RTC_Format_BIN)
 879              		.loc 1 767 0
 880 05be 7B68     		ldr	r3, [r7, #4]
 881 05c0 002B     		cmp	r3, #0
 882 05c2 12D0     		beq	.L46
 768:../src/stm32f30x_rtc.c ****   {
 769:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 883              		.loc 1 769 0
 884 05c4 3B68     		ldr	r3, [r7, #0]
 885 05c6 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 886 05c8 4FEA0342 		lsl	r2, r3, #16
 770:../src/stm32f30x_rtc.c ****              ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 887              		.loc 1 770 0
 888 05cc 3B68     		ldr	r3, [r7, #0]
 889 05ce 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 890 05d0 4FEA0323 		lsl	r3, r3, #8
 769:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 891              		.loc 1 769 0
 892 05d4 1A43     		orrs	r2, r2, r3
 771:../src/stm32f30x_rtc.c ****              ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
 893              		.loc 1 771 0
 894 05d6 3B68     		ldr	r3, [r7, #0]
 895 05d8 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 770:../src/stm32f30x_rtc.c ****              ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 896              		.loc 1 770 0
 897 05da 1A43     		orrs	r2, r2, r3
 772:../src/stm32f30x_rtc.c ****              ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
 898              		.loc 1 772 0
 899 05dc 3B68     		ldr	r3, [r7, #0]
 900 05de DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 901 05e0 4FEA0343 		lsl	r3, r3, #16
 769:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 902              		.loc 1 769 0
 903 05e4 1343     		orrs	r3, r3, r2
 904 05e6 FB60     		str	r3, [r7, #12]
 905 05e8 1EE0     		b	.L47
 906              	.L46:
 773:../src/stm32f30x_rtc.c ****   }  
 774:../src/stm32f30x_rtc.c ****   else
 775:../src/stm32f30x_rtc.c ****   {
 776:../src/stm32f30x_rtc.c ****     tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 907              		.loc 1 776 0
 908 05ea 3B68     		ldr	r3, [r7, #0]
 909 05ec 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 910 05ee 1846     		mov	r0, r3
 911 05f0 01F02EFA 		bl	RTC_ByteToBcd2
 912 05f4 0346     		mov	r3, r0
 913 05f6 4FEA0344 		lsl	r4, r3, #16
 777:../src/stm32f30x_rtc.c ****                    ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 914              		.loc 1 777 0
 915 05fa 3B68     		ldr	r3, [r7, #0]
 916 05fc 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 917 05fe 1846     		mov	r0, r3
 918 0600 01F026FA 		bl	RTC_ByteToBcd2
 919 0604 0346     		mov	r3, r0
 920 0606 4FEA0323 		lsl	r3, r3, #8
 776:../src/stm32f30x_rtc.c ****     tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 921              		.loc 1 776 0
 922 060a 1C43     		orrs	r4, r4, r3
 778:../src/stm32f30x_rtc.c ****                    ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
 923              		.loc 1 778 0
 924 060c 3B68     		ldr	r3, [r7, #0]
 925 060e 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 926 0610 1846     		mov	r0, r3
 927 0612 01F01DFA 		bl	RTC_ByteToBcd2
 928 0616 0346     		mov	r3, r0
 777:../src/stm32f30x_rtc.c ****                    ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 929              		.loc 1 777 0
 930 0618 44EA0302 		orr	r2, r4, r3
 779:../src/stm32f30x_rtc.c ****                    (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
 931              		.loc 1 779 0
 932 061c 3B68     		ldr	r3, [r7, #0]
 933 061e DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 934 0620 4FEA0343 		lsl	r3, r3, #16
 776:../src/stm32f30x_rtc.c ****     tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 935              		.loc 1 776 0
 936 0624 1343     		orrs	r3, r3, r2
 937 0626 FB60     		str	r3, [r7, #12]
 938              	.L47:
 780:../src/stm32f30x_rtc.c ****   }  
 781:../src/stm32f30x_rtc.c **** 
 782:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
 783:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 939              		.loc 1 783 0
 940 0628 4FF42053 		mov	r3, #10240
 941 062c C4F20003 		movt	r3, 16384
 942 0630 4FF0CA02 		mov	r2, #202
 943 0634 5A62     		str	r2, [r3, #36]
 784:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 944              		.loc 1 784 0
 945 0636 4FF42053 		mov	r3, #10240
 946 063a C4F20003 		movt	r3, 16384
 947 063e 4FF05302 		mov	r2, #83
 948 0642 5A62     		str	r2, [r3, #36]
 785:../src/stm32f30x_rtc.c **** 
 786:../src/stm32f30x_rtc.c ****   /* Set Initialization mode */
 787:../src/stm32f30x_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
 949              		.loc 1 787 0
 950 0644 FFF7FEFF 		bl	RTC_EnterInitMode
 951 0648 0346     		mov	r3, r0
 952 064a 002B     		cmp	r3, #0
 953 064c 03D1     		bne	.L48
 788:../src/stm32f30x_rtc.c ****   {
 789:../src/stm32f30x_rtc.c ****     status = ERROR;
 954              		.loc 1 789 0
 955 064e 4FF00003 		mov	r3, #0
 956 0652 FB72     		strb	r3, [r7, #11]
 957 0654 24E0     		b	.L49
 958              	.L48:
 790:../src/stm32f30x_rtc.c ****   } 
 791:../src/stm32f30x_rtc.c ****   else
 792:../src/stm32f30x_rtc.c ****   {
 793:../src/stm32f30x_rtc.c ****     /* Set the RTC_TR register */
 794:../src/stm32f30x_rtc.c ****     RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 959              		.loc 1 794 0
 960 0656 4FF42053 		mov	r3, #10240
 961 065a C4F20003 		movt	r3, 16384
 962 065e FA68     		ldr	r2, [r7, #12]
 963 0660 02F07F32 		and	r2, r2, #2139062143
 964 0664 22F0FE42 		bic	r2, r2, #2130706432
 965 0668 1A60     		str	r2, [r3, #0]
 795:../src/stm32f30x_rtc.c **** 
 796:../src/stm32f30x_rtc.c ****     /* Exit Initialization mode */
 797:../src/stm32f30x_rtc.c ****     RTC_ExitInitMode(); 
 966              		.loc 1 797 0
 967 066a FFF7FEFF 		bl	RTC_ExitInitMode
 798:../src/stm32f30x_rtc.c **** 
 799:../src/stm32f30x_rtc.c ****     /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
 800:../src/stm32f30x_rtc.c ****     if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 968              		.loc 1 800 0
 969 066e 4FF42053 		mov	r3, #10240
 970 0672 C4F20003 		movt	r3, 16384
 971 0676 9B68     		ldr	r3, [r3, #8]
 972 0678 03F02003 		and	r3, r3, #32
 973 067c 002B     		cmp	r3, #0
 974 067e 0CD1     		bne	.L50
 801:../src/stm32f30x_rtc.c ****     {
 802:../src/stm32f30x_rtc.c ****       if (RTC_WaitForSynchro() == ERROR)
 975              		.loc 1 802 0
 976 0680 FFF7FEFF 		bl	RTC_WaitForSynchro
 977 0684 0346     		mov	r3, r0
 978 0686 002B     		cmp	r3, #0
 979 0688 03D1     		bne	.L51
 803:../src/stm32f30x_rtc.c ****       {
 804:../src/stm32f30x_rtc.c ****         status = ERROR;
 980              		.loc 1 804 0
 981 068a 4FF00003 		mov	r3, #0
 982 068e FB72     		strb	r3, [r7, #11]
 983 0690 06E0     		b	.L49
 984              	.L51:
 805:../src/stm32f30x_rtc.c ****       }
 806:../src/stm32f30x_rtc.c ****       else
 807:../src/stm32f30x_rtc.c ****       {
 808:../src/stm32f30x_rtc.c ****         status = SUCCESS;
 985              		.loc 1 808 0
 986 0692 4FF00103 		mov	r3, #1
 987 0696 FB72     		strb	r3, [r7, #11]
 988 0698 02E0     		b	.L49
 989              	.L50:
 809:../src/stm32f30x_rtc.c ****       }
 810:../src/stm32f30x_rtc.c ****     }
 811:../src/stm32f30x_rtc.c ****     else
 812:../src/stm32f30x_rtc.c ****     {
 813:../src/stm32f30x_rtc.c ****       status = SUCCESS;
 990              		.loc 1 813 0
 991 069a 4FF00103 		mov	r3, #1
 992 069e FB72     		strb	r3, [r7, #11]
 993              	.L49:
 814:../src/stm32f30x_rtc.c ****     }
 815:../src/stm32f30x_rtc.c ****   
 816:../src/stm32f30x_rtc.c ****   }
 817:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
 818:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 994              		.loc 1 818 0
 995 06a0 4FF42053 		mov	r3, #10240
 996 06a4 C4F20003 		movt	r3, 16384
 997 06a8 4FF0FF02 		mov	r2, #255
 998 06ac 5A62     		str	r2, [r3, #36]
 819:../src/stm32f30x_rtc.c ****     
 820:../src/stm32f30x_rtc.c ****   return status;
 999              		.loc 1 820 0
 1000 06ae FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 821:../src/stm32f30x_rtc.c **** }
 1001              		.loc 1 821 0
 1002 06b0 1846     		mov	r0, r3
 1003 06b2 07F11407 		add	r7, r7, #20
 1004 06b6 BD46     		mov	sp, r7
 1005 06b8 90BD     		pop	{r4, r7, pc}
 1006              		.cfi_endproc
 1007              	.LFE120:
 1009 06ba 00BF     		.align	2
 1010              		.global	RTC_TimeStructInit
 1011              		.thumb
 1012              		.thumb_func
 1014              	RTC_TimeStructInit:
 1015              	.LFB121:
 822:../src/stm32f30x_rtc.c **** 
 823:../src/stm32f30x_rtc.c **** /**
 824:../src/stm32f30x_rtc.c ****   * @brief  Fills each RTC_TimeStruct member with its default value
 825:../src/stm32f30x_rtc.c ****   *         (Time = 00h:00min:00sec).
 826:../src/stm32f30x_rtc.c ****   * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
 827:../src/stm32f30x_rtc.c ****   *         initialized.
 828:../src/stm32f30x_rtc.c ****   * @retval None
 829:../src/stm32f30x_rtc.c ****   */
 830:../src/stm32f30x_rtc.c **** void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
 831:../src/stm32f30x_rtc.c **** {
 1016              		.loc 1 831 0
 1017              		.cfi_startproc
 1018              		@ args = 0, pretend = 0, frame = 8
 1019              		@ frame_needed = 1, uses_anonymous_args = 0
 1020              		@ link register save eliminated.
 1021 06bc 80B4     		push	{r7}
 1022              	.LCFI29:
 1023              		.cfi_def_cfa_offset 4
 1024              		.cfi_offset 7, -4
 1025 06be 83B0     		sub	sp, sp, #12
 1026              	.LCFI30:
 1027              		.cfi_def_cfa_offset 16
 1028 06c0 00AF     		add	r7, sp, #0
 1029              	.LCFI31:
 1030              		.cfi_def_cfa_register 7
 1031 06c2 7860     		str	r0, [r7, #4]
 832:../src/stm32f30x_rtc.c ****   /* Time = 00h:00min:00sec */
 833:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
 1032              		.loc 1 833 0
 1033 06c4 7B68     		ldr	r3, [r7, #4]
 1034 06c6 4FF00002 		mov	r2, #0
 1035 06ca DA70     		strb	r2, [r3, #3]
 834:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_Hours = 0;
 1036              		.loc 1 834 0
 1037 06cc 7B68     		ldr	r3, [r7, #4]
 1038 06ce 4FF00002 		mov	r2, #0
 1039 06d2 1A70     		strb	r2, [r3, #0]
 835:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_Minutes = 0;
 1040              		.loc 1 835 0
 1041 06d4 7B68     		ldr	r3, [r7, #4]
 1042 06d6 4FF00002 		mov	r2, #0
 1043 06da 5A70     		strb	r2, [r3, #1]
 836:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_Seconds = 0; 
 1044              		.loc 1 836 0
 1045 06dc 7B68     		ldr	r3, [r7, #4]
 1046 06de 4FF00002 		mov	r2, #0
 1047 06e2 9A70     		strb	r2, [r3, #2]
 837:../src/stm32f30x_rtc.c **** }
 1048              		.loc 1 837 0
 1049 06e4 07F10C07 		add	r7, r7, #12
 1050 06e8 BD46     		mov	sp, r7
 1051 06ea 80BC     		pop	{r7}
 1052 06ec 7047     		bx	lr
 1053              		.cfi_endproc
 1054              	.LFE121:
 1056 06ee 00BF     		.align	2
 1057              		.global	RTC_GetTime
 1058              		.thumb
 1059              		.thumb_func
 1061              	RTC_GetTime:
 1062              	.LFB122:
 838:../src/stm32f30x_rtc.c **** 
 839:../src/stm32f30x_rtc.c **** /**
 840:../src/stm32f30x_rtc.c ****   * @brief  Get the RTC current Time.
 841:../src/stm32f30x_rtc.c ****   * @param  RTC_Format: specifies the format of the returned parameters.
 842:../src/stm32f30x_rtc.c ****   *   This parameter can be  one of the following values:
 843:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BIN:  Binary data format 
 844:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BCD:  BCD data format
 845:../src/stm32f30x_rtc.c ****   * @param RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
 846:../src/stm32f30x_rtc.c ****   *                        contain the returned current time configuration.     
 847:../src/stm32f30x_rtc.c ****   * @retval None
 848:../src/stm32f30x_rtc.c ****   */
 849:../src/stm32f30x_rtc.c **** void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
 850:../src/stm32f30x_rtc.c **** {
 1063              		.loc 1 850 0
 1064              		.cfi_startproc
 1065              		@ args = 0, pretend = 0, frame = 16
 1066              		@ frame_needed = 1, uses_anonymous_args = 0
 1067 06f0 80B5     		push	{r7, lr}
 1068              	.LCFI32:
 1069              		.cfi_def_cfa_offset 8
 1070              		.cfi_offset 7, -8
 1071              		.cfi_offset 14, -4
 1072 06f2 84B0     		sub	sp, sp, #16
 1073              	.LCFI33:
 1074              		.cfi_def_cfa_offset 24
 1075 06f4 00AF     		add	r7, sp, #0
 1076              	.LCFI34:
 1077              		.cfi_def_cfa_register 7
 1078 06f6 7860     		str	r0, [r7, #4]
 1079 06f8 3960     		str	r1, [r7, #0]
 851:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 1080              		.loc 1 851 0
 1081 06fa 4FF00003 		mov	r3, #0
 1082 06fe FB60     		str	r3, [r7, #12]
 852:../src/stm32f30x_rtc.c **** 
 853:../src/stm32f30x_rtc.c ****   /* Check the parameters */
 854:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
 855:../src/stm32f30x_rtc.c **** 
 856:../src/stm32f30x_rtc.c ****   /* Get the RTC_TR register */
 857:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
 1083              		.loc 1 857 0
 1084 0700 4FF42053 		mov	r3, #10240
 1085 0704 C4F20003 		movt	r3, 16384
 1086 0708 1B68     		ldr	r3, [r3, #0]
 1087 070a 03F07F33 		and	r3, r3, #2139062143
 1088 070e 23F0FE43 		bic	r3, r3, #2130706432
 1089 0712 FB60     		str	r3, [r7, #12]
 858:../src/stm32f30x_rtc.c ****   
 859:../src/stm32f30x_rtc.c ****   /* Fill the structure fields with the read parameters */
 860:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 1090              		.loc 1 860 0
 1091 0714 FB68     		ldr	r3, [r7, #12]
 1092 0716 03F47C13 		and	r3, r3, #4128768
 1093 071a 4FEA1343 		lsr	r3, r3, #16
 1094 071e DAB2     		uxtb	r2, r3
 1095 0720 3B68     		ldr	r3, [r7, #0]
 1096 0722 1A70     		strb	r2, [r3, #0]
 861:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 1097              		.loc 1 861 0
 1098 0724 FB68     		ldr	r3, [r7, #12]
 1099 0726 03F4FE43 		and	r3, r3, #32512
 1100 072a 4FEA1323 		lsr	r3, r3, #8
 1101 072e DAB2     		uxtb	r2, r3
 1102 0730 3B68     		ldr	r3, [r7, #0]
 1103 0732 5A70     		strb	r2, [r3, #1]
 862:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 1104              		.loc 1 862 0
 1105 0734 FB68     		ldr	r3, [r7, #12]
 1106 0736 DBB2     		uxtb	r3, r3
 1107 0738 03F07F03 		and	r3, r3, #127
 1108 073c DAB2     		uxtb	r2, r3
 1109 073e 3B68     		ldr	r3, [r7, #0]
 1110 0740 9A70     		strb	r2, [r3, #2]
 863:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 1111              		.loc 1 863 0
 1112 0742 FB68     		ldr	r3, [r7, #12]
 1113 0744 03F48003 		and	r3, r3, #4194304
 1114 0748 4FEA1343 		lsr	r3, r3, #16
 1115 074c DAB2     		uxtb	r2, r3
 1116 074e 3B68     		ldr	r3, [r7, #0]
 1117 0750 DA70     		strb	r2, [r3, #3]
 864:../src/stm32f30x_rtc.c **** 
 865:../src/stm32f30x_rtc.c ****   /* Check the input parameters format */
 866:../src/stm32f30x_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 1118              		.loc 1 866 0
 1119 0752 7B68     		ldr	r3, [r7, #4]
 1120 0754 002B     		cmp	r3, #0
 1121 0756 1AD1     		bne	.L54
 867:../src/stm32f30x_rtc.c ****   {
 868:../src/stm32f30x_rtc.c ****     /* Convert the structure parameters to Binary format */
 869:../src/stm32f30x_rtc.c ****     RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 1122              		.loc 1 869 0
 1123 0758 3B68     		ldr	r3, [r7, #0]
 1124 075a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1125 075c 1846     		mov	r0, r3
 1126 075e 01F099F9 		bl	RTC_Bcd2ToByte
 1127 0762 0346     		mov	r3, r0
 1128 0764 1A46     		mov	r2, r3
 1129 0766 3B68     		ldr	r3, [r7, #0]
 1130 0768 1A70     		strb	r2, [r3, #0]
 870:../src/stm32f30x_rtc.c ****     RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
 1131              		.loc 1 870 0
 1132 076a 3B68     		ldr	r3, [r7, #0]
 1133 076c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1134 076e 1846     		mov	r0, r3
 1135 0770 01F090F9 		bl	RTC_Bcd2ToByte
 1136 0774 0346     		mov	r3, r0
 1137 0776 1A46     		mov	r2, r3
 1138 0778 3B68     		ldr	r3, [r7, #0]
 1139 077a 5A70     		strb	r2, [r3, #1]
 871:../src/stm32f30x_rtc.c ****     RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
 1140              		.loc 1 871 0
 1141 077c 3B68     		ldr	r3, [r7, #0]
 1142 077e 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1143 0780 1846     		mov	r0, r3
 1144 0782 01F087F9 		bl	RTC_Bcd2ToByte
 1145 0786 0346     		mov	r3, r0
 1146 0788 1A46     		mov	r2, r3
 1147 078a 3B68     		ldr	r3, [r7, #0]
 1148 078c 9A70     		strb	r2, [r3, #2]
 1149              	.L54:
 872:../src/stm32f30x_rtc.c ****   }
 873:../src/stm32f30x_rtc.c **** }
 1150              		.loc 1 873 0
 1151 078e 07F11007 		add	r7, r7, #16
 1152 0792 BD46     		mov	sp, r7
 1153 0794 80BD     		pop	{r7, pc}
 1154              		.cfi_endproc
 1155              	.LFE122:
 1157 0796 00BF     		.align	2
 1158              		.global	RTC_GetSubSecond
 1159              		.thumb
 1160              		.thumb_func
 1162              	RTC_GetSubSecond:
 1163              	.LFB123:
 874:../src/stm32f30x_rtc.c **** 
 875:../src/stm32f30x_rtc.c **** /**
 876:../src/stm32f30x_rtc.c ****   * @brief  Gets the RTC current Calendar Subseconds value.
 877:../src/stm32f30x_rtc.c ****   * @note   This function freeze the Time and Date registers after reading the 
 878:../src/stm32f30x_rtc.c ****   *         SSR register.
 879:../src/stm32f30x_rtc.c ****   * @param  None
 880:../src/stm32f30x_rtc.c ****   * @retval RTC current Calendar Subseconds value.
 881:../src/stm32f30x_rtc.c ****   */
 882:../src/stm32f30x_rtc.c **** uint32_t RTC_GetSubSecond(void)
 883:../src/stm32f30x_rtc.c **** {
 1164              		.loc 1 883 0
 1165              		.cfi_startproc
 1166              		@ args = 0, pretend = 0, frame = 8
 1167              		@ frame_needed = 1, uses_anonymous_args = 0
 1168              		@ link register save eliminated.
 1169 0798 80B4     		push	{r7}
 1170              	.LCFI35:
 1171              		.cfi_def_cfa_offset 4
 1172              		.cfi_offset 7, -4
 1173 079a 83B0     		sub	sp, sp, #12
 1174              	.LCFI36:
 1175              		.cfi_def_cfa_offset 16
 1176 079c 00AF     		add	r7, sp, #0
 1177              	.LCFI37:
 1178              		.cfi_def_cfa_register 7
 884:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 1179              		.loc 1 884 0
 1180 079e 4FF00003 		mov	r3, #0
 1181 07a2 7B60     		str	r3, [r7, #4]
 885:../src/stm32f30x_rtc.c ****   
 886:../src/stm32f30x_rtc.c ****   /* Get subseconds values from the correspondent registers*/
 887:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)(RTC->SSR);
 1182              		.loc 1 887 0
 1183 07a4 4FF42053 		mov	r3, #10240
 1184 07a8 C4F20003 		movt	r3, 16384
 1185 07ac 9B6A     		ldr	r3, [r3, #40]
 1186 07ae 7B60     		str	r3, [r7, #4]
 888:../src/stm32f30x_rtc.c ****   
 889:../src/stm32f30x_rtc.c ****   /* Read DR register to unfroze calendar registers */
 890:../src/stm32f30x_rtc.c ****   (void) (RTC->DR);
 1187              		.loc 1 890 0
 1188 07b0 4FF42053 		mov	r3, #10240
 1189 07b4 C4F20003 		movt	r3, 16384
 1190 07b8 5B68     		ldr	r3, [r3, #4]
 891:../src/stm32f30x_rtc.c ****   
 892:../src/stm32f30x_rtc.c ****   return (tmpreg);
 1191              		.loc 1 892 0
 1192 07ba 7B68     		ldr	r3, [r7, #4]
 893:../src/stm32f30x_rtc.c **** }
 1193              		.loc 1 893 0
 1194 07bc 1846     		mov	r0, r3
 1195 07be 07F10C07 		add	r7, r7, #12
 1196 07c2 BD46     		mov	sp, r7
 1197 07c4 80BC     		pop	{r7}
 1198 07c6 7047     		bx	lr
 1199              		.cfi_endproc
 1200              	.LFE123:
 1202              		.align	2
 1203              		.global	RTC_SetDate
 1204              		.thumb
 1205              		.thumb_func
 1207              	RTC_SetDate:
 1208              	.LFB124:
 894:../src/stm32f30x_rtc.c **** 
 895:../src/stm32f30x_rtc.c **** /**
 896:../src/stm32f30x_rtc.c ****   * @brief  Set the RTC current date.
 897:../src/stm32f30x_rtc.c ****   * @param  RTC_Format: specifies the format of the entered parameters.
 898:../src/stm32f30x_rtc.c ****   *   This parameter can be  one of the following values:
 899:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BIN:  Binary data format 
 900:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BCD:  BCD data format
 901:../src/stm32f30x_rtc.c ****   * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure that contains 
 902:../src/stm32f30x_rtc.c ****   *                         the date configuration information for the RTC.
 903:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
 904:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC Date register is configured
 905:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC Date register is not configured
 906:../src/stm32f30x_rtc.c ****   */
 907:../src/stm32f30x_rtc.c **** ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
 908:../src/stm32f30x_rtc.c **** {
 1209              		.loc 1 908 0
 1210              		.cfi_startproc
 1211              		@ args = 0, pretend = 0, frame = 16
 1212              		@ frame_needed = 1, uses_anonymous_args = 0
 1213 07c8 90B5     		push	{r4, r7, lr}
 1214              	.LCFI38:
 1215              		.cfi_def_cfa_offset 12
 1216              		.cfi_offset 4, -12
 1217              		.cfi_offset 7, -8
 1218              		.cfi_offset 14, -4
 1219 07ca 85B0     		sub	sp, sp, #20
 1220              	.LCFI39:
 1221              		.cfi_def_cfa_offset 32
 1222 07cc 00AF     		add	r7, sp, #0
 1223              	.LCFI40:
 1224              		.cfi_def_cfa_register 7
 1225 07ce 7860     		str	r0, [r7, #4]
 1226 07d0 3960     		str	r1, [r7, #0]
 909:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 1227              		.loc 1 909 0
 1228 07d2 4FF00003 		mov	r3, #0
 1229 07d6 FB60     		str	r3, [r7, #12]
 910:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 1230              		.loc 1 910 0
 1231 07d8 4FF00003 		mov	r3, #0
 1232 07dc FB72     		strb	r3, [r7, #11]
 911:../src/stm32f30x_rtc.c ****   
 912:../src/stm32f30x_rtc.c ****   /* Check the parameters */
 913:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
 914:../src/stm32f30x_rtc.c **** 
 915:../src/stm32f30x_rtc.c ****   if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
 1233              		.loc 1 915 0
 1234 07de 7B68     		ldr	r3, [r7, #4]
 1235 07e0 002B     		cmp	r3, #0
 1236 07e2 0FD1     		bne	.L59
 1237              		.loc 1 915 0 is_stmt 0 discriminator 1
 1238 07e4 3B68     		ldr	r3, [r7, #0]
 1239 07e6 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1240 07e8 03F01003 		and	r3, r3, #16
 1241 07ec 002B     		cmp	r3, #0
 1242 07ee 09D0     		beq	.L59
 916:../src/stm32f30x_rtc.c ****   {
 917:../src/stm32f30x_rtc.c ****     RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
 1243              		.loc 1 917 0 is_stmt 1
 1244 07f0 3B68     		ldr	r3, [r7, #0]
 1245 07f2 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1246 07f4 23F01003 		bic	r3, r3, #16
 1247 07f8 DBB2     		uxtb	r3, r3
 1248 07fa 03F10A03 		add	r3, r3, #10
 1249 07fe DAB2     		uxtb	r2, r3
 1250 0800 3B68     		ldr	r3, [r7, #0]
 1251 0802 5A70     		strb	r2, [r3, #1]
 1252              	.L59:
 918:../src/stm32f30x_rtc.c ****   }  
 919:../src/stm32f30x_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 1253              		.loc 1 919 0
 1254 0804 7B68     		ldr	r3, [r7, #4]
 1255 0806 002B     		cmp	r3, #0
 1256 0808 0DD0     		beq	.L60
 920:../src/stm32f30x_rtc.c ****   {
 921:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
 922:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
 923:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
 924:../src/stm32f30x_rtc.c ****   }
 925:../src/stm32f30x_rtc.c ****   else
 926:../src/stm32f30x_rtc.c ****   {
 927:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
 928:../src/stm32f30x_rtc.c ****     tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 1257              		.loc 1 928 0
 1258 080a 3B68     		ldr	r3, [r7, #0]
 1259 080c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1260 080e 1846     		mov	r0, r3
 1261 0810 01F040F9 		bl	RTC_Bcd2ToByte
 1262 0814 0346     		mov	r3, r0
 1263 0816 FB60     		str	r3, [r7, #12]
 929:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_MONTH(tmpreg));
 930:../src/stm32f30x_rtc.c ****     tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 1264              		.loc 1 930 0
 1265 0818 3B68     		ldr	r3, [r7, #0]
 1266 081a 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1267 081c 1846     		mov	r0, r3
 1268 081e 01F039F9 		bl	RTC_Bcd2ToByte
 1269 0822 0346     		mov	r3, r0
 1270 0824 FB60     		str	r3, [r7, #12]
 1271              	.L60:
 931:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_DATE(tmpreg));
 932:../src/stm32f30x_rtc.c ****   }
 933:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
 934:../src/stm32f30x_rtc.c **** 
 935:../src/stm32f30x_rtc.c ****   /* Check the input parameters format */
 936:../src/stm32f30x_rtc.c ****   if (RTC_Format != RTC_Format_BIN)
 1272              		.loc 1 936 0
 1273 0826 7B68     		ldr	r3, [r7, #4]
 1274 0828 002B     		cmp	r3, #0
 1275 082a 12D0     		beq	.L61
 937:../src/stm32f30x_rtc.c ****   {
 938:../src/stm32f30x_rtc.c ****     tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 1276              		.loc 1 938 0
 1277 082c 3B68     		ldr	r3, [r7, #0]
 1278 082e DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1279 0830 4FEA0342 		lsl	r2, r3, #16
 939:../src/stm32f30x_rtc.c ****               (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 1280              		.loc 1 939 0
 1281 0834 3B68     		ldr	r3, [r7, #0]
 1282 0836 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1283 0838 4FEA0323 		lsl	r3, r3, #8
 938:../src/stm32f30x_rtc.c ****     tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 1284              		.loc 1 938 0
 1285 083c 1A43     		orrs	r2, r2, r3
 940:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_DateStruct->RTC_Date) | \
 1286              		.loc 1 940 0
 1287 083e 3B68     		ldr	r3, [r7, #0]
 1288 0840 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 939:../src/stm32f30x_rtc.c ****               (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 1289              		.loc 1 939 0
 1290 0842 1A43     		orrs	r2, r2, r3
 941:../src/stm32f30x_rtc.c ****               (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
 1291              		.loc 1 941 0
 1292 0844 3B68     		ldr	r3, [r7, #0]
 1293 0846 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1294 0848 4FEA4333 		lsl	r3, r3, #13
 938:../src/stm32f30x_rtc.c ****     tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 1295              		.loc 1 938 0
 1296 084c 1343     		orrs	r3, r3, r2
 1297 084e FB60     		str	r3, [r7, #12]
 1298 0850 1EE0     		b	.L62
 1299              	.L61:
 942:../src/stm32f30x_rtc.c ****   }  
 943:../src/stm32f30x_rtc.c ****   else
 944:../src/stm32f30x_rtc.c ****   {
 945:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 1300              		.loc 1 945 0
 1301 0852 3B68     		ldr	r3, [r7, #0]
 1302 0854 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1303 0856 1846     		mov	r0, r3
 1304 0858 01F0FAF8 		bl	RTC_ByteToBcd2
 1305 085c 0346     		mov	r3, r0
 1306 085e 4FEA0344 		lsl	r4, r3, #16
 946:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 1307              		.loc 1 946 0
 1308 0862 3B68     		ldr	r3, [r7, #0]
 1309 0864 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1310 0866 1846     		mov	r0, r3
 1311 0868 01F0F2F8 		bl	RTC_ByteToBcd2
 1312 086c 0346     		mov	r3, r0
 1313 086e 4FEA0323 		lsl	r3, r3, #8
 945:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 1314              		.loc 1 945 0
 1315 0872 1C43     		orrs	r4, r4, r3
 947:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
 1316              		.loc 1 947 0
 1317 0874 3B68     		ldr	r3, [r7, #0]
 1318 0876 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1319 0878 1846     		mov	r0, r3
 1320 087a 01F0E9F8 		bl	RTC_ByteToBcd2
 1321 087e 0346     		mov	r3, r0
 946:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 1322              		.loc 1 946 0
 1323 0880 44EA0302 		orr	r2, r4, r3
 948:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
 1324              		.loc 1 948 0
 1325 0884 3B68     		ldr	r3, [r7, #0]
 1326 0886 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1327 0888 4FEA4333 		lsl	r3, r3, #13
 945:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 1328              		.loc 1 945 0
 1329 088c 1343     		orrs	r3, r3, r2
 1330 088e FB60     		str	r3, [r7, #12]
 1331              	.L62:
 949:../src/stm32f30x_rtc.c ****   }
 950:../src/stm32f30x_rtc.c **** 
 951:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
 952:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 1332              		.loc 1 952 0
 1333 0890 4FF42053 		mov	r3, #10240
 1334 0894 C4F20003 		movt	r3, 16384
 1335 0898 4FF0CA02 		mov	r2, #202
 1336 089c 5A62     		str	r2, [r3, #36]
 953:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 1337              		.loc 1 953 0
 1338 089e 4FF42053 		mov	r3, #10240
 1339 08a2 C4F20003 		movt	r3, 16384
 1340 08a6 4FF05302 		mov	r2, #83
 1341 08aa 5A62     		str	r2, [r3, #36]
 954:../src/stm32f30x_rtc.c **** 
 955:../src/stm32f30x_rtc.c ****   /* Set Initialization mode */
 956:../src/stm32f30x_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
 1342              		.loc 1 956 0
 1343 08ac FFF7FEFF 		bl	RTC_EnterInitMode
 1344 08b0 0346     		mov	r3, r0
 1345 08b2 002B     		cmp	r3, #0
 1346 08b4 03D1     		bne	.L63
 957:../src/stm32f30x_rtc.c ****   {
 958:../src/stm32f30x_rtc.c ****     status = ERROR;
 1347              		.loc 1 958 0
 1348 08b6 4FF00003 		mov	r3, #0
 1349 08ba FB72     		strb	r3, [r7, #11]
 1350 08bc 24E0     		b	.L64
 1351              	.L63:
 959:../src/stm32f30x_rtc.c ****   } 
 960:../src/stm32f30x_rtc.c ****   else
 961:../src/stm32f30x_rtc.c ****   {
 962:../src/stm32f30x_rtc.c ****     /* Set the RTC_DR register */
 963:../src/stm32f30x_rtc.c ****     RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
 1352              		.loc 1 963 0
 1353 08be 4FF42053 		mov	r3, #10240
 1354 08c2 C4F20003 		movt	r3, 16384
 1355 08c6 FA68     		ldr	r2, [r7, #12]
 1356 08c8 22F07F42 		bic	r2, r2, #-16777216
 1357 08cc 22F0C002 		bic	r2, r2, #192
 1358 08d0 5A60     		str	r2, [r3, #4]
 964:../src/stm32f30x_rtc.c **** 
 965:../src/stm32f30x_rtc.c ****     /* Exit Initialization mode */
 966:../src/stm32f30x_rtc.c ****     RTC_ExitInitMode(); 
 1359              		.loc 1 966 0
 1360 08d2 FFF7FEFF 		bl	RTC_ExitInitMode
 967:../src/stm32f30x_rtc.c **** 
 968:../src/stm32f30x_rtc.c ****     /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
 969:../src/stm32f30x_rtc.c ****     if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 1361              		.loc 1 969 0
 1362 08d6 4FF42053 		mov	r3, #10240
 1363 08da C4F20003 		movt	r3, 16384
 1364 08de 9B68     		ldr	r3, [r3, #8]
 1365 08e0 03F02003 		and	r3, r3, #32
 1366 08e4 002B     		cmp	r3, #0
 1367 08e6 0CD1     		bne	.L65
 970:../src/stm32f30x_rtc.c ****     {
 971:../src/stm32f30x_rtc.c ****       if (RTC_WaitForSynchro() == ERROR)
 1368              		.loc 1 971 0
 1369 08e8 FFF7FEFF 		bl	RTC_WaitForSynchro
 1370 08ec 0346     		mov	r3, r0
 1371 08ee 002B     		cmp	r3, #0
 1372 08f0 03D1     		bne	.L66
 972:../src/stm32f30x_rtc.c ****       {
 973:../src/stm32f30x_rtc.c ****         status = ERROR;
 1373              		.loc 1 973 0
 1374 08f2 4FF00003 		mov	r3, #0
 1375 08f6 FB72     		strb	r3, [r7, #11]
 1376 08f8 06E0     		b	.L64
 1377              	.L66:
 974:../src/stm32f30x_rtc.c ****       }
 975:../src/stm32f30x_rtc.c ****       else
 976:../src/stm32f30x_rtc.c ****       {
 977:../src/stm32f30x_rtc.c ****         status = SUCCESS;
 1378              		.loc 1 977 0
 1379 08fa 4FF00103 		mov	r3, #1
 1380 08fe FB72     		strb	r3, [r7, #11]
 1381 0900 02E0     		b	.L64
 1382              	.L65:
 978:../src/stm32f30x_rtc.c ****       }
 979:../src/stm32f30x_rtc.c ****     }
 980:../src/stm32f30x_rtc.c ****     else
 981:../src/stm32f30x_rtc.c ****     {
 982:../src/stm32f30x_rtc.c ****       status = SUCCESS;
 1383              		.loc 1 982 0
 1384 0902 4FF00103 		mov	r3, #1
 1385 0906 FB72     		strb	r3, [r7, #11]
 1386              	.L64:
 983:../src/stm32f30x_rtc.c ****     }
 984:../src/stm32f30x_rtc.c ****   }
 985:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
 986:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 1387              		.loc 1 986 0
 1388 0908 4FF42053 		mov	r3, #10240
 1389 090c C4F20003 		movt	r3, 16384
 1390 0910 4FF0FF02 		mov	r2, #255
 1391 0914 5A62     		str	r2, [r3, #36]
 987:../src/stm32f30x_rtc.c ****   
 988:../src/stm32f30x_rtc.c ****   return status;
 1392              		.loc 1 988 0
 1393 0916 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 989:../src/stm32f30x_rtc.c **** }
 1394              		.loc 1 989 0
 1395 0918 1846     		mov	r0, r3
 1396 091a 07F11407 		add	r7, r7, #20
 1397 091e BD46     		mov	sp, r7
 1398 0920 90BD     		pop	{r4, r7, pc}
 1399              		.cfi_endproc
 1400              	.LFE124:
 1402 0922 00BF     		.align	2
 1403              		.global	RTC_DateStructInit
 1404              		.thumb
 1405              		.thumb_func
 1407              	RTC_DateStructInit:
 1408              	.LFB125:
 990:../src/stm32f30x_rtc.c **** 
 991:../src/stm32f30x_rtc.c **** /**
 992:../src/stm32f30x_rtc.c ****   * @brief  Fills each RTC_DateStruct member with its default value
 993:../src/stm32f30x_rtc.c ****   *         (Monday, January 01 xx00).
 994:../src/stm32f30x_rtc.c ****   * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
 995:../src/stm32f30x_rtc.c ****   *         initialized.
 996:../src/stm32f30x_rtc.c ****   * @retval None
 997:../src/stm32f30x_rtc.c ****   */
 998:../src/stm32f30x_rtc.c **** void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
 999:../src/stm32f30x_rtc.c **** {
 1409              		.loc 1 999 0
 1410              		.cfi_startproc
 1411              		@ args = 0, pretend = 0, frame = 8
 1412              		@ frame_needed = 1, uses_anonymous_args = 0
 1413              		@ link register save eliminated.
 1414 0924 80B4     		push	{r7}
 1415              	.LCFI41:
 1416              		.cfi_def_cfa_offset 4
 1417              		.cfi_offset 7, -4
 1418 0926 83B0     		sub	sp, sp, #12
 1419              	.LCFI42:
 1420              		.cfi_def_cfa_offset 16
 1421 0928 00AF     		add	r7, sp, #0
 1422              	.LCFI43:
 1423              		.cfi_def_cfa_register 7
 1424 092a 7860     		str	r0, [r7, #4]
1000:../src/stm32f30x_rtc.c ****   /* Monday, January 01 xx00 */
1001:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
 1425              		.loc 1 1001 0
 1426 092c 7B68     		ldr	r3, [r7, #4]
 1427 092e 4FF00102 		mov	r2, #1
 1428 0932 1A70     		strb	r2, [r3, #0]
1002:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_Date = 1;
 1429              		.loc 1 1002 0
 1430 0934 7B68     		ldr	r3, [r7, #4]
 1431 0936 4FF00102 		mov	r2, #1
 1432 093a 9A70     		strb	r2, [r3, #2]
1003:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_Month = RTC_Month_January;
 1433              		.loc 1 1003 0
 1434 093c 7B68     		ldr	r3, [r7, #4]
 1435 093e 4FF00102 		mov	r2, #1
 1436 0942 5A70     		strb	r2, [r3, #1]
1004:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_Year = 0;
 1437              		.loc 1 1004 0
 1438 0944 7B68     		ldr	r3, [r7, #4]
 1439 0946 4FF00002 		mov	r2, #0
 1440 094a DA70     		strb	r2, [r3, #3]
1005:../src/stm32f30x_rtc.c **** }
 1441              		.loc 1 1005 0
 1442 094c 07F10C07 		add	r7, r7, #12
 1443 0950 BD46     		mov	sp, r7
 1444 0952 80BC     		pop	{r7}
 1445 0954 7047     		bx	lr
 1446              		.cfi_endproc
 1447              	.LFE125:
 1449 0956 00BF     		.align	2
 1450              		.global	RTC_GetDate
 1451              		.thumb
 1452              		.thumb_func
 1454              	RTC_GetDate:
 1455              	.LFB126:
1006:../src/stm32f30x_rtc.c **** 
1007:../src/stm32f30x_rtc.c **** /**
1008:../src/stm32f30x_rtc.c ****   * @brief  Get the RTC current date.
1009:../src/stm32f30x_rtc.c ****   * @param  RTC_Format: specifies the format of the returned parameters.
1010:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1011:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BIN: Binary data format 
1012:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BCD: BCD data format
1013:../src/stm32f30x_rtc.c ****   * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
1014:../src/stm32f30x_rtc.c ****   *                        contain the returned current date configuration.
1015:../src/stm32f30x_rtc.c ****   * @retval None
1016:../src/stm32f30x_rtc.c ****   */
1017:../src/stm32f30x_rtc.c **** void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
1018:../src/stm32f30x_rtc.c **** {
 1456              		.loc 1 1018 0
 1457              		.cfi_startproc
 1458              		@ args = 0, pretend = 0, frame = 16
 1459              		@ frame_needed = 1, uses_anonymous_args = 0
 1460 0958 80B5     		push	{r7, lr}
 1461              	.LCFI44:
 1462              		.cfi_def_cfa_offset 8
 1463              		.cfi_offset 7, -8
 1464              		.cfi_offset 14, -4
 1465 095a 84B0     		sub	sp, sp, #16
 1466              	.LCFI45:
 1467              		.cfi_def_cfa_offset 24
 1468 095c 00AF     		add	r7, sp, #0
 1469              	.LCFI46:
 1470              		.cfi_def_cfa_register 7
 1471 095e 7860     		str	r0, [r7, #4]
 1472 0960 3960     		str	r1, [r7, #0]
1019:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 1473              		.loc 1 1019 0
 1474 0962 4FF00003 		mov	r3, #0
 1475 0966 FB60     		str	r3, [r7, #12]
1020:../src/stm32f30x_rtc.c **** 
1021:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1022:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
1023:../src/stm32f30x_rtc.c ****   
1024:../src/stm32f30x_rtc.c ****   /* Get the RTC_TR register */
1025:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
 1476              		.loc 1 1025 0
 1477 0968 4FF42053 		mov	r3, #10240
 1478 096c C4F20003 		movt	r3, 16384
 1479 0970 5B68     		ldr	r3, [r3, #4]
 1480 0972 23F07F43 		bic	r3, r3, #-16777216
 1481 0976 23F0C003 		bic	r3, r3, #192
 1482 097a FB60     		str	r3, [r7, #12]
1026:../src/stm32f30x_rtc.c **** 
1027:../src/stm32f30x_rtc.c ****   /* Fill the structure fields with the read parameters */
1028:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 1483              		.loc 1 1028 0
 1484 097c FB68     		ldr	r3, [r7, #12]
 1485 097e 03F47F03 		and	r3, r3, #16711680
 1486 0982 4FEA1343 		lsr	r3, r3, #16
 1487 0986 DAB2     		uxtb	r2, r3
 1488 0988 3B68     		ldr	r3, [r7, #0]
 1489 098a DA70     		strb	r2, [r3, #3]
1029:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 1490              		.loc 1 1029 0
 1491 098c FB68     		ldr	r3, [r7, #12]
 1492 098e 03F4F853 		and	r3, r3, #7936
 1493 0992 4FEA1323 		lsr	r3, r3, #8
 1494 0996 DAB2     		uxtb	r2, r3
 1495 0998 3B68     		ldr	r3, [r7, #0]
 1496 099a 5A70     		strb	r2, [r3, #1]
1030:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
 1497              		.loc 1 1030 0
 1498 099c FB68     		ldr	r3, [r7, #12]
 1499 099e DBB2     		uxtb	r3, r3
 1500 09a0 03F03F03 		and	r3, r3, #63
 1501 09a4 DAB2     		uxtb	r2, r3
 1502 09a6 3B68     		ldr	r3, [r7, #0]
 1503 09a8 9A70     		strb	r2, [r3, #2]
1031:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
 1504              		.loc 1 1031 0
 1505 09aa FB68     		ldr	r3, [r7, #12]
 1506 09ac 03F46043 		and	r3, r3, #57344
 1507 09b0 4FEA5333 		lsr	r3, r3, #13
 1508 09b4 DAB2     		uxtb	r2, r3
 1509 09b6 3B68     		ldr	r3, [r7, #0]
 1510 09b8 1A70     		strb	r2, [r3, #0]
1032:../src/stm32f30x_rtc.c **** 
1033:../src/stm32f30x_rtc.c ****   /* Check the input parameters format */
1034:../src/stm32f30x_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 1511              		.loc 1 1034 0
 1512 09ba 7B68     		ldr	r3, [r7, #4]
 1513 09bc 002B     		cmp	r3, #0
 1514 09be 1ED1     		bne	.L69
1035:../src/stm32f30x_rtc.c ****   {
1036:../src/stm32f30x_rtc.c ****     /* Convert the structure parameters to Binary format */
1037:../src/stm32f30x_rtc.c ****     RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
 1515              		.loc 1 1037 0
 1516 09c0 3B68     		ldr	r3, [r7, #0]
 1517 09c2 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1518 09c4 1846     		mov	r0, r3
 1519 09c6 01F065F8 		bl	RTC_Bcd2ToByte
 1520 09ca 0346     		mov	r3, r0
 1521 09cc 1A46     		mov	r2, r3
 1522 09ce 3B68     		ldr	r3, [r7, #0]
 1523 09d0 DA70     		strb	r2, [r3, #3]
1038:../src/stm32f30x_rtc.c ****     RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 1524              		.loc 1 1038 0
 1525 09d2 3B68     		ldr	r3, [r7, #0]
 1526 09d4 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1527 09d6 1846     		mov	r0, r3
 1528 09d8 01F05CF8 		bl	RTC_Bcd2ToByte
 1529 09dc 0346     		mov	r3, r0
 1530 09de 1A46     		mov	r2, r3
 1531 09e0 3B68     		ldr	r3, [r7, #0]
 1532 09e2 5A70     		strb	r2, [r3, #1]
1039:../src/stm32f30x_rtc.c ****     RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 1533              		.loc 1 1039 0
 1534 09e4 3B68     		ldr	r3, [r7, #0]
 1535 09e6 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1536 09e8 1846     		mov	r0, r3
 1537 09ea 01F053F8 		bl	RTC_Bcd2ToByte
 1538 09ee 0346     		mov	r3, r0
 1539 09f0 1A46     		mov	r2, r3
 1540 09f2 3B68     		ldr	r3, [r7, #0]
 1541 09f4 9A70     		strb	r2, [r3, #2]
1040:../src/stm32f30x_rtc.c ****     RTC_DateStruct->RTC_WeekDay = (uint8_t)(RTC_DateStruct->RTC_WeekDay);   
 1542              		.loc 1 1040 0
 1543 09f6 3B68     		ldr	r3, [r7, #0]
 1544 09f8 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 1545 09fa 3B68     		ldr	r3, [r7, #0]
 1546 09fc 1A70     		strb	r2, [r3, #0]
 1547              	.L69:
1041:../src/stm32f30x_rtc.c ****   }
1042:../src/stm32f30x_rtc.c **** }
 1548              		.loc 1 1042 0
 1549 09fe 07F11007 		add	r7, r7, #16
 1550 0a02 BD46     		mov	sp, r7
 1551 0a04 80BD     		pop	{r7, pc}
 1552              		.cfi_endproc
 1553              	.LFE126:
 1555 0a06 00BF     		.align	2
 1556              		.global	RTC_SetAlarm
 1557              		.thumb
 1558              		.thumb_func
 1560              	RTC_SetAlarm:
 1561              	.LFB127:
1043:../src/stm32f30x_rtc.c **** 
1044:../src/stm32f30x_rtc.c **** /**
1045:../src/stm32f30x_rtc.c ****   * @}
1046:../src/stm32f30x_rtc.c ****   */
1047:../src/stm32f30x_rtc.c **** 
1048:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group3 Alarms configuration functions
1049:../src/stm32f30x_rtc.c ****  *  @brief   Alarms (Alarm A and Alarm B) configuration functions 
1050:../src/stm32f30x_rtc.c ****  *
1051:../src/stm32f30x_rtc.c **** @verbatim   
1052:../src/stm32f30x_rtc.c ****  ===============================================================================
1053:../src/stm32f30x_rtc.c ****         ##### Alarms (Alarm A and Alarm B) configuration functions #####
1054:../src/stm32f30x_rtc.c ****  ===============================================================================  
1055:../src/stm32f30x_rtc.c ****     [..] This section provides functions allowing to program and read the RTC Alarms.
1056:../src/stm32f30x_rtc.c **** 
1057:../src/stm32f30x_rtc.c **** @endverbatim
1058:../src/stm32f30x_rtc.c ****   * @{
1059:../src/stm32f30x_rtc.c ****   */
1060:../src/stm32f30x_rtc.c **** 
1061:../src/stm32f30x_rtc.c **** /**
1062:../src/stm32f30x_rtc.c ****   * @brief  Set the specified RTC Alarm.
1063:../src/stm32f30x_rtc.c ****   * @note   The Alarm register can only be written when the corresponding Alarm
1064:../src/stm32f30x_rtc.c ****   *         is disabled (Use the RTC_AlarmCmd(DISABLE)).    
1065:../src/stm32f30x_rtc.c ****   * @param  RTC_Format: specifies the format of the returned parameters.
1066:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1067:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BIN: Binary data format 
1068:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BCD: BCD data format
1069:../src/stm32f30x_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be configured.
1070:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1071:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_A: to select Alarm A
1072:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_B: to select Alarm B  
1073:../src/stm32f30x_rtc.c ****   * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
1074:../src/stm32f30x_rtc.c ****   *                          contains the alarm configuration parameters.     
1075:../src/stm32f30x_rtc.c ****   * @retval None
1076:../src/stm32f30x_rtc.c ****   */
1077:../src/stm32f30x_rtc.c **** void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
1078:../src/stm32f30x_rtc.c **** {
 1562              		.loc 1 1078 0
 1563              		.cfi_startproc
 1564              		@ args = 0, pretend = 0, frame = 24
 1565              		@ frame_needed = 1, uses_anonymous_args = 0
 1566 0a08 90B5     		push	{r4, r7, lr}
 1567              	.LCFI47:
 1568              		.cfi_def_cfa_offset 12
 1569              		.cfi_offset 4, -12
 1570              		.cfi_offset 7, -8
 1571              		.cfi_offset 14, -4
 1572 0a0a 87B0     		sub	sp, sp, #28
 1573              	.LCFI48:
 1574              		.cfi_def_cfa_offset 40
 1575 0a0c 00AF     		add	r7, sp, #0
 1576              	.LCFI49:
 1577              		.cfi_def_cfa_register 7
 1578 0a0e F860     		str	r0, [r7, #12]
 1579 0a10 B960     		str	r1, [r7, #8]
 1580 0a12 7A60     		str	r2, [r7, #4]
1079:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 1581              		.loc 1 1079 0
 1582 0a14 4FF00003 		mov	r3, #0
 1583 0a18 7B61     		str	r3, [r7, #20]
1080:../src/stm32f30x_rtc.c ****   
1081:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1082:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
1083:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_ALARM(RTC_Alarm));
1084:../src/stm32f30x_rtc.c ****   assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
1085:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
1086:../src/stm32f30x_rtc.c **** 
1087:../src/stm32f30x_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 1584              		.loc 1 1087 0
 1585 0a1a FB68     		ldr	r3, [r7, #12]
 1586 0a1c 002B     		cmp	r3, #0
 1587 0a1e 0DD1     		bne	.L72
1088:../src/stm32f30x_rtc.c ****   {
1089:../src/stm32f30x_rtc.c ****     if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 1588              		.loc 1 1089 0
 1589 0a20 4FF42053 		mov	r3, #10240
 1590 0a24 C4F20003 		movt	r3, 16384
 1591 0a28 9B68     		ldr	r3, [r3, #8]
 1592 0a2a 03F04003 		and	r3, r3, #64
 1593 0a2e 002B     		cmp	r3, #0
 1594 0a30 2CD1     		bne	.L74
1090:../src/stm32f30x_rtc.c ****     {
1091:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
1092:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
1093:../src/stm32f30x_rtc.c ****     } 
1094:../src/stm32f30x_rtc.c ****     else
1095:../src/stm32f30x_rtc.c ****     {
1096:../src/stm32f30x_rtc.c ****       RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 1595              		.loc 1 1096 0
 1596 0a32 7B68     		ldr	r3, [r7, #4]
 1597 0a34 4FF00002 		mov	r2, #0
 1598 0a38 DA70     		strb	r2, [r3, #3]
 1599 0a3a 27E0     		b	.L74
 1600              	.L72:
1097:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
1098:../src/stm32f30x_rtc.c ****     }
1099:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
1100:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
1101:../src/stm32f30x_rtc.c ****     
1102:../src/stm32f30x_rtc.c ****     if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
1103:../src/stm32f30x_rtc.c ****     {
1104:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
1105:../src/stm32f30x_rtc.c ****     }
1106:../src/stm32f30x_rtc.c ****     else
1107:../src/stm32f30x_rtc.c ****     {
1108:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
1109:../src/stm32f30x_rtc.c ****     }
1110:../src/stm32f30x_rtc.c ****   }
1111:../src/stm32f30x_rtc.c ****   else
1112:../src/stm32f30x_rtc.c ****   {
1113:../src/stm32f30x_rtc.c ****     if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 1601              		.loc 1 1113 0
 1602 0a3c 4FF42053 		mov	r3, #10240
 1603 0a40 C4F20003 		movt	r3, 16384
 1604 0a44 9B68     		ldr	r3, [r3, #8]
 1605 0a46 03F04003 		and	r3, r3, #64
 1606 0a4a 002B     		cmp	r3, #0
 1607 0a4c 07D0     		beq	.L75
1114:../src/stm32f30x_rtc.c ****     {
1115:../src/stm32f30x_rtc.c ****       tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
 1608              		.loc 1 1115 0
 1609 0a4e 7B68     		ldr	r3, [r7, #4]
 1610 0a50 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1611 0a52 1846     		mov	r0, r3
 1612 0a54 01F01EF8 		bl	RTC_Bcd2ToByte
 1613 0a58 0346     		mov	r3, r0
 1614 0a5a 7B61     		str	r3, [r7, #20]
 1615 0a5c 03E0     		b	.L76
 1616              	.L75:
1116:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR12(tmpreg));
1117:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
1118:../src/stm32f30x_rtc.c ****     } 
1119:../src/stm32f30x_rtc.c ****     else
1120:../src/stm32f30x_rtc.c ****     {
1121:../src/stm32f30x_rtc.c ****       RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 1617              		.loc 1 1121 0
 1618 0a5e 7B68     		ldr	r3, [r7, #4]
 1619 0a60 4FF00002 		mov	r2, #0
 1620 0a64 DA70     		strb	r2, [r3, #3]
 1621              	.L76:
1122:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
1123:../src/stm32f30x_rtc.c ****     }
1124:../src/stm32f30x_rtc.c ****     
1125:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
1126:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
1127:../src/stm32f30x_rtc.c ****     
1128:../src/stm32f30x_rtc.c ****     if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
 1622              		.loc 1 1128 0
 1623 0a66 7B68     		ldr	r3, [r7, #4]
 1624 0a68 9B68     		ldr	r3, [r3, #8]
 1625 0a6a 002B     		cmp	r3, #0
 1626 0a6c 07D1     		bne	.L77
1129:../src/stm32f30x_rtc.c ****     {
1130:../src/stm32f30x_rtc.c ****       tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 1627              		.loc 1 1130 0
 1628 0a6e 7B68     		ldr	r3, [r7, #4]
 1629 0a70 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1630 0a72 1846     		mov	r0, r3
 1631 0a74 01F00EF8 		bl	RTC_Bcd2ToByte
 1632 0a78 0346     		mov	r3, r0
 1633 0a7a 7B61     		str	r3, [r7, #20]
 1634 0a7c 06E0     		b	.L74
 1635              	.L77:
1131:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
1132:../src/stm32f30x_rtc.c ****     }
1133:../src/stm32f30x_rtc.c ****     else
1134:../src/stm32f30x_rtc.c ****     {
1135:../src/stm32f30x_rtc.c ****       tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 1636              		.loc 1 1135 0
 1637 0a7e 7B68     		ldr	r3, [r7, #4]
 1638 0a80 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1639 0a82 1846     		mov	r0, r3
 1640 0a84 01F006F8 		bl	RTC_Bcd2ToByte
 1641 0a88 0346     		mov	r3, r0
 1642 0a8a 7B61     		str	r3, [r7, #20]
 1643              	.L74:
1136:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
1137:../src/stm32f30x_rtc.c ****     }    
1138:../src/stm32f30x_rtc.c ****   }
1139:../src/stm32f30x_rtc.c **** 
1140:../src/stm32f30x_rtc.c ****   /* Check the input parameters format */
1141:../src/stm32f30x_rtc.c ****   if (RTC_Format != RTC_Format_BIN)
 1644              		.loc 1 1141 0
 1645 0a8c FB68     		ldr	r3, [r7, #12]
 1646 0a8e 002B     		cmp	r3, #0
 1647 0a90 1DD0     		beq	.L78
1142:../src/stm32f30x_rtc.c ****   {
1143:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 1648              		.loc 1 1143 0
 1649 0a92 7B68     		ldr	r3, [r7, #4]
 1650 0a94 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1651 0a96 4FEA0342 		lsl	r2, r3, #16
1144:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 1652              		.loc 1 1144 0
 1653 0a9a 7B68     		ldr	r3, [r7, #4]
 1654 0a9c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1655 0a9e 4FEA0323 		lsl	r3, r3, #8
1143:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 1656              		.loc 1 1143 0
 1657 0aa2 1A43     		orrs	r2, r2, r3
1145:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 1658              		.loc 1 1145 0
 1659 0aa4 7B68     		ldr	r3, [r7, #4]
 1660 0aa6 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
1144:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 1661              		.loc 1 1144 0
 1662 0aa8 1A43     		orrs	r2, r2, r3
1146:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 1663              		.loc 1 1146 0
 1664 0aaa 7B68     		ldr	r3, [r7, #4]
 1665 0aac DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1666 0aae 4FEA0343 		lsl	r3, r3, #16
1145:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 1667              		.loc 1 1145 0
 1668 0ab2 1A43     		orrs	r2, r2, r3
1147:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 1669              		.loc 1 1147 0
 1670 0ab4 7B68     		ldr	r3, [r7, #4]
 1671 0ab6 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1672 0ab8 4FEA0363 		lsl	r3, r3, #24
1146:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 1673              		.loc 1 1146 0
 1674 0abc 1A43     		orrs	r2, r2, r3
1148:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 1675              		.loc 1 1148 0
 1676 0abe 7B68     		ldr	r3, [r7, #4]
 1677 0ac0 9B68     		ldr	r3, [r3, #8]
1147:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 1678              		.loc 1 1147 0
 1679 0ac2 1A43     		orrs	r2, r2, r3
1149:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 1680              		.loc 1 1149 0
 1681 0ac4 7B68     		ldr	r3, [r7, #4]
 1682 0ac6 5B68     		ldr	r3, [r3, #4]
1143:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 1683              		.loc 1 1143 0
 1684 0ac8 1343     		orrs	r3, r3, r2
 1685 0aca 7B61     		str	r3, [r7, #20]
 1686 0acc 2FE0     		b	.L79
 1687              	.L78:
1150:../src/stm32f30x_rtc.c ****   }  
1151:../src/stm32f30x_rtc.c ****   else
1152:../src/stm32f30x_rtc.c ****   {
1153:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 1688              		.loc 1 1153 0
 1689 0ace 7B68     		ldr	r3, [r7, #4]
 1690 0ad0 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1691 0ad2 1846     		mov	r0, r3
 1692 0ad4 00F0BCFF 		bl	RTC_ByteToBcd2
 1693 0ad8 0346     		mov	r3, r0
 1694 0ada 4FEA0344 		lsl	r4, r3, #16
1154:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 1695              		.loc 1 1154 0
 1696 0ade 7B68     		ldr	r3, [r7, #4]
 1697 0ae0 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1698 0ae2 1846     		mov	r0, r3
 1699 0ae4 00F0B4FF 		bl	RTC_ByteToBcd2
 1700 0ae8 0346     		mov	r3, r0
 1701 0aea 4FEA0323 		lsl	r3, r3, #8
1153:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 1702              		.loc 1 1153 0
 1703 0aee 1C43     		orrs	r4, r4, r3
1155:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 1704              		.loc 1 1155 0
 1705 0af0 7B68     		ldr	r3, [r7, #4]
 1706 0af2 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1707 0af4 1846     		mov	r0, r3
 1708 0af6 00F0ABFF 		bl	RTC_ByteToBcd2
 1709 0afa 0346     		mov	r3, r0
1154:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 1710              		.loc 1 1154 0
 1711 0afc 44EA0302 		orr	r2, r4, r3
1156:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 1712              		.loc 1 1156 0
 1713 0b00 7B68     		ldr	r3, [r7, #4]
 1714 0b02 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1715 0b04 4FEA0343 		lsl	r3, r3, #16
1155:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 1716              		.loc 1 1155 0
 1717 0b08 42EA0304 		orr	r4, r2, r3
1157:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 1718              		.loc 1 1157 0
 1719 0b0c 7B68     		ldr	r3, [r7, #4]
 1720 0b0e 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1721 0b10 1846     		mov	r0, r3
 1722 0b12 00F09DFF 		bl	RTC_ByteToBcd2
 1723 0b16 0346     		mov	r3, r0
 1724 0b18 4FEA0363 		lsl	r3, r3, #24
1156:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 1725              		.loc 1 1156 0
 1726 0b1c 44EA0302 		orr	r2, r4, r3
1158:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 1727              		.loc 1 1158 0
 1728 0b20 7B68     		ldr	r3, [r7, #4]
 1729 0b22 9B68     		ldr	r3, [r3, #8]
1157:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 1730              		.loc 1 1157 0
 1731 0b24 1A43     		orrs	r2, r2, r3
1159:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 1732              		.loc 1 1159 0
 1733 0b26 7B68     		ldr	r3, [r7, #4]
 1734 0b28 5B68     		ldr	r3, [r3, #4]
1153:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 1735              		.loc 1 1153 0
 1736 0b2a 1343     		orrs	r3, r3, r2
 1737 0b2c 7B61     		str	r3, [r7, #20]
 1738              	.L79:
1160:../src/stm32f30x_rtc.c ****   } 
1161:../src/stm32f30x_rtc.c **** 
1162:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1163:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 1739              		.loc 1 1163 0
 1740 0b2e 4FF42053 		mov	r3, #10240
 1741 0b32 C4F20003 		movt	r3, 16384
 1742 0b36 4FF0CA02 		mov	r2, #202
 1743 0b3a 5A62     		str	r2, [r3, #36]
1164:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 1744              		.loc 1 1164 0
 1745 0b3c 4FF42053 		mov	r3, #10240
 1746 0b40 C4F20003 		movt	r3, 16384
 1747 0b44 4FF05302 		mov	r2, #83
 1748 0b48 5A62     		str	r2, [r3, #36]
1165:../src/stm32f30x_rtc.c **** 
1166:../src/stm32f30x_rtc.c ****   /* Configure the Alarm register */
1167:../src/stm32f30x_rtc.c ****   if (RTC_Alarm == RTC_Alarm_A)
 1749              		.loc 1 1167 0
 1750 0b4a BB68     		ldr	r3, [r7, #8]
 1751 0b4c B3F5807F 		cmp	r3, #256
 1752 0b50 06D1     		bne	.L80
1168:../src/stm32f30x_rtc.c ****   {
1169:../src/stm32f30x_rtc.c ****     RTC->ALRMAR = (uint32_t)tmpreg;
 1753              		.loc 1 1169 0
 1754 0b52 4FF42053 		mov	r3, #10240
 1755 0b56 C4F20003 		movt	r3, 16384
 1756 0b5a 7A69     		ldr	r2, [r7, #20]
 1757 0b5c DA61     		str	r2, [r3, #28]
 1758 0b5e 05E0     		b	.L81
 1759              	.L80:
1170:../src/stm32f30x_rtc.c ****   }
1171:../src/stm32f30x_rtc.c ****   else
1172:../src/stm32f30x_rtc.c ****   {
1173:../src/stm32f30x_rtc.c ****     RTC->ALRMBR = (uint32_t)tmpreg;
 1760              		.loc 1 1173 0
 1761 0b60 4FF42053 		mov	r3, #10240
 1762 0b64 C4F20003 		movt	r3, 16384
 1763 0b68 7A69     		ldr	r2, [r7, #20]
 1764 0b6a 1A62     		str	r2, [r3, #32]
 1765              	.L81:
1174:../src/stm32f30x_rtc.c ****   }
1175:../src/stm32f30x_rtc.c **** 
1176:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1177:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;   
 1766              		.loc 1 1177 0
 1767 0b6c 4FF42053 		mov	r3, #10240
 1768 0b70 C4F20003 		movt	r3, 16384
 1769 0b74 4FF0FF02 		mov	r2, #255
 1770 0b78 5A62     		str	r2, [r3, #36]
1178:../src/stm32f30x_rtc.c **** }
 1771              		.loc 1 1178 0
 1772 0b7a 07F11C07 		add	r7, r7, #28
 1773 0b7e BD46     		mov	sp, r7
 1774 0b80 90BD     		pop	{r4, r7, pc}
 1775              		.cfi_endproc
 1776              	.LFE127:
 1778 0b82 00BF     		.align	2
 1779              		.global	RTC_AlarmStructInit
 1780              		.thumb
 1781              		.thumb_func
 1783              	RTC_AlarmStructInit:
 1784              	.LFB128:
1179:../src/stm32f30x_rtc.c **** 
1180:../src/stm32f30x_rtc.c **** /**
1181:../src/stm32f30x_rtc.c ****   * @brief  Fills each RTC_AlarmStruct member with its default value
1182:../src/stm32f30x_rtc.c ****   *         (Time = 00h:00mn:00sec / Date = 1st day of the month/Mask =
1183:../src/stm32f30x_rtc.c ****   *         all fields are masked).
1184:../src/stm32f30x_rtc.c ****   * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
1185:../src/stm32f30x_rtc.c ****   *         will be initialized.
1186:../src/stm32f30x_rtc.c ****   * @retval None
1187:../src/stm32f30x_rtc.c ****   */
1188:../src/stm32f30x_rtc.c **** void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
1189:../src/stm32f30x_rtc.c **** {
 1785              		.loc 1 1189 0
 1786              		.cfi_startproc
 1787              		@ args = 0, pretend = 0, frame = 8
 1788              		@ frame_needed = 1, uses_anonymous_args = 0
 1789              		@ link register save eliminated.
 1790 0b84 80B4     		push	{r7}
 1791              	.LCFI50:
 1792              		.cfi_def_cfa_offset 4
 1793              		.cfi_offset 7, -4
 1794 0b86 83B0     		sub	sp, sp, #12
 1795              	.LCFI51:
 1796              		.cfi_def_cfa_offset 16
 1797 0b88 00AF     		add	r7, sp, #0
 1798              	.LCFI52:
 1799              		.cfi_def_cfa_register 7
 1800 0b8a 7860     		str	r0, [r7, #4]
1190:../src/stm32f30x_rtc.c ****   /* Alarm Time Settings : Time = 00h:00mn:00sec */
1191:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
 1801              		.loc 1 1191 0
 1802 0b8c 7B68     		ldr	r3, [r7, #4]
 1803 0b8e 4FF00002 		mov	r2, #0
 1804 0b92 DA70     		strb	r2, [r3, #3]
1192:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
 1805              		.loc 1 1192 0
 1806 0b94 7B68     		ldr	r3, [r7, #4]
 1807 0b96 4FF00002 		mov	r2, #0
 1808 0b9a 1A70     		strb	r2, [r3, #0]
1193:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
 1809              		.loc 1 1193 0
 1810 0b9c 7B68     		ldr	r3, [r7, #4]
 1811 0b9e 4FF00002 		mov	r2, #0
 1812 0ba2 5A70     		strb	r2, [r3, #1]
1194:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
 1813              		.loc 1 1194 0
 1814 0ba4 7B68     		ldr	r3, [r7, #4]
 1815 0ba6 4FF00002 		mov	r2, #0
 1816 0baa 9A70     		strb	r2, [r3, #2]
1195:../src/stm32f30x_rtc.c **** 
1196:../src/stm32f30x_rtc.c ****   /* Alarm Date Settings : Date = 1st day of the month */
1197:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
 1817              		.loc 1 1197 0
 1818 0bac 7B68     		ldr	r3, [r7, #4]
 1819 0bae 4FF00002 		mov	r2, #0
 1820 0bb2 9A60     		str	r2, [r3, #8]
1198:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
 1821              		.loc 1 1198 0
 1822 0bb4 7B68     		ldr	r3, [r7, #4]
 1823 0bb6 4FF00102 		mov	r2, #1
 1824 0bba 1A73     		strb	r2, [r3, #12]
1199:../src/stm32f30x_rtc.c **** 
1200:../src/stm32f30x_rtc.c ****   /* Alarm Masks Settings : Mask =  all fields are not masked */
1201:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
 1825              		.loc 1 1201 0
 1826 0bbc 7B68     		ldr	r3, [r7, #4]
 1827 0bbe 4FF00002 		mov	r2, #0
 1828 0bc2 5A60     		str	r2, [r3, #4]
1202:../src/stm32f30x_rtc.c **** }
 1829              		.loc 1 1202 0
 1830 0bc4 07F10C07 		add	r7, r7, #12
 1831 0bc8 BD46     		mov	sp, r7
 1832 0bca 80BC     		pop	{r7}
 1833 0bcc 7047     		bx	lr
 1834              		.cfi_endproc
 1835              	.LFE128:
 1837 0bce 00BF     		.align	2
 1838              		.global	RTC_GetAlarm
 1839              		.thumb
 1840              		.thumb_func
 1842              	RTC_GetAlarm:
 1843              	.LFB129:
1203:../src/stm32f30x_rtc.c **** 
1204:../src/stm32f30x_rtc.c **** /**
1205:../src/stm32f30x_rtc.c ****   * @brief  Get the RTC Alarm value and masks.
1206:../src/stm32f30x_rtc.c ****   * @param  RTC_Format: specifies the format of the output parameters.
1207:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1208:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BIN: Binary data format 
1209:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BCD: BCD data format
1210:../src/stm32f30x_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be read.
1211:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1212:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_A: to select Alarm A
1213:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_B: to select Alarm B  
1214:../src/stm32f30x_rtc.c ****   * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
1215:../src/stm32f30x_rtc.c ****   *                          contains the output alarm configuration values.     
1216:../src/stm32f30x_rtc.c ****   * @retval None
1217:../src/stm32f30x_rtc.c ****   */
1218:../src/stm32f30x_rtc.c **** void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
1219:../src/stm32f30x_rtc.c **** {
 1844              		.loc 1 1219 0
 1845              		.cfi_startproc
 1846              		@ args = 0, pretend = 0, frame = 24
 1847              		@ frame_needed = 1, uses_anonymous_args = 0
 1848 0bd0 80B5     		push	{r7, lr}
 1849              	.LCFI53:
 1850              		.cfi_def_cfa_offset 8
 1851              		.cfi_offset 7, -8
 1852              		.cfi_offset 14, -4
 1853 0bd2 86B0     		sub	sp, sp, #24
 1854              	.LCFI54:
 1855              		.cfi_def_cfa_offset 32
 1856 0bd4 00AF     		add	r7, sp, #0
 1857              	.LCFI55:
 1858              		.cfi_def_cfa_register 7
 1859 0bd6 F860     		str	r0, [r7, #12]
 1860 0bd8 B960     		str	r1, [r7, #8]
 1861 0bda 7A60     		str	r2, [r7, #4]
1220:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 1862              		.loc 1 1220 0
 1863 0bdc 4FF00003 		mov	r3, #0
 1864 0be0 7B61     		str	r3, [r7, #20]
1221:../src/stm32f30x_rtc.c **** 
1222:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1223:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
1224:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_ALARM(RTC_Alarm)); 
1225:../src/stm32f30x_rtc.c **** 
1226:../src/stm32f30x_rtc.c ****   /* Get the RTC_ALRMxR register */
1227:../src/stm32f30x_rtc.c ****   if (RTC_Alarm == RTC_Alarm_A)
 1865              		.loc 1 1227 0
 1866 0be2 BB68     		ldr	r3, [r7, #8]
 1867 0be4 B3F5807F 		cmp	r3, #256
 1868 0be8 06D1     		bne	.L84
1228:../src/stm32f30x_rtc.c ****   {
1229:../src/stm32f30x_rtc.c ****     tmpreg = (uint32_t)(RTC->ALRMAR);
 1869              		.loc 1 1229 0
 1870 0bea 4FF42053 		mov	r3, #10240
 1871 0bee C4F20003 		movt	r3, 16384
 1872 0bf2 DB69     		ldr	r3, [r3, #28]
 1873 0bf4 7B61     		str	r3, [r7, #20]
 1874 0bf6 05E0     		b	.L85
 1875              	.L84:
1230:../src/stm32f30x_rtc.c ****   }
1231:../src/stm32f30x_rtc.c ****   else
1232:../src/stm32f30x_rtc.c ****   {
1233:../src/stm32f30x_rtc.c ****     tmpreg = (uint32_t)(RTC->ALRMBR);
 1876              		.loc 1 1233 0
 1877 0bf8 4FF42053 		mov	r3, #10240
 1878 0bfc C4F20003 		movt	r3, 16384
 1879 0c00 1B6A     		ldr	r3, [r3, #32]
 1880 0c02 7B61     		str	r3, [r7, #20]
 1881              	.L85:
1234:../src/stm32f30x_rtc.c ****   }
1235:../src/stm32f30x_rtc.c **** 
1236:../src/stm32f30x_rtc.c ****   /* Fill the structure with the read parameters */
1237:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
 1882              		.loc 1 1237 0
 1883 0c04 7B69     		ldr	r3, [r7, #20]
 1884 0c06 03F47C13 		and	r3, r3, #4128768
 1885 0c0a 4FEA1343 		lsr	r3, r3, #16
 1886 0c0e DAB2     		uxtb	r2, r3
 1887 0c10 7B68     		ldr	r3, [r7, #4]
 1888 0c12 1A70     		strb	r2, [r3, #0]
1238:../src/stm32f30x_rtc.c ****                                                      RTC_ALRMAR_HU)) >> 16);
1239:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
 1889              		.loc 1 1239 0
 1890 0c14 7B69     		ldr	r3, [r7, #20]
 1891 0c16 03F4FE43 		and	r3, r3, #32512
 1892 0c1a 4FEA1323 		lsr	r3, r3, #8
 1893 0c1e DAB2     		uxtb	r2, r3
 1894 0c20 7B68     		ldr	r3, [r7, #4]
 1895 0c22 5A70     		strb	r2, [r3, #1]
1240:../src/stm32f30x_rtc.c ****                                                      RTC_ALRMAR_MNU)) >> 8);
1241:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
 1896              		.loc 1 1241 0
 1897 0c24 7B69     		ldr	r3, [r7, #20]
 1898 0c26 DBB2     		uxtb	r3, r3
 1899 0c28 03F07F03 		and	r3, r3, #127
 1900 0c2c DAB2     		uxtb	r2, r3
 1901 0c2e 7B68     		ldr	r3, [r7, #4]
 1902 0c30 9A70     		strb	r2, [r3, #2]
1242:../src/stm32f30x_rtc.c ****                                                      RTC_ALRMAR_SU));
1243:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 1903              		.loc 1 1243 0
 1904 0c32 7B69     		ldr	r3, [r7, #20]
 1905 0c34 03F48003 		and	r3, r3, #4194304
 1906 0c38 4FEA1343 		lsr	r3, r3, #16
 1907 0c3c DAB2     		uxtb	r2, r3
 1908 0c3e 7B68     		ldr	r3, [r7, #4]
 1909 0c40 DA70     		strb	r2, [r3, #3]
1244:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 
 1910              		.loc 1 1244 0
 1911 0c42 7B69     		ldr	r3, [r7, #20]
 1912 0c44 03F07C53 		and	r3, r3, #1056964608
 1913 0c48 4FEA1363 		lsr	r3, r3, #24
 1914 0c4c DAB2     		uxtb	r2, r3
 1915 0c4e 7B68     		ldr	r3, [r7, #4]
 1916 0c50 1A73     		strb	r2, [r3, #12]
1245:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 1917              		.loc 1 1245 0
 1918 0c52 7B69     		ldr	r3, [r7, #20]
 1919 0c54 03F08042 		and	r2, r3, #1073741824
 1920 0c58 7B68     		ldr	r3, [r7, #4]
 1921 0c5a 9A60     		str	r2, [r3, #8]
1246:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
 1922              		.loc 1 1246 0
 1923 0c5c 7B69     		ldr	r3, [r7, #20]
 1924 0c5e 03F08032 		and	r2, r3, #-2139062144
 1925 0c62 7B68     		ldr	r3, [r7, #4]
 1926 0c64 5A60     		str	r2, [r3, #4]
1247:../src/stm32f30x_rtc.c **** 
1248:../src/stm32f30x_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 1927              		.loc 1 1248 0
 1928 0c66 FB68     		ldr	r3, [r7, #12]
 1929 0c68 002B     		cmp	r3, #0
 1930 0c6a 23D1     		bne	.L83
1249:../src/stm32f30x_rtc.c ****   {
1250:../src/stm32f30x_rtc.c ****     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 1931              		.loc 1 1250 0
 1932 0c6c 7B68     		ldr	r3, [r7, #4]
 1933 0c6e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1934 0c70 1846     		mov	r0, r3
 1935 0c72 00F00FFF 		bl	RTC_Bcd2ToByte
 1936 0c76 0346     		mov	r3, r0
 1937 0c78 1A46     		mov	r2, r3
 1938 0c7a 7B68     		ldr	r3, [r7, #4]
 1939 0c7c 1A70     		strb	r2, [r3, #0]
1251:../src/stm32f30x_rtc.c ****                                                         RTC_AlarmTime.RTC_Hours);
1252:../src/stm32f30x_rtc.c ****     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 1940              		.loc 1 1252 0
 1941 0c7e 7B68     		ldr	r3, [r7, #4]
 1942 0c80 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1943 0c82 1846     		mov	r0, r3
 1944 0c84 00F006FF 		bl	RTC_Bcd2ToByte
 1945 0c88 0346     		mov	r3, r0
 1946 0c8a 1A46     		mov	r2, r3
 1947 0c8c 7B68     		ldr	r3, [r7, #4]
 1948 0c8e 5A70     		strb	r2, [r3, #1]
1253:../src/stm32f30x_rtc.c ****                                                         RTC_AlarmTime.RTC_Minutes);
1254:../src/stm32f30x_rtc.c ****     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 1949              		.loc 1 1254 0
 1950 0c90 7B68     		ldr	r3, [r7, #4]
 1951 0c92 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1952 0c94 1846     		mov	r0, r3
 1953 0c96 00F0FDFE 		bl	RTC_Bcd2ToByte
 1954 0c9a 0346     		mov	r3, r0
 1955 0c9c 1A46     		mov	r2, r3
 1956 0c9e 7B68     		ldr	r3, [r7, #4]
 1957 0ca0 9A70     		strb	r2, [r3, #2]
1255:../src/stm32f30x_rtc.c ****                                                         RTC_AlarmTime.RTC_Seconds);
1256:../src/stm32f30x_rtc.c ****     RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 1958              		.loc 1 1256 0
 1959 0ca2 7B68     		ldr	r3, [r7, #4]
 1960 0ca4 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1961 0ca6 1846     		mov	r0, r3
 1962 0ca8 00F0F4FE 		bl	RTC_Bcd2ToByte
 1963 0cac 0346     		mov	r3, r0
 1964 0cae 1A46     		mov	r2, r3
 1965 0cb0 7B68     		ldr	r3, [r7, #4]
 1966 0cb2 1A73     		strb	r2, [r3, #12]
 1967              	.L83:
1257:../src/stm32f30x_rtc.c ****   }  
1258:../src/stm32f30x_rtc.c **** }
 1968              		.loc 1 1258 0
 1969 0cb4 07F11807 		add	r7, r7, #24
 1970 0cb8 BD46     		mov	sp, r7
 1971 0cba 80BD     		pop	{r7, pc}
 1972              		.cfi_endproc
 1973              	.LFE129:
 1975              		.align	2
 1976              		.global	RTC_AlarmCmd
 1977              		.thumb
 1978              		.thumb_func
 1980              	RTC_AlarmCmd:
 1981              	.LFB130:
1259:../src/stm32f30x_rtc.c **** 
1260:../src/stm32f30x_rtc.c **** /**
1261:../src/stm32f30x_rtc.c ****   * @brief  Enables or disables the specified RTC Alarm.
1262:../src/stm32f30x_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be configured.
1263:../src/stm32f30x_rtc.c ****   *   This parameter can be any combination of the following values:
1264:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_A: to select Alarm A
1265:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_B: to select Alarm B  
1266:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the specified alarm.
1267:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.
1268:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
1269:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC Alarm is enabled/disabled
1270:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC Alarm is not enabled/disabled  
1271:../src/stm32f30x_rtc.c ****   */
1272:../src/stm32f30x_rtc.c **** ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
1273:../src/stm32f30x_rtc.c **** {
 1982              		.loc 1 1273 0
 1983              		.cfi_startproc
 1984              		@ args = 0, pretend = 0, frame = 24
 1985              		@ frame_needed = 1, uses_anonymous_args = 0
 1986              		@ link register save eliminated.
 1987 0cbc 80B4     		push	{r7}
 1988              	.LCFI56:
 1989              		.cfi_def_cfa_offset 4
 1990              		.cfi_offset 7, -4
 1991 0cbe 87B0     		sub	sp, sp, #28
 1992              	.LCFI57:
 1993              		.cfi_def_cfa_offset 32
 1994 0cc0 00AF     		add	r7, sp, #0
 1995              	.LCFI58:
 1996              		.cfi_def_cfa_register 7
 1997 0cc2 7860     		str	r0, [r7, #4]
 1998 0cc4 0B46     		mov	r3, r1
 1999 0cc6 FB70     		strb	r3, [r7, #3]
1274:../src/stm32f30x_rtc.c ****   __IO uint32_t alarmcounter = 0x00;
 2000              		.loc 1 1274 0
 2001 0cc8 4FF00003 		mov	r3, #0
 2002 0ccc FB60     		str	r3, [r7, #12]
1275:../src/stm32f30x_rtc.c ****   uint32_t alarmstatus = 0x00;
 2003              		.loc 1 1275 0
 2004 0cce 4FF00003 		mov	r3, #0
 2005 0cd2 3B61     		str	r3, [r7, #16]
1276:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 2006              		.loc 1 1276 0
 2007 0cd4 4FF00003 		mov	r3, #0
 2008 0cd8 FB75     		strb	r3, [r7, #23]
1277:../src/stm32f30x_rtc.c ****     
1278:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1279:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
1280:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1281:../src/stm32f30x_rtc.c **** 
1282:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1283:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2009              		.loc 1 1283 0
 2010 0cda 4FF42053 		mov	r3, #10240
 2011 0cde C4F20003 		movt	r3, 16384
 2012 0ce2 4FF0CA02 		mov	r2, #202
 2013 0ce6 5A62     		str	r2, [r3, #36]
1284:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2014              		.loc 1 1284 0
 2015 0ce8 4FF42053 		mov	r3, #10240
 2016 0cec C4F20003 		movt	r3, 16384
 2017 0cf0 4FF05302 		mov	r2, #83
 2018 0cf4 5A62     		str	r2, [r3, #36]
1285:../src/stm32f30x_rtc.c **** 
1286:../src/stm32f30x_rtc.c ****   /* Configure the Alarm state */
1287:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 2019              		.loc 1 1287 0
 2020 0cf6 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2021 0cf8 002B     		cmp	r3, #0
 2022 0cfa 0FD0     		beq	.L88
1288:../src/stm32f30x_rtc.c ****   {
1289:../src/stm32f30x_rtc.c ****     RTC->CR |= (uint32_t)RTC_Alarm;
 2023              		.loc 1 1289 0
 2024 0cfc 4FF42053 		mov	r3, #10240
 2025 0d00 C4F20003 		movt	r3, 16384
 2026 0d04 4FF42052 		mov	r2, #10240
 2027 0d08 C4F20002 		movt	r2, 16384
 2028 0d0c 9168     		ldr	r1, [r2, #8]
 2029 0d0e 7A68     		ldr	r2, [r7, #4]
 2030 0d10 0A43     		orrs	r2, r2, r1
 2031 0d12 9A60     		str	r2, [r3, #8]
1290:../src/stm32f30x_rtc.c **** 
1291:../src/stm32f30x_rtc.c ****     status = SUCCESS;    
 2032              		.loc 1 1291 0
 2033 0d14 4FF00103 		mov	r3, #1
 2034 0d18 FB75     		strb	r3, [r7, #23]
 2035 0d1a 34E0     		b	.L89
 2036              	.L88:
1292:../src/stm32f30x_rtc.c ****   }
1293:../src/stm32f30x_rtc.c ****   else
1294:../src/stm32f30x_rtc.c ****   { 
1295:../src/stm32f30x_rtc.c ****     /* Disable the Alarm in RTC_CR register */
1296:../src/stm32f30x_rtc.c ****     RTC->CR &= (uint32_t)~RTC_Alarm;
 2037              		.loc 1 1296 0
 2038 0d1c 4FF42053 		mov	r3, #10240
 2039 0d20 C4F20003 		movt	r3, 16384
 2040 0d24 4FF42052 		mov	r2, #10240
 2041 0d28 C4F20002 		movt	r2, 16384
 2042 0d2c 9168     		ldr	r1, [r2, #8]
 2043 0d2e 7A68     		ldr	r2, [r7, #4]
 2044 0d30 6FEA0202 		mvn	r2, r2
 2045 0d34 0A40     		ands	r2, r2, r1
 2046 0d36 9A60     		str	r2, [r3, #8]
 2047              	.L91:
1297:../src/stm32f30x_rtc.c ****    
1298:../src/stm32f30x_rtc.c ****     /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
1299:../src/stm32f30x_rtc.c ****     do
1300:../src/stm32f30x_rtc.c ****     {
1301:../src/stm32f30x_rtc.c ****       alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
 2048              		.loc 1 1301 0 discriminator 1
 2049 0d38 4FF42053 		mov	r3, #10240
 2050 0d3c C4F20003 		movt	r3, 16384
 2051 0d40 DA68     		ldr	r2, [r3, #12]
 2052 0d42 7B68     		ldr	r3, [r7, #4]
 2053 0d44 4FEA1323 		lsr	r3, r3, #8
 2054 0d48 1340     		ands	r3, r3, r2
 2055 0d4a 3B61     		str	r3, [r7, #16]
1302:../src/stm32f30x_rtc.c ****       alarmcounter++;  
 2056              		.loc 1 1302 0 discriminator 1
 2057 0d4c FB68     		ldr	r3, [r7, #12]
 2058 0d4e 03F10103 		add	r3, r3, #1
 2059 0d52 FB60     		str	r3, [r7, #12]
1303:../src/stm32f30x_rtc.c ****     } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
 2060              		.loc 1 1303 0 discriminator 1
 2061 0d54 FB68     		ldr	r3, [r7, #12]
 2062 0d56 B3F5005F 		cmp	r3, #8192
 2063 0d5a 02D0     		beq	.L90
 2064 0d5c 3B69     		ldr	r3, [r7, #16]
 2065 0d5e 002B     		cmp	r3, #0
 2066 0d60 EAD0     		beq	.L91
 2067              	.L90:
1304:../src/stm32f30x_rtc.c ****     
1305:../src/stm32f30x_rtc.c ****     if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
 2068              		.loc 1 1305 0
 2069 0d62 4FF42053 		mov	r3, #10240
 2070 0d66 C4F20003 		movt	r3, 16384
 2071 0d6a DA68     		ldr	r2, [r3, #12]
 2072 0d6c 7B68     		ldr	r3, [r7, #4]
 2073 0d6e 4FEA1323 		lsr	r3, r3, #8
 2074 0d72 1340     		ands	r3, r3, r2
 2075 0d74 002B     		cmp	r3, #0
 2076 0d76 03D1     		bne	.L92
1306:../src/stm32f30x_rtc.c ****     {
1307:../src/stm32f30x_rtc.c ****       status = ERROR;
 2077              		.loc 1 1307 0
 2078 0d78 4FF00003 		mov	r3, #0
 2079 0d7c FB75     		strb	r3, [r7, #23]
 2080 0d7e 02E0     		b	.L89
 2081              	.L92:
1308:../src/stm32f30x_rtc.c ****     } 
1309:../src/stm32f30x_rtc.c ****     else
1310:../src/stm32f30x_rtc.c ****     {
1311:../src/stm32f30x_rtc.c ****       status = SUCCESS;
 2082              		.loc 1 1311 0
 2083 0d80 4FF00103 		mov	r3, #1
 2084 0d84 FB75     		strb	r3, [r7, #23]
 2085              	.L89:
1312:../src/stm32f30x_rtc.c ****     }        
1313:../src/stm32f30x_rtc.c ****   } 
1314:../src/stm32f30x_rtc.c **** 
1315:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1316:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2086              		.loc 1 1316 0
 2087 0d86 4FF42053 		mov	r3, #10240
 2088 0d8a C4F20003 		movt	r3, 16384
 2089 0d8e 4FF0FF02 		mov	r2, #255
 2090 0d92 5A62     		str	r2, [r3, #36]
1317:../src/stm32f30x_rtc.c ****   
1318:../src/stm32f30x_rtc.c ****   return status;
 2091              		.loc 1 1318 0
 2092 0d94 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1319:../src/stm32f30x_rtc.c **** }
 2093              		.loc 1 1319 0
 2094 0d96 1846     		mov	r0, r3
 2095 0d98 07F11C07 		add	r7, r7, #28
 2096 0d9c BD46     		mov	sp, r7
 2097 0d9e 80BC     		pop	{r7}
 2098 0da0 7047     		bx	lr
 2099              		.cfi_endproc
 2100              	.LFE130:
 2102 0da2 00BF     		.align	2
 2103              		.global	RTC_AlarmSubSecondConfig
 2104              		.thumb
 2105              		.thumb_func
 2107              	RTC_AlarmSubSecondConfig:
 2108              	.LFB131:
1320:../src/stm32f30x_rtc.c **** 
1321:../src/stm32f30x_rtc.c **** /**
1322:../src/stm32f30x_rtc.c ****   * @brief  Configures the RTC AlarmA/B Subseconds value and mask.
1323:../src/stm32f30x_rtc.c ****   * @note   This function is performed only when the Alarm is disabled. 
1324:../src/stm32f30x_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be configured.
1325:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1326:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_A: to select Alarm A
1327:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_B: to select Alarm B
1328:../src/stm32f30x_rtc.c ****   * @param  RTC_AlarmSubSecondValue: specifies the Subseconds value.
1329:../src/stm32f30x_rtc.c ****   *   This parameter can be a value from 0 to 0x00007FFF.
1330:../src/stm32f30x_rtc.c ****   * @param  RTC_AlarmSubSecondMask:  specifies the Subseconds Mask.
1331:../src/stm32f30x_rtc.c ****   *   This parameter can be any combination of the following values:
1332:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_All    : All Alarm SS fields are masked.
1333:../src/stm32f30x_rtc.c ****   *                                          There is no comparison on sub seconds for Alarm.
1334:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_1 : SS[14:1] are don't care in Alarm comparison.
1335:../src/stm32f30x_rtc.c ****   *                                          Only SS[0] is compared
1336:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_2 : SS[14:2] are don't care in Alarm comparison.
1337:../src/stm32f30x_rtc.c ****   *                                          Only SS[1:0] are compared
1338:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_3 : SS[14:3] are don't care in Alarm comparison.
1339:../src/stm32f30x_rtc.c ****   *                                          Only SS[2:0] are compared
1340:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_4 : SS[14:4] are don't care in Alarm comparison.
1341:../src/stm32f30x_rtc.c ****   *                                          Only SS[3:0] are compared
1342:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_5 : SS[14:5] are don't care in Alarm comparison.
1343:../src/stm32f30x_rtc.c ****   *                                          Only SS[4:0] are compared
1344:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_6 : SS[14:6] are don't care in Alarm comparison.
1345:../src/stm32f30x_rtc.c ****   *                                          Only SS[5:0] are compared
1346:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_7 : SS[14:7] are don't care in Alarm comparison.
1347:../src/stm32f30x_rtc.c ****   *                                          Only SS[6:0] are compared
1348:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_8 : SS[14:8] are don't care in Alarm comparison.
1349:../src/stm32f30x_rtc.c ****   *                                          Only SS[7:0] are compared
1350:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_9 : SS[14:9] are don't care in Alarm comparison.
1351:../src/stm32f30x_rtc.c ****   *                                          Only SS[8:0] are compared
1352:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_10: SS[14:10] are don't care in Alarm comparison.
1353:../src/stm32f30x_rtc.c ****   *                                          Only SS[9:0] are compared
1354:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_11: SS[14:11] are don't care in Alarm comparison.
1355:../src/stm32f30x_rtc.c ****   *                                          Only SS[10:0] are compared
1356:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_12: SS[14:12] are don't care in Alarm comparison.
1357:../src/stm32f30x_rtc.c ****   *                                          Only SS[11:0] are compared
1358:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_13: SS[14:13] are don't care in Alarm comparison.
1359:../src/stm32f30x_rtc.c ****   *                                          Only SS[12:0] are compared
1360:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14   : SS[14] is don't care in Alarm comparison.
1361:../src/stm32f30x_rtc.c ****   *                                          Only SS[13:0] are compared
1362:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_None   : SS[14:0] are compared and must match
1363:../src/stm32f30x_rtc.c ****   *                                          to activate alarm
1364:../src/stm32f30x_rtc.c ****   * @retval None
1365:../src/stm32f30x_rtc.c ****   */
1366:../src/stm32f30x_rtc.c **** void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_Al
1367:../src/stm32f30x_rtc.c **** {
 2109              		.loc 1 1367 0
 2110              		.cfi_startproc
 2111              		@ args = 0, pretend = 0, frame = 24
 2112              		@ frame_needed = 1, uses_anonymous_args = 0
 2113              		@ link register save eliminated.
 2114 0da4 80B4     		push	{r7}
 2115              	.LCFI59:
 2116              		.cfi_def_cfa_offset 4
 2117              		.cfi_offset 7, -4
 2118 0da6 87B0     		sub	sp, sp, #28
 2119              	.LCFI60:
 2120              		.cfi_def_cfa_offset 32
 2121 0da8 00AF     		add	r7, sp, #0
 2122              	.LCFI61:
 2123              		.cfi_def_cfa_register 7
 2124 0daa F860     		str	r0, [r7, #12]
 2125 0dac B960     		str	r1, [r7, #8]
 2126 0dae 7A60     		str	r2, [r7, #4]
1368:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 2127              		.loc 1 1368 0
 2128 0db0 4FF00003 		mov	r3, #0
 2129 0db4 7B61     		str	r3, [r7, #20]
1369:../src/stm32f30x_rtc.c **** 
1370:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1371:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_ALARM(RTC_Alarm));
1372:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
1373:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
1374:../src/stm32f30x_rtc.c ****   
1375:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1376:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2130              		.loc 1 1376 0
 2131 0db6 4FF42053 		mov	r3, #10240
 2132 0dba C4F20003 		movt	r3, 16384
 2133 0dbe 4FF0CA02 		mov	r2, #202
 2134 0dc2 5A62     		str	r2, [r3, #36]
1377:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2135              		.loc 1 1377 0
 2136 0dc4 4FF42053 		mov	r3, #10240
 2137 0dc8 C4F20003 		movt	r3, 16384
 2138 0dcc 4FF05302 		mov	r2, #83
 2139 0dd0 5A62     		str	r2, [r3, #36]
1378:../src/stm32f30x_rtc.c ****   
1379:../src/stm32f30x_rtc.c ****   /* Configure the Alarm A or Alarm B SubSecond registers */
1380:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
 2140              		.loc 1 1380 0
 2141 0dd2 BA68     		ldr	r2, [r7, #8]
 2142 0dd4 7B68     		ldr	r3, [r7, #4]
 2143 0dd6 1343     		orrs	r3, r3, r2
 2144 0dd8 7B61     		str	r3, [r7, #20]
1381:../src/stm32f30x_rtc.c ****   
1382:../src/stm32f30x_rtc.c ****   if (RTC_Alarm == RTC_Alarm_A)
 2145              		.loc 1 1382 0
 2146 0dda FB68     		ldr	r3, [r7, #12]
 2147 0ddc B3F5807F 		cmp	r3, #256
 2148 0de0 06D1     		bne	.L95
1383:../src/stm32f30x_rtc.c ****   {
1384:../src/stm32f30x_rtc.c ****     /* Configure the AlarmA SubSecond register */
1385:../src/stm32f30x_rtc.c ****     RTC->ALRMASSR = tmpreg;
 2149              		.loc 1 1385 0
 2150 0de2 4FF42053 		mov	r3, #10240
 2151 0de6 C4F20003 		movt	r3, 16384
 2152 0dea 7A69     		ldr	r2, [r7, #20]
 2153 0dec 5A64     		str	r2, [r3, #68]
 2154 0dee 05E0     		b	.L96
 2155              	.L95:
1386:../src/stm32f30x_rtc.c ****   }
1387:../src/stm32f30x_rtc.c ****   else
1388:../src/stm32f30x_rtc.c ****   {
1389:../src/stm32f30x_rtc.c ****     /* Configure the Alarm B SubSecond register */
1390:../src/stm32f30x_rtc.c ****     RTC->ALRMBSSR = tmpreg;
 2156              		.loc 1 1390 0
 2157 0df0 4FF42053 		mov	r3, #10240
 2158 0df4 C4F20003 		movt	r3, 16384
 2159 0df8 7A69     		ldr	r2, [r7, #20]
 2160 0dfa 9A64     		str	r2, [r3, #72]
 2161              	.L96:
1391:../src/stm32f30x_rtc.c ****   }
1392:../src/stm32f30x_rtc.c **** 
1393:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1394:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2162              		.loc 1 1394 0
 2163 0dfc 4FF42053 		mov	r3, #10240
 2164 0e00 C4F20003 		movt	r3, 16384
 2165 0e04 4FF0FF02 		mov	r2, #255
 2166 0e08 5A62     		str	r2, [r3, #36]
1395:../src/stm32f30x_rtc.c **** 
1396:../src/stm32f30x_rtc.c **** }
 2167              		.loc 1 1396 0
 2168 0e0a 07F11C07 		add	r7, r7, #28
 2169 0e0e BD46     		mov	sp, r7
 2170 0e10 80BC     		pop	{r7}
 2171 0e12 7047     		bx	lr
 2172              		.cfi_endproc
 2173              	.LFE131:
 2175              		.align	2
 2176              		.global	RTC_GetAlarmSubSecond
 2177              		.thumb
 2178              		.thumb_func
 2180              	RTC_GetAlarmSubSecond:
 2181              	.LFB132:
1397:../src/stm32f30x_rtc.c **** 
1398:../src/stm32f30x_rtc.c **** /**
1399:../src/stm32f30x_rtc.c ****   * @brief  Gets the RTC Alarm Subseconds value.
1400:../src/stm32f30x_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be read.
1401:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1402:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_A: to select Alarm A
1403:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_B: to select Alarm B
1404:../src/stm32f30x_rtc.c ****   * @param  None
1405:../src/stm32f30x_rtc.c ****   * @retval RTC Alarm Subseconds value.
1406:../src/stm32f30x_rtc.c ****   */
1407:../src/stm32f30x_rtc.c **** uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
1408:../src/stm32f30x_rtc.c **** {
 2182              		.loc 1 1408 0
 2183              		.cfi_startproc
 2184              		@ args = 0, pretend = 0, frame = 16
 2185              		@ frame_needed = 1, uses_anonymous_args = 0
 2186              		@ link register save eliminated.
 2187 0e14 80B4     		push	{r7}
 2188              	.LCFI62:
 2189              		.cfi_def_cfa_offset 4
 2190              		.cfi_offset 7, -4
 2191 0e16 85B0     		sub	sp, sp, #20
 2192              	.LCFI63:
 2193              		.cfi_def_cfa_offset 24
 2194 0e18 00AF     		add	r7, sp, #0
 2195              	.LCFI64:
 2196              		.cfi_def_cfa_register 7
 2197 0e1a 7860     		str	r0, [r7, #4]
1409:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 2198              		.loc 1 1409 0
 2199 0e1c 4FF00003 		mov	r3, #0
 2200 0e20 FB60     		str	r3, [r7, #12]
1410:../src/stm32f30x_rtc.c ****   
1411:../src/stm32f30x_rtc.c ****   /* Get the RTC_ALRMxR register */
1412:../src/stm32f30x_rtc.c ****   if (RTC_Alarm == RTC_Alarm_A)
 2201              		.loc 1 1412 0
 2202 0e22 7B68     		ldr	r3, [r7, #4]
 2203 0e24 B3F5807F 		cmp	r3, #256
 2204 0e28 0AD1     		bne	.L98
1413:../src/stm32f30x_rtc.c ****   {
1414:../src/stm32f30x_rtc.c ****     tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
 2205              		.loc 1 1414 0
 2206 0e2a 4FF42053 		mov	r3, #10240
 2207 0e2e C4F20003 		movt	r3, 16384
 2208 0e32 5B6C     		ldr	r3, [r3, #68]
 2209 0e34 4FEA4343 		lsl	r3, r3, #17
 2210 0e38 4FEA5343 		lsr	r3, r3, #17
 2211 0e3c FB60     		str	r3, [r7, #12]
 2212 0e3e 09E0     		b	.L99
 2213              	.L98:
1415:../src/stm32f30x_rtc.c ****   }
1416:../src/stm32f30x_rtc.c ****   else
1417:../src/stm32f30x_rtc.c ****   {
1418:../src/stm32f30x_rtc.c ****     tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
 2214              		.loc 1 1418 0
 2215 0e40 4FF42053 		mov	r3, #10240
 2216 0e44 C4F20003 		movt	r3, 16384
 2217 0e48 9B6C     		ldr	r3, [r3, #72]
 2218 0e4a 4FEA4343 		lsl	r3, r3, #17
 2219 0e4e 4FEA5343 		lsr	r3, r3, #17
 2220 0e52 FB60     		str	r3, [r7, #12]
 2221              	.L99:
1419:../src/stm32f30x_rtc.c ****   } 
1420:../src/stm32f30x_rtc.c ****   
1421:../src/stm32f30x_rtc.c ****   return (tmpreg);
 2222              		.loc 1 1421 0
 2223 0e54 FB68     		ldr	r3, [r7, #12]
1422:../src/stm32f30x_rtc.c **** }
 2224              		.loc 1 1422 0
 2225 0e56 1846     		mov	r0, r3
 2226 0e58 07F11407 		add	r7, r7, #20
 2227 0e5c BD46     		mov	sp, r7
 2228 0e5e 80BC     		pop	{r7}
 2229 0e60 7047     		bx	lr
 2230              		.cfi_endproc
 2231              	.LFE132:
 2233 0e62 00BF     		.align	2
 2234              		.global	RTC_WakeUpClockConfig
 2235              		.thumb
 2236              		.thumb_func
 2238              	RTC_WakeUpClockConfig:
 2239              	.LFB133:
1423:../src/stm32f30x_rtc.c **** 
1424:../src/stm32f30x_rtc.c **** /**
1425:../src/stm32f30x_rtc.c ****   * @}
1426:../src/stm32f30x_rtc.c ****   */
1427:../src/stm32f30x_rtc.c **** 
1428:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group4 WakeUp Timer configuration functions
1429:../src/stm32f30x_rtc.c ****  *  @brief   WakeUp Timer configuration functions 
1430:../src/stm32f30x_rtc.c ****  *
1431:../src/stm32f30x_rtc.c **** @verbatim   
1432:../src/stm32f30x_rtc.c ****  ===============================================================================
1433:../src/stm32f30x_rtc.c ****                 ##### WakeUp Timer configuration functions #####
1434:../src/stm32f30x_rtc.c ****  ===============================================================================  
1435:../src/stm32f30x_rtc.c ****     [..] This section provide functions allowing to program and read the RTC WakeUp.
1436:../src/stm32f30x_rtc.c **** 
1437:../src/stm32f30x_rtc.c **** @endverbatim
1438:../src/stm32f30x_rtc.c ****   * @{
1439:../src/stm32f30x_rtc.c ****   */
1440:../src/stm32f30x_rtc.c **** 
1441:../src/stm32f30x_rtc.c **** /**
1442:../src/stm32f30x_rtc.c ****   * @brief  Configures the RTC Wakeup clock source.
1443:../src/stm32f30x_rtc.c ****   * @note   The WakeUp Clock source can only be changed when the RTC WakeUp
1444:../src/stm32f30x_rtc.c ****   *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).
1445:../src/stm32f30x_rtc.c ****   * @param  RTC_WakeUpClock: Wakeup Clock source.
1446:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1447:../src/stm32f30x_rtc.c ****   *     @arg RTC_WakeUpClock_RTCCLK_Div16: RTC Wakeup Counter Clock = RTCCLK/16
1448:../src/stm32f30x_rtc.c ****   *     @arg RTC_WakeUpClock_RTCCLK_Div8: RTC Wakeup Counter Clock = RTCCLK/8
1449:../src/stm32f30x_rtc.c ****   *     @arg RTC_WakeUpClock_RTCCLK_Div4: RTC Wakeup Counter Clock = RTCCLK/4
1450:../src/stm32f30x_rtc.c ****   *     @arg RTC_WakeUpClock_RTCCLK_Div2: RTC Wakeup Counter Clock = RTCCLK/2
1451:../src/stm32f30x_rtc.c ****   *     @arg RTC_WakeUpClock_CK_SPRE_16bits: RTC Wakeup Counter Clock = CK_SPRE
1452:../src/stm32f30x_rtc.c ****   *     @arg RTC_WakeUpClock_CK_SPRE_17bits: RTC Wakeup Counter Clock = CK_SPRE
1453:../src/stm32f30x_rtc.c ****   * @retval None
1454:../src/stm32f30x_rtc.c ****   */
1455:../src/stm32f30x_rtc.c **** void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
1456:../src/stm32f30x_rtc.c **** {
 2240              		.loc 1 1456 0
 2241              		.cfi_startproc
 2242              		@ args = 0, pretend = 0, frame = 8
 2243              		@ frame_needed = 1, uses_anonymous_args = 0
 2244              		@ link register save eliminated.
 2245 0e64 80B4     		push	{r7}
 2246              	.LCFI65:
 2247              		.cfi_def_cfa_offset 4
 2248              		.cfi_offset 7, -4
 2249 0e66 83B0     		sub	sp, sp, #12
 2250              	.LCFI66:
 2251              		.cfi_def_cfa_offset 16
 2252 0e68 00AF     		add	r7, sp, #0
 2253              	.LCFI67:
 2254              		.cfi_def_cfa_register 7
 2255 0e6a 7860     		str	r0, [r7, #4]
1457:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1458:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
1459:../src/stm32f30x_rtc.c **** 
1460:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1461:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2256              		.loc 1 1461 0
 2257 0e6c 4FF42053 		mov	r3, #10240
 2258 0e70 C4F20003 		movt	r3, 16384
 2259 0e74 4FF0CA02 		mov	r2, #202
 2260 0e78 5A62     		str	r2, [r3, #36]
1462:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2261              		.loc 1 1462 0
 2262 0e7a 4FF42053 		mov	r3, #10240
 2263 0e7e C4F20003 		movt	r3, 16384
 2264 0e82 4FF05302 		mov	r2, #83
 2265 0e86 5A62     		str	r2, [r3, #36]
1463:../src/stm32f30x_rtc.c **** 
1464:../src/stm32f30x_rtc.c ****   /* Clear the Wakeup Timer clock source bits in CR register */
1465:../src/stm32f30x_rtc.c ****   RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 2266              		.loc 1 1465 0
 2267 0e88 4FF42053 		mov	r3, #10240
 2268 0e8c C4F20003 		movt	r3, 16384
 2269 0e90 4FF42052 		mov	r2, #10240
 2270 0e94 C4F20002 		movt	r2, 16384
 2271 0e98 9268     		ldr	r2, [r2, #8]
 2272 0e9a 22F00702 		bic	r2, r2, #7
 2273 0e9e 9A60     		str	r2, [r3, #8]
1466:../src/stm32f30x_rtc.c **** 
1467:../src/stm32f30x_rtc.c ****   /* Configure the clock source */
1468:../src/stm32f30x_rtc.c ****   RTC->CR |= (uint32_t)RTC_WakeUpClock;
 2274              		.loc 1 1468 0
 2275 0ea0 4FF42053 		mov	r3, #10240
 2276 0ea4 C4F20003 		movt	r3, 16384
 2277 0ea8 4FF42052 		mov	r2, #10240
 2278 0eac C4F20002 		movt	r2, 16384
 2279 0eb0 9168     		ldr	r1, [r2, #8]
 2280 0eb2 7A68     		ldr	r2, [r7, #4]
 2281 0eb4 0A43     		orrs	r2, r2, r1
 2282 0eb6 9A60     		str	r2, [r3, #8]
1469:../src/stm32f30x_rtc.c ****   
1470:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1471:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2283              		.loc 1 1471 0
 2284 0eb8 4FF42053 		mov	r3, #10240
 2285 0ebc C4F20003 		movt	r3, 16384
 2286 0ec0 4FF0FF02 		mov	r2, #255
 2287 0ec4 5A62     		str	r2, [r3, #36]
1472:../src/stm32f30x_rtc.c **** }
 2288              		.loc 1 1472 0
 2289 0ec6 07F10C07 		add	r7, r7, #12
 2290 0eca BD46     		mov	sp, r7
 2291 0ecc 80BC     		pop	{r7}
 2292 0ece 7047     		bx	lr
 2293              		.cfi_endproc
 2294              	.LFE133:
 2296              		.align	2
 2297              		.global	RTC_SetWakeUpCounter
 2298              		.thumb
 2299              		.thumb_func
 2301              	RTC_SetWakeUpCounter:
 2302              	.LFB134:
1473:../src/stm32f30x_rtc.c **** 
1474:../src/stm32f30x_rtc.c **** /**
1475:../src/stm32f30x_rtc.c ****   * @brief  Configures the RTC Wakeup counter.
1476:../src/stm32f30x_rtc.c ****   * @note   The RTC WakeUp counter can only be written when the RTC WakeUp
1477:../src/stm32f30x_rtc.c ****   *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).
1478:../src/stm32f30x_rtc.c ****   * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
1479:../src/stm32f30x_rtc.c ****   *   This parameter can be a value from 0x0000 to 0xFFFF. 
1480:../src/stm32f30x_rtc.c ****   * @retval None
1481:../src/stm32f30x_rtc.c ****   */
1482:../src/stm32f30x_rtc.c **** void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
1483:../src/stm32f30x_rtc.c **** {
 2303              		.loc 1 1483 0
 2304              		.cfi_startproc
 2305              		@ args = 0, pretend = 0, frame = 8
 2306              		@ frame_needed = 1, uses_anonymous_args = 0
 2307              		@ link register save eliminated.
 2308 0ed0 80B4     		push	{r7}
 2309              	.LCFI68:
 2310              		.cfi_def_cfa_offset 4
 2311              		.cfi_offset 7, -4
 2312 0ed2 83B0     		sub	sp, sp, #12
 2313              	.LCFI69:
 2314              		.cfi_def_cfa_offset 16
 2315 0ed4 00AF     		add	r7, sp, #0
 2316              	.LCFI70:
 2317              		.cfi_def_cfa_register 7
 2318 0ed6 7860     		str	r0, [r7, #4]
1484:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1485:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
1486:../src/stm32f30x_rtc.c ****   
1487:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1488:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2319              		.loc 1 1488 0
 2320 0ed8 4FF42053 		mov	r3, #10240
 2321 0edc C4F20003 		movt	r3, 16384
 2322 0ee0 4FF0CA02 		mov	r2, #202
 2323 0ee4 5A62     		str	r2, [r3, #36]
1489:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2324              		.loc 1 1489 0
 2325 0ee6 4FF42053 		mov	r3, #10240
 2326 0eea C4F20003 		movt	r3, 16384
 2327 0eee 4FF05302 		mov	r2, #83
 2328 0ef2 5A62     		str	r2, [r3, #36]
1490:../src/stm32f30x_rtc.c ****   
1491:../src/stm32f30x_rtc.c ****   /* Configure the Wakeup Timer counter */
1492:../src/stm32f30x_rtc.c ****   RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
 2329              		.loc 1 1492 0
 2330 0ef4 4FF42053 		mov	r3, #10240
 2331 0ef8 C4F20003 		movt	r3, 16384
 2332 0efc 7A68     		ldr	r2, [r7, #4]
 2333 0efe 5A61     		str	r2, [r3, #20]
1493:../src/stm32f30x_rtc.c ****   
1494:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1495:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2334              		.loc 1 1495 0
 2335 0f00 4FF42053 		mov	r3, #10240
 2336 0f04 C4F20003 		movt	r3, 16384
 2337 0f08 4FF0FF02 		mov	r2, #255
 2338 0f0c 5A62     		str	r2, [r3, #36]
1496:../src/stm32f30x_rtc.c **** }
 2339              		.loc 1 1496 0
 2340 0f0e 07F10C07 		add	r7, r7, #12
 2341 0f12 BD46     		mov	sp, r7
 2342 0f14 80BC     		pop	{r7}
 2343 0f16 7047     		bx	lr
 2344              		.cfi_endproc
 2345              	.LFE134:
 2347              		.align	2
 2348              		.global	RTC_GetWakeUpCounter
 2349              		.thumb
 2350              		.thumb_func
 2352              	RTC_GetWakeUpCounter:
 2353              	.LFB135:
1497:../src/stm32f30x_rtc.c **** 
1498:../src/stm32f30x_rtc.c **** /**
1499:../src/stm32f30x_rtc.c ****   * @brief  Returns the RTC WakeUp timer counter value.
1500:../src/stm32f30x_rtc.c ****   * @param  None
1501:../src/stm32f30x_rtc.c ****   * @retval The RTC WakeUp Counter value.
1502:../src/stm32f30x_rtc.c ****   */
1503:../src/stm32f30x_rtc.c **** uint32_t RTC_GetWakeUpCounter(void)
1504:../src/stm32f30x_rtc.c **** {
 2354              		.loc 1 1504 0
 2355              		.cfi_startproc
 2356              		@ args = 0, pretend = 0, frame = 0
 2357              		@ frame_needed = 1, uses_anonymous_args = 0
 2358              		@ link register save eliminated.
 2359 0f18 80B4     		push	{r7}
 2360              	.LCFI71:
 2361              		.cfi_def_cfa_offset 4
 2362              		.cfi_offset 7, -4
 2363 0f1a 00AF     		add	r7, sp, #0
 2364              	.LCFI72:
 2365              		.cfi_def_cfa_register 7
1505:../src/stm32f30x_rtc.c ****   /* Get the counter value */
1506:../src/stm32f30x_rtc.c ****   return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
 2366              		.loc 1 1506 0
 2367 0f1c 4FF42053 		mov	r3, #10240
 2368 0f20 C4F20003 		movt	r3, 16384
 2369 0f24 5B69     		ldr	r3, [r3, #20]
 2370 0f26 4FEA0343 		lsl	r3, r3, #16
 2371 0f2a 4FEA1343 		lsr	r3, r3, #16
1507:../src/stm32f30x_rtc.c **** }
 2372              		.loc 1 1507 0
 2373 0f2e 1846     		mov	r0, r3
 2374 0f30 BD46     		mov	sp, r7
 2375 0f32 80BC     		pop	{r7}
 2376 0f34 7047     		bx	lr
 2377              		.cfi_endproc
 2378              	.LFE135:
 2380 0f36 00BF     		.align	2
 2381              		.global	RTC_WakeUpCmd
 2382              		.thumb
 2383              		.thumb_func
 2385              	RTC_WakeUpCmd:
 2386              	.LFB136:
1508:../src/stm32f30x_rtc.c **** 
1509:../src/stm32f30x_rtc.c **** /**
1510:../src/stm32f30x_rtc.c ****   * @brief  Enables or Disables the RTC WakeUp timer.
1511:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the WakeUp timer.
1512:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.
1513:../src/stm32f30x_rtc.c ****   * @retval None
1514:../src/stm32f30x_rtc.c ****   */
1515:../src/stm32f30x_rtc.c **** ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
1516:../src/stm32f30x_rtc.c **** {
 2387              		.loc 1 1516 0
 2388              		.cfi_startproc
 2389              		@ args = 0, pretend = 0, frame = 24
 2390              		@ frame_needed = 1, uses_anonymous_args = 0
 2391              		@ link register save eliminated.
 2392 0f38 80B4     		push	{r7}
 2393              	.LCFI73:
 2394              		.cfi_def_cfa_offset 4
 2395              		.cfi_offset 7, -4
 2396 0f3a 87B0     		sub	sp, sp, #28
 2397              	.LCFI74:
 2398              		.cfi_def_cfa_offset 32
 2399 0f3c 00AF     		add	r7, sp, #0
 2400              	.LCFI75:
 2401              		.cfi_def_cfa_register 7
 2402 0f3e 0346     		mov	r3, r0
 2403 0f40 FB71     		strb	r3, [r7, #7]
1517:../src/stm32f30x_rtc.c ****   __IO uint32_t wutcounter = 0x00;
 2404              		.loc 1 1517 0
 2405 0f42 4FF00003 		mov	r3, #0
 2406 0f46 FB60     		str	r3, [r7, #12]
1518:../src/stm32f30x_rtc.c ****   uint32_t wutwfstatus = 0x00;
 2407              		.loc 1 1518 0
 2408 0f48 4FF00003 		mov	r3, #0
 2409 0f4c 3B61     		str	r3, [r7, #16]
1519:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 2410              		.loc 1 1519 0
 2411 0f4e 4FF00003 		mov	r3, #0
 2412 0f52 FB75     		strb	r3, [r7, #23]
1520:../src/stm32f30x_rtc.c ****   
1521:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1522:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1523:../src/stm32f30x_rtc.c **** 
1524:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1525:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2413              		.loc 1 1525 0
 2414 0f54 4FF42053 		mov	r3, #10240
 2415 0f58 C4F20003 		movt	r3, 16384
 2416 0f5c 4FF0CA02 		mov	r2, #202
 2417 0f60 5A62     		str	r2, [r3, #36]
1526:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2418              		.loc 1 1526 0
 2419 0f62 4FF42053 		mov	r3, #10240
 2420 0f66 C4F20003 		movt	r3, 16384
 2421 0f6a 4FF05302 		mov	r2, #83
 2422 0f6e 5A62     		str	r2, [r3, #36]
1527:../src/stm32f30x_rtc.c **** 
1528:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 2423              		.loc 1 1528 0
 2424 0f70 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2425 0f72 002B     		cmp	r3, #0
 2426 0f74 0FD0     		beq	.L106
1529:../src/stm32f30x_rtc.c ****   {
1530:../src/stm32f30x_rtc.c ****     /* Enable the Wakeup Timer */
1531:../src/stm32f30x_rtc.c ****     RTC->CR |= (uint32_t)RTC_CR_WUTE;
 2427              		.loc 1 1531 0
 2428 0f76 4FF42053 		mov	r3, #10240
 2429 0f7a C4F20003 		movt	r3, 16384
 2430 0f7e 4FF42052 		mov	r2, #10240
 2431 0f82 C4F20002 		movt	r2, 16384
 2432 0f86 9268     		ldr	r2, [r2, #8]
 2433 0f88 42F48062 		orr	r2, r2, #1024
 2434 0f8c 9A60     		str	r2, [r3, #8]
1532:../src/stm32f30x_rtc.c ****     status = SUCCESS;    
 2435              		.loc 1 1532 0
 2436 0f8e 4FF00103 		mov	r3, #1
 2437 0f92 FB75     		strb	r3, [r7, #23]
 2438 0f94 2EE0     		b	.L107
 2439              	.L106:
1533:../src/stm32f30x_rtc.c ****   }
1534:../src/stm32f30x_rtc.c ****   else
1535:../src/stm32f30x_rtc.c ****   {
1536:../src/stm32f30x_rtc.c ****     /* Disable the Wakeup Timer */
1537:../src/stm32f30x_rtc.c ****     RTC->CR &= (uint32_t)~RTC_CR_WUTE;
 2440              		.loc 1 1537 0
 2441 0f96 4FF42053 		mov	r3, #10240
 2442 0f9a C4F20003 		movt	r3, 16384
 2443 0f9e 4FF42052 		mov	r2, #10240
 2444 0fa2 C4F20002 		movt	r2, 16384
 2445 0fa6 9268     		ldr	r2, [r2, #8]
 2446 0fa8 22F48062 		bic	r2, r2, #1024
 2447 0fac 9A60     		str	r2, [r3, #8]
 2448              	.L109:
1538:../src/stm32f30x_rtc.c ****     /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
1539:../src/stm32f30x_rtc.c ****     do
1540:../src/stm32f30x_rtc.c ****     {
1541:../src/stm32f30x_rtc.c ****       wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 2449              		.loc 1 1541 0 discriminator 1
 2450 0fae 4FF42053 		mov	r3, #10240
 2451 0fb2 C4F20003 		movt	r3, 16384
 2452 0fb6 DB68     		ldr	r3, [r3, #12]
 2453 0fb8 03F00403 		and	r3, r3, #4
 2454 0fbc 3B61     		str	r3, [r7, #16]
1542:../src/stm32f30x_rtc.c ****       wutcounter++;  
 2455              		.loc 1 1542 0 discriminator 1
 2456 0fbe FB68     		ldr	r3, [r7, #12]
 2457 0fc0 03F10103 		add	r3, r3, #1
 2458 0fc4 FB60     		str	r3, [r7, #12]
1543:../src/stm32f30x_rtc.c ****     } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 2459              		.loc 1 1543 0 discriminator 1
 2460 0fc6 FB68     		ldr	r3, [r7, #12]
 2461 0fc8 B3F5005F 		cmp	r3, #8192
 2462 0fcc 02D0     		beq	.L108
 2463 0fce 3B69     		ldr	r3, [r7, #16]
 2464 0fd0 002B     		cmp	r3, #0
 2465 0fd2 ECD0     		beq	.L109
 2466              	.L108:
1544:../src/stm32f30x_rtc.c ****     
1545:../src/stm32f30x_rtc.c ****     if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 2467              		.loc 1 1545 0
 2468 0fd4 4FF42053 		mov	r3, #10240
 2469 0fd8 C4F20003 		movt	r3, 16384
 2470 0fdc DB68     		ldr	r3, [r3, #12]
 2471 0fde 03F00403 		and	r3, r3, #4
 2472 0fe2 002B     		cmp	r3, #0
 2473 0fe4 03D1     		bne	.L110
1546:../src/stm32f30x_rtc.c ****     {
1547:../src/stm32f30x_rtc.c ****       status = ERROR;
 2474              		.loc 1 1547 0
 2475 0fe6 4FF00003 		mov	r3, #0
 2476 0fea FB75     		strb	r3, [r7, #23]
 2477 0fec 02E0     		b	.L107
 2478              	.L110:
1548:../src/stm32f30x_rtc.c ****     }
1549:../src/stm32f30x_rtc.c ****     else
1550:../src/stm32f30x_rtc.c ****     {
1551:../src/stm32f30x_rtc.c ****       status = SUCCESS;
 2479              		.loc 1 1551 0
 2480 0fee 4FF00103 		mov	r3, #1
 2481 0ff2 FB75     		strb	r3, [r7, #23]
 2482              	.L107:
1552:../src/stm32f30x_rtc.c ****     }    
1553:../src/stm32f30x_rtc.c ****   }
1554:../src/stm32f30x_rtc.c **** 
1555:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1556:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2483              		.loc 1 1556 0
 2484 0ff4 4FF42053 		mov	r3, #10240
 2485 0ff8 C4F20003 		movt	r3, 16384
 2486 0ffc 4FF0FF02 		mov	r2, #255
 2487 1000 5A62     		str	r2, [r3, #36]
1557:../src/stm32f30x_rtc.c ****   
1558:../src/stm32f30x_rtc.c ****   return status;
 2488              		.loc 1 1558 0
 2489 1002 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1559:../src/stm32f30x_rtc.c **** }
 2490              		.loc 1 1559 0
 2491 1004 1846     		mov	r0, r3
 2492 1006 07F11C07 		add	r7, r7, #28
 2493 100a BD46     		mov	sp, r7
 2494 100c 80BC     		pop	{r7}
 2495 100e 7047     		bx	lr
 2496              		.cfi_endproc
 2497              	.LFE136:
 2499              		.align	2
 2500              		.global	RTC_DayLightSavingConfig
 2501              		.thumb
 2502              		.thumb_func
 2504              	RTC_DayLightSavingConfig:
 2505              	.LFB137:
1560:../src/stm32f30x_rtc.c **** 
1561:../src/stm32f30x_rtc.c **** /**
1562:../src/stm32f30x_rtc.c ****   * @}
1563:../src/stm32f30x_rtc.c ****   */
1564:../src/stm32f30x_rtc.c **** 
1565:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group5 Daylight Saving configuration functions
1566:../src/stm32f30x_rtc.c ****  *  @brief   Daylight Saving configuration functions 
1567:../src/stm32f30x_rtc.c ****  *
1568:../src/stm32f30x_rtc.c **** @verbatim   
1569:../src/stm32f30x_rtc.c ****  ===============================================================================
1570:../src/stm32f30x_rtc.c ****                 ##### Daylight Saving configuration functions #####
1571:../src/stm32f30x_rtc.c ****  ===============================================================================  
1572:../src/stm32f30x_rtc.c ****     [..] This section provide functions allowing to configure the RTC DayLight Saving.
1573:../src/stm32f30x_rtc.c **** 
1574:../src/stm32f30x_rtc.c **** @endverbatim
1575:../src/stm32f30x_rtc.c ****   * @{
1576:../src/stm32f30x_rtc.c ****   */
1577:../src/stm32f30x_rtc.c **** 
1578:../src/stm32f30x_rtc.c **** /**
1579:../src/stm32f30x_rtc.c ****   * @brief  Adds or substract one hour from the current time.
1580:../src/stm32f30x_rtc.c ****   * @param  RTC_DayLightSaveOperation: the value of hour adjustment. 
1581:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1582:../src/stm32f30x_rtc.c ****   *     @arg RTC_DayLightSaving_SUB1H: Substract one hour (winter time)
1583:../src/stm32f30x_rtc.c ****   *     @arg RTC_DayLightSaving_ADD1H: Add one hour (summer time)
1584:../src/stm32f30x_rtc.c ****   * @param  RTC_StoreOperation: Specifies the value to be written in the BCK bit 
1585:../src/stm32f30x_rtc.c ****   *                            in CR register to store the operation.
1586:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1587:../src/stm32f30x_rtc.c ****   *     @arg RTC_StoreOperation_Reset: BCK Bit Reset
1588:../src/stm32f30x_rtc.c ****   *     @arg RTC_StoreOperation_Set: BCK Bit Set
1589:../src/stm32f30x_rtc.c ****   * @retval None
1590:../src/stm32f30x_rtc.c ****   */
1591:../src/stm32f30x_rtc.c **** void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
1592:../src/stm32f30x_rtc.c **** {
 2506              		.loc 1 1592 0
 2507              		.cfi_startproc
 2508              		@ args = 0, pretend = 0, frame = 8
 2509              		@ frame_needed = 1, uses_anonymous_args = 0
 2510              		@ link register save eliminated.
 2511 1010 80B4     		push	{r7}
 2512              	.LCFI76:
 2513              		.cfi_def_cfa_offset 4
 2514              		.cfi_offset 7, -4
 2515 1012 83B0     		sub	sp, sp, #12
 2516              	.LCFI77:
 2517              		.cfi_def_cfa_offset 16
 2518 1014 00AF     		add	r7, sp, #0
 2519              	.LCFI78:
 2520              		.cfi_def_cfa_register 7
 2521 1016 7860     		str	r0, [r7, #4]
 2522 1018 3960     		str	r1, [r7, #0]
1593:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1594:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
1595:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
1596:../src/stm32f30x_rtc.c **** 
1597:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1598:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2523              		.loc 1 1598 0
 2524 101a 4FF42053 		mov	r3, #10240
 2525 101e C4F20003 		movt	r3, 16384
 2526 1022 4FF0CA02 		mov	r2, #202
 2527 1026 5A62     		str	r2, [r3, #36]
1599:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2528              		.loc 1 1599 0
 2529 1028 4FF42053 		mov	r3, #10240
 2530 102c C4F20003 		movt	r3, 16384
 2531 1030 4FF05302 		mov	r2, #83
 2532 1034 5A62     		str	r2, [r3, #36]
1600:../src/stm32f30x_rtc.c **** 
1601:../src/stm32f30x_rtc.c ****   /* Clear the bits to be configured */
1602:../src/stm32f30x_rtc.c ****   RTC->CR &= (uint32_t)~(RTC_CR_BCK);
 2533              		.loc 1 1602 0
 2534 1036 4FF42053 		mov	r3, #10240
 2535 103a C4F20003 		movt	r3, 16384
 2536 103e 4FF42052 		mov	r2, #10240
 2537 1042 C4F20002 		movt	r2, 16384
 2538 1046 9268     		ldr	r2, [r2, #8]
 2539 1048 22F48022 		bic	r2, r2, #262144
 2540 104c 9A60     		str	r2, [r3, #8]
1603:../src/stm32f30x_rtc.c **** 
1604:../src/stm32f30x_rtc.c ****   /* Configure the RTC_CR register */
1605:../src/stm32f30x_rtc.c ****   RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
 2541              		.loc 1 1605 0
 2542 104e 4FF42053 		mov	r3, #10240
 2543 1052 C4F20003 		movt	r3, 16384
 2544 1056 4FF42052 		mov	r2, #10240
 2545 105a C4F20002 		movt	r2, 16384
 2546 105e 9168     		ldr	r1, [r2, #8]
 2547 1060 7868     		ldr	r0, [r7, #4]
 2548 1062 3A68     		ldr	r2, [r7, #0]
 2549 1064 0243     		orrs	r2, r2, r0
 2550 1066 0A43     		orrs	r2, r2, r1
 2551 1068 9A60     		str	r2, [r3, #8]
1606:../src/stm32f30x_rtc.c **** 
1607:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1608:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2552              		.loc 1 1608 0
 2553 106a 4FF42053 		mov	r3, #10240
 2554 106e C4F20003 		movt	r3, 16384
 2555 1072 4FF0FF02 		mov	r2, #255
 2556 1076 5A62     		str	r2, [r3, #36]
1609:../src/stm32f30x_rtc.c **** }
 2557              		.loc 1 1609 0
 2558 1078 07F10C07 		add	r7, r7, #12
 2559 107c BD46     		mov	sp, r7
 2560 107e 80BC     		pop	{r7}
 2561 1080 7047     		bx	lr
 2562              		.cfi_endproc
 2563              	.LFE137:
 2565 1082 00BF     		.align	2
 2566              		.global	RTC_GetStoreOperation
 2567              		.thumb
 2568              		.thumb_func
 2570              	RTC_GetStoreOperation:
 2571              	.LFB138:
1610:../src/stm32f30x_rtc.c **** 
1611:../src/stm32f30x_rtc.c **** /**
1612:../src/stm32f30x_rtc.c ****   * @brief  Returns the RTC Day Light Saving stored operation.
1613:../src/stm32f30x_rtc.c ****   * @param  None
1614:../src/stm32f30x_rtc.c ****   * @retval RTC Day Light Saving stored operation.
1615:../src/stm32f30x_rtc.c ****   *          - RTC_StoreOperation_Reset
1616:../src/stm32f30x_rtc.c ****   *          - RTC_StoreOperation_Set
1617:../src/stm32f30x_rtc.c ****   */
1618:../src/stm32f30x_rtc.c **** uint32_t RTC_GetStoreOperation(void)
1619:../src/stm32f30x_rtc.c **** {
 2572              		.loc 1 1619 0
 2573              		.cfi_startproc
 2574              		@ args = 0, pretend = 0, frame = 0
 2575              		@ frame_needed = 1, uses_anonymous_args = 0
 2576              		@ link register save eliminated.
 2577 1084 80B4     		push	{r7}
 2578              	.LCFI79:
 2579              		.cfi_def_cfa_offset 4
 2580              		.cfi_offset 7, -4
 2581 1086 00AF     		add	r7, sp, #0
 2582              	.LCFI80:
 2583              		.cfi_def_cfa_register 7
1620:../src/stm32f30x_rtc.c ****   return (RTC->CR & RTC_CR_BCK);
 2584              		.loc 1 1620 0
 2585 1088 4FF42053 		mov	r3, #10240
 2586 108c C4F20003 		movt	r3, 16384
 2587 1090 9B68     		ldr	r3, [r3, #8]
 2588 1092 03F48023 		and	r3, r3, #262144
1621:../src/stm32f30x_rtc.c **** }
 2589              		.loc 1 1621 0
 2590 1096 1846     		mov	r0, r3
 2591 1098 BD46     		mov	sp, r7
 2592 109a 80BC     		pop	{r7}
 2593 109c 7047     		bx	lr
 2594              		.cfi_endproc
 2595              	.LFE138:
 2597 109e 00BF     		.align	2
 2598              		.global	RTC_OutputConfig
 2599              		.thumb
 2600              		.thumb_func
 2602              	RTC_OutputConfig:
 2603              	.LFB139:
1622:../src/stm32f30x_rtc.c **** 
1623:../src/stm32f30x_rtc.c **** /**
1624:../src/stm32f30x_rtc.c ****   * @}
1625:../src/stm32f30x_rtc.c ****   */
1626:../src/stm32f30x_rtc.c **** 
1627:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group6 Output pin Configuration function
1628:../src/stm32f30x_rtc.c ****  *  @brief   Output pin Configuration function 
1629:../src/stm32f30x_rtc.c ****  *
1630:../src/stm32f30x_rtc.c **** @verbatim   
1631:../src/stm32f30x_rtc.c ****  ===============================================================================
1632:../src/stm32f30x_rtc.c ****                    ##### Output pin Configuration function #####
1633:../src/stm32f30x_rtc.c ****  ===============================================================================
1634:../src/stm32f30x_rtc.c ****     [..] This section provide functions allowing to configure the RTC Output source.
1635:../src/stm32f30x_rtc.c **** 
1636:../src/stm32f30x_rtc.c **** @endverbatim
1637:../src/stm32f30x_rtc.c ****   * @{
1638:../src/stm32f30x_rtc.c ****   */
1639:../src/stm32f30x_rtc.c **** 
1640:../src/stm32f30x_rtc.c **** /**
1641:../src/stm32f30x_rtc.c ****   * @brief  Configures the RTC output source (AFO_ALARM).
1642:../src/stm32f30x_rtc.c ****   * @param  RTC_Output: Specifies which signal will be routed to the RTC output. 
1643:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1644:../src/stm32f30x_rtc.c ****   *     @arg RTC_Output_Disable: No output selected
1645:../src/stm32f30x_rtc.c ****   *     @arg RTC_Output_AlarmA: signal of AlarmA mapped to output
1646:../src/stm32f30x_rtc.c ****   *     @arg RTC_Output_AlarmB: signal of AlarmB mapped to output
1647:../src/stm32f30x_rtc.c ****   *     @arg RTC_Output_WakeUp: signal of WakeUp mapped to output
1648:../src/stm32f30x_rtc.c ****   * @param  RTC_OutputPolarity: Specifies the polarity of the output signal. 
1649:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following:
1650:../src/stm32f30x_rtc.c ****   *     @arg RTC_OutputPolarity_High: The output pin is high when the 
1651:../src/stm32f30x_rtc.c ****   *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
1652:../src/stm32f30x_rtc.c ****   *     @arg RTC_OutputPolarity_Low: The output pin is low when the 
1653:../src/stm32f30x_rtc.c ****   *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
1654:../src/stm32f30x_rtc.c ****   * @retval None
1655:../src/stm32f30x_rtc.c ****   */
1656:../src/stm32f30x_rtc.c **** void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
1657:../src/stm32f30x_rtc.c **** {
 2604              		.loc 1 1657 0
 2605              		.cfi_startproc
 2606              		@ args = 0, pretend = 0, frame = 8
 2607              		@ frame_needed = 1, uses_anonymous_args = 0
 2608              		@ link register save eliminated.
 2609 10a0 80B4     		push	{r7}
 2610              	.LCFI81:
 2611              		.cfi_def_cfa_offset 4
 2612              		.cfi_offset 7, -4
 2613 10a2 83B0     		sub	sp, sp, #12
 2614              	.LCFI82:
 2615              		.cfi_def_cfa_offset 16
 2616 10a4 00AF     		add	r7, sp, #0
 2617              	.LCFI83:
 2618              		.cfi_def_cfa_register 7
 2619 10a6 7860     		str	r0, [r7, #4]
 2620 10a8 3960     		str	r1, [r7, #0]
1658:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1659:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_OUTPUT(RTC_Output));
1660:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
1661:../src/stm32f30x_rtc.c **** 
1662:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1663:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2621              		.loc 1 1663 0
 2622 10aa 4FF42053 		mov	r3, #10240
 2623 10ae C4F20003 		movt	r3, 16384
 2624 10b2 4FF0CA02 		mov	r2, #202
 2625 10b6 5A62     		str	r2, [r3, #36]
1664:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2626              		.loc 1 1664 0
 2627 10b8 4FF42053 		mov	r3, #10240
 2628 10bc C4F20003 		movt	r3, 16384
 2629 10c0 4FF05302 		mov	r2, #83
 2630 10c4 5A62     		str	r2, [r3, #36]
1665:../src/stm32f30x_rtc.c **** 
1666:../src/stm32f30x_rtc.c ****   /* Clear the bits to be configured */
1667:../src/stm32f30x_rtc.c ****   RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
 2631              		.loc 1 1667 0
 2632 10c6 4FF42053 		mov	r3, #10240
 2633 10ca C4F20003 		movt	r3, 16384
 2634 10ce 4FF42052 		mov	r2, #10240
 2635 10d2 C4F20002 		movt	r2, 16384
 2636 10d6 9268     		ldr	r2, [r2, #8]
 2637 10d8 22F4E002 		bic	r2, r2, #7340032
 2638 10dc 9A60     		str	r2, [r3, #8]
1668:../src/stm32f30x_rtc.c **** 
1669:../src/stm32f30x_rtc.c ****   /* Configure the output selection and polarity */
1670:../src/stm32f30x_rtc.c ****   RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
 2639              		.loc 1 1670 0
 2640 10de 4FF42053 		mov	r3, #10240
 2641 10e2 C4F20003 		movt	r3, 16384
 2642 10e6 4FF42052 		mov	r2, #10240
 2643 10ea C4F20002 		movt	r2, 16384
 2644 10ee 9168     		ldr	r1, [r2, #8]
 2645 10f0 7868     		ldr	r0, [r7, #4]
 2646 10f2 3A68     		ldr	r2, [r7, #0]
 2647 10f4 0243     		orrs	r2, r2, r0
 2648 10f6 0A43     		orrs	r2, r2, r1
 2649 10f8 9A60     		str	r2, [r3, #8]
1671:../src/stm32f30x_rtc.c **** 
1672:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1673:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2650              		.loc 1 1673 0
 2651 10fa 4FF42053 		mov	r3, #10240
 2652 10fe C4F20003 		movt	r3, 16384
 2653 1102 4FF0FF02 		mov	r2, #255
 2654 1106 5A62     		str	r2, [r3, #36]
1674:../src/stm32f30x_rtc.c **** }
 2655              		.loc 1 1674 0
 2656 1108 07F10C07 		add	r7, r7, #12
 2657 110c BD46     		mov	sp, r7
 2658 110e 80BC     		pop	{r7}
 2659 1110 7047     		bx	lr
 2660              		.cfi_endproc
 2661              	.LFE139:
 2663 1112 00BF     		.align	2
 2664              		.global	RTC_CalibOutputCmd
 2665              		.thumb
 2666              		.thumb_func
 2668              	RTC_CalibOutputCmd:
 2669              	.LFB140:
1675:../src/stm32f30x_rtc.c **** 
1676:../src/stm32f30x_rtc.c **** /**
1677:../src/stm32f30x_rtc.c ****   * @}
1678:../src/stm32f30x_rtc.c ****   */
1679:../src/stm32f30x_rtc.c **** 
1680:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group7 Digital Calibration configuration functions
1681:../src/stm32f30x_rtc.c ****  *  @brief   Digital Calibration configuration functions 
1682:../src/stm32f30x_rtc.c ****  *
1683:../src/stm32f30x_rtc.c **** @verbatim   
1684:../src/stm32f30x_rtc.c ****  ===============================================================================
1685:../src/stm32f30x_rtc.c ****             ##### Digital Calibration configuration functions #####
1686:../src/stm32f30x_rtc.c ****  ===============================================================================
1687:../src/stm32f30x_rtc.c **** 
1688:../src/stm32f30x_rtc.c **** @endverbatim
1689:../src/stm32f30x_rtc.c ****   * @{
1690:../src/stm32f30x_rtc.c ****   */
1691:../src/stm32f30x_rtc.c **** 
1692:../src/stm32f30x_rtc.c **** /**
1693:../src/stm32f30x_rtc.c ****   * @brief  Enables or disables the RTC clock to be output through the relative 
1694:../src/stm32f30x_rtc.c ****   *         pin.
1695:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the digital calibration Output.
1696:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.
1697:../src/stm32f30x_rtc.c ****   * @retval None
1698:../src/stm32f30x_rtc.c ****   */
1699:../src/stm32f30x_rtc.c **** void RTC_CalibOutputCmd(FunctionalState NewState)
1700:../src/stm32f30x_rtc.c **** {
 2670              		.loc 1 1700 0
 2671              		.cfi_startproc
 2672              		@ args = 0, pretend = 0, frame = 8
 2673              		@ frame_needed = 1, uses_anonymous_args = 0
 2674              		@ link register save eliminated.
 2675 1114 80B4     		push	{r7}
 2676              	.LCFI84:
 2677              		.cfi_def_cfa_offset 4
 2678              		.cfi_offset 7, -4
 2679 1116 83B0     		sub	sp, sp, #12
 2680              	.LCFI85:
 2681              		.cfi_def_cfa_offset 16
 2682 1118 00AF     		add	r7, sp, #0
 2683              	.LCFI86:
 2684              		.cfi_def_cfa_register 7
 2685 111a 0346     		mov	r3, r0
 2686 111c FB71     		strb	r3, [r7, #7]
1701:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1702:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1703:../src/stm32f30x_rtc.c ****   
1704:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1705:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2687              		.loc 1 1705 0
 2688 111e 4FF42053 		mov	r3, #10240
 2689 1122 C4F20003 		movt	r3, 16384
 2690 1126 4FF0CA02 		mov	r2, #202
 2691 112a 5A62     		str	r2, [r3, #36]
1706:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2692              		.loc 1 1706 0
 2693 112c 4FF42053 		mov	r3, #10240
 2694 1130 C4F20003 		movt	r3, 16384
 2695 1134 4FF05302 		mov	r2, #83
 2696 1138 5A62     		str	r2, [r3, #36]
1707:../src/stm32f30x_rtc.c ****   
1708:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 2697              		.loc 1 1708 0
 2698 113a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2699 113c 002B     		cmp	r3, #0
 2700 113e 0CD0     		beq	.L117
1709:../src/stm32f30x_rtc.c ****   {
1710:../src/stm32f30x_rtc.c ****     /* Enable the RTC clock output */
1711:../src/stm32f30x_rtc.c ****     RTC->CR |= (uint32_t)RTC_CR_COE;
 2701              		.loc 1 1711 0
 2702 1140 4FF42053 		mov	r3, #10240
 2703 1144 C4F20003 		movt	r3, 16384
 2704 1148 4FF42052 		mov	r2, #10240
 2705 114c C4F20002 		movt	r2, 16384
 2706 1150 9268     		ldr	r2, [r2, #8]
 2707 1152 42F40002 		orr	r2, r2, #8388608
 2708 1156 9A60     		str	r2, [r3, #8]
 2709 1158 0BE0     		b	.L118
 2710              	.L117:
1712:../src/stm32f30x_rtc.c ****   }
1713:../src/stm32f30x_rtc.c ****   else
1714:../src/stm32f30x_rtc.c ****   { 
1715:../src/stm32f30x_rtc.c ****     /* Disable the RTC clock output */
1716:../src/stm32f30x_rtc.c ****     RTC->CR &= (uint32_t)~RTC_CR_COE;
 2711              		.loc 1 1716 0
 2712 115a 4FF42053 		mov	r3, #10240
 2713 115e C4F20003 		movt	r3, 16384
 2714 1162 4FF42052 		mov	r2, #10240
 2715 1166 C4F20002 		movt	r2, 16384
 2716 116a 9268     		ldr	r2, [r2, #8]
 2717 116c 22F40002 		bic	r2, r2, #8388608
 2718 1170 9A60     		str	r2, [r3, #8]
 2719              	.L118:
1717:../src/stm32f30x_rtc.c ****   }
1718:../src/stm32f30x_rtc.c ****   
1719:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1720:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF; 
 2720              		.loc 1 1720 0
 2721 1172 4FF42053 		mov	r3, #10240
 2722 1176 C4F20003 		movt	r3, 16384
 2723 117a 4FF0FF02 		mov	r2, #255
 2724 117e 5A62     		str	r2, [r3, #36]
1721:../src/stm32f30x_rtc.c **** }
 2725              		.loc 1 1721 0
 2726 1180 07F10C07 		add	r7, r7, #12
 2727 1184 BD46     		mov	sp, r7
 2728 1186 80BC     		pop	{r7}
 2729 1188 7047     		bx	lr
 2730              		.cfi_endproc
 2731              	.LFE140:
 2733 118a 00BF     		.align	2
 2734              		.global	RTC_CalibOutputConfig
 2735              		.thumb
 2736              		.thumb_func
 2738              	RTC_CalibOutputConfig:
 2739              	.LFB141:
1722:../src/stm32f30x_rtc.c **** 
1723:../src/stm32f30x_rtc.c **** /**
1724:../src/stm32f30x_rtc.c ****   * @brief  Configures the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
1725:../src/stm32f30x_rtc.c ****   * @param  RTC_CalibOutput : Select the Calibration output Selection .
1726:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1727:../src/stm32f30x_rtc.c ****   *     @arg RTC_CalibOutput_512Hz: A signal has a regular waveform at 512Hz. 
1728:../src/stm32f30x_rtc.c ****   *     @arg RTC_CalibOutput_1Hz  : A signal has a regular waveform at 1Hz.
1729:../src/stm32f30x_rtc.c ****   * @retval None
1730:../src/stm32f30x_rtc.c **** */
1731:../src/stm32f30x_rtc.c **** void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
1732:../src/stm32f30x_rtc.c **** {
 2740              		.loc 1 1732 0
 2741              		.cfi_startproc
 2742              		@ args = 0, pretend = 0, frame = 8
 2743              		@ frame_needed = 1, uses_anonymous_args = 0
 2744              		@ link register save eliminated.
 2745 118c 80B4     		push	{r7}
 2746              	.LCFI87:
 2747              		.cfi_def_cfa_offset 4
 2748              		.cfi_offset 7, -4
 2749 118e 83B0     		sub	sp, sp, #12
 2750              	.LCFI88:
 2751              		.cfi_def_cfa_offset 16
 2752 1190 00AF     		add	r7, sp, #0
 2753              	.LCFI89:
 2754              		.cfi_def_cfa_register 7
 2755 1192 7860     		str	r0, [r7, #4]
1733:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1734:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
1735:../src/stm32f30x_rtc.c **** 
1736:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1737:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2756              		.loc 1 1737 0
 2757 1194 4FF42053 		mov	r3, #10240
 2758 1198 C4F20003 		movt	r3, 16384
 2759 119c 4FF0CA02 		mov	r2, #202
 2760 11a0 5A62     		str	r2, [r3, #36]
1738:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2761              		.loc 1 1738 0
 2762 11a2 4FF42053 		mov	r3, #10240
 2763 11a6 C4F20003 		movt	r3, 16384
 2764 11aa 4FF05302 		mov	r2, #83
 2765 11ae 5A62     		str	r2, [r3, #36]
1739:../src/stm32f30x_rtc.c ****   
1740:../src/stm32f30x_rtc.c ****   /*clear flags before config*/
1741:../src/stm32f30x_rtc.c ****   RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
 2766              		.loc 1 1741 0
 2767 11b0 4FF42053 		mov	r3, #10240
 2768 11b4 C4F20003 		movt	r3, 16384
 2769 11b8 4FF42052 		mov	r2, #10240
 2770 11bc C4F20002 		movt	r2, 16384
 2771 11c0 9268     		ldr	r2, [r2, #8]
 2772 11c2 22F40022 		bic	r2, r2, #524288
 2773 11c6 9A60     		str	r2, [r3, #8]
1742:../src/stm32f30x_rtc.c **** 
1743:../src/stm32f30x_rtc.c ****   /* Configure the RTC_CR register */
1744:../src/stm32f30x_rtc.c ****   RTC->CR |= (uint32_t)RTC_CalibOutput;
 2774              		.loc 1 1744 0
 2775 11c8 4FF42053 		mov	r3, #10240
 2776 11cc C4F20003 		movt	r3, 16384
 2777 11d0 4FF42052 		mov	r2, #10240
 2778 11d4 C4F20002 		movt	r2, 16384
 2779 11d8 9168     		ldr	r1, [r2, #8]
 2780 11da 7A68     		ldr	r2, [r7, #4]
 2781 11dc 0A43     		orrs	r2, r2, r1
 2782 11de 9A60     		str	r2, [r3, #8]
1745:../src/stm32f30x_rtc.c **** 
1746:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1747:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2783              		.loc 1 1747 0
 2784 11e0 4FF42053 		mov	r3, #10240
 2785 11e4 C4F20003 		movt	r3, 16384
 2786 11e8 4FF0FF02 		mov	r2, #255
 2787 11ec 5A62     		str	r2, [r3, #36]
1748:../src/stm32f30x_rtc.c **** }
 2788              		.loc 1 1748 0
 2789 11ee 07F10C07 		add	r7, r7, #12
 2790 11f2 BD46     		mov	sp, r7
 2791 11f4 80BC     		pop	{r7}
 2792 11f6 7047     		bx	lr
 2793              		.cfi_endproc
 2794              	.LFE141:
 2796              		.align	2
 2797              		.global	RTC_SmoothCalibConfig
 2798              		.thumb
 2799              		.thumb_func
 2801              	RTC_SmoothCalibConfig:
 2802              	.LFB142:
1749:../src/stm32f30x_rtc.c **** 
1750:../src/stm32f30x_rtc.c **** /**
1751:../src/stm32f30x_rtc.c ****   * @brief  Configures the Smooth Calibration Settings.
1752:../src/stm32f30x_rtc.c ****   * @param  RTC_SmoothCalibPeriod : Select the Smooth Calibration Period.
1753:../src/stm32f30x_rtc.c ****   *   This parameter can be can be one of the following values:
1754:../src/stm32f30x_rtc.c ****   *     @arg RTC_SmoothCalibPeriod_32sec : The smooth calibration periode is 32s.
1755:../src/stm32f30x_rtc.c ****   *     @arg RTC_SmoothCalibPeriod_16sec : The smooth calibration periode is 16s.
1756:../src/stm32f30x_rtc.c ****   *     @arg RTC_SmoothCalibPeriod_8sec  : The smooth calibartion periode is 8s.
1757:../src/stm32f30x_rtc.c ****   * @param  RTC_SmoothCalibPlusPulses : Select to Set or reset the CALP bit.
1758:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1759:../src/stm32f30x_rtc.c ****   *     @arg RTC_SmoothCalibPlusPulses_Set  : Add one RTCCLK puls every 2**11 pulses.
1760:../src/stm32f30x_rtc.c ****   *     @arg RTC_SmoothCalibPlusPulses_Reset: No RTCCLK pulses are added.
1761:../src/stm32f30x_rtc.c ****   * @param  RTC_SmouthCalibMinusPulsesValue: Select the value of CALM[8:0] bits.
1762:../src/stm32f30x_rtc.c ****   *   This parameter can be one any value from 0 to 0x000001FF.
1763:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
1764:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC Calib registers are configured
1765:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC Calib registers are not configured
1766:../src/stm32f30x_rtc.c **** */
1767:../src/stm32f30x_rtc.c **** ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
1768:../src/stm32f30x_rtc.c ****                                   uint32_t RTC_SmoothCalibPlusPulses,
1769:../src/stm32f30x_rtc.c ****                                   uint32_t RTC_SmouthCalibMinusPulsesValue)
1770:../src/stm32f30x_rtc.c **** {
 2803              		.loc 1 1770 0
 2804              		.cfi_startproc
 2805              		@ args = 0, pretend = 0, frame = 24
 2806              		@ frame_needed = 1, uses_anonymous_args = 0
 2807              		@ link register save eliminated.
 2808 11f8 80B4     		push	{r7}
 2809              	.LCFI90:
 2810              		.cfi_def_cfa_offset 4
 2811              		.cfi_offset 7, -4
 2812 11fa 87B0     		sub	sp, sp, #28
 2813              	.LCFI91:
 2814              		.cfi_def_cfa_offset 32
 2815 11fc 00AF     		add	r7, sp, #0
 2816              	.LCFI92:
 2817              		.cfi_def_cfa_register 7
 2818 11fe F860     		str	r0, [r7, #12]
 2819 1200 B960     		str	r1, [r7, #8]
 2820 1202 7A60     		str	r2, [r7, #4]
1771:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 2821              		.loc 1 1771 0
 2822 1204 4FF00003 		mov	r3, #0
 2823 1208 FB75     		strb	r3, [r7, #23]
1772:../src/stm32f30x_rtc.c ****   uint32_t recalpfcount = 0;
 2824              		.loc 1 1772 0
 2825 120a 4FF00003 		mov	r3, #0
 2826 120e 3B61     		str	r3, [r7, #16]
1773:../src/stm32f30x_rtc.c **** 
1774:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1775:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
1776:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
1777:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
1778:../src/stm32f30x_rtc.c **** 
1779:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1780:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2827              		.loc 1 1780 0
 2828 1210 4FF42053 		mov	r3, #10240
 2829 1214 C4F20003 		movt	r3, 16384
 2830 1218 4FF0CA02 		mov	r2, #202
 2831 121c 5A62     		str	r2, [r3, #36]
1781:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2832              		.loc 1 1781 0
 2833 121e 4FF42053 		mov	r3, #10240
 2834 1222 C4F20003 		movt	r3, 16384
 2835 1226 4FF05302 		mov	r2, #83
 2836 122a 5A62     		str	r2, [r3, #36]
1782:../src/stm32f30x_rtc.c ****   
1783:../src/stm32f30x_rtc.c ****   /* check if a calibration is pending*/
1784:../src/stm32f30x_rtc.c ****   if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
 2837              		.loc 1 1784 0
 2838 122c 4FF42053 		mov	r3, #10240
 2839 1230 C4F20003 		movt	r3, 16384
 2840 1234 DB68     		ldr	r3, [r3, #12]
 2841 1236 03F48033 		and	r3, r3, #65536
 2842 123a 002B     		cmp	r3, #0
 2843 123c 11D0     		beq	.L121
1785:../src/stm32f30x_rtc.c ****   {
1786:../src/stm32f30x_rtc.c ****     /* wait until the Calibration is completed*/
1787:../src/stm32f30x_rtc.c ****     while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 2844              		.loc 1 1787 0
 2845 123e 03E0     		b	.L122
 2846              	.L123:
1788:../src/stm32f30x_rtc.c ****     {
1789:../src/stm32f30x_rtc.c ****       recalpfcount++;
 2847              		.loc 1 1789 0
 2848 1240 3B69     		ldr	r3, [r7, #16]
 2849 1242 03F10103 		add	r3, r3, #1
 2850 1246 3B61     		str	r3, [r7, #16]
 2851              	.L122:
1787:../src/stm32f30x_rtc.c ****     while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 2852              		.loc 1 1787 0 discriminator 1
 2853 1248 4FF42053 		mov	r3, #10240
 2854 124c C4F20003 		movt	r3, 16384
 2855 1250 DB68     		ldr	r3, [r3, #12]
 2856 1252 03F48033 		and	r3, r3, #65536
 2857 1256 002B     		cmp	r3, #0
 2858 1258 03D0     		beq	.L121
1787:../src/stm32f30x_rtc.c ****     while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 2859              		.loc 1 1787 0 is_stmt 0 discriminator 2
 2860 125a 3B69     		ldr	r3, [r7, #16]
 2861 125c B3F5805F 		cmp	r3, #4096
 2862 1260 EED1     		bne	.L123
 2863              	.L121:
1790:../src/stm32f30x_rtc.c ****     }
1791:../src/stm32f30x_rtc.c ****   }
1792:../src/stm32f30x_rtc.c **** 
1793:../src/stm32f30x_rtc.c ****   /* check if the calibration pending is completed or if there is no calibration operation at all*/
1794:../src/stm32f30x_rtc.c ****   if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
 2864              		.loc 1 1794 0 is_stmt 1
 2865 1262 4FF42053 		mov	r3, #10240
 2866 1266 C4F20003 		movt	r3, 16384
 2867 126a DB68     		ldr	r3, [r3, #12]
 2868 126c 03F48033 		and	r3, r3, #65536
 2869 1270 002B     		cmp	r3, #0
 2870 1272 0DD1     		bne	.L124
1795:../src/stm32f30x_rtc.c ****   {
1796:../src/stm32f30x_rtc.c ****     /* Configure the Smooth calibration settings */
1797:../src/stm32f30x_rtc.c ****     RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | 
 2871              		.loc 1 1797 0
 2872 1274 4FF42053 		mov	r3, #10240
 2873 1278 C4F20003 		movt	r3, 16384
 2874 127c F968     		ldr	r1, [r7, #12]
 2875 127e BA68     		ldr	r2, [r7, #8]
 2876 1280 1143     		orrs	r1, r1, r2
 2877 1282 7A68     		ldr	r2, [r7, #4]
 2878 1284 0A43     		orrs	r2, r2, r1
 2879 1286 DA63     		str	r2, [r3, #60]
1798:../src/stm32f30x_rtc.c **** 
1799:../src/stm32f30x_rtc.c ****     status = SUCCESS;
 2880              		.loc 1 1799 0
 2881 1288 4FF00103 		mov	r3, #1
 2882 128c FB75     		strb	r3, [r7, #23]
 2883 128e 02E0     		b	.L125
 2884              	.L124:
1800:../src/stm32f30x_rtc.c ****   }
1801:../src/stm32f30x_rtc.c ****   else
1802:../src/stm32f30x_rtc.c ****   {
1803:../src/stm32f30x_rtc.c ****     status = ERROR;
 2885              		.loc 1 1803 0
 2886 1290 4FF00003 		mov	r3, #0
 2887 1294 FB75     		strb	r3, [r7, #23]
 2888              	.L125:
1804:../src/stm32f30x_rtc.c ****   }
1805:../src/stm32f30x_rtc.c **** 
1806:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1807:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2889              		.loc 1 1807 0
 2890 1296 4FF42053 		mov	r3, #10240
 2891 129a C4F20003 		movt	r3, 16384
 2892 129e 4FF0FF02 		mov	r2, #255
 2893 12a2 5A62     		str	r2, [r3, #36]
1808:../src/stm32f30x_rtc.c ****   
1809:../src/stm32f30x_rtc.c ****   return (ErrorStatus)(status);
 2894              		.loc 1 1809 0
 2895 12a4 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1810:../src/stm32f30x_rtc.c **** }
 2896              		.loc 1 1810 0
 2897 12a6 1846     		mov	r0, r3
 2898 12a8 07F11C07 		add	r7, r7, #28
 2899 12ac BD46     		mov	sp, r7
 2900 12ae 80BC     		pop	{r7}
 2901 12b0 7047     		bx	lr
 2902              		.cfi_endproc
 2903              	.LFE142:
 2905 12b2 00BF     		.align	2
 2906              		.global	RTC_TimeStampCmd
 2907              		.thumb
 2908              		.thumb_func
 2910              	RTC_TimeStampCmd:
 2911              	.LFB143:
1811:../src/stm32f30x_rtc.c **** 
1812:../src/stm32f30x_rtc.c **** /**
1813:../src/stm32f30x_rtc.c ****   * @}
1814:../src/stm32f30x_rtc.c ****   */
1815:../src/stm32f30x_rtc.c **** 
1816:../src/stm32f30x_rtc.c **** 
1817:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group8 TimeStamp configuration functions
1818:../src/stm32f30x_rtc.c ****  *  @brief   TimeStamp configuration functions 
1819:../src/stm32f30x_rtc.c ****  *
1820:../src/stm32f30x_rtc.c **** @verbatim   
1821:../src/stm32f30x_rtc.c ****  ===============================================================================
1822:../src/stm32f30x_rtc.c ****                 ##### TimeStamp configuration functions #####
1823:../src/stm32f30x_rtc.c ****  ===============================================================================  
1824:../src/stm32f30x_rtc.c **** 
1825:../src/stm32f30x_rtc.c **** @endverbatim
1826:../src/stm32f30x_rtc.c ****   * @{
1827:../src/stm32f30x_rtc.c ****   */
1828:../src/stm32f30x_rtc.c **** 
1829:../src/stm32f30x_rtc.c **** /**
1830:../src/stm32f30x_rtc.c ****   * @brief  Enables or Disables the RTC TimeStamp functionality with the 
1831:../src/stm32f30x_rtc.c ****   *         specified time stamp pin stimulating edge.
1832:../src/stm32f30x_rtc.c ****   * @param  RTC_TimeStampEdge: Specifies the pin edge on which the TimeStamp is 
1833:../src/stm32f30x_rtc.c ****   *         activated.
1834:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following:
1835:../src/stm32f30x_rtc.c ****   *     @arg RTC_TimeStampEdge_Rising: the Time stamp event occurs on the rising 
1836:../src/stm32f30x_rtc.c ****   *                                    edge of the related pin.
1837:../src/stm32f30x_rtc.c ****   *     @arg RTC_TimeStampEdge_Falling: the Time stamp event occurs on the 
1838:../src/stm32f30x_rtc.c ****   *                                     falling edge of the related pin.
1839:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the TimeStamp.
1840:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.
1841:../src/stm32f30x_rtc.c ****   * @retval None
1842:../src/stm32f30x_rtc.c ****   */
1843:../src/stm32f30x_rtc.c **** void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
1844:../src/stm32f30x_rtc.c **** {
 2912              		.loc 1 1844 0
 2913              		.cfi_startproc
 2914              		@ args = 0, pretend = 0, frame = 16
 2915              		@ frame_needed = 1, uses_anonymous_args = 0
 2916              		@ link register save eliminated.
 2917 12b4 80B4     		push	{r7}
 2918              	.LCFI93:
 2919              		.cfi_def_cfa_offset 4
 2920              		.cfi_offset 7, -4
 2921 12b6 85B0     		sub	sp, sp, #20
 2922              	.LCFI94:
 2923              		.cfi_def_cfa_offset 24
 2924 12b8 00AF     		add	r7, sp, #0
 2925              	.LCFI95:
 2926              		.cfi_def_cfa_register 7
 2927 12ba 7860     		str	r0, [r7, #4]
 2928 12bc 0B46     		mov	r3, r1
 2929 12be FB70     		strb	r3, [r7, #3]
1845:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 2930              		.loc 1 1845 0
 2931 12c0 4FF00003 		mov	r3, #0
 2932 12c4 FB60     		str	r3, [r7, #12]
1846:../src/stm32f30x_rtc.c **** 
1847:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1848:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
1849:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1850:../src/stm32f30x_rtc.c **** 
1851:../src/stm32f30x_rtc.c ****   /* Get the RTC_CR register and clear the bits to be configured */
1852:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 2933              		.loc 1 1852 0
 2934 12c6 4FF42053 		mov	r3, #10240
 2935 12ca C4F20003 		movt	r3, 16384
 2936 12ce 9B68     		ldr	r3, [r3, #8]
 2937 12d0 23F40063 		bic	r3, r3, #2048
 2938 12d4 23F00803 		bic	r3, r3, #8
 2939 12d8 FB60     		str	r3, [r7, #12]
1853:../src/stm32f30x_rtc.c **** 
1854:../src/stm32f30x_rtc.c ****   /* Get the new configuration */
1855:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 2940              		.loc 1 1855 0
 2941 12da FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2942 12dc 002B     		cmp	r3, #0
 2943 12de 06D0     		beq	.L128
1856:../src/stm32f30x_rtc.c ****   {
1857:../src/stm32f30x_rtc.c ****     tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
 2944              		.loc 1 1857 0
 2945 12e0 7A68     		ldr	r2, [r7, #4]
 2946 12e2 FB68     		ldr	r3, [r7, #12]
 2947 12e4 1343     		orrs	r3, r3, r2
 2948 12e6 43F40063 		orr	r3, r3, #2048
 2949 12ea FB60     		str	r3, [r7, #12]
 2950 12ec 03E0     		b	.L129
 2951              	.L128:
1858:../src/stm32f30x_rtc.c ****   }
1859:../src/stm32f30x_rtc.c ****   else
1860:../src/stm32f30x_rtc.c ****   {
1861:../src/stm32f30x_rtc.c ****     tmpreg |= (uint32_t)(RTC_TimeStampEdge);
 2952              		.loc 1 1861 0
 2953 12ee FA68     		ldr	r2, [r7, #12]
 2954 12f0 7B68     		ldr	r3, [r7, #4]
 2955 12f2 1343     		orrs	r3, r3, r2
 2956 12f4 FB60     		str	r3, [r7, #12]
 2957              	.L129:
1862:../src/stm32f30x_rtc.c ****   }
1863:../src/stm32f30x_rtc.c **** 
1864:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1865:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2958              		.loc 1 1865 0
 2959 12f6 4FF42053 		mov	r3, #10240
 2960 12fa C4F20003 		movt	r3, 16384
 2961 12fe 4FF0CA02 		mov	r2, #202
 2962 1302 5A62     		str	r2, [r3, #36]
1866:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2963              		.loc 1 1866 0
 2964 1304 4FF42053 		mov	r3, #10240
 2965 1308 C4F20003 		movt	r3, 16384
 2966 130c 4FF05302 		mov	r2, #83
 2967 1310 5A62     		str	r2, [r3, #36]
1867:../src/stm32f30x_rtc.c **** 
1868:../src/stm32f30x_rtc.c ****   /* Configure the Time Stamp TSEDGE and Enable bits */
1869:../src/stm32f30x_rtc.c ****   RTC->CR = (uint32_t)tmpreg;
 2968              		.loc 1 1869 0
 2969 1312 4FF42053 		mov	r3, #10240
 2970 1316 C4F20003 		movt	r3, 16384
 2971 131a FA68     		ldr	r2, [r7, #12]
 2972 131c 9A60     		str	r2, [r3, #8]
1870:../src/stm32f30x_rtc.c **** 
1871:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1872:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2973              		.loc 1 1872 0
 2974 131e 4FF42053 		mov	r3, #10240
 2975 1322 C4F20003 		movt	r3, 16384
 2976 1326 4FF0FF02 		mov	r2, #255
 2977 132a 5A62     		str	r2, [r3, #36]
1873:../src/stm32f30x_rtc.c **** }
 2978              		.loc 1 1873 0
 2979 132c 07F11407 		add	r7, r7, #20
 2980 1330 BD46     		mov	sp, r7
 2981 1332 80BC     		pop	{r7}
 2982 1334 7047     		bx	lr
 2983              		.cfi_endproc
 2984              	.LFE143:
 2986 1336 00BF     		.align	2
 2987              		.global	RTC_GetTimeStamp
 2988              		.thumb
 2989              		.thumb_func
 2991              	RTC_GetTimeStamp:
 2992              	.LFB144:
1874:../src/stm32f30x_rtc.c **** 
1875:../src/stm32f30x_rtc.c **** /**
1876:../src/stm32f30x_rtc.c ****   * @brief  Gets the RTC TimeStamp value and masks.
1877:../src/stm32f30x_rtc.c ****   * @param  RTC_Format: specifies the format of the output parameters.
1878:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1879:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BIN: Binary data format 
1880:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BCD: BCD data format
1881:../src/stm32f30x_rtc.c ****   * @param RTC_StampTimeStruct: pointer to a RTC_TimeTypeDef structure that will 
1882:../src/stm32f30x_rtc.c ****   *                             contains the TimeStamp time values. 
1883:../src/stm32f30x_rtc.c ****   * @param RTC_StampDateStruct: pointer to a RTC_DateTypeDef structure that will 
1884:../src/stm32f30x_rtc.c ****   *                             contains the TimeStamp date values.     
1885:../src/stm32f30x_rtc.c ****   * @retval None
1886:../src/stm32f30x_rtc.c ****   */
1887:../src/stm32f30x_rtc.c **** void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
1888:../src/stm32f30x_rtc.c ****                                       RTC_DateTypeDef* RTC_StampDateStruct)
1889:../src/stm32f30x_rtc.c **** {
 2993              		.loc 1 1889 0
 2994              		.cfi_startproc
 2995              		@ args = 0, pretend = 0, frame = 24
 2996              		@ frame_needed = 1, uses_anonymous_args = 0
 2997 1338 80B5     		push	{r7, lr}
 2998              	.LCFI96:
 2999              		.cfi_def_cfa_offset 8
 3000              		.cfi_offset 7, -8
 3001              		.cfi_offset 14, -4
 3002 133a 86B0     		sub	sp, sp, #24
 3003              	.LCFI97:
 3004              		.cfi_def_cfa_offset 32
 3005 133c 00AF     		add	r7, sp, #0
 3006              	.LCFI98:
 3007              		.cfi_def_cfa_register 7
 3008 133e F860     		str	r0, [r7, #12]
 3009 1340 B960     		str	r1, [r7, #8]
 3010 1342 7A60     		str	r2, [r7, #4]
1890:../src/stm32f30x_rtc.c ****   uint32_t tmptime = 0, tmpdate = 0;
 3011              		.loc 1 1890 0
 3012 1344 4FF00003 		mov	r3, #0
 3013 1348 7B61     		str	r3, [r7, #20]
 3014 134a 4FF00003 		mov	r3, #0
 3015 134e 3B61     		str	r3, [r7, #16]
1891:../src/stm32f30x_rtc.c **** 
1892:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1893:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
1894:../src/stm32f30x_rtc.c **** 
1895:../src/stm32f30x_rtc.c ****   /* Get the TimeStamp time and date registers values */
1896:../src/stm32f30x_rtc.c ****   tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
 3016              		.loc 1 1896 0
 3017 1350 4FF42053 		mov	r3, #10240
 3018 1354 C4F20003 		movt	r3, 16384
 3019 1358 1B6B     		ldr	r3, [r3, #48]
 3020 135a 03F07F33 		and	r3, r3, #2139062143
 3021 135e 23F0FE43 		bic	r3, r3, #2130706432
 3022 1362 7B61     		str	r3, [r7, #20]
1897:../src/stm32f30x_rtc.c ****   tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
 3023              		.loc 1 1897 0
 3024 1364 4FF42053 		mov	r3, #10240
 3025 1368 C4F20003 		movt	r3, 16384
 3026 136c 5B6B     		ldr	r3, [r3, #52]
 3027 136e 23F07F43 		bic	r3, r3, #-16777216
 3028 1372 23F0C003 		bic	r3, r3, #192
 3029 1376 3B61     		str	r3, [r7, #16]
1898:../src/stm32f30x_rtc.c **** 
1899:../src/stm32f30x_rtc.c ****   /* Fill the Time structure fields with the read parameters */
1900:../src/stm32f30x_rtc.c ****   RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 3030              		.loc 1 1900 0
 3031 1378 7B69     		ldr	r3, [r7, #20]
 3032 137a 03F47C13 		and	r3, r3, #4128768
 3033 137e 4FEA1343 		lsr	r3, r3, #16
 3034 1382 DAB2     		uxtb	r2, r3
 3035 1384 BB68     		ldr	r3, [r7, #8]
 3036 1386 1A70     		strb	r2, [r3, #0]
1901:../src/stm32f30x_rtc.c ****   RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
 3037              		.loc 1 1901 0
 3038 1388 7B69     		ldr	r3, [r7, #20]
 3039 138a 03F4FE43 		and	r3, r3, #32512
 3040 138e 4FEA1323 		lsr	r3, r3, #8
 3041 1392 DAB2     		uxtb	r2, r3
 3042 1394 BB68     		ldr	r3, [r7, #8]
 3043 1396 5A70     		strb	r2, [r3, #1]
1902:../src/stm32f30x_rtc.c ****   RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
 3044              		.loc 1 1902 0
 3045 1398 7B69     		ldr	r3, [r7, #20]
 3046 139a DBB2     		uxtb	r3, r3
 3047 139c 03F07F03 		and	r3, r3, #127
 3048 13a0 DAB2     		uxtb	r2, r3
 3049 13a2 BB68     		ldr	r3, [r7, #8]
 3050 13a4 9A70     		strb	r2, [r3, #2]
1903:../src/stm32f30x_rtc.c ****   RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
 3051              		.loc 1 1903 0
 3052 13a6 7B69     		ldr	r3, [r7, #20]
 3053 13a8 03F48003 		and	r3, r3, #4194304
 3054 13ac 4FEA1343 		lsr	r3, r3, #16
 3055 13b0 DAB2     		uxtb	r2, r3
 3056 13b2 BB68     		ldr	r3, [r7, #8]
 3057 13b4 DA70     		strb	r2, [r3, #3]
1904:../src/stm32f30x_rtc.c **** 
1905:../src/stm32f30x_rtc.c ****   /* Fill the Date structure fields with the read parameters */
1906:../src/stm32f30x_rtc.c ****   RTC_StampDateStruct->RTC_Year = 0;
 3058              		.loc 1 1906 0
 3059 13b6 7B68     		ldr	r3, [r7, #4]
 3060 13b8 4FF00002 		mov	r2, #0
 3061 13bc DA70     		strb	r2, [r3, #3]
1907:../src/stm32f30x_rtc.c ****   RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 3062              		.loc 1 1907 0
 3063 13be 3B69     		ldr	r3, [r7, #16]
 3064 13c0 03F4F853 		and	r3, r3, #7936
 3065 13c4 4FEA1323 		lsr	r3, r3, #8
 3066 13c8 DAB2     		uxtb	r2, r3
 3067 13ca 7B68     		ldr	r3, [r7, #4]
 3068 13cc 5A70     		strb	r2, [r3, #1]
1908:../src/stm32f30x_rtc.c ****   RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
 3069              		.loc 1 1908 0
 3070 13ce 3B69     		ldr	r3, [r7, #16]
 3071 13d0 DBB2     		uxtb	r3, r3
 3072 13d2 03F03F03 		and	r3, r3, #63
 3073 13d6 DAB2     		uxtb	r2, r3
 3074 13d8 7B68     		ldr	r3, [r7, #4]
 3075 13da 9A70     		strb	r2, [r3, #2]
1909:../src/stm32f30x_rtc.c ****   RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
 3076              		.loc 1 1909 0
 3077 13dc 3B69     		ldr	r3, [r7, #16]
 3078 13de 03F46043 		and	r3, r3, #57344
 3079 13e2 4FEA5333 		lsr	r3, r3, #13
 3080 13e6 DAB2     		uxtb	r2, r3
 3081 13e8 7B68     		ldr	r3, [r7, #4]
 3082 13ea 1A70     		strb	r2, [r3, #0]
1910:../src/stm32f30x_rtc.c **** 
1911:../src/stm32f30x_rtc.c ****   /* Check the input parameters format */
1912:../src/stm32f30x_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 3083              		.loc 1 1912 0
 3084 13ec FB68     		ldr	r3, [r7, #12]
 3085 13ee 002B     		cmp	r3, #0
 3086 13f0 35D1     		bne	.L130
1913:../src/stm32f30x_rtc.c ****   {
1914:../src/stm32f30x_rtc.c ****     /* Convert the Time structure parameters to Binary format */
1915:../src/stm32f30x_rtc.c ****     RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
 3087              		.loc 1 1915 0
 3088 13f2 BB68     		ldr	r3, [r7, #8]
 3089 13f4 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3090 13f6 1846     		mov	r0, r3
 3091 13f8 00F04CFB 		bl	RTC_Bcd2ToByte
 3092 13fc 0346     		mov	r3, r0
 3093 13fe 1A46     		mov	r2, r3
 3094 1400 BB68     		ldr	r3, [r7, #8]
 3095 1402 1A70     		strb	r2, [r3, #0]
1916:../src/stm32f30x_rtc.c ****     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
 3096              		.loc 1 1916 0
 3097 1404 BB68     		ldr	r3, [r7, #8]
 3098 1406 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 3099 1408 1846     		mov	r0, r3
 3100 140a 00F043FB 		bl	RTC_Bcd2ToByte
 3101 140e 0346     		mov	r3, r0
 3102 1410 1A46     		mov	r2, r3
 3103 1412 BB68     		ldr	r3, [r7, #8]
 3104 1414 5A70     		strb	r2, [r3, #1]
1917:../src/stm32f30x_rtc.c ****     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
 3105              		.loc 1 1917 0
 3106 1416 BB68     		ldr	r3, [r7, #8]
 3107 1418 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 3108 141a 1846     		mov	r0, r3
 3109 141c 00F03AFB 		bl	RTC_Bcd2ToByte
 3110 1420 0346     		mov	r3, r0
 3111 1422 1A46     		mov	r2, r3
 3112 1424 BB68     		ldr	r3, [r7, #8]
 3113 1426 9A70     		strb	r2, [r3, #2]
1918:../src/stm32f30x_rtc.c **** 
1919:../src/stm32f30x_rtc.c ****     /* Convert the Date structure parameters to Binary format */
1920:../src/stm32f30x_rtc.c ****     RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
 3114              		.loc 1 1920 0
 3115 1428 7B68     		ldr	r3, [r7, #4]
 3116 142a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 3117 142c 1846     		mov	r0, r3
 3118 142e 00F031FB 		bl	RTC_Bcd2ToByte
 3119 1432 0346     		mov	r3, r0
 3120 1434 1A46     		mov	r2, r3
 3121 1436 7B68     		ldr	r3, [r7, #4]
 3122 1438 5A70     		strb	r2, [r3, #1]
1921:../src/stm32f30x_rtc.c ****     RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
 3123              		.loc 1 1921 0
 3124 143a 7B68     		ldr	r3, [r7, #4]
 3125 143c 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 3126 143e 1846     		mov	r0, r3
 3127 1440 00F028FB 		bl	RTC_Bcd2ToByte
 3128 1444 0346     		mov	r3, r0
 3129 1446 1A46     		mov	r2, r3
 3130 1448 7B68     		ldr	r3, [r7, #4]
 3131 144a 9A70     		strb	r2, [r3, #2]
1922:../src/stm32f30x_rtc.c ****     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
 3132              		.loc 1 1922 0
 3133 144c 7B68     		ldr	r3, [r7, #4]
 3134 144e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3135 1450 1846     		mov	r0, r3
 3136 1452 00F01FFB 		bl	RTC_Bcd2ToByte
 3137 1456 0346     		mov	r3, r0
 3138 1458 1A46     		mov	r2, r3
 3139 145a 7B68     		ldr	r3, [r7, #4]
 3140 145c 1A70     		strb	r2, [r3, #0]
 3141              	.L130:
1923:../src/stm32f30x_rtc.c ****   }
1924:../src/stm32f30x_rtc.c **** }
 3142              		.loc 1 1924 0
 3143 145e 07F11807 		add	r7, r7, #24
 3144 1462 BD46     		mov	sp, r7
 3145 1464 80BD     		pop	{r7, pc}
 3146              		.cfi_endproc
 3147              	.LFE144:
 3149 1466 00BF     		.align	2
 3150              		.global	RTC_GetTimeStampSubSecond
 3151              		.thumb
 3152              		.thumb_func
 3154              	RTC_GetTimeStampSubSecond:
 3155              	.LFB145:
1925:../src/stm32f30x_rtc.c **** 
1926:../src/stm32f30x_rtc.c **** /**
1927:../src/stm32f30x_rtc.c ****   * @brief  Gets the RTC timestamp Subseconds value.
1928:../src/stm32f30x_rtc.c ****   * @param  None
1929:../src/stm32f30x_rtc.c ****   * @retval RTC current timestamp Subseconds value.
1930:../src/stm32f30x_rtc.c ****   */
1931:../src/stm32f30x_rtc.c **** uint32_t RTC_GetTimeStampSubSecond(void)
1932:../src/stm32f30x_rtc.c **** {
 3156              		.loc 1 1932 0
 3157              		.cfi_startproc
 3158              		@ args = 0, pretend = 0, frame = 0
 3159              		@ frame_needed = 1, uses_anonymous_args = 0
 3160              		@ link register save eliminated.
 3161 1468 80B4     		push	{r7}
 3162              	.LCFI99:
 3163              		.cfi_def_cfa_offset 4
 3164              		.cfi_offset 7, -4
 3165 146a 00AF     		add	r7, sp, #0
 3166              	.LCFI100:
 3167              		.cfi_def_cfa_register 7
1933:../src/stm32f30x_rtc.c ****   /* Get timestamp subseconds values from the correspondent registers */
1934:../src/stm32f30x_rtc.c ****   return (uint32_t)(RTC->TSSSR);
 3168              		.loc 1 1934 0
 3169 146c 4FF42053 		mov	r3, #10240
 3170 1470 C4F20003 		movt	r3, 16384
 3171 1474 9B6B     		ldr	r3, [r3, #56]
1935:../src/stm32f30x_rtc.c **** }
 3172              		.loc 1 1935 0
 3173 1476 1846     		mov	r0, r3
 3174 1478 BD46     		mov	sp, r7
 3175 147a 80BC     		pop	{r7}
 3176 147c 7047     		bx	lr
 3177              		.cfi_endproc
 3178              	.LFE145:
 3180 147e 00BF     		.align	2
 3181              		.global	RTC_TamperTriggerConfig
 3182              		.thumb
 3183              		.thumb_func
 3185              	RTC_TamperTriggerConfig:
 3186              	.LFB146:
1936:../src/stm32f30x_rtc.c **** 
1937:../src/stm32f30x_rtc.c **** /**
1938:../src/stm32f30x_rtc.c ****   * @}
1939:../src/stm32f30x_rtc.c ****   */
1940:../src/stm32f30x_rtc.c **** 
1941:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group9 Tampers configuration functions
1942:../src/stm32f30x_rtc.c ****  *  @brief   Tampers configuration functions 
1943:../src/stm32f30x_rtc.c ****  *
1944:../src/stm32f30x_rtc.c **** @verbatim   
1945:../src/stm32f30x_rtc.c ****  ===============================================================================
1946:../src/stm32f30x_rtc.c ****                 ##### Tampers configuration functions #####
1947:../src/stm32f30x_rtc.c ****  ===============================================================================  
1948:../src/stm32f30x_rtc.c **** 
1949:../src/stm32f30x_rtc.c **** @endverbatim
1950:../src/stm32f30x_rtc.c ****   * @{
1951:../src/stm32f30x_rtc.c ****   */
1952:../src/stm32f30x_rtc.c **** 
1953:../src/stm32f30x_rtc.c **** /**
1954:../src/stm32f30x_rtc.c ****   * @brief  Configures the select Tamper pin edge.
1955:../src/stm32f30x_rtc.c ****   * @param  RTC_Tamper: Selected tamper pin.
1956:../src/stm32f30x_rtc.c ****   *   This parameter can be any combination of the following values:
1957:../src/stm32f30x_rtc.c ****   *     @arg RTC_Tamper_1: Select Tamper 1.
1958:../src/stm32f30x_rtc.c ****   *     @arg RTC_Tamper_2: Select Tamper 2.
1959:../src/stm32f30x_rtc.c ****   *     @arg RTC_Tamper_3: Select Tamper 3.
1960:../src/stm32f30x_rtc.c ****   * @param  RTC_TamperTrigger: Specifies the trigger on the tamper pin that 
1961:../src/stm32f30x_rtc.c ****   *                            stimulates tamper event. 
1962:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1963:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperTrigger_RisingEdge: Rising Edge of the tamper pin causes tamper event.
1964:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperTrigger_FallingEdge: Falling Edge of the tamper pin causes tamper event.
1965:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperTrigger_LowLevel: Low Level of the tamper pin causes tamper event.
1966:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperTrigger_HighLevel: High Level of the tamper pin causes tamper event.
1967:../src/stm32f30x_rtc.c ****   * @retval None
1968:../src/stm32f30x_rtc.c ****   */
1969:../src/stm32f30x_rtc.c **** void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
1970:../src/stm32f30x_rtc.c **** {
 3187              		.loc 1 1970 0
 3188              		.cfi_startproc
 3189              		@ args = 0, pretend = 0, frame = 8
 3190              		@ frame_needed = 1, uses_anonymous_args = 0
 3191              		@ link register save eliminated.
 3192 1480 80B4     		push	{r7}
 3193              	.LCFI101:
 3194              		.cfi_def_cfa_offset 4
 3195              		.cfi_offset 7, -4
 3196 1482 83B0     		sub	sp, sp, #12
 3197              	.LCFI102:
 3198              		.cfi_def_cfa_offset 16
 3199 1484 00AF     		add	r7, sp, #0
 3200              	.LCFI103:
 3201              		.cfi_def_cfa_register 7
 3202 1486 7860     		str	r0, [r7, #4]
 3203 1488 3960     		str	r1, [r7, #0]
1971:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1972:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
1973:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
1974:../src/stm32f30x_rtc.c ****  
1975:../src/stm32f30x_rtc.c ****   /* Check if the  active level for Tamper is rising edge (Low level)*/
1976:../src/stm32f30x_rtc.c ****   if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
 3204              		.loc 1 1976 0
 3205 148a 3B68     		ldr	r3, [r7, #0]
 3206 148c 002B     		cmp	r3, #0
 3207 148e 10D1     		bne	.L135
1977:../src/stm32f30x_rtc.c ****   {  
1978:../src/stm32f30x_rtc.c ****     /* Configure the RTC_TAFCR register */
1979:../src/stm32f30x_rtc.c ****     RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
 3208              		.loc 1 1979 0
 3209 1490 4FF42053 		mov	r3, #10240
 3210 1494 C4F20003 		movt	r3, 16384
 3211 1498 4FF42052 		mov	r2, #10240
 3212 149c C4F20002 		movt	r2, 16384
 3213 14a0 116C     		ldr	r1, [r2, #64]
 3214 14a2 7A68     		ldr	r2, [r7, #4]
 3215 14a4 4FEA4202 		lsl	r2, r2, #1
 3216 14a8 6FEA0202 		mvn	r2, r2
 3217 14ac 0A40     		ands	r2, r2, r1
 3218 14ae 1A64     		str	r2, [r3, #64]
 3219 14b0 0DE0     		b	.L134
 3220              	.L135:
1980:../src/stm32f30x_rtc.c ****   }
1981:../src/stm32f30x_rtc.c ****   else
1982:../src/stm32f30x_rtc.c ****   { 
1983:../src/stm32f30x_rtc.c ****     /* Configure the RTC_TAFCR register */
1984:../src/stm32f30x_rtc.c ****     RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
 3221              		.loc 1 1984 0
 3222 14b2 4FF42053 		mov	r3, #10240
 3223 14b6 C4F20003 		movt	r3, 16384
 3224 14ba 4FF42052 		mov	r2, #10240
 3225 14be C4F20002 		movt	r2, 16384
 3226 14c2 116C     		ldr	r1, [r2, #64]
 3227 14c4 7A68     		ldr	r2, [r7, #4]
 3228 14c6 4FEA4202 		lsl	r2, r2, #1
 3229 14ca 0A43     		orrs	r2, r2, r1
 3230 14cc 1A64     		str	r2, [r3, #64]
 3231              	.L134:
1985:../src/stm32f30x_rtc.c ****   }  
1986:../src/stm32f30x_rtc.c **** }
 3232              		.loc 1 1986 0
 3233 14ce 07F10C07 		add	r7, r7, #12
 3234 14d2 BD46     		mov	sp, r7
 3235 14d4 80BC     		pop	{r7}
 3236 14d6 7047     		bx	lr
 3237              		.cfi_endproc
 3238              	.LFE146:
 3240              		.align	2
 3241              		.global	RTC_TamperCmd
 3242              		.thumb
 3243              		.thumb_func
 3245              	RTC_TamperCmd:
 3246              	.LFB147:
1987:../src/stm32f30x_rtc.c **** 
1988:../src/stm32f30x_rtc.c **** /**
1989:../src/stm32f30x_rtc.c ****   * @brief  Enables or Disables the Tamper detection.
1990:../src/stm32f30x_rtc.c ****   * @param  RTC_Tamper: Selected tamper pin.
1991:../src/stm32f30x_rtc.c ****   *   This parameter can be any combination of the following values:
1992:../src/stm32f30x_rtc.c ****   *     @arg RTC_Tamper_1: Select Tamper 1.
1993:../src/stm32f30x_rtc.c ****   *     @arg RTC_Tamper_2: Select Tamper 2.
1994:../src/stm32f30x_rtc.c ****   *     @arg RTC_Tamper_3: Select Tamper 3.
1995:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the tamper pin.
1996:../src/stm32f30x_rtc.c ****   *         This parameter can be: ENABLE or DISABLE.                   
1997:../src/stm32f30x_rtc.c ****   * @retval None
1998:../src/stm32f30x_rtc.c ****   */
1999:../src/stm32f30x_rtc.c **** void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
2000:../src/stm32f30x_rtc.c **** {
 3247              		.loc 1 2000 0
 3248              		.cfi_startproc
 3249              		@ args = 0, pretend = 0, frame = 8
 3250              		@ frame_needed = 1, uses_anonymous_args = 0
 3251              		@ link register save eliminated.
 3252 14d8 80B4     		push	{r7}
 3253              	.LCFI104:
 3254              		.cfi_def_cfa_offset 4
 3255              		.cfi_offset 7, -4
 3256 14da 83B0     		sub	sp, sp, #12
 3257              	.LCFI105:
 3258              		.cfi_def_cfa_offset 16
 3259 14dc 00AF     		add	r7, sp, #0
 3260              	.LCFI106:
 3261              		.cfi_def_cfa_register 7
 3262 14de 7860     		str	r0, [r7, #4]
 3263 14e0 0B46     		mov	r3, r1
 3264 14e2 FB70     		strb	r3, [r7, #3]
2001:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2002:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_TAMPER(RTC_Tamper));  
2003:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
2004:../src/stm32f30x_rtc.c ****   
2005:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 3265              		.loc 1 2005 0
 3266 14e4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 3267 14e6 002B     		cmp	r3, #0
 3268 14e8 0CD0     		beq	.L138
2006:../src/stm32f30x_rtc.c ****   {
2007:../src/stm32f30x_rtc.c ****     /* Enable the selected Tamper pin */
2008:../src/stm32f30x_rtc.c ****     RTC->TAFCR |= (uint32_t)RTC_Tamper;
 3269              		.loc 1 2008 0
 3270 14ea 4FF42053 		mov	r3, #10240
 3271 14ee C4F20003 		movt	r3, 16384
 3272 14f2 4FF42052 		mov	r2, #10240
 3273 14f6 C4F20002 		movt	r2, 16384
 3274 14fa 116C     		ldr	r1, [r2, #64]
 3275 14fc 7A68     		ldr	r2, [r7, #4]
 3276 14fe 0A43     		orrs	r2, r2, r1
 3277 1500 1A64     		str	r2, [r3, #64]
 3278 1502 0DE0     		b	.L137
 3279              	.L138:
2009:../src/stm32f30x_rtc.c ****   }
2010:../src/stm32f30x_rtc.c ****   else
2011:../src/stm32f30x_rtc.c ****   {
2012:../src/stm32f30x_rtc.c ****     /* Disable the selected Tamper pin */
2013:../src/stm32f30x_rtc.c ****     RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
 3280              		.loc 1 2013 0
 3281 1504 4FF42053 		mov	r3, #10240
 3282 1508 C4F20003 		movt	r3, 16384
 3283 150c 4FF42052 		mov	r2, #10240
 3284 1510 C4F20002 		movt	r2, 16384
 3285 1514 116C     		ldr	r1, [r2, #64]
 3286 1516 7A68     		ldr	r2, [r7, #4]
 3287 1518 6FEA0202 		mvn	r2, r2
 3288 151c 0A40     		ands	r2, r2, r1
 3289 151e 1A64     		str	r2, [r3, #64]
 3290              	.L137:
2014:../src/stm32f30x_rtc.c ****   }  
2015:../src/stm32f30x_rtc.c **** }
 3291              		.loc 1 2015 0
 3292 1520 07F10C07 		add	r7, r7, #12
 3293 1524 BD46     		mov	sp, r7
 3294 1526 80BC     		pop	{r7}
 3295 1528 7047     		bx	lr
 3296              		.cfi_endproc
 3297              	.LFE147:
 3299 152a 00BF     		.align	2
 3300              		.global	RTC_TamperFilterConfig
 3301              		.thumb
 3302              		.thumb_func
 3304              	RTC_TamperFilterConfig:
 3305              	.LFB148:
2016:../src/stm32f30x_rtc.c **** 
2017:../src/stm32f30x_rtc.c **** /**
2018:../src/stm32f30x_rtc.c ****   * @brief  Configures the Tampers Filter.
2019:../src/stm32f30x_rtc.c ****   * @param  RTC_TamperFilter: Specifies the tampers filter.
2020:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
2021:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperFilter_Disable: Tamper filter is disabled.
2022:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperFilter_2Sample: Tamper is activated after 2 consecutive 
2023:../src/stm32f30x_rtc.c ****   *                                    samples at the active level 
2024:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperFilter_4Sample: Tamper is activated after 4 consecutive 
2025:../src/stm32f30x_rtc.c ****   *                                    samples at the active level
2026:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperFilter_8Sample: Tamper is activated after 8 consecutive 
2027:../src/stm32f30x_rtc.c ****   *                                    samples at the active level 
2028:../src/stm32f30x_rtc.c ****   * @retval None
2029:../src/stm32f30x_rtc.c ****   */
2030:../src/stm32f30x_rtc.c **** void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
2031:../src/stm32f30x_rtc.c **** {
 3306              		.loc 1 2031 0
 3307              		.cfi_startproc
 3308              		@ args = 0, pretend = 0, frame = 8
 3309              		@ frame_needed = 1, uses_anonymous_args = 0
 3310              		@ link register save eliminated.
 3311 152c 80B4     		push	{r7}
 3312              	.LCFI107:
 3313              		.cfi_def_cfa_offset 4
 3314              		.cfi_offset 7, -4
 3315 152e 83B0     		sub	sp, sp, #12
 3316              	.LCFI108:
 3317              		.cfi_def_cfa_offset 16
 3318 1530 00AF     		add	r7, sp, #0
 3319              	.LCFI109:
 3320              		.cfi_def_cfa_register 7
 3321 1532 7860     		str	r0, [r7, #4]
2032:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2033:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
2034:../src/stm32f30x_rtc.c ****    
2035:../src/stm32f30x_rtc.c ****   /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
2036:../src/stm32f30x_rtc.c ****   RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
 3322              		.loc 1 2036 0
 3323 1534 4FF42053 		mov	r3, #10240
 3324 1538 C4F20003 		movt	r3, 16384
 3325 153c 4FF42052 		mov	r2, #10240
 3326 1540 C4F20002 		movt	r2, 16384
 3327 1544 126C     		ldr	r2, [r2, #64]
 3328 1546 22F4C052 		bic	r2, r2, #6144
 3329 154a 1A64     		str	r2, [r3, #64]
2037:../src/stm32f30x_rtc.c **** 
2038:../src/stm32f30x_rtc.c ****   /* Configure the RTC_TAFCR register */
2039:../src/stm32f30x_rtc.c ****   RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
 3330              		.loc 1 2039 0
 3331 154c 4FF42053 		mov	r3, #10240
 3332 1550 C4F20003 		movt	r3, 16384
 3333 1554 4FF42052 		mov	r2, #10240
 3334 1558 C4F20002 		movt	r2, 16384
 3335 155c 116C     		ldr	r1, [r2, #64]
 3336 155e 7A68     		ldr	r2, [r7, #4]
 3337 1560 0A43     		orrs	r2, r2, r1
 3338 1562 1A64     		str	r2, [r3, #64]
2040:../src/stm32f30x_rtc.c **** }
 3339              		.loc 1 2040 0
 3340 1564 07F10C07 		add	r7, r7, #12
 3341 1568 BD46     		mov	sp, r7
 3342 156a 80BC     		pop	{r7}
 3343 156c 7047     		bx	lr
 3344              		.cfi_endproc
 3345              	.LFE148:
 3347 156e 00BF     		.align	2
 3348              		.global	RTC_TamperSamplingFreqConfig
 3349              		.thumb
 3350              		.thumb_func
 3352              	RTC_TamperSamplingFreqConfig:
 3353              	.LFB149:
2041:../src/stm32f30x_rtc.c **** 
2042:../src/stm32f30x_rtc.c **** /**
2043:../src/stm32f30x_rtc.c ****   * @brief  Configures the Tampers Sampling Frequency.
2044:../src/stm32f30x_rtc.c ****   * @param  RTC_TamperSamplingFreq: Specifies the tampers Sampling Frequency.
2045:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
2046:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div32768: Each of the tamper inputs are sampled
2047:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 32768
2048:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div16384: Each of the tamper inputs are sampled
2049:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 16384
2050:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div8192: Each of the tamper inputs are sampled
2051:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 8192
2052:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div4096: Each of the tamper inputs are sampled
2053:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 4096
2054:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div2048: Each of the tamper inputs are sampled
2055:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 2048
2056:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div1024: Each of the tamper inputs are sampled
2057:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 1024
2058:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div512: Each of the tamper inputs are sampled
2059:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 512  
2060:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div256: Each of the tamper inputs are sampled
2061:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 256  
2062:../src/stm32f30x_rtc.c ****   * @retval None
2063:../src/stm32f30x_rtc.c ****   */
2064:../src/stm32f30x_rtc.c **** void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
2065:../src/stm32f30x_rtc.c **** {
 3354              		.loc 1 2065 0
 3355              		.cfi_startproc
 3356              		@ args = 0, pretend = 0, frame = 8
 3357              		@ frame_needed = 1, uses_anonymous_args = 0
 3358              		@ link register save eliminated.
 3359 1570 80B4     		push	{r7}
 3360              	.LCFI110:
 3361              		.cfi_def_cfa_offset 4
 3362              		.cfi_offset 7, -4
 3363 1572 83B0     		sub	sp, sp, #12
 3364              	.LCFI111:
 3365              		.cfi_def_cfa_offset 16
 3366 1574 00AF     		add	r7, sp, #0
 3367              	.LCFI112:
 3368              		.cfi_def_cfa_register 7
 3369 1576 7860     		str	r0, [r7, #4]
2066:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2067:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
2068:../src/stm32f30x_rtc.c ****  
2069:../src/stm32f30x_rtc.c ****   /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
2070:../src/stm32f30x_rtc.c ****   RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
 3370              		.loc 1 2070 0
 3371 1578 4FF42053 		mov	r3, #10240
 3372 157c C4F20003 		movt	r3, 16384
 3373 1580 4FF42052 		mov	r2, #10240
 3374 1584 C4F20002 		movt	r2, 16384
 3375 1588 126C     		ldr	r2, [r2, #64]
 3376 158a 22F4E062 		bic	r2, r2, #1792
 3377 158e 1A64     		str	r2, [r3, #64]
2071:../src/stm32f30x_rtc.c **** 
2072:../src/stm32f30x_rtc.c ****   /* Configure the RTC_TAFCR register */
2073:../src/stm32f30x_rtc.c ****   RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
 3378              		.loc 1 2073 0
 3379 1590 4FF42053 		mov	r3, #10240
 3380 1594 C4F20003 		movt	r3, 16384
 3381 1598 4FF42052 		mov	r2, #10240
 3382 159c C4F20002 		movt	r2, 16384
 3383 15a0 116C     		ldr	r1, [r2, #64]
 3384 15a2 7A68     		ldr	r2, [r7, #4]
 3385 15a4 0A43     		orrs	r2, r2, r1
 3386 15a6 1A64     		str	r2, [r3, #64]
2074:../src/stm32f30x_rtc.c **** }
 3387              		.loc 1 2074 0
 3388 15a8 07F10C07 		add	r7, r7, #12
 3389 15ac BD46     		mov	sp, r7
 3390 15ae 80BC     		pop	{r7}
 3391 15b0 7047     		bx	lr
 3392              		.cfi_endproc
 3393              	.LFE149:
 3395 15b2 00BF     		.align	2
 3396              		.global	RTC_TamperPinsPrechargeDuration
 3397              		.thumb
 3398              		.thumb_func
 3400              	RTC_TamperPinsPrechargeDuration:
 3401              	.LFB150:
2075:../src/stm32f30x_rtc.c **** 
2076:../src/stm32f30x_rtc.c **** /**
2077:../src/stm32f30x_rtc.c ****   * @brief  Configures the Tampers Pins input Precharge Duration.
2078:../src/stm32f30x_rtc.c ****   * @param  RTC_TamperPrechargeDuration: Specifies the Tampers Pins input
2079:../src/stm32f30x_rtc.c ****   *         Precharge Duration.
2080:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
2081:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperPrechargeDuration_1RTCCLK: Tamper pins are pre-charged before sampling durin
2082:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperPrechargeDuration_2RTCCLK: Tamper pins are pre-charged before sampling durin
2083:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperPrechargeDuration_4RTCCLK: Tamper pins are pre-charged before sampling durin
2084:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperPrechargeDuration_8RTCCLK: Tamper pins are pre-charged before sampling durin
2085:../src/stm32f30x_rtc.c ****   * @retval None
2086:../src/stm32f30x_rtc.c ****   */
2087:../src/stm32f30x_rtc.c **** void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
2088:../src/stm32f30x_rtc.c **** {
 3402              		.loc 1 2088 0
 3403              		.cfi_startproc
 3404              		@ args = 0, pretend = 0, frame = 8
 3405              		@ frame_needed = 1, uses_anonymous_args = 0
 3406              		@ link register save eliminated.
 3407 15b4 80B4     		push	{r7}
 3408              	.LCFI113:
 3409              		.cfi_def_cfa_offset 4
 3410              		.cfi_offset 7, -4
 3411 15b6 83B0     		sub	sp, sp, #12
 3412              	.LCFI114:
 3413              		.cfi_def_cfa_offset 16
 3414 15b8 00AF     		add	r7, sp, #0
 3415              	.LCFI115:
 3416              		.cfi_def_cfa_register 7
 3417 15ba 7860     		str	r0, [r7, #4]
2089:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2090:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
2091:../src/stm32f30x_rtc.c ****    
2092:../src/stm32f30x_rtc.c ****   /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
2093:../src/stm32f30x_rtc.c ****   RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
 3418              		.loc 1 2093 0
 3419 15bc 4FF42053 		mov	r3, #10240
 3420 15c0 C4F20003 		movt	r3, 16384
 3421 15c4 4FF42052 		mov	r2, #10240
 3422 15c8 C4F20002 		movt	r2, 16384
 3423 15cc 126C     		ldr	r2, [r2, #64]
 3424 15ce 22F4C042 		bic	r2, r2, #24576
 3425 15d2 1A64     		str	r2, [r3, #64]
2094:../src/stm32f30x_rtc.c **** 
2095:../src/stm32f30x_rtc.c ****   /* Configure the RTC_TAFCR register */
2096:../src/stm32f30x_rtc.c ****   RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
 3426              		.loc 1 2096 0
 3427 15d4 4FF42053 		mov	r3, #10240
 3428 15d8 C4F20003 		movt	r3, 16384
 3429 15dc 4FF42052 		mov	r2, #10240
 3430 15e0 C4F20002 		movt	r2, 16384
 3431 15e4 116C     		ldr	r1, [r2, #64]
 3432 15e6 7A68     		ldr	r2, [r7, #4]
 3433 15e8 0A43     		orrs	r2, r2, r1
 3434 15ea 1A64     		str	r2, [r3, #64]
2097:../src/stm32f30x_rtc.c **** }
 3435              		.loc 1 2097 0
 3436 15ec 07F10C07 		add	r7, r7, #12
 3437 15f0 BD46     		mov	sp, r7
 3438 15f2 80BC     		pop	{r7}
 3439 15f4 7047     		bx	lr
 3440              		.cfi_endproc
 3441              	.LFE150:
 3443 15f6 00BF     		.align	2
 3444              		.global	RTC_TimeStampOnTamperDetectionCmd
 3445              		.thumb
 3446              		.thumb_func
 3448              	RTC_TimeStampOnTamperDetectionCmd:
 3449              	.LFB151:
2098:../src/stm32f30x_rtc.c **** 
2099:../src/stm32f30x_rtc.c **** /**
2100:../src/stm32f30x_rtc.c ****   * @brief  Enables or Disables the TimeStamp on Tamper Detection Event.
2101:../src/stm32f30x_rtc.c ****   * @note   The timestamp is valid even the TSE bit in tamper control register 
2102:../src/stm32f30x_rtc.c ****   *         is reset.   
2103:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the timestamp on tamper event.
2104:../src/stm32f30x_rtc.c ****   *         This parameter can be: ENABLE or DISABLE.
2105:../src/stm32f30x_rtc.c ****   * @retval None
2106:../src/stm32f30x_rtc.c ****   */
2107:../src/stm32f30x_rtc.c **** void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
2108:../src/stm32f30x_rtc.c **** {
 3450              		.loc 1 2108 0
 3451              		.cfi_startproc
 3452              		@ args = 0, pretend = 0, frame = 8
 3453              		@ frame_needed = 1, uses_anonymous_args = 0
 3454              		@ link register save eliminated.
 3455 15f8 80B4     		push	{r7}
 3456              	.LCFI116:
 3457              		.cfi_def_cfa_offset 4
 3458              		.cfi_offset 7, -4
 3459 15fa 83B0     		sub	sp, sp, #12
 3460              	.LCFI117:
 3461              		.cfi_def_cfa_offset 16
 3462 15fc 00AF     		add	r7, sp, #0
 3463              	.LCFI118:
 3464              		.cfi_def_cfa_register 7
 3465 15fe 0346     		mov	r3, r0
 3466 1600 FB71     		strb	r3, [r7, #7]
2109:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2110:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
2111:../src/stm32f30x_rtc.c ****    
2112:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 3467              		.loc 1 2112 0
 3468 1602 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3469 1604 002B     		cmp	r3, #0
 3470 1606 0CD0     		beq	.L144
2113:../src/stm32f30x_rtc.c ****   {
2114:../src/stm32f30x_rtc.c ****     /* Save timestamp on tamper detection event */
2115:../src/stm32f30x_rtc.c ****     RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
 3471              		.loc 1 2115 0
 3472 1608 4FF42053 		mov	r3, #10240
 3473 160c C4F20003 		movt	r3, 16384
 3474 1610 4FF42052 		mov	r2, #10240
 3475 1614 C4F20002 		movt	r2, 16384
 3476 1618 126C     		ldr	r2, [r2, #64]
 3477 161a 42F08002 		orr	r2, r2, #128
 3478 161e 1A64     		str	r2, [r3, #64]
 3479 1620 0BE0     		b	.L143
 3480              	.L144:
2116:../src/stm32f30x_rtc.c ****   }
2117:../src/stm32f30x_rtc.c ****   else
2118:../src/stm32f30x_rtc.c ****   {
2119:../src/stm32f30x_rtc.c ****     /* Tamper detection does not cause a timestamp to be saved */
2120:../src/stm32f30x_rtc.c ****     RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
 3481              		.loc 1 2120 0
 3482 1622 4FF42053 		mov	r3, #10240
 3483 1626 C4F20003 		movt	r3, 16384
 3484 162a 4FF42052 		mov	r2, #10240
 3485 162e C4F20002 		movt	r2, 16384
 3486 1632 126C     		ldr	r2, [r2, #64]
 3487 1634 22F08002 		bic	r2, r2, #128
 3488 1638 1A64     		str	r2, [r3, #64]
 3489              	.L143:
2121:../src/stm32f30x_rtc.c ****   }
2122:../src/stm32f30x_rtc.c **** }
 3490              		.loc 1 2122 0
 3491 163a 07F10C07 		add	r7, r7, #12
 3492 163e BD46     		mov	sp, r7
 3493 1640 80BC     		pop	{r7}
 3494 1642 7047     		bx	lr
 3495              		.cfi_endproc
 3496              	.LFE151:
 3498              		.align	2
 3499              		.global	RTC_TamperPullUpCmd
 3500              		.thumb
 3501              		.thumb_func
 3503              	RTC_TamperPullUpCmd:
 3504              	.LFB152:
2123:../src/stm32f30x_rtc.c **** 
2124:../src/stm32f30x_rtc.c **** /**
2125:../src/stm32f30x_rtc.c ****   * @brief  Enables or Disables the Precharge of Tamper pin.
2126:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of tamper pull up.
2127:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.                   
2128:../src/stm32f30x_rtc.c ****   * @retval None
2129:../src/stm32f30x_rtc.c ****   */
2130:../src/stm32f30x_rtc.c **** void RTC_TamperPullUpCmd(FunctionalState NewState)
2131:../src/stm32f30x_rtc.c **** {
 3505              		.loc 1 2131 0
 3506              		.cfi_startproc
 3507              		@ args = 0, pretend = 0, frame = 8
 3508              		@ frame_needed = 1, uses_anonymous_args = 0
 3509              		@ link register save eliminated.
 3510 1644 80B4     		push	{r7}
 3511              	.LCFI119:
 3512              		.cfi_def_cfa_offset 4
 3513              		.cfi_offset 7, -4
 3514 1646 83B0     		sub	sp, sp, #12
 3515              	.LCFI120:
 3516              		.cfi_def_cfa_offset 16
 3517 1648 00AF     		add	r7, sp, #0
 3518              	.LCFI121:
 3519              		.cfi_def_cfa_register 7
 3520 164a 0346     		mov	r3, r0
 3521 164c FB71     		strb	r3, [r7, #7]
2132:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2133:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
2134:../src/stm32f30x_rtc.c ****   
2135:../src/stm32f30x_rtc.c ****  if (NewState != DISABLE)
 3522              		.loc 1 2135 0
 3523 164e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3524 1650 002B     		cmp	r3, #0
 3525 1652 0CD0     		beq	.L147
2136:../src/stm32f30x_rtc.c ****   {
2137:../src/stm32f30x_rtc.c ****     /* Enable precharge of the selected Tamper pin */
2138:../src/stm32f30x_rtc.c ****     RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
 3526              		.loc 1 2138 0
 3527 1654 4FF42053 		mov	r3, #10240
 3528 1658 C4F20003 		movt	r3, 16384
 3529 165c 4FF42052 		mov	r2, #10240
 3530 1660 C4F20002 		movt	r2, 16384
 3531 1664 126C     		ldr	r2, [r2, #64]
 3532 1666 22F40042 		bic	r2, r2, #32768
 3533 166a 1A64     		str	r2, [r3, #64]
 3534 166c 0BE0     		b	.L146
 3535              	.L147:
2139:../src/stm32f30x_rtc.c ****   }
2140:../src/stm32f30x_rtc.c ****   else
2141:../src/stm32f30x_rtc.c ****   {
2142:../src/stm32f30x_rtc.c ****     /* Disable precharge of the selected Tamper pin */
2143:../src/stm32f30x_rtc.c ****     RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
 3536              		.loc 1 2143 0
 3537 166e 4FF42053 		mov	r3, #10240
 3538 1672 C4F20003 		movt	r3, 16384
 3539 1676 4FF42052 		mov	r2, #10240
 3540 167a C4F20002 		movt	r2, 16384
 3541 167e 126C     		ldr	r2, [r2, #64]
 3542 1680 42F40042 		orr	r2, r2, #32768
 3543 1684 1A64     		str	r2, [r3, #64]
 3544              	.L146:
2144:../src/stm32f30x_rtc.c ****   } 
2145:../src/stm32f30x_rtc.c **** }
 3545              		.loc 1 2145 0
 3546 1686 07F10C07 		add	r7, r7, #12
 3547 168a BD46     		mov	sp, r7
 3548 168c 80BC     		pop	{r7}
 3549 168e 7047     		bx	lr
 3550              		.cfi_endproc
 3551              	.LFE152:
 3553              		.align	2
 3554              		.global	RTC_WriteBackupRegister
 3555              		.thumb
 3556              		.thumb_func
 3558              	RTC_WriteBackupRegister:
 3559              	.LFB153:
2146:../src/stm32f30x_rtc.c **** 
2147:../src/stm32f30x_rtc.c **** /**
2148:../src/stm32f30x_rtc.c ****   * @}
2149:../src/stm32f30x_rtc.c ****   */
2150:../src/stm32f30x_rtc.c **** 
2151:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group10 Backup Data Registers configuration functions
2152:../src/stm32f30x_rtc.c ****  *  @brief   Backup Data Registers configuration functions  
2153:../src/stm32f30x_rtc.c ****  *
2154:../src/stm32f30x_rtc.c **** @verbatim   
2155:../src/stm32f30x_rtc.c ****  ===============================================================================
2156:../src/stm32f30x_rtc.c ****           ##### Backup Data Registers configuration functions #####
2157:../src/stm32f30x_rtc.c ****  ===============================================================================  
2158:../src/stm32f30x_rtc.c **** 
2159:../src/stm32f30x_rtc.c **** @endverbatim
2160:../src/stm32f30x_rtc.c ****   * @{
2161:../src/stm32f30x_rtc.c ****   */
2162:../src/stm32f30x_rtc.c **** 
2163:../src/stm32f30x_rtc.c **** /**
2164:../src/stm32f30x_rtc.c ****   * @brief  Writes a data in a specified RTC Backup data register.
2165:../src/stm32f30x_rtc.c ****   * @param  RTC_BKP_DR: RTC Backup data Register number.
2166:../src/stm32f30x_rtc.c ****   *   This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
2167:../src/stm32f30x_rtc.c ****   *                          specify the register.
2168:../src/stm32f30x_rtc.c ****   * @param  Data: Data to be written in the specified RTC Backup data register.                    
2169:../src/stm32f30x_rtc.c ****   * @retval None
2170:../src/stm32f30x_rtc.c ****   */
2171:../src/stm32f30x_rtc.c **** void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
2172:../src/stm32f30x_rtc.c **** {
 3560              		.loc 1 2172 0
 3561              		.cfi_startproc
 3562              		@ args = 0, pretend = 0, frame = 16
 3563              		@ frame_needed = 1, uses_anonymous_args = 0
 3564              		@ link register save eliminated.
 3565 1690 80B4     		push	{r7}
 3566              	.LCFI122:
 3567              		.cfi_def_cfa_offset 4
 3568              		.cfi_offset 7, -4
 3569 1692 85B0     		sub	sp, sp, #20
 3570              	.LCFI123:
 3571              		.cfi_def_cfa_offset 24
 3572 1694 00AF     		add	r7, sp, #0
 3573              	.LCFI124:
 3574              		.cfi_def_cfa_register 7
 3575 1696 7860     		str	r0, [r7, #4]
 3576 1698 3960     		str	r1, [r7, #0]
2173:../src/stm32f30x_rtc.c ****   __IO uint32_t tmp = 0;
 3577              		.loc 1 2173 0
 3578 169a 4FF00003 		mov	r3, #0
 3579 169e FB60     		str	r3, [r7, #12]
2174:../src/stm32f30x_rtc.c ****   
2175:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2176:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_BKP(RTC_BKP_DR));
2177:../src/stm32f30x_rtc.c **** 
2178:../src/stm32f30x_rtc.c ****   tmp = RTC_BASE + 0x50;
 3580              		.loc 1 2178 0
 3581 16a0 42F65003 		movw	r3, #10320
 3582 16a4 C4F20003 		movt	r3, 16384
 3583 16a8 FB60     		str	r3, [r7, #12]
2179:../src/stm32f30x_rtc.c ****   tmp += (RTC_BKP_DR * 4);
 3584              		.loc 1 2179 0
 3585 16aa 7B68     		ldr	r3, [r7, #4]
 3586 16ac 4FEA8302 		lsl	r2, r3, #2
 3587 16b0 FB68     		ldr	r3, [r7, #12]
 3588 16b2 D318     		adds	r3, r2, r3
 3589 16b4 FB60     		str	r3, [r7, #12]
2180:../src/stm32f30x_rtc.c **** 
2181:../src/stm32f30x_rtc.c ****   /* Write the specified register */
2182:../src/stm32f30x_rtc.c ****   *(__IO uint32_t *)tmp = (uint32_t)Data;
 3590              		.loc 1 2182 0
 3591 16b6 FB68     		ldr	r3, [r7, #12]
 3592 16b8 3A68     		ldr	r2, [r7, #0]
 3593 16ba 1A60     		str	r2, [r3, #0]
2183:../src/stm32f30x_rtc.c **** }
 3594              		.loc 1 2183 0
 3595 16bc 07F11407 		add	r7, r7, #20
 3596 16c0 BD46     		mov	sp, r7
 3597 16c2 80BC     		pop	{r7}
 3598 16c4 7047     		bx	lr
 3599              		.cfi_endproc
 3600              	.LFE153:
 3602 16c6 00BF     		.align	2
 3603              		.global	RTC_ReadBackupRegister
 3604              		.thumb
 3605              		.thumb_func
 3607              	RTC_ReadBackupRegister:
 3608              	.LFB154:
2184:../src/stm32f30x_rtc.c **** 
2185:../src/stm32f30x_rtc.c **** /**
2186:../src/stm32f30x_rtc.c ****   * @brief  Reads data from the specified RTC Backup data Register.
2187:../src/stm32f30x_rtc.c ****   * @param  RTC_BKP_DR: RTC Backup data Register number.
2188:../src/stm32f30x_rtc.c ****   *   This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
2189:../src/stm32f30x_rtc.c ****   *                          specify the register.                   
2190:../src/stm32f30x_rtc.c ****   * @retval None
2191:../src/stm32f30x_rtc.c ****   */
2192:../src/stm32f30x_rtc.c **** uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
2193:../src/stm32f30x_rtc.c **** {
 3609              		.loc 1 2193 0
 3610              		.cfi_startproc
 3611              		@ args = 0, pretend = 0, frame = 16
 3612              		@ frame_needed = 1, uses_anonymous_args = 0
 3613              		@ link register save eliminated.
 3614 16c8 80B4     		push	{r7}
 3615              	.LCFI125:
 3616              		.cfi_def_cfa_offset 4
 3617              		.cfi_offset 7, -4
 3618 16ca 85B0     		sub	sp, sp, #20
 3619              	.LCFI126:
 3620              		.cfi_def_cfa_offset 24
 3621 16cc 00AF     		add	r7, sp, #0
 3622              	.LCFI127:
 3623              		.cfi_def_cfa_register 7
 3624 16ce 7860     		str	r0, [r7, #4]
2194:../src/stm32f30x_rtc.c ****   __IO uint32_t tmp = 0;
 3625              		.loc 1 2194 0
 3626 16d0 4FF00003 		mov	r3, #0
 3627 16d4 FB60     		str	r3, [r7, #12]
2195:../src/stm32f30x_rtc.c ****   
2196:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2197:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_BKP(RTC_BKP_DR));
2198:../src/stm32f30x_rtc.c **** 
2199:../src/stm32f30x_rtc.c ****   tmp = RTC_BASE + 0x50;
 3628              		.loc 1 2199 0
 3629 16d6 42F65003 		movw	r3, #10320
 3630 16da C4F20003 		movt	r3, 16384
 3631 16de FB60     		str	r3, [r7, #12]
2200:../src/stm32f30x_rtc.c ****   tmp += (RTC_BKP_DR * 4);
 3632              		.loc 1 2200 0
 3633 16e0 7B68     		ldr	r3, [r7, #4]
 3634 16e2 4FEA8302 		lsl	r2, r3, #2
 3635 16e6 FB68     		ldr	r3, [r7, #12]
 3636 16e8 D318     		adds	r3, r2, r3
 3637 16ea FB60     		str	r3, [r7, #12]
2201:../src/stm32f30x_rtc.c ****   
2202:../src/stm32f30x_rtc.c ****   /* Read the specified register */
2203:../src/stm32f30x_rtc.c ****   return (*(__IO uint32_t *)tmp);
 3638              		.loc 1 2203 0
 3639 16ec FB68     		ldr	r3, [r7, #12]
 3640 16ee 1B68     		ldr	r3, [r3, #0]
2204:../src/stm32f30x_rtc.c **** }
 3641              		.loc 1 2204 0
 3642 16f0 1846     		mov	r0, r3
 3643 16f2 07F11407 		add	r7, r7, #20
 3644 16f6 BD46     		mov	sp, r7
 3645 16f8 80BC     		pop	{r7}
 3646 16fa 7047     		bx	lr
 3647              		.cfi_endproc
 3648              	.LFE154:
 3650              		.align	2
 3651              		.global	RTC_OutputTypeConfig
 3652              		.thumb
 3653              		.thumb_func
 3655              	RTC_OutputTypeConfig:
 3656              	.LFB155:
2205:../src/stm32f30x_rtc.c **** 
2206:../src/stm32f30x_rtc.c **** /**
2207:../src/stm32f30x_rtc.c ****   * @}
2208:../src/stm32f30x_rtc.c ****   */
2209:../src/stm32f30x_rtc.c **** 
2210:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group11 Output Type Config configuration functions
2211:../src/stm32f30x_rtc.c ****  *  @brief   Output Type Config configuration functions  
2212:../src/stm32f30x_rtc.c ****  *
2213:../src/stm32f30x_rtc.c **** @verbatim   
2214:../src/stm32f30x_rtc.c ****  ===============================================================================
2215:../src/stm32f30x_rtc.c ****             ##### Output Type Config configuration functions #####
2216:../src/stm32f30x_rtc.c ****  ===============================================================================  
2217:../src/stm32f30x_rtc.c **** 
2218:../src/stm32f30x_rtc.c **** @endverbatim
2219:../src/stm32f30x_rtc.c ****   * @{
2220:../src/stm32f30x_rtc.c ****   */
2221:../src/stm32f30x_rtc.c **** 
2222:../src/stm32f30x_rtc.c **** /**
2223:../src/stm32f30x_rtc.c ****   * @brief  Configures the RTC Output Pin mode. 
2224:../src/stm32f30x_rtc.c ****   * @param  RTC_OutputType: specifies the RTC Output (PC13) pin mode.
2225:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
2226:../src/stm32f30x_rtc.c ****   *     @arg RTC_OutputType_OpenDrain: RTC Output (PC13) is configured in 
2227:../src/stm32f30x_rtc.c ****   *                                    Open Drain mode.
2228:../src/stm32f30x_rtc.c ****   *     @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
2229:../src/stm32f30x_rtc.c ****   *                                    Push Pull mode.    
2230:../src/stm32f30x_rtc.c ****   * @retval None
2231:../src/stm32f30x_rtc.c ****   */
2232:../src/stm32f30x_rtc.c **** void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
2233:../src/stm32f30x_rtc.c **** {
 3657              		.loc 1 2233 0
 3658              		.cfi_startproc
 3659              		@ args = 0, pretend = 0, frame = 8
 3660              		@ frame_needed = 1, uses_anonymous_args = 0
 3661              		@ link register save eliminated.
 3662 16fc 80B4     		push	{r7}
 3663              	.LCFI128:
 3664              		.cfi_def_cfa_offset 4
 3665              		.cfi_offset 7, -4
 3666 16fe 83B0     		sub	sp, sp, #12
 3667              	.LCFI129:
 3668              		.cfi_def_cfa_offset 16
 3669 1700 00AF     		add	r7, sp, #0
 3670              	.LCFI130:
 3671              		.cfi_def_cfa_register 7
 3672 1702 7860     		str	r0, [r7, #4]
2234:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2235:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
2236:../src/stm32f30x_rtc.c ****   
2237:../src/stm32f30x_rtc.c ****   RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
 3673              		.loc 1 2237 0
 3674 1704 4FF42053 		mov	r3, #10240
 3675 1708 C4F20003 		movt	r3, 16384
 3676 170c 4FF42052 		mov	r2, #10240
 3677 1710 C4F20002 		movt	r2, 16384
 3678 1714 126C     		ldr	r2, [r2, #64]
 3679 1716 22F48022 		bic	r2, r2, #262144
 3680 171a 1A64     		str	r2, [r3, #64]
2238:../src/stm32f30x_rtc.c ****   RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
 3681              		.loc 1 2238 0
 3682 171c 4FF42053 		mov	r3, #10240
 3683 1720 C4F20003 		movt	r3, 16384
 3684 1724 4FF42052 		mov	r2, #10240
 3685 1728 C4F20002 		movt	r2, 16384
 3686 172c 116C     		ldr	r1, [r2, #64]
 3687 172e 7A68     		ldr	r2, [r7, #4]
 3688 1730 0A43     		orrs	r2, r2, r1
 3689 1732 1A64     		str	r2, [r3, #64]
2239:../src/stm32f30x_rtc.c **** }
 3690              		.loc 1 2239 0
 3691 1734 07F10C07 		add	r7, r7, #12
 3692 1738 BD46     		mov	sp, r7
 3693 173a 80BC     		pop	{r7}
 3694 173c 7047     		bx	lr
 3695              		.cfi_endproc
 3696              	.LFE155:
 3698 173e 00BF     		.align	2
 3699              		.global	RTC_SynchroShiftConfig
 3700              		.thumb
 3701              		.thumb_func
 3703              	RTC_SynchroShiftConfig:
 3704              	.LFB156:
2240:../src/stm32f30x_rtc.c **** 
2241:../src/stm32f30x_rtc.c **** /**
2242:../src/stm32f30x_rtc.c ****   * @}
2243:../src/stm32f30x_rtc.c ****   */
2244:../src/stm32f30x_rtc.c **** 
2245:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group12 Shift control synchronisation functions
2246:../src/stm32f30x_rtc.c ****  *  @brief   Shift control synchronisation functions 
2247:../src/stm32f30x_rtc.c ****  *
2248:../src/stm32f30x_rtc.c **** @verbatim   
2249:../src/stm32f30x_rtc.c ****  ===============================================================================
2250:../src/stm32f30x_rtc.c ****               ##### Shift control synchronisation functions #####
2251:../src/stm32f30x_rtc.c ****  ===============================================================================  
2252:../src/stm32f30x_rtc.c **** 
2253:../src/stm32f30x_rtc.c **** @endverbatim
2254:../src/stm32f30x_rtc.c ****   * @{
2255:../src/stm32f30x_rtc.c ****   */
2256:../src/stm32f30x_rtc.c **** 
2257:../src/stm32f30x_rtc.c **** /**
2258:../src/stm32f30x_rtc.c ****   * @brief  Configures the Synchronization Shift Control Settings.
2259:../src/stm32f30x_rtc.c ****   * @note   When REFCKON is set, firmware must not write to Shift control register 
2260:../src/stm32f30x_rtc.c ****   * @param  RTC_ShiftAdd1S : Select to add or not 1 second to the time Calendar.
2261:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values :
2262:../src/stm32f30x_rtc.c ****   *     @arg RTC_ShiftAdd1S_Set  : Add one second to the clock calendar. 
2263:../src/stm32f30x_rtc.c ****   *     @arg RTC_ShiftAdd1S_Reset: No effect.
2264:../src/stm32f30x_rtc.c ****   * @param  RTC_ShiftSubFS: Select the number of Second Fractions to Substitute.
2265:../src/stm32f30x_rtc.c ****   *         This parameter can be one any value from 0 to 0x7FFF.
2266:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
2267:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC Shift registers are configured
2268:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC Shift registers are not configured
2269:../src/stm32f30x_rtc.c **** */
2270:../src/stm32f30x_rtc.c **** ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
2271:../src/stm32f30x_rtc.c **** {
 3705              		.loc 1 2271 0
 3706              		.cfi_startproc
 3707              		@ args = 0, pretend = 0, frame = 16
 3708              		@ frame_needed = 1, uses_anonymous_args = 0
 3709 1740 80B5     		push	{r7, lr}
 3710              	.LCFI131:
 3711              		.cfi_def_cfa_offset 8
 3712              		.cfi_offset 7, -8
 3713              		.cfi_offset 14, -4
 3714 1742 84B0     		sub	sp, sp, #16
 3715              	.LCFI132:
 3716              		.cfi_def_cfa_offset 24
 3717 1744 00AF     		add	r7, sp, #0
 3718              	.LCFI133:
 3719              		.cfi_def_cfa_register 7
 3720 1746 7860     		str	r0, [r7, #4]
 3721 1748 3960     		str	r1, [r7, #0]
2272:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 3722              		.loc 1 2272 0
 3723 174a 4FF00003 		mov	r3, #0
 3724 174e FB73     		strb	r3, [r7, #15]
2273:../src/stm32f30x_rtc.c ****   uint32_t shpfcount = 0;
 3725              		.loc 1 2273 0
 3726 1750 4FF00003 		mov	r3, #0
 3727 1754 BB60     		str	r3, [r7, #8]
2274:../src/stm32f30x_rtc.c **** 
2275:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2276:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
2277:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
2278:../src/stm32f30x_rtc.c **** 
2279:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
2280:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 3728              		.loc 1 2280 0
 3729 1756 4FF42053 		mov	r3, #10240
 3730 175a C4F20003 		movt	r3, 16384
 3731 175e 4FF0CA02 		mov	r2, #202
 3732 1762 5A62     		str	r2, [r3, #36]
2281:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 3733              		.loc 1 2281 0
 3734 1764 4FF42053 		mov	r3, #10240
 3735 1768 C4F20003 		movt	r3, 16384
 3736 176c 4FF05302 		mov	r2, #83
 3737 1770 5A62     		str	r2, [r3, #36]
2282:../src/stm32f30x_rtc.c ****   
2283:../src/stm32f30x_rtc.c ****   /* Check if a Shift is pending*/
2284:../src/stm32f30x_rtc.c ****   if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
 3738              		.loc 1 2284 0
 3739 1772 4FF42053 		mov	r3, #10240
 3740 1776 C4F20003 		movt	r3, 16384
 3741 177a DB68     		ldr	r3, [r3, #12]
 3742 177c 03F00803 		and	r3, r3, #8
 3743 1780 002B     		cmp	r3, #0
 3744 1782 11D0     		beq	.L154
2285:../src/stm32f30x_rtc.c ****   {
2286:../src/stm32f30x_rtc.c ****     /* Wait until the shift is completed*/
2287:../src/stm32f30x_rtc.c ****     while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 3745              		.loc 1 2287 0
 3746 1784 03E0     		b	.L155
 3747              	.L156:
2288:../src/stm32f30x_rtc.c ****     {
2289:../src/stm32f30x_rtc.c ****       shpfcount++;
 3748              		.loc 1 2289 0
 3749 1786 BB68     		ldr	r3, [r7, #8]
 3750 1788 03F10103 		add	r3, r3, #1
 3751 178c BB60     		str	r3, [r7, #8]
 3752              	.L155:
2287:../src/stm32f30x_rtc.c ****     while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 3753              		.loc 1 2287 0 discriminator 1
 3754 178e 4FF42053 		mov	r3, #10240
 3755 1792 C4F20003 		movt	r3, 16384
 3756 1796 DB68     		ldr	r3, [r3, #12]
 3757 1798 03F00803 		and	r3, r3, #8
 3758 179c 002B     		cmp	r3, #0
 3759 179e 03D0     		beq	.L154
2287:../src/stm32f30x_rtc.c ****     while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 3760              		.loc 1 2287 0 is_stmt 0 discriminator 2
 3761 17a0 BB68     		ldr	r3, [r7, #8]
 3762 17a2 B3F5005F 		cmp	r3, #8192
 3763 17a6 EED1     		bne	.L156
 3764              	.L154:
2290:../src/stm32f30x_rtc.c ****     }
2291:../src/stm32f30x_rtc.c ****   }
2292:../src/stm32f30x_rtc.c **** 
2293:../src/stm32f30x_rtc.c ****   /* Check if the Shift pending is completed or if there is no Shift operation at all*/
2294:../src/stm32f30x_rtc.c ****   if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
 3765              		.loc 1 2294 0 is_stmt 1
 3766 17a8 4FF42053 		mov	r3, #10240
 3767 17ac C4F20003 		movt	r3, 16384
 3768 17b0 DB68     		ldr	r3, [r3, #12]
 3769 17b2 03F00803 		and	r3, r3, #8
 3770 17b6 002B     		cmp	r3, #0
 3771 17b8 21D1     		bne	.L157
2295:../src/stm32f30x_rtc.c ****   {
2296:../src/stm32f30x_rtc.c ****     /* check if the reference clock detection is disabled */
2297:../src/stm32f30x_rtc.c ****     if((RTC->CR & RTC_CR_REFCKON) == RESET)
 3772              		.loc 1 2297 0
 3773 17ba 4FF42053 		mov	r3, #10240
 3774 17be C4F20003 		movt	r3, 16384
 3775 17c2 9B68     		ldr	r3, [r3, #8]
 3776 17c4 03F01003 		and	r3, r3, #16
 3777 17c8 002B     		cmp	r3, #0
 3778 17ca 14D1     		bne	.L158
2298:../src/stm32f30x_rtc.c ****     {
2299:../src/stm32f30x_rtc.c ****       /* Configure the Shift settings */
2300:../src/stm32f30x_rtc.c ****       RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
 3779              		.loc 1 2300 0
 3780 17cc 4FF42053 		mov	r3, #10240
 3781 17d0 C4F20003 		movt	r3, 16384
 3782 17d4 3968     		ldr	r1, [r7, #0]
 3783 17d6 7A68     		ldr	r2, [r7, #4]
 3784 17d8 0A43     		orrs	r2, r2, r1
 3785 17da DA62     		str	r2, [r3, #44]
2301:../src/stm32f30x_rtc.c ****     
2302:../src/stm32f30x_rtc.c ****       if(RTC_WaitForSynchro() == ERROR)
 3786              		.loc 1 2302 0
 3787 17dc FFF7FEFF 		bl	RTC_WaitForSynchro
 3788 17e0 0346     		mov	r3, r0
 3789 17e2 002B     		cmp	r3, #0
 3790 17e4 03D1     		bne	.L159
2303:../src/stm32f30x_rtc.c ****       {
2304:../src/stm32f30x_rtc.c ****         status = ERROR;
 3791              		.loc 1 2304 0
 3792 17e6 4FF00003 		mov	r3, #0
 3793 17ea FB73     		strb	r3, [r7, #15]
 3794 17ec 0AE0     		b	.L160
 3795              	.L159:
2305:../src/stm32f30x_rtc.c ****       }
2306:../src/stm32f30x_rtc.c ****       else
2307:../src/stm32f30x_rtc.c ****       {
2308:../src/stm32f30x_rtc.c ****         status = SUCCESS;
 3796              		.loc 1 2308 0
 3797 17ee 4FF00103 		mov	r3, #1
 3798 17f2 FB73     		strb	r3, [r7, #15]
 3799 17f4 06E0     		b	.L160
 3800              	.L158:
2309:../src/stm32f30x_rtc.c ****       }
2310:../src/stm32f30x_rtc.c ****     }
2311:../src/stm32f30x_rtc.c ****     else
2312:../src/stm32f30x_rtc.c ****     {
2313:../src/stm32f30x_rtc.c ****       status = ERROR;
 3801              		.loc 1 2313 0
 3802 17f6 4FF00003 		mov	r3, #0
 3803 17fa FB73     		strb	r3, [r7, #15]
 3804 17fc 02E0     		b	.L160
 3805              	.L157:
2314:../src/stm32f30x_rtc.c ****     }
2315:../src/stm32f30x_rtc.c ****   }
2316:../src/stm32f30x_rtc.c ****   else
2317:../src/stm32f30x_rtc.c ****   {
2318:../src/stm32f30x_rtc.c ****     status = ERROR;
 3806              		.loc 1 2318 0
 3807 17fe 4FF00003 		mov	r3, #0
 3808 1802 FB73     		strb	r3, [r7, #15]
 3809              	.L160:
2319:../src/stm32f30x_rtc.c ****   }
2320:../src/stm32f30x_rtc.c **** 
2321:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
2322:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 3810              		.loc 1 2322 0
 3811 1804 4FF42053 		mov	r3, #10240
 3812 1808 C4F20003 		movt	r3, 16384
 3813 180c 4FF0FF02 		mov	r2, #255
 3814 1810 5A62     		str	r2, [r3, #36]
2323:../src/stm32f30x_rtc.c ****   
2324:../src/stm32f30x_rtc.c ****   return (ErrorStatus)(status);
 3815              		.loc 1 2324 0
 3816 1812 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
2325:../src/stm32f30x_rtc.c **** }
 3817              		.loc 1 2325 0
 3818 1814 1846     		mov	r0, r3
 3819 1816 07F11007 		add	r7, r7, #16
 3820 181a BD46     		mov	sp, r7
 3821 181c 80BD     		pop	{r7, pc}
 3822              		.cfi_endproc
 3823              	.LFE156:
 3825 181e 00BF     		.align	2
 3826              		.global	RTC_ITConfig
 3827              		.thumb
 3828              		.thumb_func
 3830              	RTC_ITConfig:
 3831              	.LFB157:
2326:../src/stm32f30x_rtc.c **** 
2327:../src/stm32f30x_rtc.c **** /**
2328:../src/stm32f30x_rtc.c ****   * @}
2329:../src/stm32f30x_rtc.c ****   */
2330:../src/stm32f30x_rtc.c **** 
2331:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group13 Interrupts and flags management functions
2332:../src/stm32f30x_rtc.c ****  *  @brief   Interrupts and flags management functions  
2333:../src/stm32f30x_rtc.c ****  *
2334:../src/stm32f30x_rtc.c **** @verbatim   
2335:../src/stm32f30x_rtc.c ****  ===============================================================================
2336:../src/stm32f30x_rtc.c ****                 ##### Interrupts and flags management functions #####
2337:../src/stm32f30x_rtc.c ****  ===============================================================================  
2338:../src/stm32f30x_rtc.c ****     [..] All RTC interrupts are connected to the EXTI controller.
2339:../src/stm32f30x_rtc.c ****          (+) To enable the RTC Alarm interrupt, the following sequence is required:
2340:../src/stm32f30x_rtc.c ****              (++) Configure and enable the EXTI Line 17 in interrupt mode and select 
2341:../src/stm32f30x_rtc.c ****                   the rising edge sensitivity using the EXTI_Init() function.
2342:../src/stm32f30x_rtc.c ****              (++) Configure and enable the RTC_Alarm IRQ channel in the NVIC using 
2343:../src/stm32f30x_rtc.c ****                   the NVIC_Init() function.
2344:../src/stm32f30x_rtc.c ****              (++) Configure the RTC to generate RTC alarms (Alarm A and/or Alarm B)
2345:../src/stm32f30x_rtc.c ****                   using the RTC_SetAlarm() and RTC_AlarmCmd() functions.
2346:../src/stm32f30x_rtc.c ****          (+) To enable the RTC Wakeup interrupt, the following sequence is required:
2347:../src/stm32f30x_rtc.c ****              (++) Configure and enable the EXTI Line 20 in interrupt mode and select 
2348:../src/stm32f30x_rtc.c ****                   the rising edge sensitivity using the EXTI_Init() function.
2349:../src/stm32f30x_rtc.c ****              (++) Configure and enable the RTC_WKUP IRQ channel in the NVIC using
2350:../src/stm32f30x_rtc.c ****                   the NVIC_Init() function.
2351:../src/stm32f30x_rtc.c ****              (++) Configure the RTC to generate the RTC wakeup timer event using the 
2352:../src/stm32f30x_rtc.c ****                   RTC_WakeUpClockConfig(), RTC_SetWakeUpCounter() and RTC_WakeUpCmd() 
2353:../src/stm32f30x_rtc.c ****                   functions.
2354:../src/stm32f30x_rtc.c ****          (+) To enable the RTC Tamper interrupt, the following sequence is required:
2355:../src/stm32f30x_rtc.c ****              (++) Configure and enable the EXTI Line 19 in interrupt mode and select 
2356:../src/stm32f30x_rtc.c ****                   the rising edge sensitivity using the EXTI_Init() function.
2357:../src/stm32f30x_rtc.c ****              (++) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using 
2358:../src/stm32f30x_rtc.c ****                   the NVIC_Init() function.
2359:../src/stm32f30x_rtc.c ****              (++) Configure the RTC to detect the RTC tamper event using the 
2360:../src/stm32f30x_rtc.c ****                   RTC_TamperTriggerConfig() and RTC_TamperCmd() functions.
2361:../src/stm32f30x_rtc.c ****          (+) To enable the RTC TimeStamp interrupt, the following sequence is required:
2362:../src/stm32f30x_rtc.c ****              (++) Configure and enable the EXTI Line 19 in interrupt mode and select
2363:../src/stm32f30x_rtc.c ****                   the rising edge sensitivity using the EXTI_Init() function.
2364:../src/stm32f30x_rtc.c ****              (++) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using 
2365:../src/stm32f30x_rtc.c ****                   the NVIC_Init() function.
2366:../src/stm32f30x_rtc.c ****              (++) Configure the RTC to detect the RTC time-stamp event using the 
2367:../src/stm32f30x_rtc.c ****                   RTC_TimeStampCmd() functions.
2368:../src/stm32f30x_rtc.c **** 
2369:../src/stm32f30x_rtc.c **** @endverbatim
2370:../src/stm32f30x_rtc.c ****   * @{
2371:../src/stm32f30x_rtc.c ****   */
2372:../src/stm32f30x_rtc.c **** 
2373:../src/stm32f30x_rtc.c **** /**
2374:../src/stm32f30x_rtc.c ****   * @brief  Enables or disables the specified RTC interrupts.
2375:../src/stm32f30x_rtc.c ****   * @param  RTC_IT: specifies the RTC interrupt sources to be enabled or disabled. 
2376:../src/stm32f30x_rtc.c ****   *   This parameter can be any combination of the following values:
2377:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TS:  Time Stamp interrupt mask
2378:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_WUT:  WakeUp Timer interrupt mask
2379:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_ALRB:  Alarm B interrupt mask
2380:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_ALRA:  Alarm A interrupt mask
2381:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TAMP: Tamper event interrupt mask
2382:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the specified RTC interrupts.
2383:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.
2384:../src/stm32f30x_rtc.c ****   * @retval None
2385:../src/stm32f30x_rtc.c ****   */
2386:../src/stm32f30x_rtc.c **** void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
2387:../src/stm32f30x_rtc.c **** {
 3832              		.loc 1 2387 0
 3833              		.cfi_startproc
 3834              		@ args = 0, pretend = 0, frame = 8
 3835              		@ frame_needed = 1, uses_anonymous_args = 0
 3836              		@ link register save eliminated.
 3837 1820 80B4     		push	{r7}
 3838              	.LCFI134:
 3839              		.cfi_def_cfa_offset 4
 3840              		.cfi_offset 7, -4
 3841 1822 83B0     		sub	sp, sp, #12
 3842              	.LCFI135:
 3843              		.cfi_def_cfa_offset 16
 3844 1824 00AF     		add	r7, sp, #0
 3845              	.LCFI136:
 3846              		.cfi_def_cfa_register 7
 3847 1826 7860     		str	r0, [r7, #4]
 3848 1828 0B46     		mov	r3, r1
 3849 182a FB70     		strb	r3, [r7, #3]
2388:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2389:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_CONFIG_IT(RTC_IT));
2390:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
2391:../src/stm32f30x_rtc.c **** 
2392:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
2393:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 3850              		.loc 1 2393 0
 3851 182c 4FF42053 		mov	r3, #10240
 3852 1830 C4F20003 		movt	r3, 16384
 3853 1834 4FF0CA02 		mov	r2, #202
 3854 1838 5A62     		str	r2, [r3, #36]
2394:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 3855              		.loc 1 2394 0
 3856 183a 4FF42053 		mov	r3, #10240
 3857 183e C4F20003 		movt	r3, 16384
 3858 1842 4FF05302 		mov	r2, #83
 3859 1846 5A62     		str	r2, [r3, #36]
2395:../src/stm32f30x_rtc.c **** 
2396:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 3860              		.loc 1 2396 0
 3861 1848 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 3862 184a 002B     		cmp	r3, #0
 3863 184c 1CD0     		beq	.L163
2397:../src/stm32f30x_rtc.c ****   {
2398:../src/stm32f30x_rtc.c ****     /* Configure the Interrupts in the RTC_CR register */
2399:../src/stm32f30x_rtc.c ****     RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
 3864              		.loc 1 2399 0
 3865 184e 4FF42053 		mov	r3, #10240
 3866 1852 C4F20003 		movt	r3, 16384
 3867 1856 4FF42052 		mov	r2, #10240
 3868 185a C4F20002 		movt	r2, 16384
 3869 185e 9168     		ldr	r1, [r2, #8]
 3870 1860 7A68     		ldr	r2, [r7, #4]
 3871 1862 22F00402 		bic	r2, r2, #4
 3872 1866 0A43     		orrs	r2, r2, r1
 3873 1868 9A60     		str	r2, [r3, #8]
2400:../src/stm32f30x_rtc.c ****     /* Configure the Tamper Interrupt in the RTC_TAFCR */
2401:../src/stm32f30x_rtc.c ****     RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
 3874              		.loc 1 2401 0
 3875 186a 4FF42053 		mov	r3, #10240
 3876 186e C4F20003 		movt	r3, 16384
 3877 1872 4FF42052 		mov	r2, #10240
 3878 1876 C4F20002 		movt	r2, 16384
 3879 187a 116C     		ldr	r1, [r2, #64]
 3880 187c 7A68     		ldr	r2, [r7, #4]
 3881 187e 02F00402 		and	r2, r2, #4
 3882 1882 0A43     		orrs	r2, r2, r1
 3883 1884 1A64     		str	r2, [r3, #64]
 3884 1886 1FE0     		b	.L164
 3885              	.L163:
2402:../src/stm32f30x_rtc.c ****   }
2403:../src/stm32f30x_rtc.c ****   else
2404:../src/stm32f30x_rtc.c ****   {
2405:../src/stm32f30x_rtc.c ****     /* Configure the Interrupts in the RTC_CR register */
2406:../src/stm32f30x_rtc.c ****     RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
 3886              		.loc 1 2406 0
 3887 1888 4FF42053 		mov	r3, #10240
 3888 188c C4F20003 		movt	r3, 16384
 3889 1890 4FF42052 		mov	r2, #10240
 3890 1894 C4F20002 		movt	r2, 16384
 3891 1898 9168     		ldr	r1, [r2, #8]
 3892 189a 7A68     		ldr	r2, [r7, #4]
 3893 189c 22F00402 		bic	r2, r2, #4
 3894 18a0 6FEA0202 		mvn	r2, r2
 3895 18a4 0A40     		ands	r2, r2, r1
 3896 18a6 9A60     		str	r2, [r3, #8]
2407:../src/stm32f30x_rtc.c ****     /* Configure the Tamper Interrupt in the RTC_TAFCR */
2408:../src/stm32f30x_rtc.c ****     RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
 3897              		.loc 1 2408 0
 3898 18a8 4FF42053 		mov	r3, #10240
 3899 18ac C4F20003 		movt	r3, 16384
 3900 18b0 4FF42052 		mov	r2, #10240
 3901 18b4 C4F20002 		movt	r2, 16384
 3902 18b8 116C     		ldr	r1, [r2, #64]
 3903 18ba 7A68     		ldr	r2, [r7, #4]
 3904 18bc 02F00402 		and	r2, r2, #4
 3905 18c0 6FEA0202 		mvn	r2, r2
 3906 18c4 0A40     		ands	r2, r2, r1
 3907 18c6 1A64     		str	r2, [r3, #64]
 3908              	.L164:
2409:../src/stm32f30x_rtc.c ****   }
2410:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
2411:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF; 
 3909              		.loc 1 2411 0
 3910 18c8 4FF42053 		mov	r3, #10240
 3911 18cc C4F20003 		movt	r3, 16384
 3912 18d0 4FF0FF02 		mov	r2, #255
 3913 18d4 5A62     		str	r2, [r3, #36]
2412:../src/stm32f30x_rtc.c **** }
 3914              		.loc 1 2412 0
 3915 18d6 07F10C07 		add	r7, r7, #12
 3916 18da BD46     		mov	sp, r7
 3917 18dc 80BC     		pop	{r7}
 3918 18de 7047     		bx	lr
 3919              		.cfi_endproc
 3920              	.LFE157:
 3922              		.align	2
 3923              		.global	RTC_GetFlagStatus
 3924              		.thumb
 3925              		.thumb_func
 3927              	RTC_GetFlagStatus:
 3928              	.LFB158:
2413:../src/stm32f30x_rtc.c **** 
2414:../src/stm32f30x_rtc.c **** /**
2415:../src/stm32f30x_rtc.c ****   * @brief  Checks whether the specified RTC flag is set or not.
2416:../src/stm32f30x_rtc.c ****   * @param  RTC_FLAG: specifies the flag to check.
2417:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
2418:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_RECALPF: RECALPF event flag
2419:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TAMP3F: Tamper 3 event flag
2420:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TAMP2F: Tamper 2 event flag   
2421:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
2422:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TSOVF: Time Stamp OverFlow flag
2423:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TSF: Time Stamp event flag
2424:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_WUTF: WakeUp Timer flag
2425:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_ALRBF: Alarm B flag
2426:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_ALRAF: Alarm A flag
2427:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_INITF: Initialization mode flag
2428:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_RSF: Registers Synchronized flag
2429:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_INITS: Registers Configured flag
2430:../src/stm32f30x_rtc.c ****   *     @argRTC_FLAG_SHPF  : Shift operation pending flag.  
2431:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_WUTWF: WakeUp Timer Write flag
2432:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_ALRBWF: Alarm B Write flag
2433:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_ALRAWF: Alarm A write flag
2434:../src/stm32f30x_rtc.c ****   * @retval The new state of RTC_FLAG (SET or RESET).
2435:../src/stm32f30x_rtc.c ****   */
2436:../src/stm32f30x_rtc.c **** FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
2437:../src/stm32f30x_rtc.c **** {
 3929              		.loc 1 2437 0
 3930              		.cfi_startproc
 3931              		@ args = 0, pretend = 0, frame = 16
 3932              		@ frame_needed = 1, uses_anonymous_args = 0
 3933              		@ link register save eliminated.
 3934 18e0 80B4     		push	{r7}
 3935              	.LCFI137:
 3936              		.cfi_def_cfa_offset 4
 3937              		.cfi_offset 7, -4
 3938 18e2 85B0     		sub	sp, sp, #20
 3939              	.LCFI138:
 3940              		.cfi_def_cfa_offset 24
 3941 18e4 00AF     		add	r7, sp, #0
 3942              	.LCFI139:
 3943              		.cfi_def_cfa_register 7
 3944 18e6 7860     		str	r0, [r7, #4]
2438:../src/stm32f30x_rtc.c ****   FlagStatus bitstatus = RESET;
 3945              		.loc 1 2438 0
 3946 18e8 4FF00003 		mov	r3, #0
 3947 18ec FB73     		strb	r3, [r7, #15]
2439:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 3948              		.loc 1 2439 0
 3949 18ee 4FF00003 		mov	r3, #0
 3950 18f2 BB60     		str	r3, [r7, #8]
2440:../src/stm32f30x_rtc.c ****   
2441:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2442:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
2443:../src/stm32f30x_rtc.c ****   
2444:../src/stm32f30x_rtc.c ****   /* Get all the flags */
2445:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
 3951              		.loc 1 2445 0
 3952 18f4 4FF42053 		mov	r3, #10240
 3953 18f8 C4F20003 		movt	r3, 16384
 3954 18fc DA68     		ldr	r2, [r3, #12]
 3955 18fe 4FF67F73 		movw	r3, #65407
 3956 1902 C0F20103 		movt	r3, 1
 3957 1906 1340     		ands	r3, r3, r2
 3958 1908 BB60     		str	r3, [r7, #8]
2446:../src/stm32f30x_rtc.c ****   
2447:../src/stm32f30x_rtc.c ****   /* Return the status of the flag */
2448:../src/stm32f30x_rtc.c ****   if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
 3959              		.loc 1 2448 0
 3960 190a BA68     		ldr	r2, [r7, #8]
 3961 190c 7B68     		ldr	r3, [r7, #4]
 3962 190e 1340     		ands	r3, r3, r2
 3963 1910 002B     		cmp	r3, #0
 3964 1912 03D0     		beq	.L166
2449:../src/stm32f30x_rtc.c ****   {
2450:../src/stm32f30x_rtc.c ****     bitstatus = SET;
 3965              		.loc 1 2450 0
 3966 1914 4FF00103 		mov	r3, #1
 3967 1918 FB73     		strb	r3, [r7, #15]
 3968 191a 02E0     		b	.L167
 3969              	.L166:
2451:../src/stm32f30x_rtc.c ****   }
2452:../src/stm32f30x_rtc.c ****   else
2453:../src/stm32f30x_rtc.c ****   {
2454:../src/stm32f30x_rtc.c ****     bitstatus = RESET;
 3970              		.loc 1 2454 0
 3971 191c 4FF00003 		mov	r3, #0
 3972 1920 FB73     		strb	r3, [r7, #15]
 3973              	.L167:
2455:../src/stm32f30x_rtc.c ****   }
2456:../src/stm32f30x_rtc.c ****   return bitstatus;
 3974              		.loc 1 2456 0
 3975 1922 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
2457:../src/stm32f30x_rtc.c **** }
 3976              		.loc 1 2457 0
 3977 1924 1846     		mov	r0, r3
 3978 1926 07F11407 		add	r7, r7, #20
 3979 192a BD46     		mov	sp, r7
 3980 192c 80BC     		pop	{r7}
 3981 192e 7047     		bx	lr
 3982              		.cfi_endproc
 3983              	.LFE158:
 3985              		.align	2
 3986              		.global	RTC_ClearFlag
 3987              		.thumb
 3988              		.thumb_func
 3990              	RTC_ClearFlag:
 3991              	.LFB159:
2458:../src/stm32f30x_rtc.c **** 
2459:../src/stm32f30x_rtc.c **** /**
2460:../src/stm32f30x_rtc.c ****   * @brief  Clears the RTC's pending flags.
2461:../src/stm32f30x_rtc.c ****   * @param  RTC_FLAG: specifies the RTC flag to clear.
2462:../src/stm32f30x_rtc.c ****   *   This parameter can be any combination of the following values:
2463:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TAMP3F: Tamper 3 event flag
2464:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TAMP2F: Tamper 2 event flag
2465:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TAMP1F: Tamper 1 event flag 
2466:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TSOVF: Time Stamp Overflow flag 
2467:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TSF: Time Stamp event flag
2468:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_WUTF: WakeUp Timer flag
2469:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_ALRBF: Alarm B flag
2470:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_ALRAF: Alarm A flag
2471:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_RSF: Registers Synchronized flag
2472:../src/stm32f30x_rtc.c ****   * @retval None
2473:../src/stm32f30x_rtc.c ****   */
2474:../src/stm32f30x_rtc.c **** void RTC_ClearFlag(uint32_t RTC_FLAG)
2475:../src/stm32f30x_rtc.c **** {
 3992              		.loc 1 2475 0
 3993              		.cfi_startproc
 3994              		@ args = 0, pretend = 0, frame = 8
 3995              		@ frame_needed = 1, uses_anonymous_args = 0
 3996              		@ link register save eliminated.
 3997 1930 80B4     		push	{r7}
 3998              	.LCFI140:
 3999              		.cfi_def_cfa_offset 4
 4000              		.cfi_offset 7, -4
 4001 1932 83B0     		sub	sp, sp, #12
 4002              	.LCFI141:
 4003              		.cfi_def_cfa_offset 16
 4004 1934 00AF     		add	r7, sp, #0
 4005              	.LCFI142:
 4006              		.cfi_def_cfa_register 7
 4007 1936 7860     		str	r0, [r7, #4]
2476:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2477:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
2478:../src/stm32f30x_rtc.c **** 
2479:../src/stm32f30x_rtc.c ****   /* Clear the Flags in the RTC_ISR register */
2480:../src/stm32f30x_rtc.c ****   RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0001FFFF) | (uint32_t)(RTC->ISR &
 4008              		.loc 1 2480 0
 4009 1938 4FF42052 		mov	r2, #10240
 4010 193c C4F20002 		movt	r2, 16384
 4011 1940 7968     		ldr	r1, [r7, #4]
 4012 1942 4FF67F73 		movw	r3, #65407
 4013 1946 C0F20103 		movt	r3, 1
 4014 194a 0B40     		ands	r3, r3, r1
 4015 194c 43F08003 		orr	r3, r3, #128
 4016 1950 6FEA0301 		mvn	r1, r3
 4017 1954 4FF42053 		mov	r3, #10240
 4018 1958 C4F20003 		movt	r3, 16384
 4019 195c DB68     		ldr	r3, [r3, #12]
 4020 195e 03F08003 		and	r3, r3, #128
 4021 1962 0B43     		orrs	r3, r3, r1
 4022 1964 D360     		str	r3, [r2, #12]
2481:../src/stm32f30x_rtc.c **** }
 4023              		.loc 1 2481 0
 4024 1966 07F10C07 		add	r7, r7, #12
 4025 196a BD46     		mov	sp, r7
 4026 196c 80BC     		pop	{r7}
 4027 196e 7047     		bx	lr
 4028              		.cfi_endproc
 4029              	.LFE159:
 4031              		.align	2
 4032              		.global	RTC_GetITStatus
 4033              		.thumb
 4034              		.thumb_func
 4036              	RTC_GetITStatus:
 4037              	.LFB160:
2482:../src/stm32f30x_rtc.c **** 
2483:../src/stm32f30x_rtc.c **** /**
2484:../src/stm32f30x_rtc.c ****   * @brief  Checks whether the specified RTC interrupt has occurred or not.
2485:../src/stm32f30x_rtc.c ****   * @param  RTC_IT: specifies the RTC interrupt source to check.
2486:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
2487:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TS: Time Stamp interrupt 
2488:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_WUT: WakeUp Timer interrupt 
2489:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_ALRB: Alarm B interrupt 
2490:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_ALRA: Alarm A interrupt 
2491:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TAMP1: Tamper1 event interrupt 
2492:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TAMP2: Tamper2 event interrupt 
2493:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TAMP3: Tamper3 event interrupt
2494:../src/stm32f30x_rtc.c ****   * @retval The new state of RTC_IT (SET or RESET).
2495:../src/stm32f30x_rtc.c ****   */
2496:../src/stm32f30x_rtc.c **** ITStatus RTC_GetITStatus(uint32_t RTC_IT)
2497:../src/stm32f30x_rtc.c **** {
 4038              		.loc 1 2497 0
 4039              		.cfi_startproc
 4040              		@ args = 0, pretend = 0, frame = 24
 4041              		@ frame_needed = 1, uses_anonymous_args = 0
 4042              		@ link register save eliminated.
 4043 1970 80B4     		push	{r7}
 4044              	.LCFI143:
 4045              		.cfi_def_cfa_offset 4
 4046              		.cfi_offset 7, -4
 4047 1972 87B0     		sub	sp, sp, #28
 4048              	.LCFI144:
 4049              		.cfi_def_cfa_offset 32
 4050 1974 00AF     		add	r7, sp, #0
 4051              	.LCFI145:
 4052              		.cfi_def_cfa_register 7
 4053 1976 7860     		str	r0, [r7, #4]
2498:../src/stm32f30x_rtc.c ****   ITStatus bitstatus = RESET;
 4054              		.loc 1 2498 0
 4055 1978 4FF00003 		mov	r3, #0
 4056 197c FB75     		strb	r3, [r7, #23]
2499:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0, enablestatus = 0;
 4057              		.loc 1 2499 0
 4058 197e 4FF00003 		mov	r3, #0
 4059 1982 3B61     		str	r3, [r7, #16]
 4060 1984 4FF00003 		mov	r3, #0
 4061 1988 FB60     		str	r3, [r7, #12]
2500:../src/stm32f30x_rtc.c ****  
2501:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2502:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_GET_IT(RTC_IT));
2503:../src/stm32f30x_rtc.c ****   
2504:../src/stm32f30x_rtc.c ****   /* Get the TAMPER Interrupt enable bit and pending bit */
2505:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
 4062              		.loc 1 2505 0
 4063 198a 4FF42053 		mov	r3, #10240
 4064 198e C4F20003 		movt	r3, 16384
 4065 1992 1B6C     		ldr	r3, [r3, #64]
 4066 1994 03F00403 		and	r3, r3, #4
 4067 1998 3B61     		str	r3, [r7, #16]
2506:../src/stm32f30x_rtc.c ****  
2507:../src/stm32f30x_rtc.c ****   /* Get the Interrupt enable Status */
2508:../src/stm32f30x_rtc.c ****   enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & ((RTC_IT >> (RTC_IT >> 18)) >> 15)));
 4068              		.loc 1 2508 0
 4069 199a 4FF42053 		mov	r3, #10240
 4070 199e C4F20003 		movt	r3, 16384
 4071 19a2 9A68     		ldr	r2, [r3, #8]
 4072 19a4 7B68     		ldr	r3, [r7, #4]
 4073 19a6 1A40     		ands	r2, r2, r3
 4074 19a8 7B68     		ldr	r3, [r7, #4]
 4075 19aa 4FEA9343 		lsr	r3, r3, #18
 4076 19ae 7968     		ldr	r1, [r7, #4]
 4077 19b0 21FA03F3 		lsr	r3, r1, r3
 4078 19b4 4FEAD331 		lsr	r1, r3, #15
 4079 19b8 3B69     		ldr	r3, [r7, #16]
 4080 19ba 0B40     		ands	r3, r3, r1
 4081 19bc 1343     		orrs	r3, r3, r2
 4082 19be FB60     		str	r3, [r7, #12]
2509:../src/stm32f30x_rtc.c ****   
2510:../src/stm32f30x_rtc.c ****   /* Get the Interrupt pending bit */
2511:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
 4083              		.loc 1 2511 0
 4084 19c0 4FF42053 		mov	r3, #10240
 4085 19c4 C4F20003 		movt	r3, 16384
 4086 19c8 DA68     		ldr	r2, [r3, #12]
 4087 19ca 7B68     		ldr	r3, [r7, #4]
 4088 19cc 4FEA1313 		lsr	r3, r3, #4
 4089 19d0 1340     		ands	r3, r3, r2
 4090 19d2 3B61     		str	r3, [r7, #16]
2512:../src/stm32f30x_rtc.c ****   
2513:../src/stm32f30x_rtc.c ****   /* Get the status of the Interrupt */
2514:../src/stm32f30x_rtc.c ****   if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
 4091              		.loc 1 2514 0
 4092 19d4 FB68     		ldr	r3, [r7, #12]
 4093 19d6 002B     		cmp	r3, #0
 4094 19d8 0AD0     		beq	.L171
 4095              		.loc 1 2514 0 is_stmt 0 discriminator 1
 4096 19da 3B69     		ldr	r3, [r7, #16]
 4097 19dc 4FEA0343 		lsl	r3, r3, #16
 4098 19e0 4FEA1343 		lsr	r3, r3, #16
 4099 19e4 002B     		cmp	r3, #0
 4100 19e6 03D0     		beq	.L171
2515:../src/stm32f30x_rtc.c ****   {
2516:../src/stm32f30x_rtc.c ****     bitstatus = SET;
 4101              		.loc 1 2516 0 is_stmt 1
 4102 19e8 4FF00103 		mov	r3, #1
 4103 19ec FB75     		strb	r3, [r7, #23]
 4104 19ee 02E0     		b	.L172
 4105              	.L171:
2517:../src/stm32f30x_rtc.c ****   }
2518:../src/stm32f30x_rtc.c ****   else
2519:../src/stm32f30x_rtc.c ****   {
2520:../src/stm32f30x_rtc.c ****     bitstatus = RESET;
 4106              		.loc 1 2520 0
 4107 19f0 4FF00003 		mov	r3, #0
 4108 19f4 FB75     		strb	r3, [r7, #23]
 4109              	.L172:
2521:../src/stm32f30x_rtc.c ****   }
2522:../src/stm32f30x_rtc.c ****   return bitstatus;
 4110              		.loc 1 2522 0
 4111 19f6 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
2523:../src/stm32f30x_rtc.c **** }
 4112              		.loc 1 2523 0
 4113 19f8 1846     		mov	r0, r3
 4114 19fa 07F11C07 		add	r7, r7, #28
 4115 19fe BD46     		mov	sp, r7
 4116 1a00 80BC     		pop	{r7}
 4117 1a02 7047     		bx	lr
 4118              		.cfi_endproc
 4119              	.LFE160:
 4121              		.align	2
 4122              		.global	RTC_ClearITPendingBit
 4123              		.thumb
 4124              		.thumb_func
 4126              	RTC_ClearITPendingBit:
 4127              	.LFB161:
2524:../src/stm32f30x_rtc.c **** 
2525:../src/stm32f30x_rtc.c **** /**
2526:../src/stm32f30x_rtc.c ****   * @brief  Clears the RTC's interrupt pending bits.
2527:../src/stm32f30x_rtc.c ****   * @param  RTC_IT: specifies the RTC interrupt pending bit to clear.
2528:../src/stm32f30x_rtc.c ****   *   This parameter can be any combination of the following values:
2529:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TS: Time Stamp interrupt 
2530:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_WUT: WakeUp Timer interrupt 
2531:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_ALRB: Alarm B interrupt 
2532:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_ALRA: Alarm A interrupt 
2533:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TAMP1: Tamper1 event interrupt
2534:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TAMP2: Tamper2 event interrupt
2535:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TAMP3: Tamper3 event interrupt 
2536:../src/stm32f30x_rtc.c ****   * @retval None
2537:../src/stm32f30x_rtc.c ****   */
2538:../src/stm32f30x_rtc.c **** void RTC_ClearITPendingBit(uint32_t RTC_IT)
2539:../src/stm32f30x_rtc.c **** {
 4128              		.loc 1 2539 0
 4129              		.cfi_startproc
 4130              		@ args = 0, pretend = 0, frame = 16
 4131              		@ frame_needed = 1, uses_anonymous_args = 0
 4132              		@ link register save eliminated.
 4133 1a04 80B4     		push	{r7}
 4134              	.LCFI146:
 4135              		.cfi_def_cfa_offset 4
 4136              		.cfi_offset 7, -4
 4137 1a06 85B0     		sub	sp, sp, #20
 4138              	.LCFI147:
 4139              		.cfi_def_cfa_offset 24
 4140 1a08 00AF     		add	r7, sp, #0
 4141              	.LCFI148:
 4142              		.cfi_def_cfa_register 7
 4143 1a0a 7860     		str	r0, [r7, #4]
2540:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 4144              		.loc 1 2540 0
 4145 1a0c 4FF00003 		mov	r3, #0
 4146 1a10 FB60     		str	r3, [r7, #12]
2541:../src/stm32f30x_rtc.c **** 
2542:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2543:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_CLEAR_IT(RTC_IT));
2544:../src/stm32f30x_rtc.c **** 
2545:../src/stm32f30x_rtc.c ****   /* Get the RTC_ISR Interrupt pending bits mask */
2546:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)(RTC_IT >> 4);
 4147              		.loc 1 2546 0
 4148 1a12 7B68     		ldr	r3, [r7, #4]
 4149 1a14 4FEA1313 		lsr	r3, r3, #4
 4150 1a18 FB60     		str	r3, [r7, #12]
2547:../src/stm32f30x_rtc.c **** 
2548:../src/stm32f30x_rtc.c ****   /* Clear the interrupt pending bits in the RTC_ISR register */
2549:../src/stm32f30x_rtc.c ****   RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & R
 4151              		.loc 1 2549 0
 4152 1a1a 4FF42053 		mov	r3, #10240
 4153 1a1e C4F20003 		movt	r3, 16384
 4154 1a22 FA68     		ldr	r2, [r7, #12]
 4155 1a24 4FEA0242 		lsl	r2, r2, #16
 4156 1a28 4FEA1242 		lsr	r2, r2, #16
 4157 1a2c 42F08002 		orr	r2, r2, #128
 4158 1a30 6FEA0201 		mvn	r1, r2
 4159 1a34 4FF42052 		mov	r2, #10240
 4160 1a38 C4F20002 		movt	r2, 16384
 4161 1a3c D268     		ldr	r2, [r2, #12]
 4162 1a3e 02F08002 		and	r2, r2, #128
 4163 1a42 0A43     		orrs	r2, r2, r1
 4164 1a44 DA60     		str	r2, [r3, #12]
2550:../src/stm32f30x_rtc.c **** }
 4165              		.loc 1 2550 0
 4166 1a46 07F11407 		add	r7, r7, #20
 4167 1a4a BD46     		mov	sp, r7
 4168 1a4c 80BC     		pop	{r7}
 4169 1a4e 7047     		bx	lr
 4170              		.cfi_endproc
 4171              	.LFE161:
 4173              		.align	2
 4174              		.thumb
 4175              		.thumb_func
 4177              	RTC_ByteToBcd2:
 4178              	.LFB162:
2551:../src/stm32f30x_rtc.c **** 
2552:../src/stm32f30x_rtc.c **** /**
2553:../src/stm32f30x_rtc.c ****   * @}
2554:../src/stm32f30x_rtc.c ****   */
2555:../src/stm32f30x_rtc.c **** 
2556:../src/stm32f30x_rtc.c **** /**
2557:../src/stm32f30x_rtc.c ****   * @brief  Converts a 2 digit decimal to BCD format.
2558:../src/stm32f30x_rtc.c ****   * @param  Value: Byte to be converted.
2559:../src/stm32f30x_rtc.c ****   * @retval Converted byte
2560:../src/stm32f30x_rtc.c ****   */
2561:../src/stm32f30x_rtc.c **** static uint8_t RTC_ByteToBcd2(uint8_t Value)
2562:../src/stm32f30x_rtc.c **** {
 4179              		.loc 1 2562 0
 4180              		.cfi_startproc
 4181              		@ args = 0, pretend = 0, frame = 16
 4182              		@ frame_needed = 1, uses_anonymous_args = 0
 4183              		@ link register save eliminated.
 4184 1a50 80B4     		push	{r7}
 4185              	.LCFI149:
 4186              		.cfi_def_cfa_offset 4
 4187              		.cfi_offset 7, -4
 4188 1a52 85B0     		sub	sp, sp, #20
 4189              	.LCFI150:
 4190              		.cfi_def_cfa_offset 24
 4191 1a54 00AF     		add	r7, sp, #0
 4192              	.LCFI151:
 4193              		.cfi_def_cfa_register 7
 4194 1a56 0346     		mov	r3, r0
 4195 1a58 FB71     		strb	r3, [r7, #7]
2563:../src/stm32f30x_rtc.c ****   uint8_t bcdhigh = 0;
 4196              		.loc 1 2563 0
 4197 1a5a 4FF00003 		mov	r3, #0
 4198 1a5e FB73     		strb	r3, [r7, #15]
2564:../src/stm32f30x_rtc.c ****   
2565:../src/stm32f30x_rtc.c ****   while (Value >= 10)
 4199              		.loc 1 2565 0
 4200 1a60 07E0     		b	.L176
 4201              	.L177:
2566:../src/stm32f30x_rtc.c ****   {
2567:../src/stm32f30x_rtc.c ****     bcdhigh++;
 4202              		.loc 1 2567 0
 4203 1a62 FB7B     		ldrb	r3, [r7, #15]
 4204 1a64 03F10103 		add	r3, r3, #1
 4205 1a68 FB73     		strb	r3, [r7, #15]
2568:../src/stm32f30x_rtc.c ****     Value -= 10;
 4206              		.loc 1 2568 0
 4207 1a6a FB79     		ldrb	r3, [r7, #7]
 4208 1a6c A3F10A03 		sub	r3, r3, #10
 4209 1a70 FB71     		strb	r3, [r7, #7]
 4210              	.L176:
2565:../src/stm32f30x_rtc.c ****   while (Value >= 10)
 4211              		.loc 1 2565 0 discriminator 1
 4212 1a72 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4213 1a74 092B     		cmp	r3, #9
 4214 1a76 F4D8     		bhi	.L177
2569:../src/stm32f30x_rtc.c ****   }
2570:../src/stm32f30x_rtc.c ****   
2571:../src/stm32f30x_rtc.c ****   return  ((uint8_t)(bcdhigh << 4) | Value);
 4215              		.loc 1 2571 0
 4216 1a78 FB7B     		ldrb	r3, [r7, #15]
 4217 1a7a 4FEA0313 		lsl	r3, r3, #4
 4218 1a7e DAB2     		uxtb	r2, r3
 4219 1a80 FB79     		ldrb	r3, [r7, #7]
 4220 1a82 1343     		orrs	r3, r3, r2
 4221 1a84 DBB2     		uxtb	r3, r3
2572:../src/stm32f30x_rtc.c **** }
 4222              		.loc 1 2572 0
 4223 1a86 1846     		mov	r0, r3
 4224 1a88 07F11407 		add	r7, r7, #20
 4225 1a8c BD46     		mov	sp, r7
 4226 1a8e 80BC     		pop	{r7}
 4227 1a90 7047     		bx	lr
 4228              		.cfi_endproc
 4229              	.LFE162:
 4231 1a92 00BF     		.align	2
 4232              		.thumb
 4233              		.thumb_func
 4235              	RTC_Bcd2ToByte:
 4236              	.LFB163:
2573:../src/stm32f30x_rtc.c **** 
2574:../src/stm32f30x_rtc.c **** /**
2575:../src/stm32f30x_rtc.c ****   * @brief  Convert from 2 digit BCD to Binary.
2576:../src/stm32f30x_rtc.c ****   * @param  Value: BCD value to be converted.
2577:../src/stm32f30x_rtc.c ****   * @retval Converted word
2578:../src/stm32f30x_rtc.c ****   */
2579:../src/stm32f30x_rtc.c **** static uint8_t RTC_Bcd2ToByte(uint8_t Value)
2580:../src/stm32f30x_rtc.c **** {
 4237              		.loc 1 2580 0
 4238              		.cfi_startproc
 4239              		@ args = 0, pretend = 0, frame = 16
 4240              		@ frame_needed = 1, uses_anonymous_args = 0
 4241              		@ link register save eliminated.
 4242 1a94 80B4     		push	{r7}
 4243              	.LCFI152:
 4244              		.cfi_def_cfa_offset 4
 4245              		.cfi_offset 7, -4
 4246 1a96 85B0     		sub	sp, sp, #20
 4247              	.LCFI153:
 4248              		.cfi_def_cfa_offset 24
 4249 1a98 00AF     		add	r7, sp, #0
 4250              	.LCFI154:
 4251              		.cfi_def_cfa_register 7
 4252 1a9a 0346     		mov	r3, r0
 4253 1a9c FB71     		strb	r3, [r7, #7]
2581:../src/stm32f30x_rtc.c ****   uint8_t tmp = 0;
 4254              		.loc 1 2581 0
 4255 1a9e 4FF00003 		mov	r3, #0
 4256 1aa2 FB73     		strb	r3, [r7, #15]
2582:../src/stm32f30x_rtc.c ****   tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 4257              		.loc 1 2582 0
 4258 1aa4 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4259 1aa6 4FEA1313 		lsr	r3, r3, #4
 4260 1aaa DBB2     		uxtb	r3, r3
 4261 1aac 1A46     		mov	r2, r3
 4262 1aae 4FEA8202 		lsl	r2, r2, #2
 4263 1ab2 D318     		adds	r3, r2, r3
 4264 1ab4 4FEA4303 		lsl	r3, r3, #1
 4265 1ab8 FB73     		strb	r3, [r7, #15]
2583:../src/stm32f30x_rtc.c ****   return (tmp + (Value & (uint8_t)0x0F));
 4266              		.loc 1 2583 0
 4267 1aba FB79     		ldrb	r3, [r7, #7]
 4268 1abc 03F00F03 		and	r3, r3, #15
 4269 1ac0 DAB2     		uxtb	r2, r3
 4270 1ac2 FB7B     		ldrb	r3, [r7, #15]
 4271 1ac4 D318     		adds	r3, r2, r3
 4272 1ac6 DBB2     		uxtb	r3, r3
2584:../src/stm32f30x_rtc.c **** }
 4273              		.loc 1 2584 0
 4274 1ac8 1846     		mov	r0, r3
 4275 1aca 07F11407 		add	r7, r7, #20
 4276 1ace BD46     		mov	sp, r7
 4277 1ad0 80BC     		pop	{r7}
 4278 1ad2 7047     		bx	lr
 4279              		.cfi_endproc
 4280              	.LFE163:
 4282              	.Letext0:
 4283              		.file 2 "/home/aghosh01/gcc-arm-none-eabi-4_7-2012q4/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../.
 4284              		.file 3 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x.h"
 4285              		.file 4 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x_rtc.h"
 4286              		.file 5 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f30x_rtc.c
     /tmp/ccWs2aVc.s:20     .text:00000000 $t
     /tmp/ccWs2aVc.s:25     .text:00000000 RTC_DeInit
     /tmp/ccWs2aVc.s:413    .text:000002c8 RTC_EnterInitMode
     /tmp/ccWs2aVc.s:541    .text:00000380 RTC_WaitForSynchro
     /tmp/ccWs2aVc.s:214    .text:00000194 RTC_Init
     /tmp/ccWs2aVc.s:507    .text:0000035c RTC_ExitInitMode
     /tmp/ccWs2aVc.s:316    .text:00000254 RTC_StructInit
     /tmp/ccWs2aVc.s:359    .text:00000280 RTC_WriteProtectionCmd
     /tmp/ccWs2aVc.s:654    .text:00000448 RTC_RefClockCmd
     /tmp/ccWs2aVc.s:745    .text:000004e4 RTC_BypassShadowCmd
     /tmp/ccWs2aVc.s:815    .text:0000055c RTC_SetTime
     /tmp/ccWs2aVc.s:4235   .text:00001a94 RTC_Bcd2ToByte
     /tmp/ccWs2aVc.s:4177   .text:00001a50 RTC_ByteToBcd2
     /tmp/ccWs2aVc.s:1014   .text:000006bc RTC_TimeStructInit
     /tmp/ccWs2aVc.s:1061   .text:000006f0 RTC_GetTime
     /tmp/ccWs2aVc.s:1162   .text:00000798 RTC_GetSubSecond
     /tmp/ccWs2aVc.s:1207   .text:000007c8 RTC_SetDate
     /tmp/ccWs2aVc.s:1407   .text:00000924 RTC_DateStructInit
     /tmp/ccWs2aVc.s:1454   .text:00000958 RTC_GetDate
     /tmp/ccWs2aVc.s:1560   .text:00000a08 RTC_SetAlarm
     /tmp/ccWs2aVc.s:1783   .text:00000b84 RTC_AlarmStructInit
     /tmp/ccWs2aVc.s:1842   .text:00000bd0 RTC_GetAlarm
     /tmp/ccWs2aVc.s:1980   .text:00000cbc RTC_AlarmCmd
     /tmp/ccWs2aVc.s:2107   .text:00000da4 RTC_AlarmSubSecondConfig
     /tmp/ccWs2aVc.s:2180   .text:00000e14 RTC_GetAlarmSubSecond
     /tmp/ccWs2aVc.s:2238   .text:00000e64 RTC_WakeUpClockConfig
     /tmp/ccWs2aVc.s:2301   .text:00000ed0 RTC_SetWakeUpCounter
     /tmp/ccWs2aVc.s:2352   .text:00000f18 RTC_GetWakeUpCounter
     /tmp/ccWs2aVc.s:2385   .text:00000f38 RTC_WakeUpCmd
     /tmp/ccWs2aVc.s:2504   .text:00001010 RTC_DayLightSavingConfig
     /tmp/ccWs2aVc.s:2570   .text:00001084 RTC_GetStoreOperation
     /tmp/ccWs2aVc.s:2602   .text:000010a0 RTC_OutputConfig
     /tmp/ccWs2aVc.s:2668   .text:00001114 RTC_CalibOutputCmd
     /tmp/ccWs2aVc.s:2738   .text:0000118c RTC_CalibOutputConfig
     /tmp/ccWs2aVc.s:2801   .text:000011f8 RTC_SmoothCalibConfig
     /tmp/ccWs2aVc.s:2910   .text:000012b4 RTC_TimeStampCmd
     /tmp/ccWs2aVc.s:2991   .text:00001338 RTC_GetTimeStamp
     /tmp/ccWs2aVc.s:3154   .text:00001468 RTC_GetTimeStampSubSecond
     /tmp/ccWs2aVc.s:3185   .text:00001480 RTC_TamperTriggerConfig
     /tmp/ccWs2aVc.s:3245   .text:000014d8 RTC_TamperCmd
     /tmp/ccWs2aVc.s:3304   .text:0000152c RTC_TamperFilterConfig
     /tmp/ccWs2aVc.s:3352   .text:00001570 RTC_TamperSamplingFreqConfig
     /tmp/ccWs2aVc.s:3400   .text:000015b4 RTC_TamperPinsPrechargeDuration
     /tmp/ccWs2aVc.s:3448   .text:000015f8 RTC_TimeStampOnTamperDetectionCmd
     /tmp/ccWs2aVc.s:3503   .text:00001644 RTC_TamperPullUpCmd
     /tmp/ccWs2aVc.s:3558   .text:00001690 RTC_WriteBackupRegister
     /tmp/ccWs2aVc.s:3607   .text:000016c8 RTC_ReadBackupRegister
     /tmp/ccWs2aVc.s:3655   .text:000016fc RTC_OutputTypeConfig
     /tmp/ccWs2aVc.s:3703   .text:00001740 RTC_SynchroShiftConfig
     /tmp/ccWs2aVc.s:3830   .text:00001820 RTC_ITConfig
     /tmp/ccWs2aVc.s:3927   .text:000018e0 RTC_GetFlagStatus
     /tmp/ccWs2aVc.s:3990   .text:00001930 RTC_ClearFlag
     /tmp/ccWs2aVc.s:4036   .text:00001970 RTC_GetITStatus
     /tmp/ccWs2aVc.s:4126   .text:00001a04 RTC_ClearITPendingBit
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.743cd71370ebc432b539c5dba7924ecc
                           .group:00000000 wm4.stm32f30x.h.56.6f19c65e98e3319a61449cb2b2455af5
                           .group:00000000 wm4.core_cm4.h.32.1434cd257ff5806b1b03cd32ab0641e9
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.core_cmInstr.h.25.d8165482ef3061013a2fc83e2d85f3d9
                           .group:00000000 wm4.core_cm4_simd.h.29.013e5bcf58dba2d27c60184174208e07
                           .group:00000000 wm4.core_cm4.h.155.cf7c793e178943e1bbf613f1b21cd51a
                           .group:00000000 wm4.stm32f30x.h.294.d8a54360eca16e4157694b52a095202d
                           .group:00000000 wm4.stm32f30x_adc.h.130.cbebad91f78fb87381fe0860eea6104e
                           .group:00000000 wm4.stm32f30x_can.h.50.8b8f5d301152c422a6e50622b33ef620
                           .group:00000000 wm4.stm32f30x_crc.h.54.66d4c5e565e18566aebd9abfd4bcd4b0
                           .group:00000000 wm4.stm32f30x_comp.h.91.06ae44150aaaa82c077b71df8db3541a
                           .group:00000000 wm4.stm32f30x_dac.h.49.b1b5b26e4ca241dbe67fa16dc86a615f
                           .group:00000000 wm4.stm32f30x_dbgmcu.h.53.b238a263ce6a2cc83f610cc35302a38b
                           .group:00000000 wm4.stm32f30x_dma.h.96.d7a2ddd10023e12781aa8ff5ac15d212
                           .group:00000000 wm4.stm32f30x_exti.h.60.8ca0809491a21dec6fc69cf7471e2bab
                           .group:00000000 wm4.stm32f30x_flash.h.70.32613455dfe7328932f786a224daac23
                           .group:00000000 wm4.stm32f30x_gpio.h.50.408e1f6250246e4cc28221970909d34c
                           .group:00000000 wm4.stm32f30x_syscfg.h.58.4cadeb4ec8e47d36b972bbb6b96b7161
                           .group:00000000 wm4.stm32f30x_i2c.h.86.3d51d4edc0e3b9ee9aae045ccbb7739a
                           .group:00000000 wm4.stm32f30x_iwdg.h.59.467d704fb073a015941f19b50fa6470a
                           .group:00000000 wm4.stm32f30x_opamp.h.75.704e2e5e2aab039de307aaa2dcc99fa5
                           .group:00000000 wm4.stm32f30x_pwr.h.59.5c85acff2a3e3c5085b2140c06025cfc
                           .group:00000000 wm4.stm32f30x_rcc.h.79.5ba7cac1e74879861a72556c25322aa4
                           .group:00000000 wm4.stm32f30x_spi.h.119.4d21ec94ec14f3553a127e61c0a9874f
                           .group:00000000 wm4.stm32f30x_tim.h.175.d4a93cff2e7924577147254e501271b6
                           .group:00000000 wm4.stm32f30x_usart.h.110.c89016273702821ff4f9fe43881f70b5
                           .group:00000000 wm4.stm32f30x_wwdg.h.58.4688eee61a2709866472b4b4c07d9275
                           .group:00000000 wm4.stm32f30x_misc.h.113.6a52e4fe7c3825a3ab05990f30dddf92
                           .group:00000000 wm4.stm32f30x_rtc.h.133.d184e08ff40bda44db4bed94f9633384

NO UNDEFINED SYMBOLS
