   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"stm32f30x_rtc.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.align	2
  20              		.global	RTC_DeInit
  21              		.thumb
  22              		.thumb_func
  24              	RTC_DeInit:
  25              	.LFB111:
  26              		.file 1 "../src/stm32f30x_rtc.c"
   1:../src/stm32f30x_rtc.c **** /**
   2:../src/stm32f30x_rtc.c ****   ******************************************************************************
   3:../src/stm32f30x_rtc.c ****   * @file    stm32f30x_rtc.c
   4:../src/stm32f30x_rtc.c ****   * @author  MCD Application Team
   5:../src/stm32f30x_rtc.c ****   * @version V1.0.1
   6:../src/stm32f30x_rtc.c ****   * @date    23-October-2012
   7:../src/stm32f30x_rtc.c ****   * @brief   This file provides firmware functions to manage the following 
   8:../src/stm32f30x_rtc.c ****   *          functionalities of the Real-Time Clock (RTC) peripheral:
   9:../src/stm32f30x_rtc.c ****   *           + Initialization
  10:../src/stm32f30x_rtc.c ****   *           + Calendar (Time and Date) configuration
  11:../src/stm32f30x_rtc.c ****   *           + Alarms (Alarm A and Alarm B) configuration
  12:../src/stm32f30x_rtc.c ****   *           + WakeUp Timer configuration
  13:../src/stm32f30x_rtc.c ****   *           + Daylight Saving configuration
  14:../src/stm32f30x_rtc.c ****   *           + Output pin Configuration
  15:../src/stm32f30x_rtc.c ****   *           + Smooth digital Calibration configuration
  16:../src/stm32f30x_rtc.c ****   *           + TimeStamp configuration
  17:../src/stm32f30x_rtc.c ****   *           + Tampers configuration
  18:../src/stm32f30x_rtc.c ****   *           + Backup Data Registers configuration
  19:../src/stm32f30x_rtc.c ****   *           + Output Type Config configuration
  20:../src/stm32f30x_rtc.c ****   *           + Shift control synchronisation  
  21:../src/stm32f30x_rtc.c ****   *           + Interrupts and flags management       
  22:../src/stm32f30x_rtc.c ****   *                     
  23:../src/stm32f30x_rtc.c ****   @verbatim
  24:../src/stm32f30x_rtc.c ****        
  25:../src/stm32f30x_rtc.c ****  ===============================================================================     
  26:../src/stm32f30x_rtc.c ****                           ##### RTC Operating Condition #####
  27:../src/stm32f30x_rtc.c ****  ===============================================================================
  28:../src/stm32f30x_rtc.c ****     [..] The real-time clock (RTC) and the RTC backup registers can be powered
  29:../src/stm32f30x_rtc.c ****          from the VBAT voltage when the main VDD supply is powered off.
  30:../src/stm32f30x_rtc.c ****          To retain the content of the RTC backup registers and supply the RTC 
  31:../src/stm32f30x_rtc.c ****          when VDD is turned off, VBAT pin can be connected to an optional
  32:../src/stm32f30x_rtc.c ****          standby voltage supplied by a battery or by another source.
  33:../src/stm32f30x_rtc.c ****   
  34:../src/stm32f30x_rtc.c ****     [..] To allow the RTC to operate even when the main digital supply (VDD) 
  35:../src/stm32f30x_rtc.c ****          is turned off, the VBAT pin powers the following blocks:
  36:../src/stm32f30x_rtc.c ****            (#) The RTC
  37:../src/stm32f30x_rtc.c ****            (#) The LSE oscillator
  38:../src/stm32f30x_rtc.c ****            (#) PC13 to PC15 I/Os (when available)
  39:../src/stm32f30x_rtc.c ****   
  40:../src/stm32f30x_rtc.c ****     [..] When the backup domain is supplied by VDD (analog switch connected 
  41:../src/stm32f30x_rtc.c ****          to VDD), the following functions are available:
  42:../src/stm32f30x_rtc.c ****            (#) PC14 and PC15 can be used as either GPIO or LSE pins
  43:../src/stm32f30x_rtc.c ****            (#) PC13 can be used as a GPIO or as the RTC_AF pin
  44:../src/stm32f30x_rtc.c ****   
  45:../src/stm32f30x_rtc.c ****     [..] When the backup domain is supplied by VBAT (analog switch connected 
  46:../src/stm32f30x_rtc.c ****          to VBAT because VDD is not present), the following functions are available:
  47:../src/stm32f30x_rtc.c ****            (#) PC14 and PC15 can be used as LSE pins only
  48:../src/stm32f30x_rtc.c ****            (#) PC13 can be used as the RTC_AF pin 
  49:../src/stm32f30x_rtc.c **** 
  50:../src/stm32f30x_rtc.c ****                         ##### Backup Domain Reset #####
  51:../src/stm32f30x_rtc.c ****  ===============================================================================
  52:../src/stm32f30x_rtc.c ****     [..] The backup domain reset sets all RTC registers and the RCC_BDCR 
  53:../src/stm32f30x_rtc.c ****          register to their reset values. 
  54:../src/stm32f30x_rtc.c ****          A backup domain reset is generated when one of the following events
  55:../src/stm32f30x_rtc.c ****          occurs:
  56:../src/stm32f30x_rtc.c ****            (#) Software reset, triggered by setting the BDRST bit in the 
  57:../src/stm32f30x_rtc.c ****                RCC Backup domain control register (RCC_BDCR). You can use the
  58:../src/stm32f30x_rtc.c ****                RCC_BackupResetCmd().
  59:../src/stm32f30x_rtc.c ****            (#) VDD or VBAT power on, if both supplies have previously been
  60:../src/stm32f30x_rtc.c ****                powered off.
  61:../src/stm32f30x_rtc.c ****                          
  62:../src/stm32f30x_rtc.c ****                         ##### Backup Domain Access #####
  63:../src/stm32f30x_rtc.c ****  ===============================================================================
  64:../src/stm32f30x_rtc.c ****     [..] After reset, the backup domain (RTC registers and RTC backup data 
  65:../src/stm32f30x_rtc.c ****          registers) is protected against possible unwanted write accesses. 
  66:../src/stm32f30x_rtc.c ****     [..] To enable access to the Backup Domain and RTC registers, proceed as follows:
  67:../src/stm32f30x_rtc.c ****          (#) Enable the Power Controller (PWR) APB1 interface clock using the
  68:../src/stm32f30x_rtc.c ****              RCC_APB1PeriphClockCmd() function.
  69:../src/stm32f30x_rtc.c ****          (#) Enable access to Backup domain using the PWR_BackupAccessCmd() function.
  70:../src/stm32f30x_rtc.c ****          (#) Select the RTC clock source using the RCC_RTCCLKConfig() function.
  71:../src/stm32f30x_rtc.c ****          (#) Enable RTC Clock using the RCC_RTCCLKCmd() function.
  72:../src/stm32f30x_rtc.c ****               
  73:../src/stm32f30x_rtc.c ****                          ##### How to use this driver #####
  74:../src/stm32f30x_rtc.c ****  ===============================================================================
  75:../src/stm32f30x_rtc.c ****     [..]     
  76:../src/stm32f30x_rtc.c ****         (+) Enable the backup domain access (see description in the section above)
  77:../src/stm32f30x_rtc.c ****          (+) Configure the RTC Prescaler (Asynchronous and Synchronous) and
  78:../src/stm32f30x_rtc.c ****              RTC hour format using the RTC_Init() function.
  79:../src/stm32f30x_rtc.c ****                 
  80:../src/stm32f30x_rtc.c ****     *** Time and Date configuration ***
  81:../src/stm32f30x_rtc.c ****     ===================================    
  82:../src/stm32f30x_rtc.c ****     [..]     
  83:../src/stm32f30x_rtc.c ****          (+) To configure the RTC Calendar (Time and Date) use the RTC_SetTime()
  84:../src/stm32f30x_rtc.c ****              and RTC_SetDate() functions.
  85:../src/stm32f30x_rtc.c ****          (+) To read the RTC Calendar, use the RTC_GetTime() and RTC_GetDate()
  86:../src/stm32f30x_rtc.c ****              functions.
  87:../src/stm32f30x_rtc.c ****          (+) To read the RTC subsecond, use the RTC_GetSubSecond() function.
  88:../src/stm32f30x_rtc.c ****          (+) Use the RTC_DayLightSavingConfig() function to add or sub one
  89:../src/stm32f30x_rtc.c ****              hour to the RTC Calendar.    
  90:../src/stm32f30x_rtc.c ****                 
  91:../src/stm32f30x_rtc.c ****     *** Alarm configuration ***
  92:../src/stm32f30x_rtc.c ****     ===========================    
  93:../src/stm32f30x_rtc.c ****     [..]
  94:../src/stm32f30x_rtc.c ****          (+) To configure the RTC Alarm use the RTC_SetAlarm() function.
  95:../src/stm32f30x_rtc.c ****          (+) Enable the selected RTC Alarm using the RTC_AlarmCmd() function.
  96:../src/stm32f30x_rtc.c ****          (+) To read the RTC Alarm, use the RTC_GetAlarm() function.
  97:../src/stm32f30x_rtc.c ****          (+) To read the RTC alarm SubSecond, use the RTC_GetAlarmSubSecond() function.
  98:../src/stm32f30x_rtc.c ****               
  99:../src/stm32f30x_rtc.c ****     *** RTC Wakeup configuration ***
 100:../src/stm32f30x_rtc.c ****     ================================    
 101:../src/stm32f30x_rtc.c ****     [..]
 102:../src/stm32f30x_rtc.c ****          (+) Configure the RTC Wakeup Clock source use the RTC_WakeUpClockConfig()
 103:../src/stm32f30x_rtc.c ****              function.
 104:../src/stm32f30x_rtc.c ****          (+) Configure the RTC WakeUp Counter using the RTC_SetWakeUpCounter() 
 105:../src/stm32f30x_rtc.c ****              function  
 106:../src/stm32f30x_rtc.c ****          (+) Enable the RTC WakeUp using the RTC_WakeUpCmd() function  
 107:../src/stm32f30x_rtc.c ****          (+) To read the RTC WakeUp Counter register, use the RTC_GetWakeUpCounter() 
 108:../src/stm32f30x_rtc.c ****              function.
 109:../src/stm32f30x_rtc.c ****                 
 110:../src/stm32f30x_rtc.c ****     *** Outputs configuration ***
 111:../src/stm32f30x_rtc.c ****     =============================  
 112:../src/stm32f30x_rtc.c ****     [..] The RTC has 2 different outputs:
 113:../src/stm32f30x_rtc.c ****          (+) AFO_ALARM: this output is used to manage the RTC Alarm A, Alarm B
 114:../src/stm32f30x_rtc.c ****              and WaKeUp signals.          
 115:../src/stm32f30x_rtc.c ****              To output the selected RTC signal on RTC_AF pin, use the 
 116:../src/stm32f30x_rtc.c ****              RTC_OutputConfig() function.                
 117:../src/stm32f30x_rtc.c ****          (+) AFO_CALIB: this output is 512Hz signal or 1Hz .
 118:../src/stm32f30x_rtc.c ****              To output the RTC Clock on RTC_AF pin, use the RTC_CalibOutputCmd()
 119:../src/stm32f30x_rtc.c ****              function.                
 120:../src/stm32f30x_rtc.c ****                 
 121:../src/stm32f30x_rtc.c ****     *** Smooth digital Calibration configuration ***
 122:../src/stm32f30x_rtc.c ****     ================================================    
 123:../src/stm32f30x_rtc.c ****     [..]
 124:../src/stm32f30x_rtc.c ****          (+) Configure the RTC Original Digital Calibration Value and the corresponding
 125:../src/stm32f30x_rtc.c ****              calibration cycle period (32s,16s and 8s) using the RTC_SmoothCalibConfig() 
 126:../src/stm32f30x_rtc.c ****              function.                                                       
 127:../src/stm32f30x_rtc.c ****                 
 128:../src/stm32f30x_rtc.c ****     *** TimeStamp configuration ***
 129:../src/stm32f30x_rtc.c ****     ===============================    
 130:../src/stm32f30x_rtc.c ****     [..]
 131:../src/stm32f30x_rtc.c ****          (+) Configure the RTC_AF trigger and enables the RTC TimeStamp 
 132:../src/stm32f30x_rtc.c ****              using the RTC_TimeStampCmd() function.
 133:../src/stm32f30x_rtc.c ****          (+) To read the RTC TimeStamp Time and Date register, use the 
 134:../src/stm32f30x_rtc.c ****              RTC_GetTimeStamp() function.
 135:../src/stm32f30x_rtc.c ****          (+) To read the RTC TimeStamp SubSecond register, use the 
 136:../src/stm32f30x_rtc.c ****              RTC_GetTimeStampSubSecond() function.    
 137:../src/stm32f30x_rtc.c **** 
 138:../src/stm32f30x_rtc.c ****     *** Tamper configuration ***
 139:../src/stm32f30x_rtc.c ****     ============================    
 140:../src/stm32f30x_rtc.c ****     [..]
 141:../src/stm32f30x_rtc.c ****          (+) Configure the Tamper filter count using RTC_TamperFilterConfig()
 142:../src/stm32f30x_rtc.c ****              function. 
 143:../src/stm32f30x_rtc.c ****          (+) Configure the RTC Tamper trigger Edge or Level according to the Tamper 
 144:../src/stm32f30x_rtc.c ****              filter (if equal to 0 Edge else Level) value using the RTC_TamperConfig() function.
 145:../src/stm32f30x_rtc.c ****          (+) Configure the Tamper sampling frequency using RTC_TamperSamplingFreqConfig()
 146:../src/stm32f30x_rtc.c ****              function.
 147:../src/stm32f30x_rtc.c ****          (+) Configure the Tamper precharge or discharge duration using 
 148:../src/stm32f30x_rtc.c ****              RTC_TamperPinsPrechargeDuration() function.
 149:../src/stm32f30x_rtc.c ****          (+) Enable the Tamper Pull-UP using RTC_TamperPullUpDisableCmd() function.
 150:../src/stm32f30x_rtc.c ****          (+) Enable the RTC Tamper using the RTC_TamperCmd() function.
 151:../src/stm32f30x_rtc.c ****          (+) Enable the Time stamp on Tamper detection event using  
 152:../src/stm32f30x_rtc.c ****              RTC_TSOnTamperDetecCmd() function.     
 153:../src/stm32f30x_rtc.c **** 
 154:../src/stm32f30x_rtc.c ****     *** Backup Data Registers configuration ***
 155:../src/stm32f30x_rtc.c ****     ===========================================    
 156:../src/stm32f30x_rtc.c ****     [..]
 157:../src/stm32f30x_rtc.c ****          (+) To write to the RTC Backup Data registers, use the RTC_WriteBackupRegister()
 158:../src/stm32f30x_rtc.c ****              function.  
 159:../src/stm32f30x_rtc.c ****          (+) To read the RTC Backup Data registers, use the RTC_ReadBackupRegister()
 160:../src/stm32f30x_rtc.c ****              function.  
 161:../src/stm32f30x_rtc.c ****                                   
 162:../src/stm32f30x_rtc.c ****                          ##### RTC and low power modes #####
 163:../src/stm32f30x_rtc.c ****  =============================================================================== 
 164:../src/stm32f30x_rtc.c ****     [..] The MCU can be woken up from a low power mode by an RTC alternate 
 165:../src/stm32f30x_rtc.c ****          function.
 166:../src/stm32f30x_rtc.c ****     [..] The RTC alternate functions are the RTC alarms (Alarm A and Alarm B), 
 167:../src/stm32f30x_rtc.c ****          RTC wakeup, RTC tamper event detection and RTC time stamp event detection.
 168:../src/stm32f30x_rtc.c ****          These RTC alternate functions can wake up the system from the Stop 
 169:../src/stm32f30x_rtc.c ****          and Standby lowpower modes.
 170:../src/stm32f30x_rtc.c ****          The system can also wake up from low power modes without depending 
 171:../src/stm32f30x_rtc.c ****          on an external interrupt (Auto-wakeup mode), by using the RTC alarm 
 172:../src/stm32f30x_rtc.c ****          or the RTC wakeup events.
 173:../src/stm32f30x_rtc.c ****     [..] The RTC provides a programmable time base for waking up from the 
 174:../src/stm32f30x_rtc.c ****          Stop or Standby mode at regular intervals.
 175:../src/stm32f30x_rtc.c ****          Wakeup from STOP and Standby modes is possible only when the RTC 
 176:../src/stm32f30x_rtc.c ****          clock source is LSE or LSI.
 177:../src/stm32f30x_rtc.c ****            
 178:../src/stm32f30x_rtc.c ****                 ##### Selection of RTC_AF alternate functions #####
 179:../src/stm32f30x_rtc.c ****  ===============================================================================
 180:../src/stm32f30x_rtc.c ****     [..] The RTC_AF pin (PC13) can be used for the following purposes:
 181:../src/stm32f30x_rtc.c ****          (+) Wakeup pin 2 (WKUP2) using the PWR_WakeUpPinCmd() function.
 182:../src/stm32f30x_rtc.c ****          (+) AFO_ALARM output      
 183:../src/stm32f30x_rtc.c ****          (+) AFO_CALIB output
 184:../src/stm32f30x_rtc.c ****          (+) AFI_TAMPER
 185:../src/stm32f30x_rtc.c ****          (+) AFI_TIMESTAMP
 186:../src/stm32f30x_rtc.c ****                          
 187:../src/stm32f30x_rtc.c ****  +------------------------------------------------------------------------------------------+
 188:../src/stm32f30x_rtc.c ****  |     Pin         |RTC ALARM |RTC CALIB |RTC TAMPER |RTC TIMESTAMP |PC13MODE|  PC13VALUE   |
 189:../src/stm32f30x_rtc.c ****  |  configuration  | OUTPUT   | OUTPUT   |  INPUT    |    INPUT     |  bit   |     bit      |
 190:../src/stm32f30x_rtc.c ****  |  and function   | ENABLED  | ENABLED  | ENABLED   |   ENABLED    |        |              |
 191:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 192:../src/stm32f30x_rtc.c ****  |   Alarm out     |          |          |           |              | Don't  |              |
 193:../src/stm32f30x_rtc.c ****  |   output OD     |     1    |Don't care|Don't care | Don't care   | care   |      0       |
 194:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 195:../src/stm32f30x_rtc.c ****  |   Alarm out     |          |          |           |              | Don't  |              |
 196:../src/stm32f30x_rtc.c ****  |   output PP     |     1    |Don't care|Don't care | Don't care   | care   |      1       |
 197:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 198:../src/stm32f30x_rtc.c ****  | Calibration out |          |          |           |              | Don't  |              |
 199:../src/stm32f30x_rtc.c ****  |   output PP     |     0    |    1     |Don't care | Don't care   | care   |  Don't care  |
 200:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 201:../src/stm32f30x_rtc.c ****  |  TAMPER input   |          |          |           |              | Don't  |              |
 202:../src/stm32f30x_rtc.c ****  |   floating      |     0    |    0     |     1     |      0       | care   |  Don't care  |
 203:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 204:../src/stm32f30x_rtc.c ****  |  TIMESTAMP and  |          |          |           |              | Don't  |              |
 205:../src/stm32f30x_rtc.c ****  |  TAMPER input   |     0    |    0     |     1     |      1       | care   |  Don't care  |
 206:../src/stm32f30x_rtc.c ****  |   floating      |          |          |           |              |        |              |
 207:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 208:../src/stm32f30x_rtc.c ****  | TIMESTAMP input |          |          |           |              | Don't  |              |
 209:../src/stm32f30x_rtc.c ****  |    floating     |     0    |    0     |     0     |      1       | care   |  Don't care  |
 210:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 211:../src/stm32f30x_rtc.c ****  |   Output PP     |     0    |    0     |     0     |      0       |   1    | PC13 output  |
 212:../src/stm32f30x_rtc.c ****  |    Forced       |          |          |           |              |        |              |
 213:../src/stm32f30x_rtc.c ****  |-----------------|----------|----------|-----------|--------------|--------|--------------|
 214:../src/stm32f30x_rtc.c ****  |  Wakeup Pin or  |     0    |    0     |     0     |      0       |   0    | Don't care   |
 215:../src/stm32f30x_rtc.c ****  |  Standard GPIO  |          |          |           |              |        |              |
 216:../src/stm32f30x_rtc.c ****  +------------------------------------------------------------------------------------------+
 217:../src/stm32f30x_rtc.c ****     
 218:../src/stm32f30x_rtc.c ****   @endverbatim
 219:../src/stm32f30x_rtc.c ****                       
 220:../src/stm32f30x_rtc.c ****   ******************************************************************************
 221:../src/stm32f30x_rtc.c ****   * @attention
 222:../src/stm32f30x_rtc.c ****   *
 223:../src/stm32f30x_rtc.c ****   * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
 224:../src/stm32f30x_rtc.c ****   *
 225:../src/stm32f30x_rtc.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
 226:../src/stm32f30x_rtc.c ****   * You may not use this file except in compliance with the License.
 227:../src/stm32f30x_rtc.c ****   * You may obtain a copy of the License at:
 228:../src/stm32f30x_rtc.c ****   *
 229:../src/stm32f30x_rtc.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
 230:../src/stm32f30x_rtc.c ****   *
 231:../src/stm32f30x_rtc.c ****   * Unless required by applicable law or agreed to in writing, software 
 232:../src/stm32f30x_rtc.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
 233:../src/stm32f30x_rtc.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 234:../src/stm32f30x_rtc.c ****   * See the License for the specific language governing permissions and
 235:../src/stm32f30x_rtc.c ****   * limitations under the License.
 236:../src/stm32f30x_rtc.c ****   *
 237:../src/stm32f30x_rtc.c ****   ******************************************************************************
 238:../src/stm32f30x_rtc.c ****   */ 
 239:../src/stm32f30x_rtc.c **** 
 240:../src/stm32f30x_rtc.c **** /* Includes ------------------------------------------------------------------*/
 241:../src/stm32f30x_rtc.c **** #include "stm32f30x_rtc.h"
 242:../src/stm32f30x_rtc.c **** #include "stm32f30x_rcc.h"
 243:../src/stm32f30x_rtc.c **** 
 244:../src/stm32f30x_rtc.c **** /** @addtogroup STM32F30x_StdPeriph_Driver
 245:../src/stm32f30x_rtc.c ****   * @{
 246:../src/stm32f30x_rtc.c ****   */
 247:../src/stm32f30x_rtc.c **** 
 248:../src/stm32f30x_rtc.c **** /** @defgroup RTC 
 249:../src/stm32f30x_rtc.c ****   * @brief RTC driver modules
 250:../src/stm32f30x_rtc.c ****   * @{
 251:../src/stm32f30x_rtc.c ****   */
 252:../src/stm32f30x_rtc.c **** 
 253:../src/stm32f30x_rtc.c **** /* Private typedef -----------------------------------------------------------*/
 254:../src/stm32f30x_rtc.c **** /* Private define ------------------------------------------------------------*/
 255:../src/stm32f30x_rtc.c **** 
 256:../src/stm32f30x_rtc.c **** /* Masks Definition */
 257:../src/stm32f30x_rtc.c **** #define RTC_TR_RESERVED_MASK    ((uint32_t)0x007F7F7F)
 258:../src/stm32f30x_rtc.c **** #define RTC_DR_RESERVED_MASK    ((uint32_t)0x00FFFF3F) 
 259:../src/stm32f30x_rtc.c **** #define RTC_INIT_MASK           ((uint32_t)0xFFFFFFFF)  
 260:../src/stm32f30x_rtc.c **** #define RTC_RSF_MASK            ((uint32_t)0xFFFFFF5F)
 261:../src/stm32f30x_rtc.c **** #define RTC_FLAGS_MASK          ((uint32_t)(RTC_FLAG_TSOVF | RTC_FLAG_TSF | RTC_FLAG_WUTF | \
 262:../src/stm32f30x_rtc.c ****                                             RTC_FLAG_ALRBF | RTC_FLAG_ALRAF | RTC_FLAG_INITF | \
 263:../src/stm32f30x_rtc.c ****                                             RTC_FLAG_RSF | RTC_FLAG_INITS | RTC_FLAG_WUTWF | \
 264:../src/stm32f30x_rtc.c ****                                             RTC_FLAG_ALRBWF | RTC_FLAG_ALRAWF | RTC_FLAG_TAMP1F | \
 265:../src/stm32f30x_rtc.c ****                                             RTC_FLAG_TAMP2F | RTC_FLAG_TAMP3F | RTC_FLAG_RECALPF | 
 266:../src/stm32f30x_rtc.c ****                                             RTC_FLAG_SHPF))
 267:../src/stm32f30x_rtc.c **** 
 268:../src/stm32f30x_rtc.c **** #define INITMODE_TIMEOUT         ((uint32_t) 0x00002000)
 269:../src/stm32f30x_rtc.c **** #define SYNCHRO_TIMEOUT          ((uint32_t) 0x00008000)
 270:../src/stm32f30x_rtc.c **** #define RECALPF_TIMEOUT          ((uint32_t) 0x00001000)
 271:../src/stm32f30x_rtc.c **** #define SHPF_TIMEOUT             ((uint32_t) 0x00002000)
 272:../src/stm32f30x_rtc.c **** 
 273:../src/stm32f30x_rtc.c **** /* Private macro -------------------------------------------------------------*/
 274:../src/stm32f30x_rtc.c **** /* Private variables ---------------------------------------------------------*/
 275:../src/stm32f30x_rtc.c **** /* Private function prototypes -----------------------------------------------*/
 276:../src/stm32f30x_rtc.c **** static uint8_t RTC_ByteToBcd2(uint8_t Value);
 277:../src/stm32f30x_rtc.c **** static uint8_t RTC_Bcd2ToByte(uint8_t Value);
 278:../src/stm32f30x_rtc.c **** 
 279:../src/stm32f30x_rtc.c **** /* Private functions ---------------------------------------------------------*/
 280:../src/stm32f30x_rtc.c **** 
 281:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Private_Functions
 282:../src/stm32f30x_rtc.c ****   * @{
 283:../src/stm32f30x_rtc.c ****   */ 
 284:../src/stm32f30x_rtc.c **** 
 285:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group1 Initialization and Configuration functions
 286:../src/stm32f30x_rtc.c ****  *  @brief   Initialization and Configuration functions 
 287:../src/stm32f30x_rtc.c ****  *
 288:../src/stm32f30x_rtc.c **** @verbatim   
 289:../src/stm32f30x_rtc.c ****  ===============================================================================
 290:../src/stm32f30x_rtc.c ****             ##### Initialization and Configuration functions #####
 291:../src/stm32f30x_rtc.c ****  ===============================================================================  
 292:../src/stm32f30x_rtc.c ****     [..] This section provide functions allowing to initialize and configure the RTC
 293:../src/stm32f30x_rtc.c ****          Prescaler (Synchronous and Asynchronous), RTC Hour format, disable RTC registers
 294:../src/stm32f30x_rtc.c ****          Write protection, enter and exit the RTC initialization mode, RTC registers
 295:../src/stm32f30x_rtc.c ****          synchronization check and reference clock detection enable.
 296:../src/stm32f30x_rtc.c ****          (#) The RTC Prescaler is programmed to generate the RTC 1Hz time base. It is
 297:../src/stm32f30x_rtc.c ****              split into 2 programmable prescalers to minimize power consumption.
 298:../src/stm32f30x_rtc.c ****              (++) A 7-bit asynchronous prescaler and A 13-bit synchronous prescaler.
 299:../src/stm32f30x_rtc.c ****              (++) When both prescalers are used, it is recommended to configure the 
 300:../src/stm32f30x_rtc.c ****                   asynchronous prescaler to a high value to minimize consumption.
 301:../src/stm32f30x_rtc.c ****          (#) All RTC registers are Write protected. Writing to the RTC registers
 302:../src/stm32f30x_rtc.c ****              is enabled by writing a key into the Write Protection register, RTC_WPR.
 303:../src/stm32f30x_rtc.c ****          (#) To Configure the RTC Calendar, user application should enter initialization
 304:../src/stm32f30x_rtc.c ****              mode. In this mode, the calendar counter is stopped and its value 
 305:../src/stm32f30x_rtc.c ****              can be updated. When the initialization sequence is complete, the 
 306:../src/stm32f30x_rtc.c ****              calendar restarts counting after 4 RTCCLK cycles.
 307:../src/stm32f30x_rtc.c ****          (#) To read the calendar through the shadow registers after Calendar 
 308:../src/stm32f30x_rtc.c ****              initialization, calendar update or after wakeup from low power modes 
 309:../src/stm32f30x_rtc.c ****              the software must first clear the RSF flag. The software must then 
 310:../src/stm32f30x_rtc.c ****              wait until it is set again before reading the calendar, which means 
 311:../src/stm32f30x_rtc.c ****              that the calendar registers have been correctly copied into the RTC_TR 
 312:../src/stm32f30x_rtc.c ****              and RTC_DR shadow registers. The RTC_WaitForSynchro() function 
 313:../src/stm32f30x_rtc.c ****              implements the above software sequence (RSF clear and RSF check).
 314:../src/stm32f30x_rtc.c **** 
 315:../src/stm32f30x_rtc.c **** @endverbatim
 316:../src/stm32f30x_rtc.c ****   * @{
 317:../src/stm32f30x_rtc.c ****   */
 318:../src/stm32f30x_rtc.c **** 
 319:../src/stm32f30x_rtc.c **** /**
 320:../src/stm32f30x_rtc.c ****   * @brief  Deinitializes the RTC registers to their default reset values.
 321:../src/stm32f30x_rtc.c ****   * @note   This function doesn't reset the RTC Clock source and RTC Backup Data
 322:../src/stm32f30x_rtc.c ****   *         registers.       
 323:../src/stm32f30x_rtc.c ****   * @param  None
 324:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
 325:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC registers are deinitialized
 326:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC registers are not deinitialized
 327:../src/stm32f30x_rtc.c ****   */
 328:../src/stm32f30x_rtc.c **** ErrorStatus RTC_DeInit(void)
 329:../src/stm32f30x_rtc.c **** {
  27              		.loc 1 329 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 16
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31 0000 80B5     		push	{r7, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  36 0002 84B0     		sub	sp, sp, #16
  37              	.LCFI1:
  38              		.cfi_def_cfa_offset 24
  39 0004 00AF     		add	r7, sp, #0
  40              	.LCFI2:
  41              		.cfi_def_cfa_register 7
 330:../src/stm32f30x_rtc.c ****   __IO uint32_t wutcounter = 0x00;
  42              		.loc 1 330 0
  43 0006 4FF00003 		mov	r3, #0
  44 000a 7B60     		str	r3, [r7, #4]
 331:../src/stm32f30x_rtc.c ****   uint32_t wutwfstatus = 0x00;
  45              		.loc 1 331 0
  46 000c 4FF00003 		mov	r3, #0
  47 0010 BB60     		str	r3, [r7, #8]
 332:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
  48              		.loc 1 332 0
  49 0012 4FF00003 		mov	r3, #0
  50 0016 FB73     		strb	r3, [r7, #15]
 333:../src/stm32f30x_rtc.c ****   
 334:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
 335:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
  51              		.loc 1 335 0
  52 0018 4FF42053 		mov	r3, #10240
  53 001c C4F20003 		movt	r3, 16384
  54 0020 4FF0CA02 		mov	r2, #202
  55 0024 5A62     		str	r2, [r3, #36]
 336:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
  56              		.loc 1 336 0
  57 0026 4FF42053 		mov	r3, #10240
  58 002a C4F20003 		movt	r3, 16384
  59 002e 4FF05302 		mov	r2, #83
  60 0032 5A62     		str	r2, [r3, #36]
 337:../src/stm32f30x_rtc.c **** 
 338:../src/stm32f30x_rtc.c ****   /* Set Initialization mode */
 339:../src/stm32f30x_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
  61              		.loc 1 339 0
  62 0034 FFF7FEFF 		bl	RTC_EnterInitMode
  63 0038 0346     		mov	r3, r0
  64 003a 002B     		cmp	r3, #0
  65 003c 03D1     		bne	.L2
 340:../src/stm32f30x_rtc.c ****   {
 341:../src/stm32f30x_rtc.c ****     status = ERROR;
  66              		.loc 1 341 0
  67 003e 4FF00003 		mov	r3, #0
  68 0042 FB73     		strb	r3, [r7, #15]
  69 0044 99E0     		b	.L3
  70              	.L2:
 342:../src/stm32f30x_rtc.c ****   }  
 343:../src/stm32f30x_rtc.c ****   else
 344:../src/stm32f30x_rtc.c ****   {
 345:../src/stm32f30x_rtc.c ****     /* Reset TR, DR and CR registers */
 346:../src/stm32f30x_rtc.c ****     RTC->TR = (uint32_t)0x00000000;
  71              		.loc 1 346 0
  72 0046 4FF42053 		mov	r3, #10240
  73 004a C4F20003 		movt	r3, 16384
  74 004e 4FF00002 		mov	r2, #0
  75 0052 1A60     		str	r2, [r3, #0]
 347:../src/stm32f30x_rtc.c ****     RTC->DR = (uint32_t)0x00002101;
  76              		.loc 1 347 0
  77 0054 4FF42053 		mov	r3, #10240
  78 0058 C4F20003 		movt	r3, 16384
  79 005c 42F20112 		movw	r2, #8449
  80 0060 5A60     		str	r2, [r3, #4]
 348:../src/stm32f30x_rtc.c ****     
 349:../src/stm32f30x_rtc.c ****     /* Reset All CR bits except CR[2:0] */
 350:../src/stm32f30x_rtc.c ****     RTC->CR &= (uint32_t)0x00000007;
  81              		.loc 1 350 0
  82 0062 4FF42053 		mov	r3, #10240
  83 0066 C4F20003 		movt	r3, 16384
  84 006a 4FF42052 		mov	r2, #10240
  85 006e C4F20002 		movt	r2, 16384
  86 0072 9268     		ldr	r2, [r2, #8]
  87 0074 02F00702 		and	r2, r2, #7
  88 0078 9A60     		str	r2, [r3, #8]
  89              	.L5:
 351:../src/stm32f30x_rtc.c ****   
 352:../src/stm32f30x_rtc.c ****     /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
 353:../src/stm32f30x_rtc.c ****     do
 354:../src/stm32f30x_rtc.c ****     {
 355:../src/stm32f30x_rtc.c ****       wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
  90              		.loc 1 355 0 discriminator 1
  91 007a 4FF42053 		mov	r3, #10240
  92 007e C4F20003 		movt	r3, 16384
  93 0082 DB68     		ldr	r3, [r3, #12]
  94 0084 03F00403 		and	r3, r3, #4
  95 0088 BB60     		str	r3, [r7, #8]
 356:../src/stm32f30x_rtc.c ****       wutcounter++;  
  96              		.loc 1 356 0 discriminator 1
  97 008a 7B68     		ldr	r3, [r7, #4]
  98 008c 03F10103 		add	r3, r3, #1
  99 0090 7B60     		str	r3, [r7, #4]
 357:../src/stm32f30x_rtc.c ****     } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 100              		.loc 1 357 0 discriminator 1
 101 0092 7B68     		ldr	r3, [r7, #4]
 102 0094 B3F5005F 		cmp	r3, #8192
 103 0098 02D0     		beq	.L4
 104 009a BB68     		ldr	r3, [r7, #8]
 105 009c 002B     		cmp	r3, #0
 106 009e ECD0     		beq	.L5
 107              	.L4:
 358:../src/stm32f30x_rtc.c ****     
 359:../src/stm32f30x_rtc.c ****     if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 108              		.loc 1 359 0
 109 00a0 4FF42053 		mov	r3, #10240
 110 00a4 C4F20003 		movt	r3, 16384
 111 00a8 DB68     		ldr	r3, [r3, #12]
 112 00aa 03F00403 		and	r3, r3, #4
 113 00ae 002B     		cmp	r3, #0
 114 00b0 03D1     		bne	.L6
 360:../src/stm32f30x_rtc.c ****     {
 361:../src/stm32f30x_rtc.c ****       status = ERROR;
 115              		.loc 1 361 0
 116 00b2 4FF00003 		mov	r3, #0
 117 00b6 FB73     		strb	r3, [r7, #15]
 118 00b8 5FE0     		b	.L3
 119              	.L6:
 362:../src/stm32f30x_rtc.c ****     }
 363:../src/stm32f30x_rtc.c ****     else
 364:../src/stm32f30x_rtc.c ****     {
 365:../src/stm32f30x_rtc.c ****       /* Reset all RTC CR register bits */
 366:../src/stm32f30x_rtc.c ****       RTC->CR        &= (uint32_t)0x00000000;
 120              		.loc 1 366 0
 121 00ba 4FF42053 		mov	r3, #10240
 122 00be C4F20003 		movt	r3, 16384
 123 00c2 9B68     		ldr	r3, [r3, #8]
 124 00c4 4FF42053 		mov	r3, #10240
 125 00c8 C4F20003 		movt	r3, 16384
 126 00cc 4FF00002 		mov	r2, #0
 127 00d0 9A60     		str	r2, [r3, #8]
 367:../src/stm32f30x_rtc.c ****       RTC->WUTR      = (uint32_t)0x0000FFFF;
 128              		.loc 1 367 0
 129 00d2 4FF42053 		mov	r3, #10240
 130 00d6 C4F20003 		movt	r3, 16384
 131 00da 4FF6FF72 		movw	r2, #65535
 132 00de 5A61     		str	r2, [r3, #20]
 368:../src/stm32f30x_rtc.c ****       RTC->PRER      = (uint32_t)0x007F00FF;
 133              		.loc 1 368 0
 134 00e0 4FF42053 		mov	r3, #10240
 135 00e4 C4F20003 		movt	r3, 16384
 136 00e8 4FF0FF02 		mov	r2, #255
 137 00ec C0F27F02 		movt	r2, 127
 138 00f0 1A61     		str	r2, [r3, #16]
 369:../src/stm32f30x_rtc.c ****       RTC->ALRMAR    = (uint32_t)0x00000000;
 139              		.loc 1 369 0
 140 00f2 4FF42053 		mov	r3, #10240
 141 00f6 C4F20003 		movt	r3, 16384
 142 00fa 4FF00002 		mov	r2, #0
 143 00fe DA61     		str	r2, [r3, #28]
 370:../src/stm32f30x_rtc.c ****       RTC->ALRMBR    = (uint32_t)0x00000000;
 144              		.loc 1 370 0
 145 0100 4FF42053 		mov	r3, #10240
 146 0104 C4F20003 		movt	r3, 16384
 147 0108 4FF00002 		mov	r2, #0
 148 010c 1A62     		str	r2, [r3, #32]
 371:../src/stm32f30x_rtc.c ****       RTC->SHIFTR    = (uint32_t)0x00000000;
 149              		.loc 1 371 0
 150 010e 4FF42053 		mov	r3, #10240
 151 0112 C4F20003 		movt	r3, 16384
 152 0116 4FF00002 		mov	r2, #0
 153 011a DA62     		str	r2, [r3, #44]
 372:../src/stm32f30x_rtc.c ****       RTC->CALR       = (uint32_t)0x00000000;
 154              		.loc 1 372 0
 155 011c 4FF42053 		mov	r3, #10240
 156 0120 C4F20003 		movt	r3, 16384
 157 0124 4FF00002 		mov	r2, #0
 158 0128 DA63     		str	r2, [r3, #60]
 373:../src/stm32f30x_rtc.c ****       RTC->ALRMASSR  = (uint32_t)0x00000000;
 159              		.loc 1 373 0
 160 012a 4FF42053 		mov	r3, #10240
 161 012e C4F20003 		movt	r3, 16384
 162 0132 4FF00002 		mov	r2, #0
 163 0136 5A64     		str	r2, [r3, #68]
 374:../src/stm32f30x_rtc.c ****       RTC->ALRMBSSR  = (uint32_t)0x00000000;
 164              		.loc 1 374 0
 165 0138 4FF42053 		mov	r3, #10240
 166 013c C4F20003 		movt	r3, 16384
 167 0140 4FF00002 		mov	r2, #0
 168 0144 9A64     		str	r2, [r3, #72]
 375:../src/stm32f30x_rtc.c **** 
 376:../src/stm32f30x_rtc.c ****       /* Reset ISR register and exit initialization mode */
 377:../src/stm32f30x_rtc.c ****       RTC->ISR = (uint32_t)0x00000000;
 169              		.loc 1 377 0
 170 0146 4FF42053 		mov	r3, #10240
 171 014a C4F20003 		movt	r3, 16384
 172 014e 4FF00002 		mov	r2, #0
 173 0152 DA60     		str	r2, [r3, #12]
 378:../src/stm32f30x_rtc.c ****       
 379:../src/stm32f30x_rtc.c ****       /* Reset Tamper and alternate functions configuration register */
 380:../src/stm32f30x_rtc.c ****       RTC->TAFCR = 0x00000000;
 174              		.loc 1 380 0
 175 0154 4FF42053 		mov	r3, #10240
 176 0158 C4F20003 		movt	r3, 16384
 177 015c 4FF00002 		mov	r2, #0
 178 0160 1A64     		str	r2, [r3, #64]
 381:../src/stm32f30x_rtc.c ****       
 382:../src/stm32f30x_rtc.c ****       /* Wait till the RTC RSF flag is set */
 383:../src/stm32f30x_rtc.c ****       if (RTC_WaitForSynchro() == ERROR)
 179              		.loc 1 383 0
 180 0162 FFF7FEFF 		bl	RTC_WaitForSynchro
 181 0166 0346     		mov	r3, r0
 182 0168 002B     		cmp	r3, #0
 183 016a 03D1     		bne	.L7
 384:../src/stm32f30x_rtc.c ****       {
 385:../src/stm32f30x_rtc.c ****         status = ERROR;
 184              		.loc 1 385 0
 185 016c 4FF00003 		mov	r3, #0
 186 0170 FB73     		strb	r3, [r7, #15]
 187 0172 02E0     		b	.L3
 188              	.L7:
 386:../src/stm32f30x_rtc.c ****       }
 387:../src/stm32f30x_rtc.c ****       else
 388:../src/stm32f30x_rtc.c ****       {
 389:../src/stm32f30x_rtc.c ****         status = SUCCESS;
 189              		.loc 1 389 0
 190 0174 4FF00103 		mov	r3, #1
 191 0178 FB73     		strb	r3, [r7, #15]
 192              	.L3:
 390:../src/stm32f30x_rtc.c ****       }
 391:../src/stm32f30x_rtc.c ****     }
 392:../src/stm32f30x_rtc.c ****   }
 393:../src/stm32f30x_rtc.c ****   
 394:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
 395:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;  
 193              		.loc 1 395 0
 194 017a 4FF42053 		mov	r3, #10240
 195 017e C4F20003 		movt	r3, 16384
 196 0182 4FF0FF02 		mov	r2, #255
 197 0186 5A62     		str	r2, [r3, #36]
 396:../src/stm32f30x_rtc.c ****   
 397:../src/stm32f30x_rtc.c ****   return status;
 198              		.loc 1 397 0
 199 0188 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 398:../src/stm32f30x_rtc.c **** }
 200              		.loc 1 398 0
 201 018a 1846     		mov	r0, r3
 202 018c 07F11007 		add	r7, r7, #16
 203 0190 BD46     		mov	sp, r7
 204 0192 80BD     		pop	{r7, pc}
 205              		.cfi_endproc
 206              	.LFE111:
 208              		.align	2
 209              		.global	RTC_Init
 210              		.thumb
 211              		.thumb_func
 213              	RTC_Init:
 214              	.LFB112:
 399:../src/stm32f30x_rtc.c **** 
 400:../src/stm32f30x_rtc.c **** /**
 401:../src/stm32f30x_rtc.c ****   * @brief  Initializes the RTC registers according to the specified parameters 
 402:../src/stm32f30x_rtc.c ****   *         in RTC_InitStruct.
 403:../src/stm32f30x_rtc.c ****   * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure that contains 
 404:../src/stm32f30x_rtc.c ****   *         the configuration information for the RTC peripheral.
 405:../src/stm32f30x_rtc.c ****   * @note   The RTC Prescaler register is write protected and can be written in 
 406:../src/stm32f30x_rtc.c ****   *         initialization mode only.  
 407:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
 408:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC registers are initialized
 409:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC registers are not initialized  
 410:../src/stm32f30x_rtc.c ****   */
 411:../src/stm32f30x_rtc.c **** ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
 412:../src/stm32f30x_rtc.c **** {
 215              		.loc 1 412 0
 216              		.cfi_startproc
 217              		@ args = 0, pretend = 0, frame = 16
 218              		@ frame_needed = 1, uses_anonymous_args = 0
 219 0194 80B5     		push	{r7, lr}
 220              	.LCFI3:
 221              		.cfi_def_cfa_offset 8
 222              		.cfi_offset 7, -8
 223              		.cfi_offset 14, -4
 224 0196 84B0     		sub	sp, sp, #16
 225              	.LCFI4:
 226              		.cfi_def_cfa_offset 24
 227 0198 00AF     		add	r7, sp, #0
 228              	.LCFI5:
 229              		.cfi_def_cfa_register 7
 230 019a 7860     		str	r0, [r7, #4]
 413:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 231              		.loc 1 413 0
 232 019c 4FF00003 		mov	r3, #0
 233 01a0 FB73     		strb	r3, [r7, #15]
 414:../src/stm32f30x_rtc.c ****   
 415:../src/stm32f30x_rtc.c ****   /* Check the parameters */
 416:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
 417:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
 418:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
 419:../src/stm32f30x_rtc.c **** 
 420:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
 421:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 234              		.loc 1 421 0
 235 01a2 4FF42053 		mov	r3, #10240
 236 01a6 C4F20003 		movt	r3, 16384
 237 01aa 4FF0CA02 		mov	r2, #202
 238 01ae 5A62     		str	r2, [r3, #36]
 422:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 239              		.loc 1 422 0
 240 01b0 4FF42053 		mov	r3, #10240
 241 01b4 C4F20003 		movt	r3, 16384
 242 01b8 4FF05302 		mov	r2, #83
 243 01bc 5A62     		str	r2, [r3, #36]
 423:../src/stm32f30x_rtc.c **** 
 424:../src/stm32f30x_rtc.c ****   /* Set Initialization mode */
 425:../src/stm32f30x_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
 244              		.loc 1 425 0
 245 01be FFF7FEFF 		bl	RTC_EnterInitMode
 246 01c2 0346     		mov	r3, r0
 247 01c4 002B     		cmp	r3, #0
 248 01c6 03D1     		bne	.L10
 426:../src/stm32f30x_rtc.c ****   {
 427:../src/stm32f30x_rtc.c ****     status = ERROR;
 249              		.loc 1 427 0
 250 01c8 4FF00003 		mov	r3, #0
 251 01cc FB73     		strb	r3, [r7, #15]
 252 01ce 33E0     		b	.L11
 253              	.L10:
 428:../src/stm32f30x_rtc.c ****   } 
 429:../src/stm32f30x_rtc.c ****   else
 430:../src/stm32f30x_rtc.c ****   {
 431:../src/stm32f30x_rtc.c ****     /* Clear RTC CR FMT Bit */
 432:../src/stm32f30x_rtc.c ****     RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
 254              		.loc 1 432 0
 255 01d0 4FF42053 		mov	r3, #10240
 256 01d4 C4F20003 		movt	r3, 16384
 257 01d8 4FF42052 		mov	r2, #10240
 258 01dc C4F20002 		movt	r2, 16384
 259 01e0 9268     		ldr	r2, [r2, #8]
 260 01e2 22F04002 		bic	r2, r2, #64
 261 01e6 9A60     		str	r2, [r3, #8]
 433:../src/stm32f30x_rtc.c ****     /* Set RTC_CR register */
 434:../src/stm32f30x_rtc.c ****     RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
 262              		.loc 1 434 0
 263 01e8 4FF42053 		mov	r3, #10240
 264 01ec C4F20003 		movt	r3, 16384
 265 01f0 4FF42052 		mov	r2, #10240
 266 01f4 C4F20002 		movt	r2, 16384
 267 01f8 9168     		ldr	r1, [r2, #8]
 268 01fa 7A68     		ldr	r2, [r7, #4]
 269 01fc 1268     		ldr	r2, [r2, #0]
 270 01fe 0A43     		orrs	r2, r2, r1
 271 0200 9A60     		str	r2, [r3, #8]
 435:../src/stm32f30x_rtc.c ****   
 436:../src/stm32f30x_rtc.c ****     /* Configure the RTC PRER */
 437:../src/stm32f30x_rtc.c ****     RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
 272              		.loc 1 437 0
 273 0202 4FF42053 		mov	r3, #10240
 274 0206 C4F20003 		movt	r3, 16384
 275 020a 7A68     		ldr	r2, [r7, #4]
 276 020c 9268     		ldr	r2, [r2, #8]
 277 020e 1A61     		str	r2, [r3, #16]
 438:../src/stm32f30x_rtc.c ****     RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
 278              		.loc 1 438 0
 279 0210 4FF42053 		mov	r3, #10240
 280 0214 C4F20003 		movt	r3, 16384
 281 0218 4FF42052 		mov	r2, #10240
 282 021c C4F20002 		movt	r2, 16384
 283 0220 1169     		ldr	r1, [r2, #16]
 284 0222 7A68     		ldr	r2, [r7, #4]
 285 0224 5268     		ldr	r2, [r2, #4]
 286 0226 4FEA0242 		lsl	r2, r2, #16
 287 022a 0A43     		orrs	r2, r2, r1
 288 022c 1A61     		str	r2, [r3, #16]
 439:../src/stm32f30x_rtc.c **** 
 440:../src/stm32f30x_rtc.c ****     /* Exit Initialization mode */
 441:../src/stm32f30x_rtc.c ****     RTC_ExitInitMode();
 289              		.loc 1 441 0
 290 022e FFF7FEFF 		bl	RTC_ExitInitMode
 442:../src/stm32f30x_rtc.c **** 
 443:../src/stm32f30x_rtc.c ****     status = SUCCESS;    
 291              		.loc 1 443 0
 292 0232 4FF00103 		mov	r3, #1
 293 0236 FB73     		strb	r3, [r7, #15]
 294              	.L11:
 444:../src/stm32f30x_rtc.c ****   }
 445:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
 446:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF; 
 295              		.loc 1 446 0
 296 0238 4FF42053 		mov	r3, #10240
 297 023c C4F20003 		movt	r3, 16384
 298 0240 4FF0FF02 		mov	r2, #255
 299 0244 5A62     		str	r2, [r3, #36]
 447:../src/stm32f30x_rtc.c ****   
 448:../src/stm32f30x_rtc.c ****   return status;
 300              		.loc 1 448 0
 301 0246 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 449:../src/stm32f30x_rtc.c **** }
 302              		.loc 1 449 0
 303 0248 1846     		mov	r0, r3
 304 024a 07F11007 		add	r7, r7, #16
 305 024e BD46     		mov	sp, r7
 306 0250 80BD     		pop	{r7, pc}
 307              		.cfi_endproc
 308              	.LFE112:
 310 0252 00BF     		.align	2
 311              		.global	RTC_StructInit
 312              		.thumb
 313              		.thumb_func
 315              	RTC_StructInit:
 316              	.LFB113:
 450:../src/stm32f30x_rtc.c **** 
 451:../src/stm32f30x_rtc.c **** /**
 452:../src/stm32f30x_rtc.c ****   * @brief  Fills each RTC_InitStruct member with its default value.
 453:../src/stm32f30x_rtc.c ****   * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
 454:../src/stm32f30x_rtc.c ****   *         initialized.
 455:../src/stm32f30x_rtc.c ****   * @retval None
 456:../src/stm32f30x_rtc.c ****   */
 457:../src/stm32f30x_rtc.c **** void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
 458:../src/stm32f30x_rtc.c **** {
 317              		.loc 1 458 0
 318              		.cfi_startproc
 319              		@ args = 0, pretend = 0, frame = 8
 320              		@ frame_needed = 1, uses_anonymous_args = 0
 321              		@ link register save eliminated.
 322 0254 80B4     		push	{r7}
 323              	.LCFI6:
 324              		.cfi_def_cfa_offset 4
 325              		.cfi_offset 7, -4
 326 0256 83B0     		sub	sp, sp, #12
 327              	.LCFI7:
 328              		.cfi_def_cfa_offset 16
 329 0258 00AF     		add	r7, sp, #0
 330              	.LCFI8:
 331              		.cfi_def_cfa_register 7
 332 025a 7860     		str	r0, [r7, #4]
 459:../src/stm32f30x_rtc.c ****   /* Initialize the RTC_HourFormat member */
 460:../src/stm32f30x_rtc.c ****   RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
 333              		.loc 1 460 0
 334 025c 7B68     		ldr	r3, [r7, #4]
 335 025e 4FF00002 		mov	r2, #0
 336 0262 1A60     		str	r2, [r3, #0]
 461:../src/stm32f30x_rtc.c ****     
 462:../src/stm32f30x_rtc.c ****   /* Initialize the RTC_AsynchPrediv member */
 463:../src/stm32f30x_rtc.c ****   RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
 337              		.loc 1 463 0
 338 0264 7B68     		ldr	r3, [r7, #4]
 339 0266 4FF07F02 		mov	r2, #127
 340 026a 5A60     		str	r2, [r3, #4]
 464:../src/stm32f30x_rtc.c **** 
 465:../src/stm32f30x_rtc.c ****   /* Initialize the RTC_SynchPrediv member */
 466:../src/stm32f30x_rtc.c ****   RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
 341              		.loc 1 466 0
 342 026c 7B68     		ldr	r3, [r7, #4]
 343 026e 4FF0FF02 		mov	r2, #255
 344 0272 9A60     		str	r2, [r3, #8]
 467:../src/stm32f30x_rtc.c **** }
 345              		.loc 1 467 0
 346 0274 07F10C07 		add	r7, r7, #12
 347 0278 BD46     		mov	sp, r7
 348 027a 80BC     		pop	{r7}
 349 027c 7047     		bx	lr
 350              		.cfi_endproc
 351              	.LFE113:
 353 027e 00BF     		.align	2
 354              		.global	RTC_WriteProtectionCmd
 355              		.thumb
 356              		.thumb_func
 358              	RTC_WriteProtectionCmd:
 359              	.LFB114:
 468:../src/stm32f30x_rtc.c **** 
 469:../src/stm32f30x_rtc.c **** /**
 470:../src/stm32f30x_rtc.c ****   * @brief  Enables or disables the RTC registers write protection.
 471:../src/stm32f30x_rtc.c ****   * @note   All the RTC registers are write protected except for RTC_ISR[13:8], 
 472:../src/stm32f30x_rtc.c ****   *         RTC_TAFCR and RTC_BKPxR.
 473:../src/stm32f30x_rtc.c ****   * @note   Writing a wrong key reactivates the write protection.
 474:../src/stm32f30x_rtc.c ****   * @note   The protection mechanism is not affected by system reset.  
 475:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the write protection.
 476:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.
 477:../src/stm32f30x_rtc.c ****   * @retval None
 478:../src/stm32f30x_rtc.c ****   */
 479:../src/stm32f30x_rtc.c **** void RTC_WriteProtectionCmd(FunctionalState NewState)
 480:../src/stm32f30x_rtc.c **** {
 360              		.loc 1 480 0
 361              		.cfi_startproc
 362              		@ args = 0, pretend = 0, frame = 8
 363              		@ frame_needed = 1, uses_anonymous_args = 0
 364              		@ link register save eliminated.
 365 0280 80B4     		push	{r7}
 366              	.LCFI9:
 367              		.cfi_def_cfa_offset 4
 368              		.cfi_offset 7, -4
 369 0282 83B0     		sub	sp, sp, #12
 370              	.LCFI10:
 371              		.cfi_def_cfa_offset 16
 372 0284 00AF     		add	r7, sp, #0
 373              	.LCFI11:
 374              		.cfi_def_cfa_register 7
 375 0286 0346     		mov	r3, r0
 376 0288 FB71     		strb	r3, [r7, #7]
 481:../src/stm32f30x_rtc.c ****   /* Check the parameters */
 482:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 483:../src/stm32f30x_rtc.c ****     
 484:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 377              		.loc 1 484 0
 378 028a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 379 028c 002B     		cmp	r3, #0
 380 028e 07D0     		beq	.L15
 485:../src/stm32f30x_rtc.c ****   {
 486:../src/stm32f30x_rtc.c ****     /* Enable the write protection for RTC registers */
 487:../src/stm32f30x_rtc.c ****     RTC->WPR = 0xFF;   
 381              		.loc 1 487 0
 382 0290 4FF42053 		mov	r3, #10240
 383 0294 C4F20003 		movt	r3, 16384
 384 0298 4FF0FF02 		mov	r2, #255
 385 029c 5A62     		str	r2, [r3, #36]
 386 029e 0DE0     		b	.L14
 387              	.L15:
 488:../src/stm32f30x_rtc.c ****   }
 489:../src/stm32f30x_rtc.c ****   else
 490:../src/stm32f30x_rtc.c ****   {
 491:../src/stm32f30x_rtc.c ****     /* Disable the write protection for RTC registers */
 492:../src/stm32f30x_rtc.c ****     RTC->WPR = 0xCA;
 388              		.loc 1 492 0
 389 02a0 4FF42053 		mov	r3, #10240
 390 02a4 C4F20003 		movt	r3, 16384
 391 02a8 4FF0CA02 		mov	r2, #202
 392 02ac 5A62     		str	r2, [r3, #36]
 493:../src/stm32f30x_rtc.c ****     RTC->WPR = 0x53;    
 393              		.loc 1 493 0
 394 02ae 4FF42053 		mov	r3, #10240
 395 02b2 C4F20003 		movt	r3, 16384
 396 02b6 4FF05302 		mov	r2, #83
 397 02ba 5A62     		str	r2, [r3, #36]
 398              	.L14:
 494:../src/stm32f30x_rtc.c ****   }
 495:../src/stm32f30x_rtc.c **** }
 399              		.loc 1 495 0
 400 02bc 07F10C07 		add	r7, r7, #12
 401 02c0 BD46     		mov	sp, r7
 402 02c2 80BC     		pop	{r7}
 403 02c4 7047     		bx	lr
 404              		.cfi_endproc
 405              	.LFE114:
 407 02c6 00BF     		.align	2
 408              		.global	RTC_EnterInitMode
 409              		.thumb
 410              		.thumb_func
 412              	RTC_EnterInitMode:
 413              	.LFB115:
 496:../src/stm32f30x_rtc.c **** 
 497:../src/stm32f30x_rtc.c **** /**
 498:../src/stm32f30x_rtc.c ****   * @brief  Enters the RTC Initialization mode.
 499:../src/stm32f30x_rtc.c ****   * @note   The RTC Initialization mode is write protected, use the 
 500:../src/stm32f30x_rtc.c ****   *         RTC_WriteProtectionCmd(DISABLE) before calling this function.    
 501:../src/stm32f30x_rtc.c ****   * @param  None
 502:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
 503:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC is in Init mode
 504:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC is not in Init mode  
 505:../src/stm32f30x_rtc.c ****   */
 506:../src/stm32f30x_rtc.c **** ErrorStatus RTC_EnterInitMode(void)
 507:../src/stm32f30x_rtc.c **** {
 414              		.loc 1 507 0
 415              		.cfi_startproc
 416              		@ args = 0, pretend = 0, frame = 16
 417              		@ frame_needed = 1, uses_anonymous_args = 0
 418              		@ link register save eliminated.
 419 02c8 80B4     		push	{r7}
 420              	.LCFI12:
 421              		.cfi_def_cfa_offset 4
 422              		.cfi_offset 7, -4
 423 02ca 85B0     		sub	sp, sp, #20
 424              	.LCFI13:
 425              		.cfi_def_cfa_offset 24
 426 02cc 00AF     		add	r7, sp, #0
 427              	.LCFI14:
 428              		.cfi_def_cfa_register 7
 508:../src/stm32f30x_rtc.c ****   __IO uint32_t initcounter = 0x00;
 429              		.loc 1 508 0
 430 02ce 4FF00003 		mov	r3, #0
 431 02d2 7B60     		str	r3, [r7, #4]
 509:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 432              		.loc 1 509 0
 433 02d4 4FF00003 		mov	r3, #0
 434 02d8 FB73     		strb	r3, [r7, #15]
 510:../src/stm32f30x_rtc.c ****   uint32_t initstatus = 0x00;
 435              		.loc 1 510 0
 436 02da 4FF00003 		mov	r3, #0
 437 02de BB60     		str	r3, [r7, #8]
 511:../src/stm32f30x_rtc.c ****      
 512:../src/stm32f30x_rtc.c ****   /* Check if the Initialization mode is set */
 513:../src/stm32f30x_rtc.c ****   if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 438              		.loc 1 513 0
 439 02e0 4FF42053 		mov	r3, #10240
 440 02e4 C4F20003 		movt	r3, 16384
 441 02e8 DB68     		ldr	r3, [r3, #12]
 442 02ea 03F04003 		and	r3, r3, #64
 443 02ee 002B     		cmp	r3, #0
 444 02f0 2AD1     		bne	.L18
 514:../src/stm32f30x_rtc.c ****   {
 515:../src/stm32f30x_rtc.c ****     /* Set the Initialization mode */
 516:../src/stm32f30x_rtc.c ****     RTC->ISR = (uint32_t)RTC_INIT_MASK;
 445              		.loc 1 516 0
 446 02f2 4FF42053 		mov	r3, #10240
 447 02f6 C4F20003 		movt	r3, 16384
 448 02fa 4FF0FF32 		mov	r2, #-1
 449 02fe DA60     		str	r2, [r3, #12]
 450              	.L20:
 517:../src/stm32f30x_rtc.c ****     
 518:../src/stm32f30x_rtc.c ****     /* Wait till RTC is in INIT state and if Time out is reached exit */
 519:../src/stm32f30x_rtc.c ****     do
 520:../src/stm32f30x_rtc.c ****     {
 521:../src/stm32f30x_rtc.c ****       initstatus = RTC->ISR & RTC_ISR_INITF;
 451              		.loc 1 521 0 discriminator 1
 452 0300 4FF42053 		mov	r3, #10240
 453 0304 C4F20003 		movt	r3, 16384
 454 0308 DB68     		ldr	r3, [r3, #12]
 455 030a 03F04003 		and	r3, r3, #64
 456 030e BB60     		str	r3, [r7, #8]
 522:../src/stm32f30x_rtc.c ****       initcounter++;  
 457              		.loc 1 522 0 discriminator 1
 458 0310 7B68     		ldr	r3, [r7, #4]
 459 0312 03F10103 		add	r3, r3, #1
 460 0316 7B60     		str	r3, [r7, #4]
 523:../src/stm32f30x_rtc.c ****     } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 461              		.loc 1 523 0 discriminator 1
 462 0318 7B68     		ldr	r3, [r7, #4]
 463 031a B3F5005F 		cmp	r3, #8192
 464 031e 02D0     		beq	.L19
 465 0320 BB68     		ldr	r3, [r7, #8]
 466 0322 002B     		cmp	r3, #0
 467 0324 ECD0     		beq	.L20
 468              	.L19:
 524:../src/stm32f30x_rtc.c ****     
 525:../src/stm32f30x_rtc.c ****     if ((RTC->ISR & RTC_ISR_INITF) != RESET)
 469              		.loc 1 525 0
 470 0326 4FF42053 		mov	r3, #10240
 471 032a C4F20003 		movt	r3, 16384
 472 032e DB68     		ldr	r3, [r3, #12]
 473 0330 03F04003 		and	r3, r3, #64
 474 0334 002B     		cmp	r3, #0
 475 0336 03D0     		beq	.L21
 526:../src/stm32f30x_rtc.c ****     {
 527:../src/stm32f30x_rtc.c ****       status = SUCCESS;
 476              		.loc 1 527 0
 477 0338 4FF00103 		mov	r3, #1
 478 033c FB73     		strb	r3, [r7, #15]
 479 033e 06E0     		b	.L22
 480              	.L21:
 528:../src/stm32f30x_rtc.c ****     }
 529:../src/stm32f30x_rtc.c ****     else
 530:../src/stm32f30x_rtc.c ****     {
 531:../src/stm32f30x_rtc.c ****       status = ERROR;
 481              		.loc 1 531 0
 482 0340 4FF00003 		mov	r3, #0
 483 0344 FB73     		strb	r3, [r7, #15]
 484 0346 02E0     		b	.L22
 485              	.L18:
 532:../src/stm32f30x_rtc.c ****     }        
 533:../src/stm32f30x_rtc.c ****   }
 534:../src/stm32f30x_rtc.c ****   else
 535:../src/stm32f30x_rtc.c ****   {
 536:../src/stm32f30x_rtc.c ****     status = SUCCESS;  
 486              		.loc 1 536 0
 487 0348 4FF00103 		mov	r3, #1
 488 034c FB73     		strb	r3, [r7, #15]
 489              	.L22:
 537:../src/stm32f30x_rtc.c ****   } 
 538:../src/stm32f30x_rtc.c ****     
 539:../src/stm32f30x_rtc.c ****   return (status);  
 490              		.loc 1 539 0
 491 034e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 540:../src/stm32f30x_rtc.c **** }
 492              		.loc 1 540 0
 493 0350 1846     		mov	r0, r3
 494 0352 07F11407 		add	r7, r7, #20
 495 0356 BD46     		mov	sp, r7
 496 0358 80BC     		pop	{r7}
 497 035a 7047     		bx	lr
 498              		.cfi_endproc
 499              	.LFE115:
 501              		.align	2
 502              		.global	RTC_ExitInitMode
 503              		.thumb
 504              		.thumb_func
 506              	RTC_ExitInitMode:
 507              	.LFB116:
 541:../src/stm32f30x_rtc.c **** 
 542:../src/stm32f30x_rtc.c **** /**
 543:../src/stm32f30x_rtc.c ****   * @brief  Exits the RTC Initialization mode.
 544:../src/stm32f30x_rtc.c ****   * @note   When the initialization sequence is complete, the calendar restarts 
 545:../src/stm32f30x_rtc.c ****   *         counting after 4 RTCCLK cycles.  
 546:../src/stm32f30x_rtc.c ****   * @note   The RTC Initialization mode is write protected, use the 
 547:../src/stm32f30x_rtc.c ****   *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
 548:../src/stm32f30x_rtc.c ****   * @param  None
 549:../src/stm32f30x_rtc.c ****   * @retval None
 550:../src/stm32f30x_rtc.c ****   */
 551:../src/stm32f30x_rtc.c **** void RTC_ExitInitMode(void)
 552:../src/stm32f30x_rtc.c **** {
 508              		.loc 1 552 0
 509              		.cfi_startproc
 510              		@ args = 0, pretend = 0, frame = 0
 511              		@ frame_needed = 1, uses_anonymous_args = 0
 512              		@ link register save eliminated.
 513 035c 80B4     		push	{r7}
 514              	.LCFI15:
 515              		.cfi_def_cfa_offset 4
 516              		.cfi_offset 7, -4
 517 035e 00AF     		add	r7, sp, #0
 518              	.LCFI16:
 519              		.cfi_def_cfa_register 7
 553:../src/stm32f30x_rtc.c ****   /* Exit Initialization mode */
 554:../src/stm32f30x_rtc.c ****   RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
 520              		.loc 1 554 0
 521 0360 4FF42053 		mov	r3, #10240
 522 0364 C4F20003 		movt	r3, 16384
 523 0368 4FF42052 		mov	r2, #10240
 524 036c C4F20002 		movt	r2, 16384
 525 0370 D268     		ldr	r2, [r2, #12]
 526 0372 22F08002 		bic	r2, r2, #128
 527 0376 DA60     		str	r2, [r3, #12]
 555:../src/stm32f30x_rtc.c **** }
 528              		.loc 1 555 0
 529 0378 BD46     		mov	sp, r7
 530 037a 80BC     		pop	{r7}
 531 037c 7047     		bx	lr
 532              		.cfi_endproc
 533              	.LFE116:
 535 037e 00BF     		.align	2
 536              		.global	RTC_WaitForSynchro
 537              		.thumb
 538              		.thumb_func
 540              	RTC_WaitForSynchro:
 541              	.LFB117:
 556:../src/stm32f30x_rtc.c **** 
 557:../src/stm32f30x_rtc.c **** /**
 558:../src/stm32f30x_rtc.c ****   * @brief  Waits until the RTC Time and Date registers (RTC_TR and RTC_DR) are 
 559:../src/stm32f30x_rtc.c ****   *         synchronized with RTC APB clock.
 560:../src/stm32f30x_rtc.c ****   * @note   The RTC Resynchronization mode is write protected, use the 
 561:../src/stm32f30x_rtc.c ****   *         RTC_WriteProtectionCmd(DISABLE) before calling this function. 
 562:../src/stm32f30x_rtc.c ****   * @note   To read the calendar through the shadow registers after Calendar 
 563:../src/stm32f30x_rtc.c ****   *         initialization, calendar update or after wakeup from low power modes 
 564:../src/stm32f30x_rtc.c ****   *         the software must first clear the RSF flag. 
 565:../src/stm32f30x_rtc.c ****   *         The software must then wait until it is set again before reading 
 566:../src/stm32f30x_rtc.c ****   *         the calendar, which means that the calendar registers have been 
 567:../src/stm32f30x_rtc.c ****   *         correctly copied into the RTC_TR and RTC_DR shadow registers.   
 568:../src/stm32f30x_rtc.c ****   * @param  None
 569:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
 570:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC registers are synchronised
 571:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC registers are not synchronised
 572:../src/stm32f30x_rtc.c ****   */
 573:../src/stm32f30x_rtc.c **** ErrorStatus RTC_WaitForSynchro(void)
 574:../src/stm32f30x_rtc.c **** {
 542              		.loc 1 574 0
 543              		.cfi_startproc
 544              		@ args = 0, pretend = 0, frame = 16
 545              		@ frame_needed = 1, uses_anonymous_args = 0
 546              		@ link register save eliminated.
 547 0380 80B4     		push	{r7}
 548              	.LCFI17:
 549              		.cfi_def_cfa_offset 4
 550              		.cfi_offset 7, -4
 551 0382 85B0     		sub	sp, sp, #20
 552              	.LCFI18:
 553              		.cfi_def_cfa_offset 24
 554 0384 00AF     		add	r7, sp, #0
 555              	.LCFI19:
 556              		.cfi_def_cfa_register 7
 575:../src/stm32f30x_rtc.c ****   __IO uint32_t synchrocounter = 0;
 557              		.loc 1 575 0
 558 0386 4FF00003 		mov	r3, #0
 559 038a 7B60     		str	r3, [r7, #4]
 576:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 560              		.loc 1 576 0
 561 038c 4FF00003 		mov	r3, #0
 562 0390 FB73     		strb	r3, [r7, #15]
 577:../src/stm32f30x_rtc.c ****   uint32_t synchrostatus = 0x00;
 563              		.loc 1 577 0
 564 0392 4FF00003 		mov	r3, #0
 565 0396 BB60     		str	r3, [r7, #8]
 578:../src/stm32f30x_rtc.c **** 
 579:../src/stm32f30x_rtc.c ****   if ((RTC->CR & RTC_CR_BYPSHAD) != RESET)
 566              		.loc 1 579 0
 567 0398 4FF42053 		mov	r3, #10240
 568 039c C4F20003 		movt	r3, 16384
 569 03a0 9B68     		ldr	r3, [r3, #8]
 570 03a2 03F02003 		and	r3, r3, #32
 571 03a6 002B     		cmp	r3, #0
 572 03a8 03D0     		beq	.L26
 580:../src/stm32f30x_rtc.c ****   {
 581:../src/stm32f30x_rtc.c ****     /* Bypass shadow mode */
 582:../src/stm32f30x_rtc.c ****     status = SUCCESS;
 573              		.loc 1 582 0
 574 03aa 4FF00103 		mov	r3, #1
 575 03ae FB73     		strb	r3, [r7, #15]
 576 03b0 43E0     		b	.L27
 577              	.L26:
 583:../src/stm32f30x_rtc.c ****   }
 584:../src/stm32f30x_rtc.c ****   else
 585:../src/stm32f30x_rtc.c ****   {
 586:../src/stm32f30x_rtc.c ****     /* Disable the write protection for RTC registers */
 587:../src/stm32f30x_rtc.c ****     RTC->WPR = 0xCA;
 578              		.loc 1 587 0
 579 03b2 4FF42053 		mov	r3, #10240
 580 03b6 C4F20003 		movt	r3, 16384
 581 03ba 4FF0CA02 		mov	r2, #202
 582 03be 5A62     		str	r2, [r3, #36]
 588:../src/stm32f30x_rtc.c ****     RTC->WPR = 0x53;
 583              		.loc 1 588 0
 584 03c0 4FF42053 		mov	r3, #10240
 585 03c4 C4F20003 		movt	r3, 16384
 586 03c8 4FF05302 		mov	r2, #83
 587 03cc 5A62     		str	r2, [r3, #36]
 589:../src/stm32f30x_rtc.c ****     
 590:../src/stm32f30x_rtc.c ****     /* Clear RSF flag */
 591:../src/stm32f30x_rtc.c ****     RTC->ISR &= (uint32_t)RTC_RSF_MASK;
 588              		.loc 1 591 0
 589 03ce 4FF42053 		mov	r3, #10240
 590 03d2 C4F20003 		movt	r3, 16384
 591 03d6 4FF42052 		mov	r2, #10240
 592 03da C4F20002 		movt	r2, 16384
 593 03de D268     		ldr	r2, [r2, #12]
 594 03e0 22F0A002 		bic	r2, r2, #160
 595 03e4 DA60     		str	r2, [r3, #12]
 596              	.L29:
 592:../src/stm32f30x_rtc.c ****     
 593:../src/stm32f30x_rtc.c ****     /* Wait the registers to be synchronised */
 594:../src/stm32f30x_rtc.c ****     do
 595:../src/stm32f30x_rtc.c ****     {
 596:../src/stm32f30x_rtc.c ****       synchrostatus = RTC->ISR & RTC_ISR_RSF;
 597              		.loc 1 596 0 discriminator 1
 598 03e6 4FF42053 		mov	r3, #10240
 599 03ea C4F20003 		movt	r3, 16384
 600 03ee DB68     		ldr	r3, [r3, #12]
 601 03f0 03F02003 		and	r3, r3, #32
 602 03f4 BB60     		str	r3, [r7, #8]
 597:../src/stm32f30x_rtc.c ****       synchrocounter++;  
 603              		.loc 1 597 0 discriminator 1
 604 03f6 7B68     		ldr	r3, [r7, #4]
 605 03f8 03F10103 		add	r3, r3, #1
 606 03fc 7B60     		str	r3, [r7, #4]
 598:../src/stm32f30x_rtc.c ****     } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 607              		.loc 1 598 0 discriminator 1
 608 03fe 7B68     		ldr	r3, [r7, #4]
 609 0400 B3F5004F 		cmp	r3, #32768
 610 0404 02D0     		beq	.L28
 611 0406 BB68     		ldr	r3, [r7, #8]
 612 0408 002B     		cmp	r3, #0
 613 040a ECD0     		beq	.L29
 614              	.L28:
 599:../src/stm32f30x_rtc.c ****     
 600:../src/stm32f30x_rtc.c ****     if ((RTC->ISR & RTC_ISR_RSF) != RESET)
 615              		.loc 1 600 0
 616 040c 4FF42053 		mov	r3, #10240
 617 0410 C4F20003 		movt	r3, 16384
 618 0414 DB68     		ldr	r3, [r3, #12]
 619 0416 03F02003 		and	r3, r3, #32
 620 041a 002B     		cmp	r3, #0
 621 041c 03D0     		beq	.L30
 601:../src/stm32f30x_rtc.c ****     {
 602:../src/stm32f30x_rtc.c ****       status = SUCCESS;
 622              		.loc 1 602 0
 623 041e 4FF00103 		mov	r3, #1
 624 0422 FB73     		strb	r3, [r7, #15]
 625 0424 02E0     		b	.L31
 626              	.L30:
 603:../src/stm32f30x_rtc.c ****     }
 604:../src/stm32f30x_rtc.c ****     else
 605:../src/stm32f30x_rtc.c ****     {
 606:../src/stm32f30x_rtc.c ****       status = ERROR;
 627              		.loc 1 606 0
 628 0426 4FF00003 		mov	r3, #0
 629 042a FB73     		strb	r3, [r7, #15]
 630              	.L31:
 607:../src/stm32f30x_rtc.c ****     }
 608:../src/stm32f30x_rtc.c **** 
 609:../src/stm32f30x_rtc.c ****     /* Enable the write protection for RTC registers */
 610:../src/stm32f30x_rtc.c ****     RTC->WPR = 0xFF;
 631              		.loc 1 610 0
 632 042c 4FF42053 		mov	r3, #10240
 633 0430 C4F20003 		movt	r3, 16384
 634 0434 4FF0FF02 		mov	r2, #255
 635 0438 5A62     		str	r2, [r3, #36]
 636              	.L27:
 611:../src/stm32f30x_rtc.c ****   } 
 612:../src/stm32f30x_rtc.c ****   
 613:../src/stm32f30x_rtc.c ****   return (status);
 637              		.loc 1 613 0
 638 043a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 614:../src/stm32f30x_rtc.c **** }
 639              		.loc 1 614 0
 640 043c 1846     		mov	r0, r3
 641 043e 07F11407 		add	r7, r7, #20
 642 0442 BD46     		mov	sp, r7
 643 0444 80BC     		pop	{r7}
 644 0446 7047     		bx	lr
 645              		.cfi_endproc
 646              	.LFE117:
 648              		.align	2
 649              		.global	RTC_RefClockCmd
 650              		.thumb
 651              		.thumb_func
 653              	RTC_RefClockCmd:
 654              	.LFB118:
 615:../src/stm32f30x_rtc.c **** 
 616:../src/stm32f30x_rtc.c **** /**
 617:../src/stm32f30x_rtc.c ****   * @brief  Enables or disables the RTC reference clock detection.
 618:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the RTC reference clock.
 619:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.
 620:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
 621:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC reference clock detection is enabled
 622:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC reference clock detection is disabled  
 623:../src/stm32f30x_rtc.c ****   */
 624:../src/stm32f30x_rtc.c **** ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
 625:../src/stm32f30x_rtc.c **** {
 655              		.loc 1 625 0
 656              		.cfi_startproc
 657              		@ args = 0, pretend = 0, frame = 16
 658              		@ frame_needed = 1, uses_anonymous_args = 0
 659 0448 80B5     		push	{r7, lr}
 660              	.LCFI20:
 661              		.cfi_def_cfa_offset 8
 662              		.cfi_offset 7, -8
 663              		.cfi_offset 14, -4
 664 044a 84B0     		sub	sp, sp, #16
 665              	.LCFI21:
 666              		.cfi_def_cfa_offset 24
 667 044c 00AF     		add	r7, sp, #0
 668              	.LCFI22:
 669              		.cfi_def_cfa_register 7
 670 044e 0346     		mov	r3, r0
 671 0450 FB71     		strb	r3, [r7, #7]
 626:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 672              		.loc 1 626 0
 673 0452 4FF00003 		mov	r3, #0
 674 0456 FB73     		strb	r3, [r7, #15]
 627:../src/stm32f30x_rtc.c **** 
 628:../src/stm32f30x_rtc.c ****   /* Check the parameters */
 629:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 630:../src/stm32f30x_rtc.c **** 
 631:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
 632:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 675              		.loc 1 632 0
 676 0458 4FF42053 		mov	r3, #10240
 677 045c C4F20003 		movt	r3, 16384
 678 0460 4FF0CA02 		mov	r2, #202
 679 0464 5A62     		str	r2, [r3, #36]
 633:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 680              		.loc 1 633 0
 681 0466 4FF42053 		mov	r3, #10240
 682 046a C4F20003 		movt	r3, 16384
 683 046e 4FF05302 		mov	r2, #83
 684 0472 5A62     		str	r2, [r3, #36]
 634:../src/stm32f30x_rtc.c **** 
 635:../src/stm32f30x_rtc.c ****   /* Set Initialization mode */
 636:../src/stm32f30x_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
 685              		.loc 1 636 0
 686 0474 FFF7FEFF 		bl	RTC_EnterInitMode
 687 0478 0346     		mov	r3, r0
 688 047a 002B     		cmp	r3, #0
 689 047c 03D1     		bne	.L34
 637:../src/stm32f30x_rtc.c ****   {
 638:../src/stm32f30x_rtc.c ****     status = ERROR;
 690              		.loc 1 638 0
 691 047e 4FF00003 		mov	r3, #0
 692 0482 FB73     		strb	r3, [r7, #15]
 693 0484 20E0     		b	.L35
 694              	.L34:
 639:../src/stm32f30x_rtc.c ****   }
 640:../src/stm32f30x_rtc.c ****   else
 641:../src/stm32f30x_rtc.c ****   {
 642:../src/stm32f30x_rtc.c ****     if (NewState != DISABLE)
 695              		.loc 1 642 0
 696 0486 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 697 0488 002B     		cmp	r3, #0
 698 048a 0CD0     		beq	.L36
 643:../src/stm32f30x_rtc.c ****     {
 644:../src/stm32f30x_rtc.c ****       /* Enable the RTC reference clock detection */
 645:../src/stm32f30x_rtc.c ****       RTC->CR |= RTC_CR_REFCKON;   
 699              		.loc 1 645 0
 700 048c 4FF42053 		mov	r3, #10240
 701 0490 C4F20003 		movt	r3, 16384
 702 0494 4FF42052 		mov	r2, #10240
 703 0498 C4F20002 		movt	r2, 16384
 704 049c 9268     		ldr	r2, [r2, #8]
 705 049e 42F01002 		orr	r2, r2, #16
 706 04a2 9A60     		str	r2, [r3, #8]
 707 04a4 0BE0     		b	.L37
 708              	.L36:
 646:../src/stm32f30x_rtc.c ****     }
 647:../src/stm32f30x_rtc.c ****     else
 648:../src/stm32f30x_rtc.c ****     {
 649:../src/stm32f30x_rtc.c ****       /* Disable the RTC reference clock detection */
 650:../src/stm32f30x_rtc.c ****       RTC->CR &= ~RTC_CR_REFCKON;    
 709              		.loc 1 650 0
 710 04a6 4FF42053 		mov	r3, #10240
 711 04aa C4F20003 		movt	r3, 16384
 712 04ae 4FF42052 		mov	r2, #10240
 713 04b2 C4F20002 		movt	r2, 16384
 714 04b6 9268     		ldr	r2, [r2, #8]
 715 04b8 22F01002 		bic	r2, r2, #16
 716 04bc 9A60     		str	r2, [r3, #8]
 717              	.L37:
 651:../src/stm32f30x_rtc.c ****     }
 652:../src/stm32f30x_rtc.c ****     /* Exit Initialization mode */
 653:../src/stm32f30x_rtc.c ****     RTC_ExitInitMode();
 718              		.loc 1 653 0
 719 04be FFF7FEFF 		bl	RTC_ExitInitMode
 654:../src/stm32f30x_rtc.c **** 
 655:../src/stm32f30x_rtc.c ****     status = SUCCESS;
 720              		.loc 1 655 0
 721 04c2 4FF00103 		mov	r3, #1
 722 04c6 FB73     		strb	r3, [r7, #15]
 723              	.L35:
 656:../src/stm32f30x_rtc.c ****   }
 657:../src/stm32f30x_rtc.c **** 
 658:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
 659:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 724              		.loc 1 659 0
 725 04c8 4FF42053 		mov	r3, #10240
 726 04cc C4F20003 		movt	r3, 16384
 727 04d0 4FF0FF02 		mov	r2, #255
 728 04d4 5A62     		str	r2, [r3, #36]
 660:../src/stm32f30x_rtc.c **** 
 661:../src/stm32f30x_rtc.c ****   return status;
 729              		.loc 1 661 0
 730 04d6 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 662:../src/stm32f30x_rtc.c **** }
 731              		.loc 1 662 0
 732 04d8 1846     		mov	r0, r3
 733 04da 07F11007 		add	r7, r7, #16
 734 04de BD46     		mov	sp, r7
 735 04e0 80BD     		pop	{r7, pc}
 736              		.cfi_endproc
 737              	.LFE118:
 739 04e2 00BF     		.align	2
 740              		.global	RTC_BypassShadowCmd
 741              		.thumb
 742              		.thumb_func
 744              	RTC_BypassShadowCmd:
 745              	.LFB119:
 663:../src/stm32f30x_rtc.c **** 
 664:../src/stm32f30x_rtc.c **** /**
 665:../src/stm32f30x_rtc.c ****   * @brief  Enables or Disables the Bypass Shadow feature.
 666:../src/stm32f30x_rtc.c ****   * @note   When the Bypass Shadow is enabled the calendar value are taken 
 667:../src/stm32f30x_rtc.c ****   *         directly from the Calendar counter.
 668:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the Bypass Shadow feature.
 669:../src/stm32f30x_rtc.c ****   *         This parameter can be: ENABLE or DISABLE.
 670:../src/stm32f30x_rtc.c ****   * @retval None
 671:../src/stm32f30x_rtc.c **** */
 672:../src/stm32f30x_rtc.c **** void RTC_BypassShadowCmd(FunctionalState NewState)
 673:../src/stm32f30x_rtc.c **** {
 746              		.loc 1 673 0
 747              		.cfi_startproc
 748              		@ args = 0, pretend = 0, frame = 8
 749              		@ frame_needed = 1, uses_anonymous_args = 0
 750              		@ link register save eliminated.
 751 04e4 80B4     		push	{r7}
 752              	.LCFI23:
 753              		.cfi_def_cfa_offset 4
 754              		.cfi_offset 7, -4
 755 04e6 83B0     		sub	sp, sp, #12
 756              	.LCFI24:
 757              		.cfi_def_cfa_offset 16
 758 04e8 00AF     		add	r7, sp, #0
 759              	.LCFI25:
 760              		.cfi_def_cfa_register 7
 761 04ea 0346     		mov	r3, r0
 762 04ec FB71     		strb	r3, [r7, #7]
 674:../src/stm32f30x_rtc.c ****   /* Check the parameters */
 675:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 676:../src/stm32f30x_rtc.c **** 
 677:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
 678:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 763              		.loc 1 678 0
 764 04ee 4FF42053 		mov	r3, #10240
 765 04f2 C4F20003 		movt	r3, 16384
 766 04f6 4FF0CA02 		mov	r2, #202
 767 04fa 5A62     		str	r2, [r3, #36]
 679:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 768              		.loc 1 679 0
 769 04fc 4FF42053 		mov	r3, #10240
 770 0500 C4F20003 		movt	r3, 16384
 771 0504 4FF05302 		mov	r2, #83
 772 0508 5A62     		str	r2, [r3, #36]
 680:../src/stm32f30x_rtc.c ****   
 681:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 773              		.loc 1 681 0
 774 050a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 775 050c 002B     		cmp	r3, #0
 776 050e 0CD0     		beq	.L40
 682:../src/stm32f30x_rtc.c ****   {
 683:../src/stm32f30x_rtc.c ****     /* Set the BYPSHAD bit */
 684:../src/stm32f30x_rtc.c ****     RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
 777              		.loc 1 684 0
 778 0510 4FF42053 		mov	r3, #10240
 779 0514 C4F20003 		movt	r3, 16384
 780 0518 4FF42052 		mov	r2, #10240
 781 051c C4F20002 		movt	r2, 16384
 782 0520 9268     		ldr	r2, [r2, #8]
 783 0522 42F02002 		orr	r2, r2, #32
 784 0526 9A60     		str	r2, [r3, #8]
 785 0528 0BE0     		b	.L41
 786              	.L40:
 685:../src/stm32f30x_rtc.c ****   }
 686:../src/stm32f30x_rtc.c ****   else
 687:../src/stm32f30x_rtc.c ****   {
 688:../src/stm32f30x_rtc.c ****     /* Reset the BYPSHAD bit */
 689:../src/stm32f30x_rtc.c ****     RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
 787              		.loc 1 689 0
 788 052a 4FF42053 		mov	r3, #10240
 789 052e C4F20003 		movt	r3, 16384
 790 0532 4FF42052 		mov	r2, #10240
 791 0536 C4F20002 		movt	r2, 16384
 792 053a 9268     		ldr	r2, [r2, #8]
 793 053c 02F0DF02 		and	r2, r2, #223
 794 0540 9A60     		str	r2, [r3, #8]
 795              	.L41:
 690:../src/stm32f30x_rtc.c ****   }
 691:../src/stm32f30x_rtc.c **** 
 692:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
 693:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 796              		.loc 1 693 0
 797 0542 4FF42053 		mov	r3, #10240
 798 0546 C4F20003 		movt	r3, 16384
 799 054a 4FF0FF02 		mov	r2, #255
 800 054e 5A62     		str	r2, [r3, #36]
 694:../src/stm32f30x_rtc.c **** }
 801              		.loc 1 694 0
 802 0550 07F10C07 		add	r7, r7, #12
 803 0554 BD46     		mov	sp, r7
 804 0556 80BC     		pop	{r7}
 805 0558 7047     		bx	lr
 806              		.cfi_endproc
 807              	.LFE119:
 809 055a 00BF     		.align	2
 810              		.global	RTC_SetTime
 811              		.thumb
 812              		.thumb_func
 814              	RTC_SetTime:
 815              	.LFB120:
 695:../src/stm32f30x_rtc.c **** 
 696:../src/stm32f30x_rtc.c **** /**
 697:../src/stm32f30x_rtc.c ****   * @}
 698:../src/stm32f30x_rtc.c ****   */
 699:../src/stm32f30x_rtc.c **** 
 700:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group2 Time and Date configuration functions
 701:../src/stm32f30x_rtc.c ****  *  @brief   Time and Date configuration functions 
 702:../src/stm32f30x_rtc.c ****  *
 703:../src/stm32f30x_rtc.c **** @verbatim   
 704:../src/stm32f30x_rtc.c ****  ===============================================================================
 705:../src/stm32f30x_rtc.c ****                ##### Time and Date configuration functions #####
 706:../src/stm32f30x_rtc.c ****  ===============================================================================  
 707:../src/stm32f30x_rtc.c ****     [..] This section provide functions allowing to program and read the RTC Calendar
 708:../src/stm32f30x_rtc.c ****          (Time and Date).
 709:../src/stm32f30x_rtc.c **** 
 710:../src/stm32f30x_rtc.c **** @endverbatim
 711:../src/stm32f30x_rtc.c ****   * @{
 712:../src/stm32f30x_rtc.c ****   */
 713:../src/stm32f30x_rtc.c **** 
 714:../src/stm32f30x_rtc.c **** /**
 715:../src/stm32f30x_rtc.c ****   * @brief  Set the RTC current time.
 716:../src/stm32f30x_rtc.c ****   * @param  RTC_Format: specifies the format of the entered parameters.
 717:../src/stm32f30x_rtc.c ****   *   This parameter can be  one of the following values:
 718:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BIN:  Binary data format 
 719:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BCD:  BCD data format
 720:../src/stm32f30x_rtc.c ****   * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that contains 
 721:../src/stm32f30x_rtc.c ****   *                        the time configuration information for the RTC.     
 722:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
 723:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC Time register is configured
 724:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC Time register is not configured
 725:../src/stm32f30x_rtc.c ****   */
 726:../src/stm32f30x_rtc.c **** ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
 727:../src/stm32f30x_rtc.c **** {
 816              		.loc 1 727 0
 817              		.cfi_startproc
 818              		@ args = 0, pretend = 0, frame = 16
 819              		@ frame_needed = 1, uses_anonymous_args = 0
 820 055c 90B5     		push	{r4, r7, lr}
 821              	.LCFI26:
 822              		.cfi_def_cfa_offset 12
 823              		.cfi_offset 4, -12
 824              		.cfi_offset 7, -8
 825              		.cfi_offset 14, -4
 826 055e 85B0     		sub	sp, sp, #20
 827              	.LCFI27:
 828              		.cfi_def_cfa_offset 32
 829 0560 00AF     		add	r7, sp, #0
 830              	.LCFI28:
 831              		.cfi_def_cfa_register 7
 832 0562 7860     		str	r0, [r7, #4]
 833 0564 3960     		str	r1, [r7, #0]
 728:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 834              		.loc 1 728 0
 835 0566 4FF00003 		mov	r3, #0
 836 056a FB60     		str	r3, [r7, #12]
 729:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 837              		.loc 1 729 0
 838 056c 4FF00003 		mov	r3, #0
 839 0570 FB72     		strb	r3, [r7, #11]
 730:../src/stm32f30x_rtc.c ****     
 731:../src/stm32f30x_rtc.c ****   /* Check the parameters */
 732:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
 733:../src/stm32f30x_rtc.c ****   
 734:../src/stm32f30x_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 840              		.loc 1 734 0
 841 0572 7B68     		ldr	r3, [r7, #4]
 842 0574 002B     		cmp	r3, #0
 843 0576 0DD1     		bne	.L43
 735:../src/stm32f30x_rtc.c ****   {
 736:../src/stm32f30x_rtc.c ****     if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 844              		.loc 1 736 0
 845 0578 4FF42053 		mov	r3, #10240
 846 057c C4F20003 		movt	r3, 16384
 847 0580 9B68     		ldr	r3, [r3, #8]
 848 0582 03F04003 		and	r3, r3, #64
 849 0586 002B     		cmp	r3, #0
 850 0588 19D1     		bne	.L44
 737:../src/stm32f30x_rtc.c ****     {
 738:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
 739:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
 740:../src/stm32f30x_rtc.c ****     } 
 741:../src/stm32f30x_rtc.c ****     else
 742:../src/stm32f30x_rtc.c ****     {
 743:../src/stm32f30x_rtc.c ****       RTC_TimeStruct->RTC_H12 = 0x00;
 851              		.loc 1 743 0
 852 058a 3B68     		ldr	r3, [r7, #0]
 853 058c 4FF00002 		mov	r2, #0
 854 0590 DA70     		strb	r2, [r3, #3]
 855 0592 14E0     		b	.L44
 856              	.L43:
 744:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
 745:../src/stm32f30x_rtc.c ****     }
 746:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
 747:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
 748:../src/stm32f30x_rtc.c ****   }
 749:../src/stm32f30x_rtc.c ****   else
 750:../src/stm32f30x_rtc.c ****   {
 751:../src/stm32f30x_rtc.c ****     if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 857              		.loc 1 751 0
 858 0594 4FF42053 		mov	r3, #10240
 859 0598 C4F20003 		movt	r3, 16384
 860 059c 9B68     		ldr	r3, [r3, #8]
 861 059e 03F04003 		and	r3, r3, #64
 862 05a2 002B     		cmp	r3, #0
 863 05a4 07D0     		beq	.L45
 752:../src/stm32f30x_rtc.c ****     {
 753:../src/stm32f30x_rtc.c ****       tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 864              		.loc 1 753 0
 865 05a6 3B68     		ldr	r3, [r7, #0]
 866 05a8 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 867 05aa 1846     		mov	r0, r3
 868 05ac 01F072FA 		bl	RTC_Bcd2ToByte
 869 05b0 0346     		mov	r3, r0
 870 05b2 FB60     		str	r3, [r7, #12]
 871 05b4 03E0     		b	.L44
 872              	.L45:
 754:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR12(tmpreg));
 755:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
 756:../src/stm32f30x_rtc.c ****     } 
 757:../src/stm32f30x_rtc.c ****     else
 758:../src/stm32f30x_rtc.c ****     {
 759:../src/stm32f30x_rtc.c ****       RTC_TimeStruct->RTC_H12 = 0x00;
 873              		.loc 1 759 0
 874 05b6 3B68     		ldr	r3, [r7, #0]
 875 05b8 4FF00002 		mov	r2, #0
 876 05bc DA70     		strb	r2, [r3, #3]
 877              	.L44:
 760:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
 761:../src/stm32f30x_rtc.c ****     }
 762:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
 763:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
 764:../src/stm32f30x_rtc.c ****   }
 765:../src/stm32f30x_rtc.c ****   
 766:../src/stm32f30x_rtc.c ****   /* Check the input parameters format */
 767:../src/stm32f30x_rtc.c ****   if (RTC_Format != RTC_Format_BIN)
 878              		.loc 1 767 0
 879 05be 7B68     		ldr	r3, [r7, #4]
 880 05c0 002B     		cmp	r3, #0
 881 05c2 12D0     		beq	.L46
 768:../src/stm32f30x_rtc.c ****   {
 769:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 882              		.loc 1 769 0
 883 05c4 3B68     		ldr	r3, [r7, #0]
 884 05c6 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 885 05c8 4FEA0342 		lsl	r2, r3, #16
 770:../src/stm32f30x_rtc.c ****              ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 886              		.loc 1 770 0
 887 05cc 3B68     		ldr	r3, [r7, #0]
 888 05ce 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 889 05d0 4FEA0323 		lsl	r3, r3, #8
 769:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 890              		.loc 1 769 0
 891 05d4 1A43     		orrs	r2, r2, r3
 771:../src/stm32f30x_rtc.c ****              ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
 892              		.loc 1 771 0
 893 05d6 3B68     		ldr	r3, [r7, #0]
 894 05d8 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 770:../src/stm32f30x_rtc.c ****              ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 895              		.loc 1 770 0
 896 05da 1A43     		orrs	r2, r2, r3
 772:../src/stm32f30x_rtc.c ****              ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
 897              		.loc 1 772 0
 898 05dc 3B68     		ldr	r3, [r7, #0]
 899 05de DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 900 05e0 4FEA0343 		lsl	r3, r3, #16
 769:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 901              		.loc 1 769 0
 902 05e4 1343     		orrs	r3, r3, r2
 903 05e6 FB60     		str	r3, [r7, #12]
 904 05e8 1EE0     		b	.L47
 905              	.L46:
 773:../src/stm32f30x_rtc.c ****   }  
 774:../src/stm32f30x_rtc.c ****   else
 775:../src/stm32f30x_rtc.c ****   {
 776:../src/stm32f30x_rtc.c ****     tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 906              		.loc 1 776 0
 907 05ea 3B68     		ldr	r3, [r7, #0]
 908 05ec 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 909 05ee 1846     		mov	r0, r3
 910 05f0 01F02EFA 		bl	RTC_ByteToBcd2
 911 05f4 0346     		mov	r3, r0
 912 05f6 4FEA0344 		lsl	r4, r3, #16
 777:../src/stm32f30x_rtc.c ****                    ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 913              		.loc 1 777 0
 914 05fa 3B68     		ldr	r3, [r7, #0]
 915 05fc 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 916 05fe 1846     		mov	r0, r3
 917 0600 01F026FA 		bl	RTC_ByteToBcd2
 918 0604 0346     		mov	r3, r0
 919 0606 4FEA0323 		lsl	r3, r3, #8
 776:../src/stm32f30x_rtc.c ****     tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 920              		.loc 1 776 0
 921 060a 1C43     		orrs	r4, r4, r3
 778:../src/stm32f30x_rtc.c ****                    ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
 922              		.loc 1 778 0
 923 060c 3B68     		ldr	r3, [r7, #0]
 924 060e 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 925 0610 1846     		mov	r0, r3
 926 0612 01F01DFA 		bl	RTC_ByteToBcd2
 927 0616 0346     		mov	r3, r0
 777:../src/stm32f30x_rtc.c ****                    ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 928              		.loc 1 777 0
 929 0618 44EA0302 		orr	r2, r4, r3
 779:../src/stm32f30x_rtc.c ****                    (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
 930              		.loc 1 779 0
 931 061c 3B68     		ldr	r3, [r7, #0]
 932 061e DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 933 0620 4FEA0343 		lsl	r3, r3, #16
 776:../src/stm32f30x_rtc.c ****     tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 934              		.loc 1 776 0
 935 0624 1343     		orrs	r3, r3, r2
 936 0626 FB60     		str	r3, [r7, #12]
 937              	.L47:
 780:../src/stm32f30x_rtc.c ****   }  
 781:../src/stm32f30x_rtc.c **** 
 782:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
 783:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 938              		.loc 1 783 0
 939 0628 4FF42053 		mov	r3, #10240
 940 062c C4F20003 		movt	r3, 16384
 941 0630 4FF0CA02 		mov	r2, #202
 942 0634 5A62     		str	r2, [r3, #36]
 784:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 943              		.loc 1 784 0
 944 0636 4FF42053 		mov	r3, #10240
 945 063a C4F20003 		movt	r3, 16384
 946 063e 4FF05302 		mov	r2, #83
 947 0642 5A62     		str	r2, [r3, #36]
 785:../src/stm32f30x_rtc.c **** 
 786:../src/stm32f30x_rtc.c ****   /* Set Initialization mode */
 787:../src/stm32f30x_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
 948              		.loc 1 787 0
 949 0644 FFF7FEFF 		bl	RTC_EnterInitMode
 950 0648 0346     		mov	r3, r0
 951 064a 002B     		cmp	r3, #0
 952 064c 03D1     		bne	.L48
 788:../src/stm32f30x_rtc.c ****   {
 789:../src/stm32f30x_rtc.c ****     status = ERROR;
 953              		.loc 1 789 0
 954 064e 4FF00003 		mov	r3, #0
 955 0652 FB72     		strb	r3, [r7, #11]
 956 0654 24E0     		b	.L49
 957              	.L48:
 790:../src/stm32f30x_rtc.c ****   } 
 791:../src/stm32f30x_rtc.c ****   else
 792:../src/stm32f30x_rtc.c ****   {
 793:../src/stm32f30x_rtc.c ****     /* Set the RTC_TR register */
 794:../src/stm32f30x_rtc.c ****     RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 958              		.loc 1 794 0
 959 0656 4FF42053 		mov	r3, #10240
 960 065a C4F20003 		movt	r3, 16384
 961 065e FA68     		ldr	r2, [r7, #12]
 962 0660 02F07F32 		and	r2, r2, #2139062143
 963 0664 22F0FE42 		bic	r2, r2, #2130706432
 964 0668 1A60     		str	r2, [r3, #0]
 795:../src/stm32f30x_rtc.c **** 
 796:../src/stm32f30x_rtc.c ****     /* Exit Initialization mode */
 797:../src/stm32f30x_rtc.c ****     RTC_ExitInitMode(); 
 965              		.loc 1 797 0
 966 066a FFF7FEFF 		bl	RTC_ExitInitMode
 798:../src/stm32f30x_rtc.c **** 
 799:../src/stm32f30x_rtc.c ****     /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
 800:../src/stm32f30x_rtc.c ****     if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 967              		.loc 1 800 0
 968 066e 4FF42053 		mov	r3, #10240
 969 0672 C4F20003 		movt	r3, 16384
 970 0676 9B68     		ldr	r3, [r3, #8]
 971 0678 03F02003 		and	r3, r3, #32
 972 067c 002B     		cmp	r3, #0
 973 067e 0CD1     		bne	.L50
 801:../src/stm32f30x_rtc.c ****     {
 802:../src/stm32f30x_rtc.c ****       if (RTC_WaitForSynchro() == ERROR)
 974              		.loc 1 802 0
 975 0680 FFF7FEFF 		bl	RTC_WaitForSynchro
 976 0684 0346     		mov	r3, r0
 977 0686 002B     		cmp	r3, #0
 978 0688 03D1     		bne	.L51
 803:../src/stm32f30x_rtc.c ****       {
 804:../src/stm32f30x_rtc.c ****         status = ERROR;
 979              		.loc 1 804 0
 980 068a 4FF00003 		mov	r3, #0
 981 068e FB72     		strb	r3, [r7, #11]
 982 0690 06E0     		b	.L49
 983              	.L51:
 805:../src/stm32f30x_rtc.c ****       }
 806:../src/stm32f30x_rtc.c ****       else
 807:../src/stm32f30x_rtc.c ****       {
 808:../src/stm32f30x_rtc.c ****         status = SUCCESS;
 984              		.loc 1 808 0
 985 0692 4FF00103 		mov	r3, #1
 986 0696 FB72     		strb	r3, [r7, #11]
 987 0698 02E0     		b	.L49
 988              	.L50:
 809:../src/stm32f30x_rtc.c ****       }
 810:../src/stm32f30x_rtc.c ****     }
 811:../src/stm32f30x_rtc.c ****     else
 812:../src/stm32f30x_rtc.c ****     {
 813:../src/stm32f30x_rtc.c ****       status = SUCCESS;
 989              		.loc 1 813 0
 990 069a 4FF00103 		mov	r3, #1
 991 069e FB72     		strb	r3, [r7, #11]
 992              	.L49:
 814:../src/stm32f30x_rtc.c ****     }
 815:../src/stm32f30x_rtc.c ****   
 816:../src/stm32f30x_rtc.c ****   }
 817:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
 818:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 993              		.loc 1 818 0
 994 06a0 4FF42053 		mov	r3, #10240
 995 06a4 C4F20003 		movt	r3, 16384
 996 06a8 4FF0FF02 		mov	r2, #255
 997 06ac 5A62     		str	r2, [r3, #36]
 819:../src/stm32f30x_rtc.c ****     
 820:../src/stm32f30x_rtc.c ****   return status;
 998              		.loc 1 820 0
 999 06ae FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 821:../src/stm32f30x_rtc.c **** }
 1000              		.loc 1 821 0
 1001 06b0 1846     		mov	r0, r3
 1002 06b2 07F11407 		add	r7, r7, #20
 1003 06b6 BD46     		mov	sp, r7
 1004 06b8 90BD     		pop	{r4, r7, pc}
 1005              		.cfi_endproc
 1006              	.LFE120:
 1008 06ba 00BF     		.align	2
 1009              		.global	RTC_TimeStructInit
 1010              		.thumb
 1011              		.thumb_func
 1013              	RTC_TimeStructInit:
 1014              	.LFB121:
 822:../src/stm32f30x_rtc.c **** 
 823:../src/stm32f30x_rtc.c **** /**
 824:../src/stm32f30x_rtc.c ****   * @brief  Fills each RTC_TimeStruct member with its default value
 825:../src/stm32f30x_rtc.c ****   *         (Time = 00h:00min:00sec).
 826:../src/stm32f30x_rtc.c ****   * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
 827:../src/stm32f30x_rtc.c ****   *         initialized.
 828:../src/stm32f30x_rtc.c ****   * @retval None
 829:../src/stm32f30x_rtc.c ****   */
 830:../src/stm32f30x_rtc.c **** void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
 831:../src/stm32f30x_rtc.c **** {
 1015              		.loc 1 831 0
 1016              		.cfi_startproc
 1017              		@ args = 0, pretend = 0, frame = 8
 1018              		@ frame_needed = 1, uses_anonymous_args = 0
 1019              		@ link register save eliminated.
 1020 06bc 80B4     		push	{r7}
 1021              	.LCFI29:
 1022              		.cfi_def_cfa_offset 4
 1023              		.cfi_offset 7, -4
 1024 06be 83B0     		sub	sp, sp, #12
 1025              	.LCFI30:
 1026              		.cfi_def_cfa_offset 16
 1027 06c0 00AF     		add	r7, sp, #0
 1028              	.LCFI31:
 1029              		.cfi_def_cfa_register 7
 1030 06c2 7860     		str	r0, [r7, #4]
 832:../src/stm32f30x_rtc.c ****   /* Time = 00h:00min:00sec */
 833:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
 1031              		.loc 1 833 0
 1032 06c4 7B68     		ldr	r3, [r7, #4]
 1033 06c6 4FF00002 		mov	r2, #0
 1034 06ca DA70     		strb	r2, [r3, #3]
 834:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_Hours = 0;
 1035              		.loc 1 834 0
 1036 06cc 7B68     		ldr	r3, [r7, #4]
 1037 06ce 4FF00002 		mov	r2, #0
 1038 06d2 1A70     		strb	r2, [r3, #0]
 835:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_Minutes = 0;
 1039              		.loc 1 835 0
 1040 06d4 7B68     		ldr	r3, [r7, #4]
 1041 06d6 4FF00002 		mov	r2, #0
 1042 06da 5A70     		strb	r2, [r3, #1]
 836:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_Seconds = 0; 
 1043              		.loc 1 836 0
 1044 06dc 7B68     		ldr	r3, [r7, #4]
 1045 06de 4FF00002 		mov	r2, #0
 1046 06e2 9A70     		strb	r2, [r3, #2]
 837:../src/stm32f30x_rtc.c **** }
 1047              		.loc 1 837 0
 1048 06e4 07F10C07 		add	r7, r7, #12
 1049 06e8 BD46     		mov	sp, r7
 1050 06ea 80BC     		pop	{r7}
 1051 06ec 7047     		bx	lr
 1052              		.cfi_endproc
 1053              	.LFE121:
 1055 06ee 00BF     		.align	2
 1056              		.global	RTC_GetTime
 1057              		.thumb
 1058              		.thumb_func
 1060              	RTC_GetTime:
 1061              	.LFB122:
 838:../src/stm32f30x_rtc.c **** 
 839:../src/stm32f30x_rtc.c **** /**
 840:../src/stm32f30x_rtc.c ****   * @brief  Get the RTC current Time.
 841:../src/stm32f30x_rtc.c ****   * @param  RTC_Format: specifies the format of the returned parameters.
 842:../src/stm32f30x_rtc.c ****   *   This parameter can be  one of the following values:
 843:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BIN:  Binary data format 
 844:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BCD:  BCD data format
 845:../src/stm32f30x_rtc.c ****   * @param RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
 846:../src/stm32f30x_rtc.c ****   *                        contain the returned current time configuration.     
 847:../src/stm32f30x_rtc.c ****   * @retval None
 848:../src/stm32f30x_rtc.c ****   */
 849:../src/stm32f30x_rtc.c **** void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
 850:../src/stm32f30x_rtc.c **** {
 1062              		.loc 1 850 0
 1063              		.cfi_startproc
 1064              		@ args = 0, pretend = 0, frame = 16
 1065              		@ frame_needed = 1, uses_anonymous_args = 0
 1066 06f0 80B5     		push	{r7, lr}
 1067              	.LCFI32:
 1068              		.cfi_def_cfa_offset 8
 1069              		.cfi_offset 7, -8
 1070              		.cfi_offset 14, -4
 1071 06f2 84B0     		sub	sp, sp, #16
 1072              	.LCFI33:
 1073              		.cfi_def_cfa_offset 24
 1074 06f4 00AF     		add	r7, sp, #0
 1075              	.LCFI34:
 1076              		.cfi_def_cfa_register 7
 1077 06f6 7860     		str	r0, [r7, #4]
 1078 06f8 3960     		str	r1, [r7, #0]
 851:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 1079              		.loc 1 851 0
 1080 06fa 4FF00003 		mov	r3, #0
 1081 06fe FB60     		str	r3, [r7, #12]
 852:../src/stm32f30x_rtc.c **** 
 853:../src/stm32f30x_rtc.c ****   /* Check the parameters */
 854:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
 855:../src/stm32f30x_rtc.c **** 
 856:../src/stm32f30x_rtc.c ****   /* Get the RTC_TR register */
 857:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
 1082              		.loc 1 857 0
 1083 0700 4FF42053 		mov	r3, #10240
 1084 0704 C4F20003 		movt	r3, 16384
 1085 0708 1B68     		ldr	r3, [r3, #0]
 1086 070a 03F07F33 		and	r3, r3, #2139062143
 1087 070e 23F0FE43 		bic	r3, r3, #2130706432
 1088 0712 FB60     		str	r3, [r7, #12]
 858:../src/stm32f30x_rtc.c ****   
 859:../src/stm32f30x_rtc.c ****   /* Fill the structure fields with the read parameters */
 860:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 1089              		.loc 1 860 0
 1090 0714 FB68     		ldr	r3, [r7, #12]
 1091 0716 03F47C13 		and	r3, r3, #4128768
 1092 071a 4FEA1343 		lsr	r3, r3, #16
 1093 071e DAB2     		uxtb	r2, r3
 1094 0720 3B68     		ldr	r3, [r7, #0]
 1095 0722 1A70     		strb	r2, [r3, #0]
 861:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 1096              		.loc 1 861 0
 1097 0724 FB68     		ldr	r3, [r7, #12]
 1098 0726 03F4FE43 		and	r3, r3, #32512
 1099 072a 4FEA1323 		lsr	r3, r3, #8
 1100 072e DAB2     		uxtb	r2, r3
 1101 0730 3B68     		ldr	r3, [r7, #0]
 1102 0732 5A70     		strb	r2, [r3, #1]
 862:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 1103              		.loc 1 862 0
 1104 0734 FB68     		ldr	r3, [r7, #12]
 1105 0736 DBB2     		uxtb	r3, r3
 1106 0738 03F07F03 		and	r3, r3, #127
 1107 073c DAB2     		uxtb	r2, r3
 1108 073e 3B68     		ldr	r3, [r7, #0]
 1109 0740 9A70     		strb	r2, [r3, #2]
 863:../src/stm32f30x_rtc.c ****   RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 1110              		.loc 1 863 0
 1111 0742 FB68     		ldr	r3, [r7, #12]
 1112 0744 03F48003 		and	r3, r3, #4194304
 1113 0748 4FEA1343 		lsr	r3, r3, #16
 1114 074c DAB2     		uxtb	r2, r3
 1115 074e 3B68     		ldr	r3, [r7, #0]
 1116 0750 DA70     		strb	r2, [r3, #3]
 864:../src/stm32f30x_rtc.c **** 
 865:../src/stm32f30x_rtc.c ****   /* Check the input parameters format */
 866:../src/stm32f30x_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 1117              		.loc 1 866 0
 1118 0752 7B68     		ldr	r3, [r7, #4]
 1119 0754 002B     		cmp	r3, #0
 1120 0756 1AD1     		bne	.L54
 867:../src/stm32f30x_rtc.c ****   {
 868:../src/stm32f30x_rtc.c ****     /* Convert the structure parameters to Binary format */
 869:../src/stm32f30x_rtc.c ****     RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 1121              		.loc 1 869 0
 1122 0758 3B68     		ldr	r3, [r7, #0]
 1123 075a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1124 075c 1846     		mov	r0, r3
 1125 075e 01F099F9 		bl	RTC_Bcd2ToByte
 1126 0762 0346     		mov	r3, r0
 1127 0764 1A46     		mov	r2, r3
 1128 0766 3B68     		ldr	r3, [r7, #0]
 1129 0768 1A70     		strb	r2, [r3, #0]
 870:../src/stm32f30x_rtc.c ****     RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
 1130              		.loc 1 870 0
 1131 076a 3B68     		ldr	r3, [r7, #0]
 1132 076c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1133 076e 1846     		mov	r0, r3
 1134 0770 01F090F9 		bl	RTC_Bcd2ToByte
 1135 0774 0346     		mov	r3, r0
 1136 0776 1A46     		mov	r2, r3
 1137 0778 3B68     		ldr	r3, [r7, #0]
 1138 077a 5A70     		strb	r2, [r3, #1]
 871:../src/stm32f30x_rtc.c ****     RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
 1139              		.loc 1 871 0
 1140 077c 3B68     		ldr	r3, [r7, #0]
 1141 077e 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1142 0780 1846     		mov	r0, r3
 1143 0782 01F087F9 		bl	RTC_Bcd2ToByte
 1144 0786 0346     		mov	r3, r0
 1145 0788 1A46     		mov	r2, r3
 1146 078a 3B68     		ldr	r3, [r7, #0]
 1147 078c 9A70     		strb	r2, [r3, #2]
 1148              	.L54:
 872:../src/stm32f30x_rtc.c ****   }
 873:../src/stm32f30x_rtc.c **** }
 1149              		.loc 1 873 0
 1150 078e 07F11007 		add	r7, r7, #16
 1151 0792 BD46     		mov	sp, r7
 1152 0794 80BD     		pop	{r7, pc}
 1153              		.cfi_endproc
 1154              	.LFE122:
 1156 0796 00BF     		.align	2
 1157              		.global	RTC_GetSubSecond
 1158              		.thumb
 1159              		.thumb_func
 1161              	RTC_GetSubSecond:
 1162              	.LFB123:
 874:../src/stm32f30x_rtc.c **** 
 875:../src/stm32f30x_rtc.c **** /**
 876:../src/stm32f30x_rtc.c ****   * @brief  Gets the RTC current Calendar Subseconds value.
 877:../src/stm32f30x_rtc.c ****   * @note   This function freeze the Time and Date registers after reading the 
 878:../src/stm32f30x_rtc.c ****   *         SSR register.
 879:../src/stm32f30x_rtc.c ****   * @param  None
 880:../src/stm32f30x_rtc.c ****   * @retval RTC current Calendar Subseconds value.
 881:../src/stm32f30x_rtc.c ****   */
 882:../src/stm32f30x_rtc.c **** uint32_t RTC_GetSubSecond(void)
 883:../src/stm32f30x_rtc.c **** {
 1163              		.loc 1 883 0
 1164              		.cfi_startproc
 1165              		@ args = 0, pretend = 0, frame = 8
 1166              		@ frame_needed = 1, uses_anonymous_args = 0
 1167              		@ link register save eliminated.
 1168 0798 80B4     		push	{r7}
 1169              	.LCFI35:
 1170              		.cfi_def_cfa_offset 4
 1171              		.cfi_offset 7, -4
 1172 079a 83B0     		sub	sp, sp, #12
 1173              	.LCFI36:
 1174              		.cfi_def_cfa_offset 16
 1175 079c 00AF     		add	r7, sp, #0
 1176              	.LCFI37:
 1177              		.cfi_def_cfa_register 7
 884:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 1178              		.loc 1 884 0
 1179 079e 4FF00003 		mov	r3, #0
 1180 07a2 7B60     		str	r3, [r7, #4]
 885:../src/stm32f30x_rtc.c ****   
 886:../src/stm32f30x_rtc.c ****   /* Get subseconds values from the correspondent registers*/
 887:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)(RTC->SSR);
 1181              		.loc 1 887 0
 1182 07a4 4FF42053 		mov	r3, #10240
 1183 07a8 C4F20003 		movt	r3, 16384
 1184 07ac 9B6A     		ldr	r3, [r3, #40]
 1185 07ae 7B60     		str	r3, [r7, #4]
 888:../src/stm32f30x_rtc.c ****   
 889:../src/stm32f30x_rtc.c ****   /* Read DR register to unfroze calendar registers */
 890:../src/stm32f30x_rtc.c ****   (void) (RTC->DR);
 1186              		.loc 1 890 0
 1187 07b0 4FF42053 		mov	r3, #10240
 1188 07b4 C4F20003 		movt	r3, 16384
 1189 07b8 5B68     		ldr	r3, [r3, #4]
 891:../src/stm32f30x_rtc.c ****   
 892:../src/stm32f30x_rtc.c ****   return (tmpreg);
 1190              		.loc 1 892 0
 1191 07ba 7B68     		ldr	r3, [r7, #4]
 893:../src/stm32f30x_rtc.c **** }
 1192              		.loc 1 893 0
 1193 07bc 1846     		mov	r0, r3
 1194 07be 07F10C07 		add	r7, r7, #12
 1195 07c2 BD46     		mov	sp, r7
 1196 07c4 80BC     		pop	{r7}
 1197 07c6 7047     		bx	lr
 1198              		.cfi_endproc
 1199              	.LFE123:
 1201              		.align	2
 1202              		.global	RTC_SetDate
 1203              		.thumb
 1204              		.thumb_func
 1206              	RTC_SetDate:
 1207              	.LFB124:
 894:../src/stm32f30x_rtc.c **** 
 895:../src/stm32f30x_rtc.c **** /**
 896:../src/stm32f30x_rtc.c ****   * @brief  Set the RTC current date.
 897:../src/stm32f30x_rtc.c ****   * @param  RTC_Format: specifies the format of the entered parameters.
 898:../src/stm32f30x_rtc.c ****   *   This parameter can be  one of the following values:
 899:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BIN:  Binary data format 
 900:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BCD:  BCD data format
 901:../src/stm32f30x_rtc.c ****   * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure that contains 
 902:../src/stm32f30x_rtc.c ****   *                         the date configuration information for the RTC.
 903:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
 904:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC Date register is configured
 905:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC Date register is not configured
 906:../src/stm32f30x_rtc.c ****   */
 907:../src/stm32f30x_rtc.c **** ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
 908:../src/stm32f30x_rtc.c **** {
 1208              		.loc 1 908 0
 1209              		.cfi_startproc
 1210              		@ args = 0, pretend = 0, frame = 16
 1211              		@ frame_needed = 1, uses_anonymous_args = 0
 1212 07c8 90B5     		push	{r4, r7, lr}
 1213              	.LCFI38:
 1214              		.cfi_def_cfa_offset 12
 1215              		.cfi_offset 4, -12
 1216              		.cfi_offset 7, -8
 1217              		.cfi_offset 14, -4
 1218 07ca 85B0     		sub	sp, sp, #20
 1219              	.LCFI39:
 1220              		.cfi_def_cfa_offset 32
 1221 07cc 00AF     		add	r7, sp, #0
 1222              	.LCFI40:
 1223              		.cfi_def_cfa_register 7
 1224 07ce 7860     		str	r0, [r7, #4]
 1225 07d0 3960     		str	r1, [r7, #0]
 909:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 1226              		.loc 1 909 0
 1227 07d2 4FF00003 		mov	r3, #0
 1228 07d6 FB60     		str	r3, [r7, #12]
 910:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 1229              		.loc 1 910 0
 1230 07d8 4FF00003 		mov	r3, #0
 1231 07dc FB72     		strb	r3, [r7, #11]
 911:../src/stm32f30x_rtc.c ****   
 912:../src/stm32f30x_rtc.c ****   /* Check the parameters */
 913:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
 914:../src/stm32f30x_rtc.c **** 
 915:../src/stm32f30x_rtc.c ****   if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
 1232              		.loc 1 915 0
 1233 07de 7B68     		ldr	r3, [r7, #4]
 1234 07e0 002B     		cmp	r3, #0
 1235 07e2 0FD1     		bne	.L59
 1236              		.loc 1 915 0 is_stmt 0 discriminator 1
 1237 07e4 3B68     		ldr	r3, [r7, #0]
 1238 07e6 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1239 07e8 03F01003 		and	r3, r3, #16
 1240 07ec 002B     		cmp	r3, #0
 1241 07ee 09D0     		beq	.L59
 916:../src/stm32f30x_rtc.c ****   {
 917:../src/stm32f30x_rtc.c ****     RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
 1242              		.loc 1 917 0 is_stmt 1
 1243 07f0 3B68     		ldr	r3, [r7, #0]
 1244 07f2 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1245 07f4 23F01003 		bic	r3, r3, #16
 1246 07f8 DBB2     		uxtb	r3, r3
 1247 07fa 03F10A03 		add	r3, r3, #10
 1248 07fe DAB2     		uxtb	r2, r3
 1249 0800 3B68     		ldr	r3, [r7, #0]
 1250 0802 5A70     		strb	r2, [r3, #1]
 1251              	.L59:
 918:../src/stm32f30x_rtc.c ****   }  
 919:../src/stm32f30x_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 1252              		.loc 1 919 0
 1253 0804 7B68     		ldr	r3, [r7, #4]
 1254 0806 002B     		cmp	r3, #0
 1255 0808 0DD0     		beq	.L60
 920:../src/stm32f30x_rtc.c ****   {
 921:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
 922:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
 923:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
 924:../src/stm32f30x_rtc.c ****   }
 925:../src/stm32f30x_rtc.c ****   else
 926:../src/stm32f30x_rtc.c ****   {
 927:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
 928:../src/stm32f30x_rtc.c ****     tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 1256              		.loc 1 928 0
 1257 080a 3B68     		ldr	r3, [r7, #0]
 1258 080c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1259 080e 1846     		mov	r0, r3
 1260 0810 01F040F9 		bl	RTC_Bcd2ToByte
 1261 0814 0346     		mov	r3, r0
 1262 0816 FB60     		str	r3, [r7, #12]
 929:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_MONTH(tmpreg));
 930:../src/stm32f30x_rtc.c ****     tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 1263              		.loc 1 930 0
 1264 0818 3B68     		ldr	r3, [r7, #0]
 1265 081a 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1266 081c 1846     		mov	r0, r3
 1267 081e 01F039F9 		bl	RTC_Bcd2ToByte
 1268 0822 0346     		mov	r3, r0
 1269 0824 FB60     		str	r3, [r7, #12]
 1270              	.L60:
 931:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_DATE(tmpreg));
 932:../src/stm32f30x_rtc.c ****   }
 933:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
 934:../src/stm32f30x_rtc.c **** 
 935:../src/stm32f30x_rtc.c ****   /* Check the input parameters format */
 936:../src/stm32f30x_rtc.c ****   if (RTC_Format != RTC_Format_BIN)
 1271              		.loc 1 936 0
 1272 0826 7B68     		ldr	r3, [r7, #4]
 1273 0828 002B     		cmp	r3, #0
 1274 082a 12D0     		beq	.L61
 937:../src/stm32f30x_rtc.c ****   {
 938:../src/stm32f30x_rtc.c ****     tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 1275              		.loc 1 938 0
 1276 082c 3B68     		ldr	r3, [r7, #0]
 1277 082e DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1278 0830 4FEA0342 		lsl	r2, r3, #16
 939:../src/stm32f30x_rtc.c ****               (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 1279              		.loc 1 939 0
 1280 0834 3B68     		ldr	r3, [r7, #0]
 1281 0836 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1282 0838 4FEA0323 		lsl	r3, r3, #8
 938:../src/stm32f30x_rtc.c ****     tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 1283              		.loc 1 938 0
 1284 083c 1A43     		orrs	r2, r2, r3
 940:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_DateStruct->RTC_Date) | \
 1285              		.loc 1 940 0
 1286 083e 3B68     		ldr	r3, [r7, #0]
 1287 0840 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 939:../src/stm32f30x_rtc.c ****               (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 1288              		.loc 1 939 0
 1289 0842 1A43     		orrs	r2, r2, r3
 941:../src/stm32f30x_rtc.c ****               (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
 1290              		.loc 1 941 0
 1291 0844 3B68     		ldr	r3, [r7, #0]
 1292 0846 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1293 0848 4FEA4333 		lsl	r3, r3, #13
 938:../src/stm32f30x_rtc.c ****     tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 1294              		.loc 1 938 0
 1295 084c 1343     		orrs	r3, r3, r2
 1296 084e FB60     		str	r3, [r7, #12]
 1297 0850 1EE0     		b	.L62
 1298              	.L61:
 942:../src/stm32f30x_rtc.c ****   }  
 943:../src/stm32f30x_rtc.c ****   else
 944:../src/stm32f30x_rtc.c ****   {
 945:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 1299              		.loc 1 945 0
 1300 0852 3B68     		ldr	r3, [r7, #0]
 1301 0854 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1302 0856 1846     		mov	r0, r3
 1303 0858 01F0FAF8 		bl	RTC_ByteToBcd2
 1304 085c 0346     		mov	r3, r0
 1305 085e 4FEA0344 		lsl	r4, r3, #16
 946:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 1306              		.loc 1 946 0
 1307 0862 3B68     		ldr	r3, [r7, #0]
 1308 0864 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1309 0866 1846     		mov	r0, r3
 1310 0868 01F0F2F8 		bl	RTC_ByteToBcd2
 1311 086c 0346     		mov	r3, r0
 1312 086e 4FEA0323 		lsl	r3, r3, #8
 945:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 1313              		.loc 1 945 0
 1314 0872 1C43     		orrs	r4, r4, r3
 947:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
 1315              		.loc 1 947 0
 1316 0874 3B68     		ldr	r3, [r7, #0]
 1317 0876 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1318 0878 1846     		mov	r0, r3
 1319 087a 01F0E9F8 		bl	RTC_ByteToBcd2
 1320 087e 0346     		mov	r3, r0
 946:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 1321              		.loc 1 946 0
 1322 0880 44EA0302 		orr	r2, r4, r3
 948:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
 1323              		.loc 1 948 0
 1324 0884 3B68     		ldr	r3, [r7, #0]
 1325 0886 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1326 0888 4FEA4333 		lsl	r3, r3, #13
 945:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 1327              		.loc 1 945 0
 1328 088c 1343     		orrs	r3, r3, r2
 1329 088e FB60     		str	r3, [r7, #12]
 1330              	.L62:
 949:../src/stm32f30x_rtc.c ****   }
 950:../src/stm32f30x_rtc.c **** 
 951:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
 952:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 1331              		.loc 1 952 0
 1332 0890 4FF42053 		mov	r3, #10240
 1333 0894 C4F20003 		movt	r3, 16384
 1334 0898 4FF0CA02 		mov	r2, #202
 1335 089c 5A62     		str	r2, [r3, #36]
 953:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 1336              		.loc 1 953 0
 1337 089e 4FF42053 		mov	r3, #10240
 1338 08a2 C4F20003 		movt	r3, 16384
 1339 08a6 4FF05302 		mov	r2, #83
 1340 08aa 5A62     		str	r2, [r3, #36]
 954:../src/stm32f30x_rtc.c **** 
 955:../src/stm32f30x_rtc.c ****   /* Set Initialization mode */
 956:../src/stm32f30x_rtc.c ****   if (RTC_EnterInitMode() == ERROR)
 1341              		.loc 1 956 0
 1342 08ac FFF7FEFF 		bl	RTC_EnterInitMode
 1343 08b0 0346     		mov	r3, r0
 1344 08b2 002B     		cmp	r3, #0
 1345 08b4 03D1     		bne	.L63
 957:../src/stm32f30x_rtc.c ****   {
 958:../src/stm32f30x_rtc.c ****     status = ERROR;
 1346              		.loc 1 958 0
 1347 08b6 4FF00003 		mov	r3, #0
 1348 08ba FB72     		strb	r3, [r7, #11]
 1349 08bc 24E0     		b	.L64
 1350              	.L63:
 959:../src/stm32f30x_rtc.c ****   } 
 960:../src/stm32f30x_rtc.c ****   else
 961:../src/stm32f30x_rtc.c ****   {
 962:../src/stm32f30x_rtc.c ****     /* Set the RTC_DR register */
 963:../src/stm32f30x_rtc.c ****     RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
 1351              		.loc 1 963 0
 1352 08be 4FF42053 		mov	r3, #10240
 1353 08c2 C4F20003 		movt	r3, 16384
 1354 08c6 FA68     		ldr	r2, [r7, #12]
 1355 08c8 22F07F42 		bic	r2, r2, #-16777216
 1356 08cc 22F0C002 		bic	r2, r2, #192
 1357 08d0 5A60     		str	r2, [r3, #4]
 964:../src/stm32f30x_rtc.c **** 
 965:../src/stm32f30x_rtc.c ****     /* Exit Initialization mode */
 966:../src/stm32f30x_rtc.c ****     RTC_ExitInitMode(); 
 1358              		.loc 1 966 0
 1359 08d2 FFF7FEFF 		bl	RTC_ExitInitMode
 967:../src/stm32f30x_rtc.c **** 
 968:../src/stm32f30x_rtc.c ****     /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
 969:../src/stm32f30x_rtc.c ****     if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 1360              		.loc 1 969 0
 1361 08d6 4FF42053 		mov	r3, #10240
 1362 08da C4F20003 		movt	r3, 16384
 1363 08de 9B68     		ldr	r3, [r3, #8]
 1364 08e0 03F02003 		and	r3, r3, #32
 1365 08e4 002B     		cmp	r3, #0
 1366 08e6 0CD1     		bne	.L65
 970:../src/stm32f30x_rtc.c ****     {
 971:../src/stm32f30x_rtc.c ****       if (RTC_WaitForSynchro() == ERROR)
 1367              		.loc 1 971 0
 1368 08e8 FFF7FEFF 		bl	RTC_WaitForSynchro
 1369 08ec 0346     		mov	r3, r0
 1370 08ee 002B     		cmp	r3, #0
 1371 08f0 03D1     		bne	.L66
 972:../src/stm32f30x_rtc.c ****       {
 973:../src/stm32f30x_rtc.c ****         status = ERROR;
 1372              		.loc 1 973 0
 1373 08f2 4FF00003 		mov	r3, #0
 1374 08f6 FB72     		strb	r3, [r7, #11]
 1375 08f8 06E0     		b	.L64
 1376              	.L66:
 974:../src/stm32f30x_rtc.c ****       }
 975:../src/stm32f30x_rtc.c ****       else
 976:../src/stm32f30x_rtc.c ****       {
 977:../src/stm32f30x_rtc.c ****         status = SUCCESS;
 1377              		.loc 1 977 0
 1378 08fa 4FF00103 		mov	r3, #1
 1379 08fe FB72     		strb	r3, [r7, #11]
 1380 0900 02E0     		b	.L64
 1381              	.L65:
 978:../src/stm32f30x_rtc.c ****       }
 979:../src/stm32f30x_rtc.c ****     }
 980:../src/stm32f30x_rtc.c ****     else
 981:../src/stm32f30x_rtc.c ****     {
 982:../src/stm32f30x_rtc.c ****       status = SUCCESS;
 1382              		.loc 1 982 0
 1383 0902 4FF00103 		mov	r3, #1
 1384 0906 FB72     		strb	r3, [r7, #11]
 1385              	.L64:
 983:../src/stm32f30x_rtc.c ****     }
 984:../src/stm32f30x_rtc.c ****   }
 985:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
 986:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 1386              		.loc 1 986 0
 1387 0908 4FF42053 		mov	r3, #10240
 1388 090c C4F20003 		movt	r3, 16384
 1389 0910 4FF0FF02 		mov	r2, #255
 1390 0914 5A62     		str	r2, [r3, #36]
 987:../src/stm32f30x_rtc.c ****   
 988:../src/stm32f30x_rtc.c ****   return status;
 1391              		.loc 1 988 0
 1392 0916 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 989:../src/stm32f30x_rtc.c **** }
 1393              		.loc 1 989 0
 1394 0918 1846     		mov	r0, r3
 1395 091a 07F11407 		add	r7, r7, #20
 1396 091e BD46     		mov	sp, r7
 1397 0920 90BD     		pop	{r4, r7, pc}
 1398              		.cfi_endproc
 1399              	.LFE124:
 1401 0922 00BF     		.align	2
 1402              		.global	RTC_DateStructInit
 1403              		.thumb
 1404              		.thumb_func
 1406              	RTC_DateStructInit:
 1407              	.LFB125:
 990:../src/stm32f30x_rtc.c **** 
 991:../src/stm32f30x_rtc.c **** /**
 992:../src/stm32f30x_rtc.c ****   * @brief  Fills each RTC_DateStruct member with its default value
 993:../src/stm32f30x_rtc.c ****   *         (Monday, January 01 xx00).
 994:../src/stm32f30x_rtc.c ****   * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
 995:../src/stm32f30x_rtc.c ****   *         initialized.
 996:../src/stm32f30x_rtc.c ****   * @retval None
 997:../src/stm32f30x_rtc.c ****   */
 998:../src/stm32f30x_rtc.c **** void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
 999:../src/stm32f30x_rtc.c **** {
 1408              		.loc 1 999 0
 1409              		.cfi_startproc
 1410              		@ args = 0, pretend = 0, frame = 8
 1411              		@ frame_needed = 1, uses_anonymous_args = 0
 1412              		@ link register save eliminated.
 1413 0924 80B4     		push	{r7}
 1414              	.LCFI41:
 1415              		.cfi_def_cfa_offset 4
 1416              		.cfi_offset 7, -4
 1417 0926 83B0     		sub	sp, sp, #12
 1418              	.LCFI42:
 1419              		.cfi_def_cfa_offset 16
 1420 0928 00AF     		add	r7, sp, #0
 1421              	.LCFI43:
 1422              		.cfi_def_cfa_register 7
 1423 092a 7860     		str	r0, [r7, #4]
1000:../src/stm32f30x_rtc.c ****   /* Monday, January 01 xx00 */
1001:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
 1424              		.loc 1 1001 0
 1425 092c 7B68     		ldr	r3, [r7, #4]
 1426 092e 4FF00102 		mov	r2, #1
 1427 0932 1A70     		strb	r2, [r3, #0]
1002:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_Date = 1;
 1428              		.loc 1 1002 0
 1429 0934 7B68     		ldr	r3, [r7, #4]
 1430 0936 4FF00102 		mov	r2, #1
 1431 093a 9A70     		strb	r2, [r3, #2]
1003:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_Month = RTC_Month_January;
 1432              		.loc 1 1003 0
 1433 093c 7B68     		ldr	r3, [r7, #4]
 1434 093e 4FF00102 		mov	r2, #1
 1435 0942 5A70     		strb	r2, [r3, #1]
1004:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_Year = 0;
 1436              		.loc 1 1004 0
 1437 0944 7B68     		ldr	r3, [r7, #4]
 1438 0946 4FF00002 		mov	r2, #0
 1439 094a DA70     		strb	r2, [r3, #3]
1005:../src/stm32f30x_rtc.c **** }
 1440              		.loc 1 1005 0
 1441 094c 07F10C07 		add	r7, r7, #12
 1442 0950 BD46     		mov	sp, r7
 1443 0952 80BC     		pop	{r7}
 1444 0954 7047     		bx	lr
 1445              		.cfi_endproc
 1446              	.LFE125:
 1448 0956 00BF     		.align	2
 1449              		.global	RTC_GetDate
 1450              		.thumb
 1451              		.thumb_func
 1453              	RTC_GetDate:
 1454              	.LFB126:
1006:../src/stm32f30x_rtc.c **** 
1007:../src/stm32f30x_rtc.c **** /**
1008:../src/stm32f30x_rtc.c ****   * @brief  Get the RTC current date.
1009:../src/stm32f30x_rtc.c ****   * @param  RTC_Format: specifies the format of the returned parameters.
1010:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1011:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BIN: Binary data format 
1012:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BCD: BCD data format
1013:../src/stm32f30x_rtc.c ****   * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
1014:../src/stm32f30x_rtc.c ****   *                        contain the returned current date configuration.
1015:../src/stm32f30x_rtc.c ****   * @retval None
1016:../src/stm32f30x_rtc.c ****   */
1017:../src/stm32f30x_rtc.c **** void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
1018:../src/stm32f30x_rtc.c **** {
 1455              		.loc 1 1018 0
 1456              		.cfi_startproc
 1457              		@ args = 0, pretend = 0, frame = 16
 1458              		@ frame_needed = 1, uses_anonymous_args = 0
 1459 0958 80B5     		push	{r7, lr}
 1460              	.LCFI44:
 1461              		.cfi_def_cfa_offset 8
 1462              		.cfi_offset 7, -8
 1463              		.cfi_offset 14, -4
 1464 095a 84B0     		sub	sp, sp, #16
 1465              	.LCFI45:
 1466              		.cfi_def_cfa_offset 24
 1467 095c 00AF     		add	r7, sp, #0
 1468              	.LCFI46:
 1469              		.cfi_def_cfa_register 7
 1470 095e 7860     		str	r0, [r7, #4]
 1471 0960 3960     		str	r1, [r7, #0]
1019:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 1472              		.loc 1 1019 0
 1473 0962 4FF00003 		mov	r3, #0
 1474 0966 FB60     		str	r3, [r7, #12]
1020:../src/stm32f30x_rtc.c **** 
1021:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1022:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
1023:../src/stm32f30x_rtc.c ****   
1024:../src/stm32f30x_rtc.c ****   /* Get the RTC_TR register */
1025:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
 1475              		.loc 1 1025 0
 1476 0968 4FF42053 		mov	r3, #10240
 1477 096c C4F20003 		movt	r3, 16384
 1478 0970 5B68     		ldr	r3, [r3, #4]
 1479 0972 23F07F43 		bic	r3, r3, #-16777216
 1480 0976 23F0C003 		bic	r3, r3, #192
 1481 097a FB60     		str	r3, [r7, #12]
1026:../src/stm32f30x_rtc.c **** 
1027:../src/stm32f30x_rtc.c ****   /* Fill the structure fields with the read parameters */
1028:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 1482              		.loc 1 1028 0
 1483 097c FB68     		ldr	r3, [r7, #12]
 1484 097e 03F47F03 		and	r3, r3, #16711680
 1485 0982 4FEA1343 		lsr	r3, r3, #16
 1486 0986 DAB2     		uxtb	r2, r3
 1487 0988 3B68     		ldr	r3, [r7, #0]
 1488 098a DA70     		strb	r2, [r3, #3]
1029:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 1489              		.loc 1 1029 0
 1490 098c FB68     		ldr	r3, [r7, #12]
 1491 098e 03F4F853 		and	r3, r3, #7936
 1492 0992 4FEA1323 		lsr	r3, r3, #8
 1493 0996 DAB2     		uxtb	r2, r3
 1494 0998 3B68     		ldr	r3, [r7, #0]
 1495 099a 5A70     		strb	r2, [r3, #1]
1030:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
 1496              		.loc 1 1030 0
 1497 099c FB68     		ldr	r3, [r7, #12]
 1498 099e DBB2     		uxtb	r3, r3
 1499 09a0 03F03F03 		and	r3, r3, #63
 1500 09a4 DAB2     		uxtb	r2, r3
 1501 09a6 3B68     		ldr	r3, [r7, #0]
 1502 09a8 9A70     		strb	r2, [r3, #2]
1031:../src/stm32f30x_rtc.c ****   RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
 1503              		.loc 1 1031 0
 1504 09aa FB68     		ldr	r3, [r7, #12]
 1505 09ac 03F46043 		and	r3, r3, #57344
 1506 09b0 4FEA5333 		lsr	r3, r3, #13
 1507 09b4 DAB2     		uxtb	r2, r3
 1508 09b6 3B68     		ldr	r3, [r7, #0]
 1509 09b8 1A70     		strb	r2, [r3, #0]
1032:../src/stm32f30x_rtc.c **** 
1033:../src/stm32f30x_rtc.c ****   /* Check the input parameters format */
1034:../src/stm32f30x_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 1510              		.loc 1 1034 0
 1511 09ba 7B68     		ldr	r3, [r7, #4]
 1512 09bc 002B     		cmp	r3, #0
 1513 09be 1ED1     		bne	.L69
1035:../src/stm32f30x_rtc.c ****   {
1036:../src/stm32f30x_rtc.c ****     /* Convert the structure parameters to Binary format */
1037:../src/stm32f30x_rtc.c ****     RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
 1514              		.loc 1 1037 0
 1515 09c0 3B68     		ldr	r3, [r7, #0]
 1516 09c2 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1517 09c4 1846     		mov	r0, r3
 1518 09c6 01F065F8 		bl	RTC_Bcd2ToByte
 1519 09ca 0346     		mov	r3, r0
 1520 09cc 1A46     		mov	r2, r3
 1521 09ce 3B68     		ldr	r3, [r7, #0]
 1522 09d0 DA70     		strb	r2, [r3, #3]
1038:../src/stm32f30x_rtc.c ****     RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 1523              		.loc 1 1038 0
 1524 09d2 3B68     		ldr	r3, [r7, #0]
 1525 09d4 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1526 09d6 1846     		mov	r0, r3
 1527 09d8 01F05CF8 		bl	RTC_Bcd2ToByte
 1528 09dc 0346     		mov	r3, r0
 1529 09de 1A46     		mov	r2, r3
 1530 09e0 3B68     		ldr	r3, [r7, #0]
 1531 09e2 5A70     		strb	r2, [r3, #1]
1039:../src/stm32f30x_rtc.c ****     RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 1532              		.loc 1 1039 0
 1533 09e4 3B68     		ldr	r3, [r7, #0]
 1534 09e6 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1535 09e8 1846     		mov	r0, r3
 1536 09ea 01F053F8 		bl	RTC_Bcd2ToByte
 1537 09ee 0346     		mov	r3, r0
 1538 09f0 1A46     		mov	r2, r3
 1539 09f2 3B68     		ldr	r3, [r7, #0]
 1540 09f4 9A70     		strb	r2, [r3, #2]
1040:../src/stm32f30x_rtc.c ****     RTC_DateStruct->RTC_WeekDay = (uint8_t)(RTC_DateStruct->RTC_WeekDay);   
 1541              		.loc 1 1040 0
 1542 09f6 3B68     		ldr	r3, [r7, #0]
 1543 09f8 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 1544 09fa 3B68     		ldr	r3, [r7, #0]
 1545 09fc 1A70     		strb	r2, [r3, #0]
 1546              	.L69:
1041:../src/stm32f30x_rtc.c ****   }
1042:../src/stm32f30x_rtc.c **** }
 1547              		.loc 1 1042 0
 1548 09fe 07F11007 		add	r7, r7, #16
 1549 0a02 BD46     		mov	sp, r7
 1550 0a04 80BD     		pop	{r7, pc}
 1551              		.cfi_endproc
 1552              	.LFE126:
 1554 0a06 00BF     		.align	2
 1555              		.global	RTC_SetAlarm
 1556              		.thumb
 1557              		.thumb_func
 1559              	RTC_SetAlarm:
 1560              	.LFB127:
1043:../src/stm32f30x_rtc.c **** 
1044:../src/stm32f30x_rtc.c **** /**
1045:../src/stm32f30x_rtc.c ****   * @}
1046:../src/stm32f30x_rtc.c ****   */
1047:../src/stm32f30x_rtc.c **** 
1048:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group3 Alarms configuration functions
1049:../src/stm32f30x_rtc.c ****  *  @brief   Alarms (Alarm A and Alarm B) configuration functions 
1050:../src/stm32f30x_rtc.c ****  *
1051:../src/stm32f30x_rtc.c **** @verbatim   
1052:../src/stm32f30x_rtc.c ****  ===============================================================================
1053:../src/stm32f30x_rtc.c ****         ##### Alarms (Alarm A and Alarm B) configuration functions #####
1054:../src/stm32f30x_rtc.c ****  ===============================================================================  
1055:../src/stm32f30x_rtc.c ****     [..] This section provides functions allowing to program and read the RTC Alarms.
1056:../src/stm32f30x_rtc.c **** 
1057:../src/stm32f30x_rtc.c **** @endverbatim
1058:../src/stm32f30x_rtc.c ****   * @{
1059:../src/stm32f30x_rtc.c ****   */
1060:../src/stm32f30x_rtc.c **** 
1061:../src/stm32f30x_rtc.c **** /**
1062:../src/stm32f30x_rtc.c ****   * @brief  Set the specified RTC Alarm.
1063:../src/stm32f30x_rtc.c ****   * @note   The Alarm register can only be written when the corresponding Alarm
1064:../src/stm32f30x_rtc.c ****   *         is disabled (Use the RTC_AlarmCmd(DISABLE)).    
1065:../src/stm32f30x_rtc.c ****   * @param  RTC_Format: specifies the format of the returned parameters.
1066:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1067:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BIN: Binary data format 
1068:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BCD: BCD data format
1069:../src/stm32f30x_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be configured.
1070:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1071:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_A: to select Alarm A
1072:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_B: to select Alarm B  
1073:../src/stm32f30x_rtc.c ****   * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
1074:../src/stm32f30x_rtc.c ****   *                          contains the alarm configuration parameters.     
1075:../src/stm32f30x_rtc.c ****   * @retval None
1076:../src/stm32f30x_rtc.c ****   */
1077:../src/stm32f30x_rtc.c **** void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
1078:../src/stm32f30x_rtc.c **** {
 1561              		.loc 1 1078 0
 1562              		.cfi_startproc
 1563              		@ args = 0, pretend = 0, frame = 24
 1564              		@ frame_needed = 1, uses_anonymous_args = 0
 1565 0a08 90B5     		push	{r4, r7, lr}
 1566              	.LCFI47:
 1567              		.cfi_def_cfa_offset 12
 1568              		.cfi_offset 4, -12
 1569              		.cfi_offset 7, -8
 1570              		.cfi_offset 14, -4
 1571 0a0a 87B0     		sub	sp, sp, #28
 1572              	.LCFI48:
 1573              		.cfi_def_cfa_offset 40
 1574 0a0c 00AF     		add	r7, sp, #0
 1575              	.LCFI49:
 1576              		.cfi_def_cfa_register 7
 1577 0a0e F860     		str	r0, [r7, #12]
 1578 0a10 B960     		str	r1, [r7, #8]
 1579 0a12 7A60     		str	r2, [r7, #4]
1079:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 1580              		.loc 1 1079 0
 1581 0a14 4FF00003 		mov	r3, #0
 1582 0a18 7B61     		str	r3, [r7, #20]
1080:../src/stm32f30x_rtc.c ****   
1081:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1082:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
1083:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_ALARM(RTC_Alarm));
1084:../src/stm32f30x_rtc.c ****   assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
1085:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
1086:../src/stm32f30x_rtc.c **** 
1087:../src/stm32f30x_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 1583              		.loc 1 1087 0
 1584 0a1a FB68     		ldr	r3, [r7, #12]
 1585 0a1c 002B     		cmp	r3, #0
 1586 0a1e 0DD1     		bne	.L72
1088:../src/stm32f30x_rtc.c ****   {
1089:../src/stm32f30x_rtc.c ****     if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 1587              		.loc 1 1089 0
 1588 0a20 4FF42053 		mov	r3, #10240
 1589 0a24 C4F20003 		movt	r3, 16384
 1590 0a28 9B68     		ldr	r3, [r3, #8]
 1591 0a2a 03F04003 		and	r3, r3, #64
 1592 0a2e 002B     		cmp	r3, #0
 1593 0a30 2CD1     		bne	.L74
1090:../src/stm32f30x_rtc.c ****     {
1091:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
1092:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
1093:../src/stm32f30x_rtc.c ****     } 
1094:../src/stm32f30x_rtc.c ****     else
1095:../src/stm32f30x_rtc.c ****     {
1096:../src/stm32f30x_rtc.c ****       RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 1594              		.loc 1 1096 0
 1595 0a32 7B68     		ldr	r3, [r7, #4]
 1596 0a34 4FF00002 		mov	r2, #0
 1597 0a38 DA70     		strb	r2, [r3, #3]
 1598 0a3a 27E0     		b	.L74
 1599              	.L72:
1097:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
1098:../src/stm32f30x_rtc.c ****     }
1099:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
1100:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
1101:../src/stm32f30x_rtc.c ****     
1102:../src/stm32f30x_rtc.c ****     if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
1103:../src/stm32f30x_rtc.c ****     {
1104:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
1105:../src/stm32f30x_rtc.c ****     }
1106:../src/stm32f30x_rtc.c ****     else
1107:../src/stm32f30x_rtc.c ****     {
1108:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
1109:../src/stm32f30x_rtc.c ****     }
1110:../src/stm32f30x_rtc.c ****   }
1111:../src/stm32f30x_rtc.c ****   else
1112:../src/stm32f30x_rtc.c ****   {
1113:../src/stm32f30x_rtc.c ****     if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 1600              		.loc 1 1113 0
 1601 0a3c 4FF42053 		mov	r3, #10240
 1602 0a40 C4F20003 		movt	r3, 16384
 1603 0a44 9B68     		ldr	r3, [r3, #8]
 1604 0a46 03F04003 		and	r3, r3, #64
 1605 0a4a 002B     		cmp	r3, #0
 1606 0a4c 07D0     		beq	.L75
1114:../src/stm32f30x_rtc.c ****     {
1115:../src/stm32f30x_rtc.c ****       tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
 1607              		.loc 1 1115 0
 1608 0a4e 7B68     		ldr	r3, [r7, #4]
 1609 0a50 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1610 0a52 1846     		mov	r0, r3
 1611 0a54 01F01EF8 		bl	RTC_Bcd2ToByte
 1612 0a58 0346     		mov	r3, r0
 1613 0a5a 7B61     		str	r3, [r7, #20]
 1614 0a5c 03E0     		b	.L76
 1615              	.L75:
1116:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR12(tmpreg));
1117:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
1118:../src/stm32f30x_rtc.c ****     } 
1119:../src/stm32f30x_rtc.c ****     else
1120:../src/stm32f30x_rtc.c ****     {
1121:../src/stm32f30x_rtc.c ****       RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 1616              		.loc 1 1121 0
 1617 0a5e 7B68     		ldr	r3, [r7, #4]
 1618 0a60 4FF00002 		mov	r2, #0
 1619 0a64 DA70     		strb	r2, [r3, #3]
 1620              	.L76:
1122:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
1123:../src/stm32f30x_rtc.c ****     }
1124:../src/stm32f30x_rtc.c ****     
1125:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
1126:../src/stm32f30x_rtc.c ****     assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
1127:../src/stm32f30x_rtc.c ****     
1128:../src/stm32f30x_rtc.c ****     if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
 1621              		.loc 1 1128 0
 1622 0a66 7B68     		ldr	r3, [r7, #4]
 1623 0a68 9B68     		ldr	r3, [r3, #8]
 1624 0a6a 002B     		cmp	r3, #0
 1625 0a6c 07D1     		bne	.L77
1129:../src/stm32f30x_rtc.c ****     {
1130:../src/stm32f30x_rtc.c ****       tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 1626              		.loc 1 1130 0
 1627 0a6e 7B68     		ldr	r3, [r7, #4]
 1628 0a70 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1629 0a72 1846     		mov	r0, r3
 1630 0a74 01F00EF8 		bl	RTC_Bcd2ToByte
 1631 0a78 0346     		mov	r3, r0
 1632 0a7a 7B61     		str	r3, [r7, #20]
 1633 0a7c 06E0     		b	.L74
 1634              	.L77:
1131:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
1132:../src/stm32f30x_rtc.c ****     }
1133:../src/stm32f30x_rtc.c ****     else
1134:../src/stm32f30x_rtc.c ****     {
1135:../src/stm32f30x_rtc.c ****       tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 1635              		.loc 1 1135 0
 1636 0a7e 7B68     		ldr	r3, [r7, #4]
 1637 0a80 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1638 0a82 1846     		mov	r0, r3
 1639 0a84 01F006F8 		bl	RTC_Bcd2ToByte
 1640 0a88 0346     		mov	r3, r0
 1641 0a8a 7B61     		str	r3, [r7, #20]
 1642              	.L74:
1136:../src/stm32f30x_rtc.c ****       assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
1137:../src/stm32f30x_rtc.c ****     }    
1138:../src/stm32f30x_rtc.c ****   }
1139:../src/stm32f30x_rtc.c **** 
1140:../src/stm32f30x_rtc.c ****   /* Check the input parameters format */
1141:../src/stm32f30x_rtc.c ****   if (RTC_Format != RTC_Format_BIN)
 1643              		.loc 1 1141 0
 1644 0a8c FB68     		ldr	r3, [r7, #12]
 1645 0a8e 002B     		cmp	r3, #0
 1646 0a90 1DD0     		beq	.L78
1142:../src/stm32f30x_rtc.c ****   {
1143:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 1647              		.loc 1 1143 0
 1648 0a92 7B68     		ldr	r3, [r7, #4]
 1649 0a94 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1650 0a96 4FEA0342 		lsl	r2, r3, #16
1144:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 1651              		.loc 1 1144 0
 1652 0a9a 7B68     		ldr	r3, [r7, #4]
 1653 0a9c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1654 0a9e 4FEA0323 		lsl	r3, r3, #8
1143:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 1655              		.loc 1 1143 0
 1656 0aa2 1A43     		orrs	r2, r2, r3
1145:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 1657              		.loc 1 1145 0
 1658 0aa4 7B68     		ldr	r3, [r7, #4]
 1659 0aa6 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
1144:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 1660              		.loc 1 1144 0
 1661 0aa8 1A43     		orrs	r2, r2, r3
1146:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 1662              		.loc 1 1146 0
 1663 0aaa 7B68     		ldr	r3, [r7, #4]
 1664 0aac DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1665 0aae 4FEA0343 		lsl	r3, r3, #16
1145:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 1666              		.loc 1 1145 0
 1667 0ab2 1A43     		orrs	r2, r2, r3
1147:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 1668              		.loc 1 1147 0
 1669 0ab4 7B68     		ldr	r3, [r7, #4]
 1670 0ab6 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1671 0ab8 4FEA0363 		lsl	r3, r3, #24
1146:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 1672              		.loc 1 1146 0
 1673 0abc 1A43     		orrs	r2, r2, r3
1148:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 1674              		.loc 1 1148 0
 1675 0abe 7B68     		ldr	r3, [r7, #4]
 1676 0ac0 9B68     		ldr	r3, [r3, #8]
1147:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 1677              		.loc 1 1147 0
 1678 0ac2 1A43     		orrs	r2, r2, r3
1149:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 1679              		.loc 1 1149 0
 1680 0ac4 7B68     		ldr	r3, [r7, #4]
 1681 0ac6 5B68     		ldr	r3, [r3, #4]
1143:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 1682              		.loc 1 1143 0
 1683 0ac8 1343     		orrs	r3, r3, r2
 1684 0aca 7B61     		str	r3, [r7, #20]
 1685 0acc 2FE0     		b	.L79
 1686              	.L78:
1150:../src/stm32f30x_rtc.c ****   }  
1151:../src/stm32f30x_rtc.c ****   else
1152:../src/stm32f30x_rtc.c ****   {
1153:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 1687              		.loc 1 1153 0
 1688 0ace 7B68     		ldr	r3, [r7, #4]
 1689 0ad0 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1690 0ad2 1846     		mov	r0, r3
 1691 0ad4 00F0BCFF 		bl	RTC_ByteToBcd2
 1692 0ad8 0346     		mov	r3, r0
 1693 0ada 4FEA0344 		lsl	r4, r3, #16
1154:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 1694              		.loc 1 1154 0
 1695 0ade 7B68     		ldr	r3, [r7, #4]
 1696 0ae0 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1697 0ae2 1846     		mov	r0, r3
 1698 0ae4 00F0B4FF 		bl	RTC_ByteToBcd2
 1699 0ae8 0346     		mov	r3, r0
 1700 0aea 4FEA0323 		lsl	r3, r3, #8
1153:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 1701              		.loc 1 1153 0
 1702 0aee 1C43     		orrs	r4, r4, r3
1155:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 1703              		.loc 1 1155 0
 1704 0af0 7B68     		ldr	r3, [r7, #4]
 1705 0af2 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1706 0af4 1846     		mov	r0, r3
 1707 0af6 00F0ABFF 		bl	RTC_ByteToBcd2
 1708 0afa 0346     		mov	r3, r0
1154:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 1709              		.loc 1 1154 0
 1710 0afc 44EA0302 		orr	r2, r4, r3
1156:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 1711              		.loc 1 1156 0
 1712 0b00 7B68     		ldr	r3, [r7, #4]
 1713 0b02 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1714 0b04 4FEA0343 		lsl	r3, r3, #16
1155:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 1715              		.loc 1 1155 0
 1716 0b08 42EA0304 		orr	r4, r2, r3
1157:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 1717              		.loc 1 1157 0
 1718 0b0c 7B68     		ldr	r3, [r7, #4]
 1719 0b0e 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1720 0b10 1846     		mov	r0, r3
 1721 0b12 00F09DFF 		bl	RTC_ByteToBcd2
 1722 0b16 0346     		mov	r3, r0
 1723 0b18 4FEA0363 		lsl	r3, r3, #24
1156:../src/stm32f30x_rtc.c ****               ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 1724              		.loc 1 1156 0
 1725 0b1c 44EA0302 		orr	r2, r4, r3
1158:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 1726              		.loc 1 1158 0
 1727 0b20 7B68     		ldr	r3, [r7, #4]
 1728 0b22 9B68     		ldr	r3, [r3, #8]
1157:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 1729              		.loc 1 1157 0
 1730 0b24 1A43     		orrs	r2, r2, r3
1159:../src/stm32f30x_rtc.c ****               ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 1731              		.loc 1 1159 0
 1732 0b26 7B68     		ldr	r3, [r7, #4]
 1733 0b28 5B68     		ldr	r3, [r3, #4]
1153:../src/stm32f30x_rtc.c ****     tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 1734              		.loc 1 1153 0
 1735 0b2a 1343     		orrs	r3, r3, r2
 1736 0b2c 7B61     		str	r3, [r7, #20]
 1737              	.L79:
1160:../src/stm32f30x_rtc.c ****   } 
1161:../src/stm32f30x_rtc.c **** 
1162:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1163:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 1738              		.loc 1 1163 0
 1739 0b2e 4FF42053 		mov	r3, #10240
 1740 0b32 C4F20003 		movt	r3, 16384
 1741 0b36 4FF0CA02 		mov	r2, #202
 1742 0b3a 5A62     		str	r2, [r3, #36]
1164:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 1743              		.loc 1 1164 0
 1744 0b3c 4FF42053 		mov	r3, #10240
 1745 0b40 C4F20003 		movt	r3, 16384
 1746 0b44 4FF05302 		mov	r2, #83
 1747 0b48 5A62     		str	r2, [r3, #36]
1165:../src/stm32f30x_rtc.c **** 
1166:../src/stm32f30x_rtc.c ****   /* Configure the Alarm register */
1167:../src/stm32f30x_rtc.c ****   if (RTC_Alarm == RTC_Alarm_A)
 1748              		.loc 1 1167 0
 1749 0b4a BB68     		ldr	r3, [r7, #8]
 1750 0b4c B3F5807F 		cmp	r3, #256
 1751 0b50 06D1     		bne	.L80
1168:../src/stm32f30x_rtc.c ****   {
1169:../src/stm32f30x_rtc.c ****     RTC->ALRMAR = (uint32_t)tmpreg;
 1752              		.loc 1 1169 0
 1753 0b52 4FF42053 		mov	r3, #10240
 1754 0b56 C4F20003 		movt	r3, 16384
 1755 0b5a 7A69     		ldr	r2, [r7, #20]
 1756 0b5c DA61     		str	r2, [r3, #28]
 1757 0b5e 05E0     		b	.L81
 1758              	.L80:
1170:../src/stm32f30x_rtc.c ****   }
1171:../src/stm32f30x_rtc.c ****   else
1172:../src/stm32f30x_rtc.c ****   {
1173:../src/stm32f30x_rtc.c ****     RTC->ALRMBR = (uint32_t)tmpreg;
 1759              		.loc 1 1173 0
 1760 0b60 4FF42053 		mov	r3, #10240
 1761 0b64 C4F20003 		movt	r3, 16384
 1762 0b68 7A69     		ldr	r2, [r7, #20]
 1763 0b6a 1A62     		str	r2, [r3, #32]
 1764              	.L81:
1174:../src/stm32f30x_rtc.c ****   }
1175:../src/stm32f30x_rtc.c **** 
1176:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1177:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;   
 1765              		.loc 1 1177 0
 1766 0b6c 4FF42053 		mov	r3, #10240
 1767 0b70 C4F20003 		movt	r3, 16384
 1768 0b74 4FF0FF02 		mov	r2, #255
 1769 0b78 5A62     		str	r2, [r3, #36]
1178:../src/stm32f30x_rtc.c **** }
 1770              		.loc 1 1178 0
 1771 0b7a 07F11C07 		add	r7, r7, #28
 1772 0b7e BD46     		mov	sp, r7
 1773 0b80 90BD     		pop	{r4, r7, pc}
 1774              		.cfi_endproc
 1775              	.LFE127:
 1777 0b82 00BF     		.align	2
 1778              		.global	RTC_AlarmStructInit
 1779              		.thumb
 1780              		.thumb_func
 1782              	RTC_AlarmStructInit:
 1783              	.LFB128:
1179:../src/stm32f30x_rtc.c **** 
1180:../src/stm32f30x_rtc.c **** /**
1181:../src/stm32f30x_rtc.c ****   * @brief  Fills each RTC_AlarmStruct member with its default value
1182:../src/stm32f30x_rtc.c ****   *         (Time = 00h:00mn:00sec / Date = 1st day of the month/Mask =
1183:../src/stm32f30x_rtc.c ****   *         all fields are masked).
1184:../src/stm32f30x_rtc.c ****   * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
1185:../src/stm32f30x_rtc.c ****   *         will be initialized.
1186:../src/stm32f30x_rtc.c ****   * @retval None
1187:../src/stm32f30x_rtc.c ****   */
1188:../src/stm32f30x_rtc.c **** void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
1189:../src/stm32f30x_rtc.c **** {
 1784              		.loc 1 1189 0
 1785              		.cfi_startproc
 1786              		@ args = 0, pretend = 0, frame = 8
 1787              		@ frame_needed = 1, uses_anonymous_args = 0
 1788              		@ link register save eliminated.
 1789 0b84 80B4     		push	{r7}
 1790              	.LCFI50:
 1791              		.cfi_def_cfa_offset 4
 1792              		.cfi_offset 7, -4
 1793 0b86 83B0     		sub	sp, sp, #12
 1794              	.LCFI51:
 1795              		.cfi_def_cfa_offset 16
 1796 0b88 00AF     		add	r7, sp, #0
 1797              	.LCFI52:
 1798              		.cfi_def_cfa_register 7
 1799 0b8a 7860     		str	r0, [r7, #4]
1190:../src/stm32f30x_rtc.c ****   /* Alarm Time Settings : Time = 00h:00mn:00sec */
1191:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
 1800              		.loc 1 1191 0
 1801 0b8c 7B68     		ldr	r3, [r7, #4]
 1802 0b8e 4FF00002 		mov	r2, #0
 1803 0b92 DA70     		strb	r2, [r3, #3]
1192:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
 1804              		.loc 1 1192 0
 1805 0b94 7B68     		ldr	r3, [r7, #4]
 1806 0b96 4FF00002 		mov	r2, #0
 1807 0b9a 1A70     		strb	r2, [r3, #0]
1193:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
 1808              		.loc 1 1193 0
 1809 0b9c 7B68     		ldr	r3, [r7, #4]
 1810 0b9e 4FF00002 		mov	r2, #0
 1811 0ba2 5A70     		strb	r2, [r3, #1]
1194:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
 1812              		.loc 1 1194 0
 1813 0ba4 7B68     		ldr	r3, [r7, #4]
 1814 0ba6 4FF00002 		mov	r2, #0
 1815 0baa 9A70     		strb	r2, [r3, #2]
1195:../src/stm32f30x_rtc.c **** 
1196:../src/stm32f30x_rtc.c ****   /* Alarm Date Settings : Date = 1st day of the month */
1197:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
 1816              		.loc 1 1197 0
 1817 0bac 7B68     		ldr	r3, [r7, #4]
 1818 0bae 4FF00002 		mov	r2, #0
 1819 0bb2 9A60     		str	r2, [r3, #8]
1198:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
 1820              		.loc 1 1198 0
 1821 0bb4 7B68     		ldr	r3, [r7, #4]
 1822 0bb6 4FF00102 		mov	r2, #1
 1823 0bba 1A73     		strb	r2, [r3, #12]
1199:../src/stm32f30x_rtc.c **** 
1200:../src/stm32f30x_rtc.c ****   /* Alarm Masks Settings : Mask =  all fields are not masked */
1201:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
 1824              		.loc 1 1201 0
 1825 0bbc 7B68     		ldr	r3, [r7, #4]
 1826 0bbe 4FF00002 		mov	r2, #0
 1827 0bc2 5A60     		str	r2, [r3, #4]
1202:../src/stm32f30x_rtc.c **** }
 1828              		.loc 1 1202 0
 1829 0bc4 07F10C07 		add	r7, r7, #12
 1830 0bc8 BD46     		mov	sp, r7
 1831 0bca 80BC     		pop	{r7}
 1832 0bcc 7047     		bx	lr
 1833              		.cfi_endproc
 1834              	.LFE128:
 1836 0bce 00BF     		.align	2
 1837              		.global	RTC_GetAlarm
 1838              		.thumb
 1839              		.thumb_func
 1841              	RTC_GetAlarm:
 1842              	.LFB129:
1203:../src/stm32f30x_rtc.c **** 
1204:../src/stm32f30x_rtc.c **** /**
1205:../src/stm32f30x_rtc.c ****   * @brief  Get the RTC Alarm value and masks.
1206:../src/stm32f30x_rtc.c ****   * @param  RTC_Format: specifies the format of the output parameters.
1207:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1208:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BIN: Binary data format 
1209:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BCD: BCD data format
1210:../src/stm32f30x_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be read.
1211:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1212:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_A: to select Alarm A
1213:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_B: to select Alarm B  
1214:../src/stm32f30x_rtc.c ****   * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
1215:../src/stm32f30x_rtc.c ****   *                          contains the output alarm configuration values.     
1216:../src/stm32f30x_rtc.c ****   * @retval None
1217:../src/stm32f30x_rtc.c ****   */
1218:../src/stm32f30x_rtc.c **** void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
1219:../src/stm32f30x_rtc.c **** {
 1843              		.loc 1 1219 0
 1844              		.cfi_startproc
 1845              		@ args = 0, pretend = 0, frame = 24
 1846              		@ frame_needed = 1, uses_anonymous_args = 0
 1847 0bd0 80B5     		push	{r7, lr}
 1848              	.LCFI53:
 1849              		.cfi_def_cfa_offset 8
 1850              		.cfi_offset 7, -8
 1851              		.cfi_offset 14, -4
 1852 0bd2 86B0     		sub	sp, sp, #24
 1853              	.LCFI54:
 1854              		.cfi_def_cfa_offset 32
 1855 0bd4 00AF     		add	r7, sp, #0
 1856              	.LCFI55:
 1857              		.cfi_def_cfa_register 7
 1858 0bd6 F860     		str	r0, [r7, #12]
 1859 0bd8 B960     		str	r1, [r7, #8]
 1860 0bda 7A60     		str	r2, [r7, #4]
1220:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 1861              		.loc 1 1220 0
 1862 0bdc 4FF00003 		mov	r3, #0
 1863 0be0 7B61     		str	r3, [r7, #20]
1221:../src/stm32f30x_rtc.c **** 
1222:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1223:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
1224:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_ALARM(RTC_Alarm)); 
1225:../src/stm32f30x_rtc.c **** 
1226:../src/stm32f30x_rtc.c ****   /* Get the RTC_ALRMxR register */
1227:../src/stm32f30x_rtc.c ****   if (RTC_Alarm == RTC_Alarm_A)
 1864              		.loc 1 1227 0
 1865 0be2 BB68     		ldr	r3, [r7, #8]
 1866 0be4 B3F5807F 		cmp	r3, #256
 1867 0be8 06D1     		bne	.L84
1228:../src/stm32f30x_rtc.c ****   {
1229:../src/stm32f30x_rtc.c ****     tmpreg = (uint32_t)(RTC->ALRMAR);
 1868              		.loc 1 1229 0
 1869 0bea 4FF42053 		mov	r3, #10240
 1870 0bee C4F20003 		movt	r3, 16384
 1871 0bf2 DB69     		ldr	r3, [r3, #28]
 1872 0bf4 7B61     		str	r3, [r7, #20]
 1873 0bf6 05E0     		b	.L85
 1874              	.L84:
1230:../src/stm32f30x_rtc.c ****   }
1231:../src/stm32f30x_rtc.c ****   else
1232:../src/stm32f30x_rtc.c ****   {
1233:../src/stm32f30x_rtc.c ****     tmpreg = (uint32_t)(RTC->ALRMBR);
 1875              		.loc 1 1233 0
 1876 0bf8 4FF42053 		mov	r3, #10240
 1877 0bfc C4F20003 		movt	r3, 16384
 1878 0c00 1B6A     		ldr	r3, [r3, #32]
 1879 0c02 7B61     		str	r3, [r7, #20]
 1880              	.L85:
1234:../src/stm32f30x_rtc.c ****   }
1235:../src/stm32f30x_rtc.c **** 
1236:../src/stm32f30x_rtc.c ****   /* Fill the structure with the read parameters */
1237:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
 1881              		.loc 1 1237 0
 1882 0c04 7B69     		ldr	r3, [r7, #20]
 1883 0c06 03F47C13 		and	r3, r3, #4128768
 1884 0c0a 4FEA1343 		lsr	r3, r3, #16
 1885 0c0e DAB2     		uxtb	r2, r3
 1886 0c10 7B68     		ldr	r3, [r7, #4]
 1887 0c12 1A70     		strb	r2, [r3, #0]
1238:../src/stm32f30x_rtc.c ****                                                      RTC_ALRMAR_HU)) >> 16);
1239:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
 1888              		.loc 1 1239 0
 1889 0c14 7B69     		ldr	r3, [r7, #20]
 1890 0c16 03F4FE43 		and	r3, r3, #32512
 1891 0c1a 4FEA1323 		lsr	r3, r3, #8
 1892 0c1e DAB2     		uxtb	r2, r3
 1893 0c20 7B68     		ldr	r3, [r7, #4]
 1894 0c22 5A70     		strb	r2, [r3, #1]
1240:../src/stm32f30x_rtc.c ****                                                      RTC_ALRMAR_MNU)) >> 8);
1241:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
 1895              		.loc 1 1241 0
 1896 0c24 7B69     		ldr	r3, [r7, #20]
 1897 0c26 DBB2     		uxtb	r3, r3
 1898 0c28 03F07F03 		and	r3, r3, #127
 1899 0c2c DAB2     		uxtb	r2, r3
 1900 0c2e 7B68     		ldr	r3, [r7, #4]
 1901 0c30 9A70     		strb	r2, [r3, #2]
1242:../src/stm32f30x_rtc.c ****                                                      RTC_ALRMAR_SU));
1243:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 1902              		.loc 1 1243 0
 1903 0c32 7B69     		ldr	r3, [r7, #20]
 1904 0c34 03F48003 		and	r3, r3, #4194304
 1905 0c38 4FEA1343 		lsr	r3, r3, #16
 1906 0c3c DAB2     		uxtb	r2, r3
 1907 0c3e 7B68     		ldr	r3, [r7, #4]
 1908 0c40 DA70     		strb	r2, [r3, #3]
1244:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 
 1909              		.loc 1 1244 0
 1910 0c42 7B69     		ldr	r3, [r7, #20]
 1911 0c44 03F07C53 		and	r3, r3, #1056964608
 1912 0c48 4FEA1363 		lsr	r3, r3, #24
 1913 0c4c DAB2     		uxtb	r2, r3
 1914 0c4e 7B68     		ldr	r3, [r7, #4]
 1915 0c50 1A73     		strb	r2, [r3, #12]
1245:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 1916              		.loc 1 1245 0
 1917 0c52 7B69     		ldr	r3, [r7, #20]
 1918 0c54 03F08042 		and	r2, r3, #1073741824
 1919 0c58 7B68     		ldr	r3, [r7, #4]
 1920 0c5a 9A60     		str	r2, [r3, #8]
1246:../src/stm32f30x_rtc.c ****   RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
 1921              		.loc 1 1246 0
 1922 0c5c 7B69     		ldr	r3, [r7, #20]
 1923 0c5e 03F08032 		and	r2, r3, #-2139062144
 1924 0c62 7B68     		ldr	r3, [r7, #4]
 1925 0c64 5A60     		str	r2, [r3, #4]
1247:../src/stm32f30x_rtc.c **** 
1248:../src/stm32f30x_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 1926              		.loc 1 1248 0
 1927 0c66 FB68     		ldr	r3, [r7, #12]
 1928 0c68 002B     		cmp	r3, #0
 1929 0c6a 23D1     		bne	.L83
1249:../src/stm32f30x_rtc.c ****   {
1250:../src/stm32f30x_rtc.c ****     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 1930              		.loc 1 1250 0
 1931 0c6c 7B68     		ldr	r3, [r7, #4]
 1932 0c6e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1933 0c70 1846     		mov	r0, r3
 1934 0c72 00F00FFF 		bl	RTC_Bcd2ToByte
 1935 0c76 0346     		mov	r3, r0
 1936 0c78 1A46     		mov	r2, r3
 1937 0c7a 7B68     		ldr	r3, [r7, #4]
 1938 0c7c 1A70     		strb	r2, [r3, #0]
1251:../src/stm32f30x_rtc.c ****                                                         RTC_AlarmTime.RTC_Hours);
1252:../src/stm32f30x_rtc.c ****     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 1939              		.loc 1 1252 0
 1940 0c7e 7B68     		ldr	r3, [r7, #4]
 1941 0c80 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1942 0c82 1846     		mov	r0, r3
 1943 0c84 00F006FF 		bl	RTC_Bcd2ToByte
 1944 0c88 0346     		mov	r3, r0
 1945 0c8a 1A46     		mov	r2, r3
 1946 0c8c 7B68     		ldr	r3, [r7, #4]
 1947 0c8e 5A70     		strb	r2, [r3, #1]
1253:../src/stm32f30x_rtc.c ****                                                         RTC_AlarmTime.RTC_Minutes);
1254:../src/stm32f30x_rtc.c ****     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 1948              		.loc 1 1254 0
 1949 0c90 7B68     		ldr	r3, [r7, #4]
 1950 0c92 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 1951 0c94 1846     		mov	r0, r3
 1952 0c96 00F0FDFE 		bl	RTC_Bcd2ToByte
 1953 0c9a 0346     		mov	r3, r0
 1954 0c9c 1A46     		mov	r2, r3
 1955 0c9e 7B68     		ldr	r3, [r7, #4]
 1956 0ca0 9A70     		strb	r2, [r3, #2]
1255:../src/stm32f30x_rtc.c ****                                                         RTC_AlarmTime.RTC_Seconds);
1256:../src/stm32f30x_rtc.c ****     RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 1957              		.loc 1 1256 0
 1958 0ca2 7B68     		ldr	r3, [r7, #4]
 1959 0ca4 1B7B     		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1960 0ca6 1846     		mov	r0, r3
 1961 0ca8 00F0F4FE 		bl	RTC_Bcd2ToByte
 1962 0cac 0346     		mov	r3, r0
 1963 0cae 1A46     		mov	r2, r3
 1964 0cb0 7B68     		ldr	r3, [r7, #4]
 1965 0cb2 1A73     		strb	r2, [r3, #12]
 1966              	.L83:
1257:../src/stm32f30x_rtc.c ****   }  
1258:../src/stm32f30x_rtc.c **** }
 1967              		.loc 1 1258 0
 1968 0cb4 07F11807 		add	r7, r7, #24
 1969 0cb8 BD46     		mov	sp, r7
 1970 0cba 80BD     		pop	{r7, pc}
 1971              		.cfi_endproc
 1972              	.LFE129:
 1974              		.align	2
 1975              		.global	RTC_AlarmCmd
 1976              		.thumb
 1977              		.thumb_func
 1979              	RTC_AlarmCmd:
 1980              	.LFB130:
1259:../src/stm32f30x_rtc.c **** 
1260:../src/stm32f30x_rtc.c **** /**
1261:../src/stm32f30x_rtc.c ****   * @brief  Enables or disables the specified RTC Alarm.
1262:../src/stm32f30x_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be configured.
1263:../src/stm32f30x_rtc.c ****   *   This parameter can be any combination of the following values:
1264:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_A: to select Alarm A
1265:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_B: to select Alarm B  
1266:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the specified alarm.
1267:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.
1268:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
1269:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC Alarm is enabled/disabled
1270:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC Alarm is not enabled/disabled  
1271:../src/stm32f30x_rtc.c ****   */
1272:../src/stm32f30x_rtc.c **** ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
1273:../src/stm32f30x_rtc.c **** {
 1981              		.loc 1 1273 0
 1982              		.cfi_startproc
 1983              		@ args = 0, pretend = 0, frame = 24
 1984              		@ frame_needed = 1, uses_anonymous_args = 0
 1985              		@ link register save eliminated.
 1986 0cbc 80B4     		push	{r7}
 1987              	.LCFI56:
 1988              		.cfi_def_cfa_offset 4
 1989              		.cfi_offset 7, -4
 1990 0cbe 87B0     		sub	sp, sp, #28
 1991              	.LCFI57:
 1992              		.cfi_def_cfa_offset 32
 1993 0cc0 00AF     		add	r7, sp, #0
 1994              	.LCFI58:
 1995              		.cfi_def_cfa_register 7
 1996 0cc2 7860     		str	r0, [r7, #4]
 1997 0cc4 0B46     		mov	r3, r1
 1998 0cc6 FB70     		strb	r3, [r7, #3]
1274:../src/stm32f30x_rtc.c ****   __IO uint32_t alarmcounter = 0x00;
 1999              		.loc 1 1274 0
 2000 0cc8 4FF00003 		mov	r3, #0
 2001 0ccc FB60     		str	r3, [r7, #12]
1275:../src/stm32f30x_rtc.c ****   uint32_t alarmstatus = 0x00;
 2002              		.loc 1 1275 0
 2003 0cce 4FF00003 		mov	r3, #0
 2004 0cd2 3B61     		str	r3, [r7, #16]
1276:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 2005              		.loc 1 1276 0
 2006 0cd4 4FF00003 		mov	r3, #0
 2007 0cd8 FB75     		strb	r3, [r7, #23]
1277:../src/stm32f30x_rtc.c ****     
1278:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1279:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
1280:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1281:../src/stm32f30x_rtc.c **** 
1282:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1283:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2008              		.loc 1 1283 0
 2009 0cda 4FF42053 		mov	r3, #10240
 2010 0cde C4F20003 		movt	r3, 16384
 2011 0ce2 4FF0CA02 		mov	r2, #202
 2012 0ce6 5A62     		str	r2, [r3, #36]
1284:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2013              		.loc 1 1284 0
 2014 0ce8 4FF42053 		mov	r3, #10240
 2015 0cec C4F20003 		movt	r3, 16384
 2016 0cf0 4FF05302 		mov	r2, #83
 2017 0cf4 5A62     		str	r2, [r3, #36]
1285:../src/stm32f30x_rtc.c **** 
1286:../src/stm32f30x_rtc.c ****   /* Configure the Alarm state */
1287:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 2018              		.loc 1 1287 0
 2019 0cf6 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2020 0cf8 002B     		cmp	r3, #0
 2021 0cfa 0FD0     		beq	.L88
1288:../src/stm32f30x_rtc.c ****   {
1289:../src/stm32f30x_rtc.c ****     RTC->CR |= (uint32_t)RTC_Alarm;
 2022              		.loc 1 1289 0
 2023 0cfc 4FF42053 		mov	r3, #10240
 2024 0d00 C4F20003 		movt	r3, 16384
 2025 0d04 4FF42052 		mov	r2, #10240
 2026 0d08 C4F20002 		movt	r2, 16384
 2027 0d0c 9168     		ldr	r1, [r2, #8]
 2028 0d0e 7A68     		ldr	r2, [r7, #4]
 2029 0d10 0A43     		orrs	r2, r2, r1
 2030 0d12 9A60     		str	r2, [r3, #8]
1290:../src/stm32f30x_rtc.c **** 
1291:../src/stm32f30x_rtc.c ****     status = SUCCESS;    
 2031              		.loc 1 1291 0
 2032 0d14 4FF00103 		mov	r3, #1
 2033 0d18 FB75     		strb	r3, [r7, #23]
 2034 0d1a 34E0     		b	.L89
 2035              	.L88:
1292:../src/stm32f30x_rtc.c ****   }
1293:../src/stm32f30x_rtc.c ****   else
1294:../src/stm32f30x_rtc.c ****   { 
1295:../src/stm32f30x_rtc.c ****     /* Disable the Alarm in RTC_CR register */
1296:../src/stm32f30x_rtc.c ****     RTC->CR &= (uint32_t)~RTC_Alarm;
 2036              		.loc 1 1296 0
 2037 0d1c 4FF42053 		mov	r3, #10240
 2038 0d20 C4F20003 		movt	r3, 16384
 2039 0d24 4FF42052 		mov	r2, #10240
 2040 0d28 C4F20002 		movt	r2, 16384
 2041 0d2c 9168     		ldr	r1, [r2, #8]
 2042 0d2e 7A68     		ldr	r2, [r7, #4]
 2043 0d30 6FEA0202 		mvn	r2, r2
 2044 0d34 0A40     		ands	r2, r2, r1
 2045 0d36 9A60     		str	r2, [r3, #8]
 2046              	.L91:
1297:../src/stm32f30x_rtc.c ****    
1298:../src/stm32f30x_rtc.c ****     /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
1299:../src/stm32f30x_rtc.c ****     do
1300:../src/stm32f30x_rtc.c ****     {
1301:../src/stm32f30x_rtc.c ****       alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
 2047              		.loc 1 1301 0 discriminator 1
 2048 0d38 4FF42053 		mov	r3, #10240
 2049 0d3c C4F20003 		movt	r3, 16384
 2050 0d40 DA68     		ldr	r2, [r3, #12]
 2051 0d42 7B68     		ldr	r3, [r7, #4]
 2052 0d44 4FEA1323 		lsr	r3, r3, #8
 2053 0d48 1340     		ands	r3, r3, r2
 2054 0d4a 3B61     		str	r3, [r7, #16]
1302:../src/stm32f30x_rtc.c ****       alarmcounter++;  
 2055              		.loc 1 1302 0 discriminator 1
 2056 0d4c FB68     		ldr	r3, [r7, #12]
 2057 0d4e 03F10103 		add	r3, r3, #1
 2058 0d52 FB60     		str	r3, [r7, #12]
1303:../src/stm32f30x_rtc.c ****     } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
 2059              		.loc 1 1303 0 discriminator 1
 2060 0d54 FB68     		ldr	r3, [r7, #12]
 2061 0d56 B3F5005F 		cmp	r3, #8192
 2062 0d5a 02D0     		beq	.L90
 2063 0d5c 3B69     		ldr	r3, [r7, #16]
 2064 0d5e 002B     		cmp	r3, #0
 2065 0d60 EAD0     		beq	.L91
 2066              	.L90:
1304:../src/stm32f30x_rtc.c ****     
1305:../src/stm32f30x_rtc.c ****     if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
 2067              		.loc 1 1305 0
 2068 0d62 4FF42053 		mov	r3, #10240
 2069 0d66 C4F20003 		movt	r3, 16384
 2070 0d6a DA68     		ldr	r2, [r3, #12]
 2071 0d6c 7B68     		ldr	r3, [r7, #4]
 2072 0d6e 4FEA1323 		lsr	r3, r3, #8
 2073 0d72 1340     		ands	r3, r3, r2
 2074 0d74 002B     		cmp	r3, #0
 2075 0d76 03D1     		bne	.L92
1306:../src/stm32f30x_rtc.c ****     {
1307:../src/stm32f30x_rtc.c ****       status = ERROR;
 2076              		.loc 1 1307 0
 2077 0d78 4FF00003 		mov	r3, #0
 2078 0d7c FB75     		strb	r3, [r7, #23]
 2079 0d7e 02E0     		b	.L89
 2080              	.L92:
1308:../src/stm32f30x_rtc.c ****     } 
1309:../src/stm32f30x_rtc.c ****     else
1310:../src/stm32f30x_rtc.c ****     {
1311:../src/stm32f30x_rtc.c ****       status = SUCCESS;
 2081              		.loc 1 1311 0
 2082 0d80 4FF00103 		mov	r3, #1
 2083 0d84 FB75     		strb	r3, [r7, #23]
 2084              	.L89:
1312:../src/stm32f30x_rtc.c ****     }        
1313:../src/stm32f30x_rtc.c ****   } 
1314:../src/stm32f30x_rtc.c **** 
1315:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1316:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2085              		.loc 1 1316 0
 2086 0d86 4FF42053 		mov	r3, #10240
 2087 0d8a C4F20003 		movt	r3, 16384
 2088 0d8e 4FF0FF02 		mov	r2, #255
 2089 0d92 5A62     		str	r2, [r3, #36]
1317:../src/stm32f30x_rtc.c ****   
1318:../src/stm32f30x_rtc.c ****   return status;
 2090              		.loc 1 1318 0
 2091 0d94 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1319:../src/stm32f30x_rtc.c **** }
 2092              		.loc 1 1319 0
 2093 0d96 1846     		mov	r0, r3
 2094 0d98 07F11C07 		add	r7, r7, #28
 2095 0d9c BD46     		mov	sp, r7
 2096 0d9e 80BC     		pop	{r7}
 2097 0da0 7047     		bx	lr
 2098              		.cfi_endproc
 2099              	.LFE130:
 2101 0da2 00BF     		.align	2
 2102              		.global	RTC_AlarmSubSecondConfig
 2103              		.thumb
 2104              		.thumb_func
 2106              	RTC_AlarmSubSecondConfig:
 2107              	.LFB131:
1320:../src/stm32f30x_rtc.c **** 
1321:../src/stm32f30x_rtc.c **** /**
1322:../src/stm32f30x_rtc.c ****   * @brief  Configures the RTC AlarmA/B Subseconds value and mask.
1323:../src/stm32f30x_rtc.c ****   * @note   This function is performed only when the Alarm is disabled. 
1324:../src/stm32f30x_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be configured.
1325:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1326:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_A: to select Alarm A
1327:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_B: to select Alarm B
1328:../src/stm32f30x_rtc.c ****   * @param  RTC_AlarmSubSecondValue: specifies the Subseconds value.
1329:../src/stm32f30x_rtc.c ****   *   This parameter can be a value from 0 to 0x00007FFF.
1330:../src/stm32f30x_rtc.c ****   * @param  RTC_AlarmSubSecondMask:  specifies the Subseconds Mask.
1331:../src/stm32f30x_rtc.c ****   *   This parameter can be any combination of the following values:
1332:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_All    : All Alarm SS fields are masked.
1333:../src/stm32f30x_rtc.c ****   *                                          There is no comparison on sub seconds for Alarm.
1334:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_1 : SS[14:1] are don't care in Alarm comparison.
1335:../src/stm32f30x_rtc.c ****   *                                          Only SS[0] is compared
1336:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_2 : SS[14:2] are don't care in Alarm comparison.
1337:../src/stm32f30x_rtc.c ****   *                                          Only SS[1:0] are compared
1338:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_3 : SS[14:3] are don't care in Alarm comparison.
1339:../src/stm32f30x_rtc.c ****   *                                          Only SS[2:0] are compared
1340:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_4 : SS[14:4] are don't care in Alarm comparison.
1341:../src/stm32f30x_rtc.c ****   *                                          Only SS[3:0] are compared
1342:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_5 : SS[14:5] are don't care in Alarm comparison.
1343:../src/stm32f30x_rtc.c ****   *                                          Only SS[4:0] are compared
1344:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_6 : SS[14:6] are don't care in Alarm comparison.
1345:../src/stm32f30x_rtc.c ****   *                                          Only SS[5:0] are compared
1346:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_7 : SS[14:7] are don't care in Alarm comparison.
1347:../src/stm32f30x_rtc.c ****   *                                          Only SS[6:0] are compared
1348:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_8 : SS[14:8] are don't care in Alarm comparison.
1349:../src/stm32f30x_rtc.c ****   *                                          Only SS[7:0] are compared
1350:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_9 : SS[14:9] are don't care in Alarm comparison.
1351:../src/stm32f30x_rtc.c ****   *                                          Only SS[8:0] are compared
1352:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_10: SS[14:10] are don't care in Alarm comparison.
1353:../src/stm32f30x_rtc.c ****   *                                          Only SS[9:0] are compared
1354:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_11: SS[14:11] are don't care in Alarm comparison.
1355:../src/stm32f30x_rtc.c ****   *                                          Only SS[10:0] are compared
1356:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_12: SS[14:12] are don't care in Alarm comparison.
1357:../src/stm32f30x_rtc.c ****   *                                          Only SS[11:0] are compared
1358:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14_13: SS[14:13] are don't care in Alarm comparison.
1359:../src/stm32f30x_rtc.c ****   *                                          Only SS[12:0] are compared
1360:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_SS14   : SS[14] is don't care in Alarm comparison.
1361:../src/stm32f30x_rtc.c ****   *                                          Only SS[13:0] are compared
1362:../src/stm32f30x_rtc.c ****   *     @arg RTC_AlarmSubSecondMask_None   : SS[14:0] are compared and must match
1363:../src/stm32f30x_rtc.c ****   *                                          to activate alarm
1364:../src/stm32f30x_rtc.c ****   * @retval None
1365:../src/stm32f30x_rtc.c ****   */
1366:../src/stm32f30x_rtc.c **** void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_Al
1367:../src/stm32f30x_rtc.c **** {
 2108              		.loc 1 1367 0
 2109              		.cfi_startproc
 2110              		@ args = 0, pretend = 0, frame = 24
 2111              		@ frame_needed = 1, uses_anonymous_args = 0
 2112              		@ link register save eliminated.
 2113 0da4 80B4     		push	{r7}
 2114              	.LCFI59:
 2115              		.cfi_def_cfa_offset 4
 2116              		.cfi_offset 7, -4
 2117 0da6 87B0     		sub	sp, sp, #28
 2118              	.LCFI60:
 2119              		.cfi_def_cfa_offset 32
 2120 0da8 00AF     		add	r7, sp, #0
 2121              	.LCFI61:
 2122              		.cfi_def_cfa_register 7
 2123 0daa F860     		str	r0, [r7, #12]
 2124 0dac B960     		str	r1, [r7, #8]
 2125 0dae 7A60     		str	r2, [r7, #4]
1368:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 2126              		.loc 1 1368 0
 2127 0db0 4FF00003 		mov	r3, #0
 2128 0db4 7B61     		str	r3, [r7, #20]
1369:../src/stm32f30x_rtc.c **** 
1370:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1371:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_ALARM(RTC_Alarm));
1372:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
1373:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
1374:../src/stm32f30x_rtc.c ****   
1375:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1376:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2129              		.loc 1 1376 0
 2130 0db6 4FF42053 		mov	r3, #10240
 2131 0dba C4F20003 		movt	r3, 16384
 2132 0dbe 4FF0CA02 		mov	r2, #202
 2133 0dc2 5A62     		str	r2, [r3, #36]
1377:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2134              		.loc 1 1377 0
 2135 0dc4 4FF42053 		mov	r3, #10240
 2136 0dc8 C4F20003 		movt	r3, 16384
 2137 0dcc 4FF05302 		mov	r2, #83
 2138 0dd0 5A62     		str	r2, [r3, #36]
1378:../src/stm32f30x_rtc.c ****   
1379:../src/stm32f30x_rtc.c ****   /* Configure the Alarm A or Alarm B SubSecond registers */
1380:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
 2139              		.loc 1 1380 0
 2140 0dd2 BA68     		ldr	r2, [r7, #8]
 2141 0dd4 7B68     		ldr	r3, [r7, #4]
 2142 0dd6 1343     		orrs	r3, r3, r2
 2143 0dd8 7B61     		str	r3, [r7, #20]
1381:../src/stm32f30x_rtc.c ****   
1382:../src/stm32f30x_rtc.c ****   if (RTC_Alarm == RTC_Alarm_A)
 2144              		.loc 1 1382 0
 2145 0dda FB68     		ldr	r3, [r7, #12]
 2146 0ddc B3F5807F 		cmp	r3, #256
 2147 0de0 06D1     		bne	.L95
1383:../src/stm32f30x_rtc.c ****   {
1384:../src/stm32f30x_rtc.c ****     /* Configure the AlarmA SubSecond register */
1385:../src/stm32f30x_rtc.c ****     RTC->ALRMASSR = tmpreg;
 2148              		.loc 1 1385 0
 2149 0de2 4FF42053 		mov	r3, #10240
 2150 0de6 C4F20003 		movt	r3, 16384
 2151 0dea 7A69     		ldr	r2, [r7, #20]
 2152 0dec 5A64     		str	r2, [r3, #68]
 2153 0dee 05E0     		b	.L96
 2154              	.L95:
1386:../src/stm32f30x_rtc.c ****   }
1387:../src/stm32f30x_rtc.c ****   else
1388:../src/stm32f30x_rtc.c ****   {
1389:../src/stm32f30x_rtc.c ****     /* Configure the Alarm B SubSecond register */
1390:../src/stm32f30x_rtc.c ****     RTC->ALRMBSSR = tmpreg;
 2155              		.loc 1 1390 0
 2156 0df0 4FF42053 		mov	r3, #10240
 2157 0df4 C4F20003 		movt	r3, 16384
 2158 0df8 7A69     		ldr	r2, [r7, #20]
 2159 0dfa 9A64     		str	r2, [r3, #72]
 2160              	.L96:
1391:../src/stm32f30x_rtc.c ****   }
1392:../src/stm32f30x_rtc.c **** 
1393:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1394:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2161              		.loc 1 1394 0
 2162 0dfc 4FF42053 		mov	r3, #10240
 2163 0e00 C4F20003 		movt	r3, 16384
 2164 0e04 4FF0FF02 		mov	r2, #255
 2165 0e08 5A62     		str	r2, [r3, #36]
1395:../src/stm32f30x_rtc.c **** 
1396:../src/stm32f30x_rtc.c **** }
 2166              		.loc 1 1396 0
 2167 0e0a 07F11C07 		add	r7, r7, #28
 2168 0e0e BD46     		mov	sp, r7
 2169 0e10 80BC     		pop	{r7}
 2170 0e12 7047     		bx	lr
 2171              		.cfi_endproc
 2172              	.LFE131:
 2174              		.align	2
 2175              		.global	RTC_GetAlarmSubSecond
 2176              		.thumb
 2177              		.thumb_func
 2179              	RTC_GetAlarmSubSecond:
 2180              	.LFB132:
1397:../src/stm32f30x_rtc.c **** 
1398:../src/stm32f30x_rtc.c **** /**
1399:../src/stm32f30x_rtc.c ****   * @brief  Gets the RTC Alarm Subseconds value.
1400:../src/stm32f30x_rtc.c ****   * @param  RTC_Alarm: specifies the alarm to be read.
1401:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1402:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_A: to select Alarm A
1403:../src/stm32f30x_rtc.c ****   *     @arg RTC_Alarm_B: to select Alarm B
1404:../src/stm32f30x_rtc.c ****   * @param  None
1405:../src/stm32f30x_rtc.c ****   * @retval RTC Alarm Subseconds value.
1406:../src/stm32f30x_rtc.c ****   */
1407:../src/stm32f30x_rtc.c **** uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
1408:../src/stm32f30x_rtc.c **** {
 2181              		.loc 1 1408 0
 2182              		.cfi_startproc
 2183              		@ args = 0, pretend = 0, frame = 16
 2184              		@ frame_needed = 1, uses_anonymous_args = 0
 2185              		@ link register save eliminated.
 2186 0e14 80B4     		push	{r7}
 2187              	.LCFI62:
 2188              		.cfi_def_cfa_offset 4
 2189              		.cfi_offset 7, -4
 2190 0e16 85B0     		sub	sp, sp, #20
 2191              	.LCFI63:
 2192              		.cfi_def_cfa_offset 24
 2193 0e18 00AF     		add	r7, sp, #0
 2194              	.LCFI64:
 2195              		.cfi_def_cfa_register 7
 2196 0e1a 7860     		str	r0, [r7, #4]
1409:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 2197              		.loc 1 1409 0
 2198 0e1c 4FF00003 		mov	r3, #0
 2199 0e20 FB60     		str	r3, [r7, #12]
1410:../src/stm32f30x_rtc.c ****   
1411:../src/stm32f30x_rtc.c ****   /* Get the RTC_ALRMxR register */
1412:../src/stm32f30x_rtc.c ****   if (RTC_Alarm == RTC_Alarm_A)
 2200              		.loc 1 1412 0
 2201 0e22 7B68     		ldr	r3, [r7, #4]
 2202 0e24 B3F5807F 		cmp	r3, #256
 2203 0e28 0AD1     		bne	.L98
1413:../src/stm32f30x_rtc.c ****   {
1414:../src/stm32f30x_rtc.c ****     tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
 2204              		.loc 1 1414 0
 2205 0e2a 4FF42053 		mov	r3, #10240
 2206 0e2e C4F20003 		movt	r3, 16384
 2207 0e32 5B6C     		ldr	r3, [r3, #68]
 2208 0e34 4FEA4343 		lsl	r3, r3, #17
 2209 0e38 4FEA5343 		lsr	r3, r3, #17
 2210 0e3c FB60     		str	r3, [r7, #12]
 2211 0e3e 09E0     		b	.L99
 2212              	.L98:
1415:../src/stm32f30x_rtc.c ****   }
1416:../src/stm32f30x_rtc.c ****   else
1417:../src/stm32f30x_rtc.c ****   {
1418:../src/stm32f30x_rtc.c ****     tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
 2213              		.loc 1 1418 0
 2214 0e40 4FF42053 		mov	r3, #10240
 2215 0e44 C4F20003 		movt	r3, 16384
 2216 0e48 9B6C     		ldr	r3, [r3, #72]
 2217 0e4a 4FEA4343 		lsl	r3, r3, #17
 2218 0e4e 4FEA5343 		lsr	r3, r3, #17
 2219 0e52 FB60     		str	r3, [r7, #12]
 2220              	.L99:
1419:../src/stm32f30x_rtc.c ****   } 
1420:../src/stm32f30x_rtc.c ****   
1421:../src/stm32f30x_rtc.c ****   return (tmpreg);
 2221              		.loc 1 1421 0
 2222 0e54 FB68     		ldr	r3, [r7, #12]
1422:../src/stm32f30x_rtc.c **** }
 2223              		.loc 1 1422 0
 2224 0e56 1846     		mov	r0, r3
 2225 0e58 07F11407 		add	r7, r7, #20
 2226 0e5c BD46     		mov	sp, r7
 2227 0e5e 80BC     		pop	{r7}
 2228 0e60 7047     		bx	lr
 2229              		.cfi_endproc
 2230              	.LFE132:
 2232 0e62 00BF     		.align	2
 2233              		.global	RTC_WakeUpClockConfig
 2234              		.thumb
 2235              		.thumb_func
 2237              	RTC_WakeUpClockConfig:
 2238              	.LFB133:
1423:../src/stm32f30x_rtc.c **** 
1424:../src/stm32f30x_rtc.c **** /**
1425:../src/stm32f30x_rtc.c ****   * @}
1426:../src/stm32f30x_rtc.c ****   */
1427:../src/stm32f30x_rtc.c **** 
1428:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group4 WakeUp Timer configuration functions
1429:../src/stm32f30x_rtc.c ****  *  @brief   WakeUp Timer configuration functions 
1430:../src/stm32f30x_rtc.c ****  *
1431:../src/stm32f30x_rtc.c **** @verbatim   
1432:../src/stm32f30x_rtc.c ****  ===============================================================================
1433:../src/stm32f30x_rtc.c ****                 ##### WakeUp Timer configuration functions #####
1434:../src/stm32f30x_rtc.c ****  ===============================================================================  
1435:../src/stm32f30x_rtc.c ****     [..] This section provide functions allowing to program and read the RTC WakeUp.
1436:../src/stm32f30x_rtc.c **** 
1437:../src/stm32f30x_rtc.c **** @endverbatim
1438:../src/stm32f30x_rtc.c ****   * @{
1439:../src/stm32f30x_rtc.c ****   */
1440:../src/stm32f30x_rtc.c **** 
1441:../src/stm32f30x_rtc.c **** /**
1442:../src/stm32f30x_rtc.c ****   * @brief  Configures the RTC Wakeup clock source.
1443:../src/stm32f30x_rtc.c ****   * @note   The WakeUp Clock source can only be changed when the RTC WakeUp
1444:../src/stm32f30x_rtc.c ****   *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).
1445:../src/stm32f30x_rtc.c ****   * @param  RTC_WakeUpClock: Wakeup Clock source.
1446:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1447:../src/stm32f30x_rtc.c ****   *     @arg RTC_WakeUpClock_RTCCLK_Div16: RTC Wakeup Counter Clock = RTCCLK/16
1448:../src/stm32f30x_rtc.c ****   *     @arg RTC_WakeUpClock_RTCCLK_Div8: RTC Wakeup Counter Clock = RTCCLK/8
1449:../src/stm32f30x_rtc.c ****   *     @arg RTC_WakeUpClock_RTCCLK_Div4: RTC Wakeup Counter Clock = RTCCLK/4
1450:../src/stm32f30x_rtc.c ****   *     @arg RTC_WakeUpClock_RTCCLK_Div2: RTC Wakeup Counter Clock = RTCCLK/2
1451:../src/stm32f30x_rtc.c ****   *     @arg RTC_WakeUpClock_CK_SPRE_16bits: RTC Wakeup Counter Clock = CK_SPRE
1452:../src/stm32f30x_rtc.c ****   *     @arg RTC_WakeUpClock_CK_SPRE_17bits: RTC Wakeup Counter Clock = CK_SPRE
1453:../src/stm32f30x_rtc.c ****   * @retval None
1454:../src/stm32f30x_rtc.c ****   */
1455:../src/stm32f30x_rtc.c **** void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
1456:../src/stm32f30x_rtc.c **** {
 2239              		.loc 1 1456 0
 2240              		.cfi_startproc
 2241              		@ args = 0, pretend = 0, frame = 8
 2242              		@ frame_needed = 1, uses_anonymous_args = 0
 2243              		@ link register save eliminated.
 2244 0e64 80B4     		push	{r7}
 2245              	.LCFI65:
 2246              		.cfi_def_cfa_offset 4
 2247              		.cfi_offset 7, -4
 2248 0e66 83B0     		sub	sp, sp, #12
 2249              	.LCFI66:
 2250              		.cfi_def_cfa_offset 16
 2251 0e68 00AF     		add	r7, sp, #0
 2252              	.LCFI67:
 2253              		.cfi_def_cfa_register 7
 2254 0e6a 7860     		str	r0, [r7, #4]
1457:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1458:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
1459:../src/stm32f30x_rtc.c **** 
1460:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1461:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2255              		.loc 1 1461 0
 2256 0e6c 4FF42053 		mov	r3, #10240
 2257 0e70 C4F20003 		movt	r3, 16384
 2258 0e74 4FF0CA02 		mov	r2, #202
 2259 0e78 5A62     		str	r2, [r3, #36]
1462:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2260              		.loc 1 1462 0
 2261 0e7a 4FF42053 		mov	r3, #10240
 2262 0e7e C4F20003 		movt	r3, 16384
 2263 0e82 4FF05302 		mov	r2, #83
 2264 0e86 5A62     		str	r2, [r3, #36]
1463:../src/stm32f30x_rtc.c **** 
1464:../src/stm32f30x_rtc.c ****   /* Clear the Wakeup Timer clock source bits in CR register */
1465:../src/stm32f30x_rtc.c ****   RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 2265              		.loc 1 1465 0
 2266 0e88 4FF42053 		mov	r3, #10240
 2267 0e8c C4F20003 		movt	r3, 16384
 2268 0e90 4FF42052 		mov	r2, #10240
 2269 0e94 C4F20002 		movt	r2, 16384
 2270 0e98 9268     		ldr	r2, [r2, #8]
 2271 0e9a 22F00702 		bic	r2, r2, #7
 2272 0e9e 9A60     		str	r2, [r3, #8]
1466:../src/stm32f30x_rtc.c **** 
1467:../src/stm32f30x_rtc.c ****   /* Configure the clock source */
1468:../src/stm32f30x_rtc.c ****   RTC->CR |= (uint32_t)RTC_WakeUpClock;
 2273              		.loc 1 1468 0
 2274 0ea0 4FF42053 		mov	r3, #10240
 2275 0ea4 C4F20003 		movt	r3, 16384
 2276 0ea8 4FF42052 		mov	r2, #10240
 2277 0eac C4F20002 		movt	r2, 16384
 2278 0eb0 9168     		ldr	r1, [r2, #8]
 2279 0eb2 7A68     		ldr	r2, [r7, #4]
 2280 0eb4 0A43     		orrs	r2, r2, r1
 2281 0eb6 9A60     		str	r2, [r3, #8]
1469:../src/stm32f30x_rtc.c ****   
1470:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1471:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2282              		.loc 1 1471 0
 2283 0eb8 4FF42053 		mov	r3, #10240
 2284 0ebc C4F20003 		movt	r3, 16384
 2285 0ec0 4FF0FF02 		mov	r2, #255
 2286 0ec4 5A62     		str	r2, [r3, #36]
1472:../src/stm32f30x_rtc.c **** }
 2287              		.loc 1 1472 0
 2288 0ec6 07F10C07 		add	r7, r7, #12
 2289 0eca BD46     		mov	sp, r7
 2290 0ecc 80BC     		pop	{r7}
 2291 0ece 7047     		bx	lr
 2292              		.cfi_endproc
 2293              	.LFE133:
 2295              		.align	2
 2296              		.global	RTC_SetWakeUpCounter
 2297              		.thumb
 2298              		.thumb_func
 2300              	RTC_SetWakeUpCounter:
 2301              	.LFB134:
1473:../src/stm32f30x_rtc.c **** 
1474:../src/stm32f30x_rtc.c **** /**
1475:../src/stm32f30x_rtc.c ****   * @brief  Configures the RTC Wakeup counter.
1476:../src/stm32f30x_rtc.c ****   * @note   The RTC WakeUp counter can only be written when the RTC WakeUp
1477:../src/stm32f30x_rtc.c ****   *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).
1478:../src/stm32f30x_rtc.c ****   * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
1479:../src/stm32f30x_rtc.c ****   *   This parameter can be a value from 0x0000 to 0xFFFF. 
1480:../src/stm32f30x_rtc.c ****   * @retval None
1481:../src/stm32f30x_rtc.c ****   */
1482:../src/stm32f30x_rtc.c **** void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
1483:../src/stm32f30x_rtc.c **** {
 2302              		.loc 1 1483 0
 2303              		.cfi_startproc
 2304              		@ args = 0, pretend = 0, frame = 8
 2305              		@ frame_needed = 1, uses_anonymous_args = 0
 2306              		@ link register save eliminated.
 2307 0ed0 80B4     		push	{r7}
 2308              	.LCFI68:
 2309              		.cfi_def_cfa_offset 4
 2310              		.cfi_offset 7, -4
 2311 0ed2 83B0     		sub	sp, sp, #12
 2312              	.LCFI69:
 2313              		.cfi_def_cfa_offset 16
 2314 0ed4 00AF     		add	r7, sp, #0
 2315              	.LCFI70:
 2316              		.cfi_def_cfa_register 7
 2317 0ed6 7860     		str	r0, [r7, #4]
1484:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1485:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
1486:../src/stm32f30x_rtc.c ****   
1487:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1488:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2318              		.loc 1 1488 0
 2319 0ed8 4FF42053 		mov	r3, #10240
 2320 0edc C4F20003 		movt	r3, 16384
 2321 0ee0 4FF0CA02 		mov	r2, #202
 2322 0ee4 5A62     		str	r2, [r3, #36]
1489:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2323              		.loc 1 1489 0
 2324 0ee6 4FF42053 		mov	r3, #10240
 2325 0eea C4F20003 		movt	r3, 16384
 2326 0eee 4FF05302 		mov	r2, #83
 2327 0ef2 5A62     		str	r2, [r3, #36]
1490:../src/stm32f30x_rtc.c ****   
1491:../src/stm32f30x_rtc.c ****   /* Configure the Wakeup Timer counter */
1492:../src/stm32f30x_rtc.c ****   RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
 2328              		.loc 1 1492 0
 2329 0ef4 4FF42053 		mov	r3, #10240
 2330 0ef8 C4F20003 		movt	r3, 16384
 2331 0efc 7A68     		ldr	r2, [r7, #4]
 2332 0efe 5A61     		str	r2, [r3, #20]
1493:../src/stm32f30x_rtc.c ****   
1494:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1495:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2333              		.loc 1 1495 0
 2334 0f00 4FF42053 		mov	r3, #10240
 2335 0f04 C4F20003 		movt	r3, 16384
 2336 0f08 4FF0FF02 		mov	r2, #255
 2337 0f0c 5A62     		str	r2, [r3, #36]
1496:../src/stm32f30x_rtc.c **** }
 2338              		.loc 1 1496 0
 2339 0f0e 07F10C07 		add	r7, r7, #12
 2340 0f12 BD46     		mov	sp, r7
 2341 0f14 80BC     		pop	{r7}
 2342 0f16 7047     		bx	lr
 2343              		.cfi_endproc
 2344              	.LFE134:
 2346              		.align	2
 2347              		.global	RTC_GetWakeUpCounter
 2348              		.thumb
 2349              		.thumb_func
 2351              	RTC_GetWakeUpCounter:
 2352              	.LFB135:
1497:../src/stm32f30x_rtc.c **** 
1498:../src/stm32f30x_rtc.c **** /**
1499:../src/stm32f30x_rtc.c ****   * @brief  Returns the RTC WakeUp timer counter value.
1500:../src/stm32f30x_rtc.c ****   * @param  None
1501:../src/stm32f30x_rtc.c ****   * @retval The RTC WakeUp Counter value.
1502:../src/stm32f30x_rtc.c ****   */
1503:../src/stm32f30x_rtc.c **** uint32_t RTC_GetWakeUpCounter(void)
1504:../src/stm32f30x_rtc.c **** {
 2353              		.loc 1 1504 0
 2354              		.cfi_startproc
 2355              		@ args = 0, pretend = 0, frame = 0
 2356              		@ frame_needed = 1, uses_anonymous_args = 0
 2357              		@ link register save eliminated.
 2358 0f18 80B4     		push	{r7}
 2359              	.LCFI71:
 2360              		.cfi_def_cfa_offset 4
 2361              		.cfi_offset 7, -4
 2362 0f1a 00AF     		add	r7, sp, #0
 2363              	.LCFI72:
 2364              		.cfi_def_cfa_register 7
1505:../src/stm32f30x_rtc.c ****   /* Get the counter value */
1506:../src/stm32f30x_rtc.c ****   return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
 2365              		.loc 1 1506 0
 2366 0f1c 4FF42053 		mov	r3, #10240
 2367 0f20 C4F20003 		movt	r3, 16384
 2368 0f24 5B69     		ldr	r3, [r3, #20]
 2369 0f26 4FEA0343 		lsl	r3, r3, #16
 2370 0f2a 4FEA1343 		lsr	r3, r3, #16
1507:../src/stm32f30x_rtc.c **** }
 2371              		.loc 1 1507 0
 2372 0f2e 1846     		mov	r0, r3
 2373 0f30 BD46     		mov	sp, r7
 2374 0f32 80BC     		pop	{r7}
 2375 0f34 7047     		bx	lr
 2376              		.cfi_endproc
 2377              	.LFE135:
 2379 0f36 00BF     		.align	2
 2380              		.global	RTC_WakeUpCmd
 2381              		.thumb
 2382              		.thumb_func
 2384              	RTC_WakeUpCmd:
 2385              	.LFB136:
1508:../src/stm32f30x_rtc.c **** 
1509:../src/stm32f30x_rtc.c **** /**
1510:../src/stm32f30x_rtc.c ****   * @brief  Enables or Disables the RTC WakeUp timer.
1511:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the WakeUp timer.
1512:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.
1513:../src/stm32f30x_rtc.c ****   * @retval None
1514:../src/stm32f30x_rtc.c ****   */
1515:../src/stm32f30x_rtc.c **** ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
1516:../src/stm32f30x_rtc.c **** {
 2386              		.loc 1 1516 0
 2387              		.cfi_startproc
 2388              		@ args = 0, pretend = 0, frame = 24
 2389              		@ frame_needed = 1, uses_anonymous_args = 0
 2390              		@ link register save eliminated.
 2391 0f38 80B4     		push	{r7}
 2392              	.LCFI73:
 2393              		.cfi_def_cfa_offset 4
 2394              		.cfi_offset 7, -4
 2395 0f3a 87B0     		sub	sp, sp, #28
 2396              	.LCFI74:
 2397              		.cfi_def_cfa_offset 32
 2398 0f3c 00AF     		add	r7, sp, #0
 2399              	.LCFI75:
 2400              		.cfi_def_cfa_register 7
 2401 0f3e 0346     		mov	r3, r0
 2402 0f40 FB71     		strb	r3, [r7, #7]
1517:../src/stm32f30x_rtc.c ****   __IO uint32_t wutcounter = 0x00;
 2403              		.loc 1 1517 0
 2404 0f42 4FF00003 		mov	r3, #0
 2405 0f46 FB60     		str	r3, [r7, #12]
1518:../src/stm32f30x_rtc.c ****   uint32_t wutwfstatus = 0x00;
 2406              		.loc 1 1518 0
 2407 0f48 4FF00003 		mov	r3, #0
 2408 0f4c 3B61     		str	r3, [r7, #16]
1519:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 2409              		.loc 1 1519 0
 2410 0f4e 4FF00003 		mov	r3, #0
 2411 0f52 FB75     		strb	r3, [r7, #23]
1520:../src/stm32f30x_rtc.c ****   
1521:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1522:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1523:../src/stm32f30x_rtc.c **** 
1524:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1525:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2412              		.loc 1 1525 0
 2413 0f54 4FF42053 		mov	r3, #10240
 2414 0f58 C4F20003 		movt	r3, 16384
 2415 0f5c 4FF0CA02 		mov	r2, #202
 2416 0f60 5A62     		str	r2, [r3, #36]
1526:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2417              		.loc 1 1526 0
 2418 0f62 4FF42053 		mov	r3, #10240
 2419 0f66 C4F20003 		movt	r3, 16384
 2420 0f6a 4FF05302 		mov	r2, #83
 2421 0f6e 5A62     		str	r2, [r3, #36]
1527:../src/stm32f30x_rtc.c **** 
1528:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 2422              		.loc 1 1528 0
 2423 0f70 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2424 0f72 002B     		cmp	r3, #0
 2425 0f74 0FD0     		beq	.L106
1529:../src/stm32f30x_rtc.c ****   {
1530:../src/stm32f30x_rtc.c ****     /* Enable the Wakeup Timer */
1531:../src/stm32f30x_rtc.c ****     RTC->CR |= (uint32_t)RTC_CR_WUTE;
 2426              		.loc 1 1531 0
 2427 0f76 4FF42053 		mov	r3, #10240
 2428 0f7a C4F20003 		movt	r3, 16384
 2429 0f7e 4FF42052 		mov	r2, #10240
 2430 0f82 C4F20002 		movt	r2, 16384
 2431 0f86 9268     		ldr	r2, [r2, #8]
 2432 0f88 42F48062 		orr	r2, r2, #1024
 2433 0f8c 9A60     		str	r2, [r3, #8]
1532:../src/stm32f30x_rtc.c ****     status = SUCCESS;    
 2434              		.loc 1 1532 0
 2435 0f8e 4FF00103 		mov	r3, #1
 2436 0f92 FB75     		strb	r3, [r7, #23]
 2437 0f94 2EE0     		b	.L107
 2438              	.L106:
1533:../src/stm32f30x_rtc.c ****   }
1534:../src/stm32f30x_rtc.c ****   else
1535:../src/stm32f30x_rtc.c ****   {
1536:../src/stm32f30x_rtc.c ****     /* Disable the Wakeup Timer */
1537:../src/stm32f30x_rtc.c ****     RTC->CR &= (uint32_t)~RTC_CR_WUTE;
 2439              		.loc 1 1537 0
 2440 0f96 4FF42053 		mov	r3, #10240
 2441 0f9a C4F20003 		movt	r3, 16384
 2442 0f9e 4FF42052 		mov	r2, #10240
 2443 0fa2 C4F20002 		movt	r2, 16384
 2444 0fa6 9268     		ldr	r2, [r2, #8]
 2445 0fa8 22F48062 		bic	r2, r2, #1024
 2446 0fac 9A60     		str	r2, [r3, #8]
 2447              	.L109:
1538:../src/stm32f30x_rtc.c ****     /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
1539:../src/stm32f30x_rtc.c ****     do
1540:../src/stm32f30x_rtc.c ****     {
1541:../src/stm32f30x_rtc.c ****       wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 2448              		.loc 1 1541 0 discriminator 1
 2449 0fae 4FF42053 		mov	r3, #10240
 2450 0fb2 C4F20003 		movt	r3, 16384
 2451 0fb6 DB68     		ldr	r3, [r3, #12]
 2452 0fb8 03F00403 		and	r3, r3, #4
 2453 0fbc 3B61     		str	r3, [r7, #16]
1542:../src/stm32f30x_rtc.c ****       wutcounter++;  
 2454              		.loc 1 1542 0 discriminator 1
 2455 0fbe FB68     		ldr	r3, [r7, #12]
 2456 0fc0 03F10103 		add	r3, r3, #1
 2457 0fc4 FB60     		str	r3, [r7, #12]
1543:../src/stm32f30x_rtc.c ****     } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 2458              		.loc 1 1543 0 discriminator 1
 2459 0fc6 FB68     		ldr	r3, [r7, #12]
 2460 0fc8 B3F5005F 		cmp	r3, #8192
 2461 0fcc 02D0     		beq	.L108
 2462 0fce 3B69     		ldr	r3, [r7, #16]
 2463 0fd0 002B     		cmp	r3, #0
 2464 0fd2 ECD0     		beq	.L109
 2465              	.L108:
1544:../src/stm32f30x_rtc.c ****     
1545:../src/stm32f30x_rtc.c ****     if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 2466              		.loc 1 1545 0
 2467 0fd4 4FF42053 		mov	r3, #10240
 2468 0fd8 C4F20003 		movt	r3, 16384
 2469 0fdc DB68     		ldr	r3, [r3, #12]
 2470 0fde 03F00403 		and	r3, r3, #4
 2471 0fe2 002B     		cmp	r3, #0
 2472 0fe4 03D1     		bne	.L110
1546:../src/stm32f30x_rtc.c ****     {
1547:../src/stm32f30x_rtc.c ****       status = ERROR;
 2473              		.loc 1 1547 0
 2474 0fe6 4FF00003 		mov	r3, #0
 2475 0fea FB75     		strb	r3, [r7, #23]
 2476 0fec 02E0     		b	.L107
 2477              	.L110:
1548:../src/stm32f30x_rtc.c ****     }
1549:../src/stm32f30x_rtc.c ****     else
1550:../src/stm32f30x_rtc.c ****     {
1551:../src/stm32f30x_rtc.c ****       status = SUCCESS;
 2478              		.loc 1 1551 0
 2479 0fee 4FF00103 		mov	r3, #1
 2480 0ff2 FB75     		strb	r3, [r7, #23]
 2481              	.L107:
1552:../src/stm32f30x_rtc.c ****     }    
1553:../src/stm32f30x_rtc.c ****   }
1554:../src/stm32f30x_rtc.c **** 
1555:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1556:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2482              		.loc 1 1556 0
 2483 0ff4 4FF42053 		mov	r3, #10240
 2484 0ff8 C4F20003 		movt	r3, 16384
 2485 0ffc 4FF0FF02 		mov	r2, #255
 2486 1000 5A62     		str	r2, [r3, #36]
1557:../src/stm32f30x_rtc.c ****   
1558:../src/stm32f30x_rtc.c ****   return status;
 2487              		.loc 1 1558 0
 2488 1002 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1559:../src/stm32f30x_rtc.c **** }
 2489              		.loc 1 1559 0
 2490 1004 1846     		mov	r0, r3
 2491 1006 07F11C07 		add	r7, r7, #28
 2492 100a BD46     		mov	sp, r7
 2493 100c 80BC     		pop	{r7}
 2494 100e 7047     		bx	lr
 2495              		.cfi_endproc
 2496              	.LFE136:
 2498              		.align	2
 2499              		.global	RTC_DayLightSavingConfig
 2500              		.thumb
 2501              		.thumb_func
 2503              	RTC_DayLightSavingConfig:
 2504              	.LFB137:
1560:../src/stm32f30x_rtc.c **** 
1561:../src/stm32f30x_rtc.c **** /**
1562:../src/stm32f30x_rtc.c ****   * @}
1563:../src/stm32f30x_rtc.c ****   */
1564:../src/stm32f30x_rtc.c **** 
1565:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group5 Daylight Saving configuration functions
1566:../src/stm32f30x_rtc.c ****  *  @brief   Daylight Saving configuration functions 
1567:../src/stm32f30x_rtc.c ****  *
1568:../src/stm32f30x_rtc.c **** @verbatim   
1569:../src/stm32f30x_rtc.c ****  ===============================================================================
1570:../src/stm32f30x_rtc.c ****                 ##### Daylight Saving configuration functions #####
1571:../src/stm32f30x_rtc.c ****  ===============================================================================  
1572:../src/stm32f30x_rtc.c ****     [..] This section provide functions allowing to configure the RTC DayLight Saving.
1573:../src/stm32f30x_rtc.c **** 
1574:../src/stm32f30x_rtc.c **** @endverbatim
1575:../src/stm32f30x_rtc.c ****   * @{
1576:../src/stm32f30x_rtc.c ****   */
1577:../src/stm32f30x_rtc.c **** 
1578:../src/stm32f30x_rtc.c **** /**
1579:../src/stm32f30x_rtc.c ****   * @brief  Adds or substract one hour from the current time.
1580:../src/stm32f30x_rtc.c ****   * @param  RTC_DayLightSaveOperation: the value of hour adjustment. 
1581:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1582:../src/stm32f30x_rtc.c ****   *     @arg RTC_DayLightSaving_SUB1H: Substract one hour (winter time)
1583:../src/stm32f30x_rtc.c ****   *     @arg RTC_DayLightSaving_ADD1H: Add one hour (summer time)
1584:../src/stm32f30x_rtc.c ****   * @param  RTC_StoreOperation: Specifies the value to be written in the BCK bit 
1585:../src/stm32f30x_rtc.c ****   *                            in CR register to store the operation.
1586:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1587:../src/stm32f30x_rtc.c ****   *     @arg RTC_StoreOperation_Reset: BCK Bit Reset
1588:../src/stm32f30x_rtc.c ****   *     @arg RTC_StoreOperation_Set: BCK Bit Set
1589:../src/stm32f30x_rtc.c ****   * @retval None
1590:../src/stm32f30x_rtc.c ****   */
1591:../src/stm32f30x_rtc.c **** void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
1592:../src/stm32f30x_rtc.c **** {
 2505              		.loc 1 1592 0
 2506              		.cfi_startproc
 2507              		@ args = 0, pretend = 0, frame = 8
 2508              		@ frame_needed = 1, uses_anonymous_args = 0
 2509              		@ link register save eliminated.
 2510 1010 80B4     		push	{r7}
 2511              	.LCFI76:
 2512              		.cfi_def_cfa_offset 4
 2513              		.cfi_offset 7, -4
 2514 1012 83B0     		sub	sp, sp, #12
 2515              	.LCFI77:
 2516              		.cfi_def_cfa_offset 16
 2517 1014 00AF     		add	r7, sp, #0
 2518              	.LCFI78:
 2519              		.cfi_def_cfa_register 7
 2520 1016 7860     		str	r0, [r7, #4]
 2521 1018 3960     		str	r1, [r7, #0]
1593:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1594:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
1595:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
1596:../src/stm32f30x_rtc.c **** 
1597:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1598:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2522              		.loc 1 1598 0
 2523 101a 4FF42053 		mov	r3, #10240
 2524 101e C4F20003 		movt	r3, 16384
 2525 1022 4FF0CA02 		mov	r2, #202
 2526 1026 5A62     		str	r2, [r3, #36]
1599:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2527              		.loc 1 1599 0
 2528 1028 4FF42053 		mov	r3, #10240
 2529 102c C4F20003 		movt	r3, 16384
 2530 1030 4FF05302 		mov	r2, #83
 2531 1034 5A62     		str	r2, [r3, #36]
1600:../src/stm32f30x_rtc.c **** 
1601:../src/stm32f30x_rtc.c ****   /* Clear the bits to be configured */
1602:../src/stm32f30x_rtc.c ****   RTC->CR &= (uint32_t)~(RTC_CR_BCK);
 2532              		.loc 1 1602 0
 2533 1036 4FF42053 		mov	r3, #10240
 2534 103a C4F20003 		movt	r3, 16384
 2535 103e 4FF42052 		mov	r2, #10240
 2536 1042 C4F20002 		movt	r2, 16384
 2537 1046 9268     		ldr	r2, [r2, #8]
 2538 1048 22F48022 		bic	r2, r2, #262144
 2539 104c 9A60     		str	r2, [r3, #8]
1603:../src/stm32f30x_rtc.c **** 
1604:../src/stm32f30x_rtc.c ****   /* Configure the RTC_CR register */
1605:../src/stm32f30x_rtc.c ****   RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
 2540              		.loc 1 1605 0
 2541 104e 4FF42053 		mov	r3, #10240
 2542 1052 C4F20003 		movt	r3, 16384
 2543 1056 4FF42052 		mov	r2, #10240
 2544 105a C4F20002 		movt	r2, 16384
 2545 105e 9168     		ldr	r1, [r2, #8]
 2546 1060 7868     		ldr	r0, [r7, #4]
 2547 1062 3A68     		ldr	r2, [r7, #0]
 2548 1064 0243     		orrs	r2, r2, r0
 2549 1066 0A43     		orrs	r2, r2, r1
 2550 1068 9A60     		str	r2, [r3, #8]
1606:../src/stm32f30x_rtc.c **** 
1607:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1608:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2551              		.loc 1 1608 0
 2552 106a 4FF42053 		mov	r3, #10240
 2553 106e C4F20003 		movt	r3, 16384
 2554 1072 4FF0FF02 		mov	r2, #255
 2555 1076 5A62     		str	r2, [r3, #36]
1609:../src/stm32f30x_rtc.c **** }
 2556              		.loc 1 1609 0
 2557 1078 07F10C07 		add	r7, r7, #12
 2558 107c BD46     		mov	sp, r7
 2559 107e 80BC     		pop	{r7}
 2560 1080 7047     		bx	lr
 2561              		.cfi_endproc
 2562              	.LFE137:
 2564 1082 00BF     		.align	2
 2565              		.global	RTC_GetStoreOperation
 2566              		.thumb
 2567              		.thumb_func
 2569              	RTC_GetStoreOperation:
 2570              	.LFB138:
1610:../src/stm32f30x_rtc.c **** 
1611:../src/stm32f30x_rtc.c **** /**
1612:../src/stm32f30x_rtc.c ****   * @brief  Returns the RTC Day Light Saving stored operation.
1613:../src/stm32f30x_rtc.c ****   * @param  None
1614:../src/stm32f30x_rtc.c ****   * @retval RTC Day Light Saving stored operation.
1615:../src/stm32f30x_rtc.c ****   *          - RTC_StoreOperation_Reset
1616:../src/stm32f30x_rtc.c ****   *          - RTC_StoreOperation_Set
1617:../src/stm32f30x_rtc.c ****   */
1618:../src/stm32f30x_rtc.c **** uint32_t RTC_GetStoreOperation(void)
1619:../src/stm32f30x_rtc.c **** {
 2571              		.loc 1 1619 0
 2572              		.cfi_startproc
 2573              		@ args = 0, pretend = 0, frame = 0
 2574              		@ frame_needed = 1, uses_anonymous_args = 0
 2575              		@ link register save eliminated.
 2576 1084 80B4     		push	{r7}
 2577              	.LCFI79:
 2578              		.cfi_def_cfa_offset 4
 2579              		.cfi_offset 7, -4
 2580 1086 00AF     		add	r7, sp, #0
 2581              	.LCFI80:
 2582              		.cfi_def_cfa_register 7
1620:../src/stm32f30x_rtc.c ****   return (RTC->CR & RTC_CR_BCK);
 2583              		.loc 1 1620 0
 2584 1088 4FF42053 		mov	r3, #10240
 2585 108c C4F20003 		movt	r3, 16384
 2586 1090 9B68     		ldr	r3, [r3, #8]
 2587 1092 03F48023 		and	r3, r3, #262144
1621:../src/stm32f30x_rtc.c **** }
 2588              		.loc 1 1621 0
 2589 1096 1846     		mov	r0, r3
 2590 1098 BD46     		mov	sp, r7
 2591 109a 80BC     		pop	{r7}
 2592 109c 7047     		bx	lr
 2593              		.cfi_endproc
 2594              	.LFE138:
 2596 109e 00BF     		.align	2
 2597              		.global	RTC_OutputConfig
 2598              		.thumb
 2599              		.thumb_func
 2601              	RTC_OutputConfig:
 2602              	.LFB139:
1622:../src/stm32f30x_rtc.c **** 
1623:../src/stm32f30x_rtc.c **** /**
1624:../src/stm32f30x_rtc.c ****   * @}
1625:../src/stm32f30x_rtc.c ****   */
1626:../src/stm32f30x_rtc.c **** 
1627:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group6 Output pin Configuration function
1628:../src/stm32f30x_rtc.c ****  *  @brief   Output pin Configuration function 
1629:../src/stm32f30x_rtc.c ****  *
1630:../src/stm32f30x_rtc.c **** @verbatim   
1631:../src/stm32f30x_rtc.c ****  ===============================================================================
1632:../src/stm32f30x_rtc.c ****                    ##### Output pin Configuration function #####
1633:../src/stm32f30x_rtc.c ****  ===============================================================================
1634:../src/stm32f30x_rtc.c ****     [..] This section provide functions allowing to configure the RTC Output source.
1635:../src/stm32f30x_rtc.c **** 
1636:../src/stm32f30x_rtc.c **** @endverbatim
1637:../src/stm32f30x_rtc.c ****   * @{
1638:../src/stm32f30x_rtc.c ****   */
1639:../src/stm32f30x_rtc.c **** 
1640:../src/stm32f30x_rtc.c **** /**
1641:../src/stm32f30x_rtc.c ****   * @brief  Configures the RTC output source (AFO_ALARM).
1642:../src/stm32f30x_rtc.c ****   * @param  RTC_Output: Specifies which signal will be routed to the RTC output. 
1643:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1644:../src/stm32f30x_rtc.c ****   *     @arg RTC_Output_Disable: No output selected
1645:../src/stm32f30x_rtc.c ****   *     @arg RTC_Output_AlarmA: signal of AlarmA mapped to output
1646:../src/stm32f30x_rtc.c ****   *     @arg RTC_Output_AlarmB: signal of AlarmB mapped to output
1647:../src/stm32f30x_rtc.c ****   *     @arg RTC_Output_WakeUp: signal of WakeUp mapped to output
1648:../src/stm32f30x_rtc.c ****   * @param  RTC_OutputPolarity: Specifies the polarity of the output signal. 
1649:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following:
1650:../src/stm32f30x_rtc.c ****   *     @arg RTC_OutputPolarity_High: The output pin is high when the 
1651:../src/stm32f30x_rtc.c ****   *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
1652:../src/stm32f30x_rtc.c ****   *     @arg RTC_OutputPolarity_Low: The output pin is low when the 
1653:../src/stm32f30x_rtc.c ****   *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
1654:../src/stm32f30x_rtc.c ****   * @retval None
1655:../src/stm32f30x_rtc.c ****   */
1656:../src/stm32f30x_rtc.c **** void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
1657:../src/stm32f30x_rtc.c **** {
 2603              		.loc 1 1657 0
 2604              		.cfi_startproc
 2605              		@ args = 0, pretend = 0, frame = 8
 2606              		@ frame_needed = 1, uses_anonymous_args = 0
 2607              		@ link register save eliminated.
 2608 10a0 80B4     		push	{r7}
 2609              	.LCFI81:
 2610              		.cfi_def_cfa_offset 4
 2611              		.cfi_offset 7, -4
 2612 10a2 83B0     		sub	sp, sp, #12
 2613              	.LCFI82:
 2614              		.cfi_def_cfa_offset 16
 2615 10a4 00AF     		add	r7, sp, #0
 2616              	.LCFI83:
 2617              		.cfi_def_cfa_register 7
 2618 10a6 7860     		str	r0, [r7, #4]
 2619 10a8 3960     		str	r1, [r7, #0]
1658:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1659:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_OUTPUT(RTC_Output));
1660:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
1661:../src/stm32f30x_rtc.c **** 
1662:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1663:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2620              		.loc 1 1663 0
 2621 10aa 4FF42053 		mov	r3, #10240
 2622 10ae C4F20003 		movt	r3, 16384
 2623 10b2 4FF0CA02 		mov	r2, #202
 2624 10b6 5A62     		str	r2, [r3, #36]
1664:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2625              		.loc 1 1664 0
 2626 10b8 4FF42053 		mov	r3, #10240
 2627 10bc C4F20003 		movt	r3, 16384
 2628 10c0 4FF05302 		mov	r2, #83
 2629 10c4 5A62     		str	r2, [r3, #36]
1665:../src/stm32f30x_rtc.c **** 
1666:../src/stm32f30x_rtc.c ****   /* Clear the bits to be configured */
1667:../src/stm32f30x_rtc.c ****   RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
 2630              		.loc 1 1667 0
 2631 10c6 4FF42053 		mov	r3, #10240
 2632 10ca C4F20003 		movt	r3, 16384
 2633 10ce 4FF42052 		mov	r2, #10240
 2634 10d2 C4F20002 		movt	r2, 16384
 2635 10d6 9268     		ldr	r2, [r2, #8]
 2636 10d8 22F4E002 		bic	r2, r2, #7340032
 2637 10dc 9A60     		str	r2, [r3, #8]
1668:../src/stm32f30x_rtc.c **** 
1669:../src/stm32f30x_rtc.c ****   /* Configure the output selection and polarity */
1670:../src/stm32f30x_rtc.c ****   RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
 2638              		.loc 1 1670 0
 2639 10de 4FF42053 		mov	r3, #10240
 2640 10e2 C4F20003 		movt	r3, 16384
 2641 10e6 4FF42052 		mov	r2, #10240
 2642 10ea C4F20002 		movt	r2, 16384
 2643 10ee 9168     		ldr	r1, [r2, #8]
 2644 10f0 7868     		ldr	r0, [r7, #4]
 2645 10f2 3A68     		ldr	r2, [r7, #0]
 2646 10f4 0243     		orrs	r2, r2, r0
 2647 10f6 0A43     		orrs	r2, r2, r1
 2648 10f8 9A60     		str	r2, [r3, #8]
1671:../src/stm32f30x_rtc.c **** 
1672:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1673:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2649              		.loc 1 1673 0
 2650 10fa 4FF42053 		mov	r3, #10240
 2651 10fe C4F20003 		movt	r3, 16384
 2652 1102 4FF0FF02 		mov	r2, #255
 2653 1106 5A62     		str	r2, [r3, #36]
1674:../src/stm32f30x_rtc.c **** }
 2654              		.loc 1 1674 0
 2655 1108 07F10C07 		add	r7, r7, #12
 2656 110c BD46     		mov	sp, r7
 2657 110e 80BC     		pop	{r7}
 2658 1110 7047     		bx	lr
 2659              		.cfi_endproc
 2660              	.LFE139:
 2662 1112 00BF     		.align	2
 2663              		.global	RTC_CalibOutputCmd
 2664              		.thumb
 2665              		.thumb_func
 2667              	RTC_CalibOutputCmd:
 2668              	.LFB140:
1675:../src/stm32f30x_rtc.c **** 
1676:../src/stm32f30x_rtc.c **** /**
1677:../src/stm32f30x_rtc.c ****   * @}
1678:../src/stm32f30x_rtc.c ****   */
1679:../src/stm32f30x_rtc.c **** 
1680:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group7 Digital Calibration configuration functions
1681:../src/stm32f30x_rtc.c ****  *  @brief   Digital Calibration configuration functions 
1682:../src/stm32f30x_rtc.c ****  *
1683:../src/stm32f30x_rtc.c **** @verbatim   
1684:../src/stm32f30x_rtc.c ****  ===============================================================================
1685:../src/stm32f30x_rtc.c ****             ##### Digital Calibration configuration functions #####
1686:../src/stm32f30x_rtc.c ****  ===============================================================================
1687:../src/stm32f30x_rtc.c **** 
1688:../src/stm32f30x_rtc.c **** @endverbatim
1689:../src/stm32f30x_rtc.c ****   * @{
1690:../src/stm32f30x_rtc.c ****   */
1691:../src/stm32f30x_rtc.c **** 
1692:../src/stm32f30x_rtc.c **** /**
1693:../src/stm32f30x_rtc.c ****   * @brief  Enables or disables the RTC clock to be output through the relative 
1694:../src/stm32f30x_rtc.c ****   *         pin.
1695:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the digital calibration Output.
1696:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.
1697:../src/stm32f30x_rtc.c ****   * @retval None
1698:../src/stm32f30x_rtc.c ****   */
1699:../src/stm32f30x_rtc.c **** void RTC_CalibOutputCmd(FunctionalState NewState)
1700:../src/stm32f30x_rtc.c **** {
 2669              		.loc 1 1700 0
 2670              		.cfi_startproc
 2671              		@ args = 0, pretend = 0, frame = 8
 2672              		@ frame_needed = 1, uses_anonymous_args = 0
 2673              		@ link register save eliminated.
 2674 1114 80B4     		push	{r7}
 2675              	.LCFI84:
 2676              		.cfi_def_cfa_offset 4
 2677              		.cfi_offset 7, -4
 2678 1116 83B0     		sub	sp, sp, #12
 2679              	.LCFI85:
 2680              		.cfi_def_cfa_offset 16
 2681 1118 00AF     		add	r7, sp, #0
 2682              	.LCFI86:
 2683              		.cfi_def_cfa_register 7
 2684 111a 0346     		mov	r3, r0
 2685 111c FB71     		strb	r3, [r7, #7]
1701:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1702:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1703:../src/stm32f30x_rtc.c ****   
1704:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1705:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2686              		.loc 1 1705 0
 2687 111e 4FF42053 		mov	r3, #10240
 2688 1122 C4F20003 		movt	r3, 16384
 2689 1126 4FF0CA02 		mov	r2, #202
 2690 112a 5A62     		str	r2, [r3, #36]
1706:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2691              		.loc 1 1706 0
 2692 112c 4FF42053 		mov	r3, #10240
 2693 1130 C4F20003 		movt	r3, 16384
 2694 1134 4FF05302 		mov	r2, #83
 2695 1138 5A62     		str	r2, [r3, #36]
1707:../src/stm32f30x_rtc.c ****   
1708:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 2696              		.loc 1 1708 0
 2697 113a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2698 113c 002B     		cmp	r3, #0
 2699 113e 0CD0     		beq	.L117
1709:../src/stm32f30x_rtc.c ****   {
1710:../src/stm32f30x_rtc.c ****     /* Enable the RTC clock output */
1711:../src/stm32f30x_rtc.c ****     RTC->CR |= (uint32_t)RTC_CR_COE;
 2700              		.loc 1 1711 0
 2701 1140 4FF42053 		mov	r3, #10240
 2702 1144 C4F20003 		movt	r3, 16384
 2703 1148 4FF42052 		mov	r2, #10240
 2704 114c C4F20002 		movt	r2, 16384
 2705 1150 9268     		ldr	r2, [r2, #8]
 2706 1152 42F40002 		orr	r2, r2, #8388608
 2707 1156 9A60     		str	r2, [r3, #8]
 2708 1158 0BE0     		b	.L118
 2709              	.L117:
1712:../src/stm32f30x_rtc.c ****   }
1713:../src/stm32f30x_rtc.c ****   else
1714:../src/stm32f30x_rtc.c ****   { 
1715:../src/stm32f30x_rtc.c ****     /* Disable the RTC clock output */
1716:../src/stm32f30x_rtc.c ****     RTC->CR &= (uint32_t)~RTC_CR_COE;
 2710              		.loc 1 1716 0
 2711 115a 4FF42053 		mov	r3, #10240
 2712 115e C4F20003 		movt	r3, 16384
 2713 1162 4FF42052 		mov	r2, #10240
 2714 1166 C4F20002 		movt	r2, 16384
 2715 116a 9268     		ldr	r2, [r2, #8]
 2716 116c 22F40002 		bic	r2, r2, #8388608
 2717 1170 9A60     		str	r2, [r3, #8]
 2718              	.L118:
1717:../src/stm32f30x_rtc.c ****   }
1718:../src/stm32f30x_rtc.c ****   
1719:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1720:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF; 
 2719              		.loc 1 1720 0
 2720 1172 4FF42053 		mov	r3, #10240
 2721 1176 C4F20003 		movt	r3, 16384
 2722 117a 4FF0FF02 		mov	r2, #255
 2723 117e 5A62     		str	r2, [r3, #36]
1721:../src/stm32f30x_rtc.c **** }
 2724              		.loc 1 1721 0
 2725 1180 07F10C07 		add	r7, r7, #12
 2726 1184 BD46     		mov	sp, r7
 2727 1186 80BC     		pop	{r7}
 2728 1188 7047     		bx	lr
 2729              		.cfi_endproc
 2730              	.LFE140:
 2732 118a 00BF     		.align	2
 2733              		.global	RTC_CalibOutputConfig
 2734              		.thumb
 2735              		.thumb_func
 2737              	RTC_CalibOutputConfig:
 2738              	.LFB141:
1722:../src/stm32f30x_rtc.c **** 
1723:../src/stm32f30x_rtc.c **** /**
1724:../src/stm32f30x_rtc.c ****   * @brief  Configures the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
1725:../src/stm32f30x_rtc.c ****   * @param  RTC_CalibOutput : Select the Calibration output Selection .
1726:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1727:../src/stm32f30x_rtc.c ****   *     @arg RTC_CalibOutput_512Hz: A signal has a regular waveform at 512Hz. 
1728:../src/stm32f30x_rtc.c ****   *     @arg RTC_CalibOutput_1Hz  : A signal has a regular waveform at 1Hz.
1729:../src/stm32f30x_rtc.c ****   * @retval None
1730:../src/stm32f30x_rtc.c **** */
1731:../src/stm32f30x_rtc.c **** void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
1732:../src/stm32f30x_rtc.c **** {
 2739              		.loc 1 1732 0
 2740              		.cfi_startproc
 2741              		@ args = 0, pretend = 0, frame = 8
 2742              		@ frame_needed = 1, uses_anonymous_args = 0
 2743              		@ link register save eliminated.
 2744 118c 80B4     		push	{r7}
 2745              	.LCFI87:
 2746              		.cfi_def_cfa_offset 4
 2747              		.cfi_offset 7, -4
 2748 118e 83B0     		sub	sp, sp, #12
 2749              	.LCFI88:
 2750              		.cfi_def_cfa_offset 16
 2751 1190 00AF     		add	r7, sp, #0
 2752              	.LCFI89:
 2753              		.cfi_def_cfa_register 7
 2754 1192 7860     		str	r0, [r7, #4]
1733:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1734:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
1735:../src/stm32f30x_rtc.c **** 
1736:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1737:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2755              		.loc 1 1737 0
 2756 1194 4FF42053 		mov	r3, #10240
 2757 1198 C4F20003 		movt	r3, 16384
 2758 119c 4FF0CA02 		mov	r2, #202
 2759 11a0 5A62     		str	r2, [r3, #36]
1738:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2760              		.loc 1 1738 0
 2761 11a2 4FF42053 		mov	r3, #10240
 2762 11a6 C4F20003 		movt	r3, 16384
 2763 11aa 4FF05302 		mov	r2, #83
 2764 11ae 5A62     		str	r2, [r3, #36]
1739:../src/stm32f30x_rtc.c ****   
1740:../src/stm32f30x_rtc.c ****   /*clear flags before config*/
1741:../src/stm32f30x_rtc.c ****   RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
 2765              		.loc 1 1741 0
 2766 11b0 4FF42053 		mov	r3, #10240
 2767 11b4 C4F20003 		movt	r3, 16384
 2768 11b8 4FF42052 		mov	r2, #10240
 2769 11bc C4F20002 		movt	r2, 16384
 2770 11c0 9268     		ldr	r2, [r2, #8]
 2771 11c2 22F40022 		bic	r2, r2, #524288
 2772 11c6 9A60     		str	r2, [r3, #8]
1742:../src/stm32f30x_rtc.c **** 
1743:../src/stm32f30x_rtc.c ****   /* Configure the RTC_CR register */
1744:../src/stm32f30x_rtc.c ****   RTC->CR |= (uint32_t)RTC_CalibOutput;
 2773              		.loc 1 1744 0
 2774 11c8 4FF42053 		mov	r3, #10240
 2775 11cc C4F20003 		movt	r3, 16384
 2776 11d0 4FF42052 		mov	r2, #10240
 2777 11d4 C4F20002 		movt	r2, 16384
 2778 11d8 9168     		ldr	r1, [r2, #8]
 2779 11da 7A68     		ldr	r2, [r7, #4]
 2780 11dc 0A43     		orrs	r2, r2, r1
 2781 11de 9A60     		str	r2, [r3, #8]
1745:../src/stm32f30x_rtc.c **** 
1746:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1747:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2782              		.loc 1 1747 0
 2783 11e0 4FF42053 		mov	r3, #10240
 2784 11e4 C4F20003 		movt	r3, 16384
 2785 11e8 4FF0FF02 		mov	r2, #255
 2786 11ec 5A62     		str	r2, [r3, #36]
1748:../src/stm32f30x_rtc.c **** }
 2787              		.loc 1 1748 0
 2788 11ee 07F10C07 		add	r7, r7, #12
 2789 11f2 BD46     		mov	sp, r7
 2790 11f4 80BC     		pop	{r7}
 2791 11f6 7047     		bx	lr
 2792              		.cfi_endproc
 2793              	.LFE141:
 2795              		.align	2
 2796              		.global	RTC_SmoothCalibConfig
 2797              		.thumb
 2798              		.thumb_func
 2800              	RTC_SmoothCalibConfig:
 2801              	.LFB142:
1749:../src/stm32f30x_rtc.c **** 
1750:../src/stm32f30x_rtc.c **** /**
1751:../src/stm32f30x_rtc.c ****   * @brief  Configures the Smooth Calibration Settings.
1752:../src/stm32f30x_rtc.c ****   * @param  RTC_SmoothCalibPeriod : Select the Smooth Calibration Period.
1753:../src/stm32f30x_rtc.c ****   *   This parameter can be can be one of the following values:
1754:../src/stm32f30x_rtc.c ****   *     @arg RTC_SmoothCalibPeriod_32sec : The smooth calibration periode is 32s.
1755:../src/stm32f30x_rtc.c ****   *     @arg RTC_SmoothCalibPeriod_16sec : The smooth calibration periode is 16s.
1756:../src/stm32f30x_rtc.c ****   *     @arg RTC_SmoothCalibPeriod_8sec  : The smooth calibartion periode is 8s.
1757:../src/stm32f30x_rtc.c ****   * @param  RTC_SmoothCalibPlusPulses : Select to Set or reset the CALP bit.
1758:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1759:../src/stm32f30x_rtc.c ****   *     @arg RTC_SmoothCalibPlusPulses_Set  : Add one RTCCLK puls every 2**11 pulses.
1760:../src/stm32f30x_rtc.c ****   *     @arg RTC_SmoothCalibPlusPulses_Reset: No RTCCLK pulses are added.
1761:../src/stm32f30x_rtc.c ****   * @param  RTC_SmouthCalibMinusPulsesValue: Select the value of CALM[8:0] bits.
1762:../src/stm32f30x_rtc.c ****   *   This parameter can be one any value from 0 to 0x000001FF.
1763:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
1764:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC Calib registers are configured
1765:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC Calib registers are not configured
1766:../src/stm32f30x_rtc.c **** */
1767:../src/stm32f30x_rtc.c **** ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
1768:../src/stm32f30x_rtc.c ****                                   uint32_t RTC_SmoothCalibPlusPulses,
1769:../src/stm32f30x_rtc.c ****                                   uint32_t RTC_SmouthCalibMinusPulsesValue)
1770:../src/stm32f30x_rtc.c **** {
 2802              		.loc 1 1770 0
 2803              		.cfi_startproc
 2804              		@ args = 0, pretend = 0, frame = 24
 2805              		@ frame_needed = 1, uses_anonymous_args = 0
 2806              		@ link register save eliminated.
 2807 11f8 80B4     		push	{r7}
 2808              	.LCFI90:
 2809              		.cfi_def_cfa_offset 4
 2810              		.cfi_offset 7, -4
 2811 11fa 87B0     		sub	sp, sp, #28
 2812              	.LCFI91:
 2813              		.cfi_def_cfa_offset 32
 2814 11fc 00AF     		add	r7, sp, #0
 2815              	.LCFI92:
 2816              		.cfi_def_cfa_register 7
 2817 11fe F860     		str	r0, [r7, #12]
 2818 1200 B960     		str	r1, [r7, #8]
 2819 1202 7A60     		str	r2, [r7, #4]
1771:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 2820              		.loc 1 1771 0
 2821 1204 4FF00003 		mov	r3, #0
 2822 1208 FB75     		strb	r3, [r7, #23]
1772:../src/stm32f30x_rtc.c ****   uint32_t recalpfcount = 0;
 2823              		.loc 1 1772 0
 2824 120a 4FF00003 		mov	r3, #0
 2825 120e 3B61     		str	r3, [r7, #16]
1773:../src/stm32f30x_rtc.c **** 
1774:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1775:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
1776:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
1777:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
1778:../src/stm32f30x_rtc.c **** 
1779:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1780:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2826              		.loc 1 1780 0
 2827 1210 4FF42053 		mov	r3, #10240
 2828 1214 C4F20003 		movt	r3, 16384
 2829 1218 4FF0CA02 		mov	r2, #202
 2830 121c 5A62     		str	r2, [r3, #36]
1781:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2831              		.loc 1 1781 0
 2832 121e 4FF42053 		mov	r3, #10240
 2833 1222 C4F20003 		movt	r3, 16384
 2834 1226 4FF05302 		mov	r2, #83
 2835 122a 5A62     		str	r2, [r3, #36]
1782:../src/stm32f30x_rtc.c ****   
1783:../src/stm32f30x_rtc.c ****   /* check if a calibration is pending*/
1784:../src/stm32f30x_rtc.c ****   if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
 2836              		.loc 1 1784 0
 2837 122c 4FF42053 		mov	r3, #10240
 2838 1230 C4F20003 		movt	r3, 16384
 2839 1234 DB68     		ldr	r3, [r3, #12]
 2840 1236 03F48033 		and	r3, r3, #65536
 2841 123a 002B     		cmp	r3, #0
 2842 123c 11D0     		beq	.L121
1785:../src/stm32f30x_rtc.c ****   {
1786:../src/stm32f30x_rtc.c ****     /* wait until the Calibration is completed*/
1787:../src/stm32f30x_rtc.c ****     while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 2843              		.loc 1 1787 0
 2844 123e 03E0     		b	.L122
 2845              	.L123:
1788:../src/stm32f30x_rtc.c ****     {
1789:../src/stm32f30x_rtc.c ****       recalpfcount++;
 2846              		.loc 1 1789 0
 2847 1240 3B69     		ldr	r3, [r7, #16]
 2848 1242 03F10103 		add	r3, r3, #1
 2849 1246 3B61     		str	r3, [r7, #16]
 2850              	.L122:
1787:../src/stm32f30x_rtc.c ****     while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 2851              		.loc 1 1787 0 discriminator 1
 2852 1248 4FF42053 		mov	r3, #10240
 2853 124c C4F20003 		movt	r3, 16384
 2854 1250 DB68     		ldr	r3, [r3, #12]
 2855 1252 03F48033 		and	r3, r3, #65536
 2856 1256 002B     		cmp	r3, #0
 2857 1258 03D0     		beq	.L121
1787:../src/stm32f30x_rtc.c ****     while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 2858              		.loc 1 1787 0 is_stmt 0 discriminator 2
 2859 125a 3B69     		ldr	r3, [r7, #16]
 2860 125c B3F5805F 		cmp	r3, #4096
 2861 1260 EED1     		bne	.L123
 2862              	.L121:
1790:../src/stm32f30x_rtc.c ****     }
1791:../src/stm32f30x_rtc.c ****   }
1792:../src/stm32f30x_rtc.c **** 
1793:../src/stm32f30x_rtc.c ****   /* check if the calibration pending is completed or if there is no calibration operation at all*/
1794:../src/stm32f30x_rtc.c ****   if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
 2863              		.loc 1 1794 0 is_stmt 1
 2864 1262 4FF42053 		mov	r3, #10240
 2865 1266 C4F20003 		movt	r3, 16384
 2866 126a DB68     		ldr	r3, [r3, #12]
 2867 126c 03F48033 		and	r3, r3, #65536
 2868 1270 002B     		cmp	r3, #0
 2869 1272 0DD1     		bne	.L124
1795:../src/stm32f30x_rtc.c ****   {
1796:../src/stm32f30x_rtc.c ****     /* Configure the Smooth calibration settings */
1797:../src/stm32f30x_rtc.c ****     RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | 
 2870              		.loc 1 1797 0
 2871 1274 4FF42053 		mov	r3, #10240
 2872 1278 C4F20003 		movt	r3, 16384
 2873 127c F968     		ldr	r1, [r7, #12]
 2874 127e BA68     		ldr	r2, [r7, #8]
 2875 1280 1143     		orrs	r1, r1, r2
 2876 1282 7A68     		ldr	r2, [r7, #4]
 2877 1284 0A43     		orrs	r2, r2, r1
 2878 1286 DA63     		str	r2, [r3, #60]
1798:../src/stm32f30x_rtc.c **** 
1799:../src/stm32f30x_rtc.c ****     status = SUCCESS;
 2879              		.loc 1 1799 0
 2880 1288 4FF00103 		mov	r3, #1
 2881 128c FB75     		strb	r3, [r7, #23]
 2882 128e 02E0     		b	.L125
 2883              	.L124:
1800:../src/stm32f30x_rtc.c ****   }
1801:../src/stm32f30x_rtc.c ****   else
1802:../src/stm32f30x_rtc.c ****   {
1803:../src/stm32f30x_rtc.c ****     status = ERROR;
 2884              		.loc 1 1803 0
 2885 1290 4FF00003 		mov	r3, #0
 2886 1294 FB75     		strb	r3, [r7, #23]
 2887              	.L125:
1804:../src/stm32f30x_rtc.c ****   }
1805:../src/stm32f30x_rtc.c **** 
1806:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1807:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2888              		.loc 1 1807 0
 2889 1296 4FF42053 		mov	r3, #10240
 2890 129a C4F20003 		movt	r3, 16384
 2891 129e 4FF0FF02 		mov	r2, #255
 2892 12a2 5A62     		str	r2, [r3, #36]
1808:../src/stm32f30x_rtc.c ****   
1809:../src/stm32f30x_rtc.c ****   return (ErrorStatus)(status);
 2893              		.loc 1 1809 0
 2894 12a4 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1810:../src/stm32f30x_rtc.c **** }
 2895              		.loc 1 1810 0
 2896 12a6 1846     		mov	r0, r3
 2897 12a8 07F11C07 		add	r7, r7, #28
 2898 12ac BD46     		mov	sp, r7
 2899 12ae 80BC     		pop	{r7}
 2900 12b0 7047     		bx	lr
 2901              		.cfi_endproc
 2902              	.LFE142:
 2904 12b2 00BF     		.align	2
 2905              		.global	RTC_TimeStampCmd
 2906              		.thumb
 2907              		.thumb_func
 2909              	RTC_TimeStampCmd:
 2910              	.LFB143:
1811:../src/stm32f30x_rtc.c **** 
1812:../src/stm32f30x_rtc.c **** /**
1813:../src/stm32f30x_rtc.c ****   * @}
1814:../src/stm32f30x_rtc.c ****   */
1815:../src/stm32f30x_rtc.c **** 
1816:../src/stm32f30x_rtc.c **** 
1817:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group8 TimeStamp configuration functions
1818:../src/stm32f30x_rtc.c ****  *  @brief   TimeStamp configuration functions 
1819:../src/stm32f30x_rtc.c ****  *
1820:../src/stm32f30x_rtc.c **** @verbatim   
1821:../src/stm32f30x_rtc.c ****  ===============================================================================
1822:../src/stm32f30x_rtc.c ****                 ##### TimeStamp configuration functions #####
1823:../src/stm32f30x_rtc.c ****  ===============================================================================  
1824:../src/stm32f30x_rtc.c **** 
1825:../src/stm32f30x_rtc.c **** @endverbatim
1826:../src/stm32f30x_rtc.c ****   * @{
1827:../src/stm32f30x_rtc.c ****   */
1828:../src/stm32f30x_rtc.c **** 
1829:../src/stm32f30x_rtc.c **** /**
1830:../src/stm32f30x_rtc.c ****   * @brief  Enables or Disables the RTC TimeStamp functionality with the 
1831:../src/stm32f30x_rtc.c ****   *         specified time stamp pin stimulating edge.
1832:../src/stm32f30x_rtc.c ****   * @param  RTC_TimeStampEdge: Specifies the pin edge on which the TimeStamp is 
1833:../src/stm32f30x_rtc.c ****   *         activated.
1834:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following:
1835:../src/stm32f30x_rtc.c ****   *     @arg RTC_TimeStampEdge_Rising: the Time stamp event occurs on the rising 
1836:../src/stm32f30x_rtc.c ****   *                                    edge of the related pin.
1837:../src/stm32f30x_rtc.c ****   *     @arg RTC_TimeStampEdge_Falling: the Time stamp event occurs on the 
1838:../src/stm32f30x_rtc.c ****   *                                     falling edge of the related pin.
1839:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the TimeStamp.
1840:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.
1841:../src/stm32f30x_rtc.c ****   * @retval None
1842:../src/stm32f30x_rtc.c ****   */
1843:../src/stm32f30x_rtc.c **** void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
1844:../src/stm32f30x_rtc.c **** {
 2911              		.loc 1 1844 0
 2912              		.cfi_startproc
 2913              		@ args = 0, pretend = 0, frame = 16
 2914              		@ frame_needed = 1, uses_anonymous_args = 0
 2915              		@ link register save eliminated.
 2916 12b4 80B4     		push	{r7}
 2917              	.LCFI93:
 2918              		.cfi_def_cfa_offset 4
 2919              		.cfi_offset 7, -4
 2920 12b6 85B0     		sub	sp, sp, #20
 2921              	.LCFI94:
 2922              		.cfi_def_cfa_offset 24
 2923 12b8 00AF     		add	r7, sp, #0
 2924              	.LCFI95:
 2925              		.cfi_def_cfa_register 7
 2926 12ba 7860     		str	r0, [r7, #4]
 2927 12bc 0B46     		mov	r3, r1
 2928 12be FB70     		strb	r3, [r7, #3]
1845:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 2929              		.loc 1 1845 0
 2930 12c0 4FF00003 		mov	r3, #0
 2931 12c4 FB60     		str	r3, [r7, #12]
1846:../src/stm32f30x_rtc.c **** 
1847:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1848:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
1849:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1850:../src/stm32f30x_rtc.c **** 
1851:../src/stm32f30x_rtc.c ****   /* Get the RTC_CR register and clear the bits to be configured */
1852:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 2932              		.loc 1 1852 0
 2933 12c6 4FF42053 		mov	r3, #10240
 2934 12ca C4F20003 		movt	r3, 16384
 2935 12ce 9B68     		ldr	r3, [r3, #8]
 2936 12d0 23F40063 		bic	r3, r3, #2048
 2937 12d4 23F00803 		bic	r3, r3, #8
 2938 12d8 FB60     		str	r3, [r7, #12]
1853:../src/stm32f30x_rtc.c **** 
1854:../src/stm32f30x_rtc.c ****   /* Get the new configuration */
1855:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 2939              		.loc 1 1855 0
 2940 12da FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2941 12dc 002B     		cmp	r3, #0
 2942 12de 06D0     		beq	.L128
1856:../src/stm32f30x_rtc.c ****   {
1857:../src/stm32f30x_rtc.c ****     tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
 2943              		.loc 1 1857 0
 2944 12e0 7A68     		ldr	r2, [r7, #4]
 2945 12e2 FB68     		ldr	r3, [r7, #12]
 2946 12e4 1343     		orrs	r3, r3, r2
 2947 12e6 43F40063 		orr	r3, r3, #2048
 2948 12ea FB60     		str	r3, [r7, #12]
 2949 12ec 03E0     		b	.L129
 2950              	.L128:
1858:../src/stm32f30x_rtc.c ****   }
1859:../src/stm32f30x_rtc.c ****   else
1860:../src/stm32f30x_rtc.c ****   {
1861:../src/stm32f30x_rtc.c ****     tmpreg |= (uint32_t)(RTC_TimeStampEdge);
 2951              		.loc 1 1861 0
 2952 12ee FA68     		ldr	r2, [r7, #12]
 2953 12f0 7B68     		ldr	r3, [r7, #4]
 2954 12f2 1343     		orrs	r3, r3, r2
 2955 12f4 FB60     		str	r3, [r7, #12]
 2956              	.L129:
1862:../src/stm32f30x_rtc.c ****   }
1863:../src/stm32f30x_rtc.c **** 
1864:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
1865:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 2957              		.loc 1 1865 0
 2958 12f6 4FF42053 		mov	r3, #10240
 2959 12fa C4F20003 		movt	r3, 16384
 2960 12fe 4FF0CA02 		mov	r2, #202
 2961 1302 5A62     		str	r2, [r3, #36]
1866:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 2962              		.loc 1 1866 0
 2963 1304 4FF42053 		mov	r3, #10240
 2964 1308 C4F20003 		movt	r3, 16384
 2965 130c 4FF05302 		mov	r2, #83
 2966 1310 5A62     		str	r2, [r3, #36]
1867:../src/stm32f30x_rtc.c **** 
1868:../src/stm32f30x_rtc.c ****   /* Configure the Time Stamp TSEDGE and Enable bits */
1869:../src/stm32f30x_rtc.c ****   RTC->CR = (uint32_t)tmpreg;
 2967              		.loc 1 1869 0
 2968 1312 4FF42053 		mov	r3, #10240
 2969 1316 C4F20003 		movt	r3, 16384
 2970 131a FA68     		ldr	r2, [r7, #12]
 2971 131c 9A60     		str	r2, [r3, #8]
1870:../src/stm32f30x_rtc.c **** 
1871:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
1872:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 2972              		.loc 1 1872 0
 2973 131e 4FF42053 		mov	r3, #10240
 2974 1322 C4F20003 		movt	r3, 16384
 2975 1326 4FF0FF02 		mov	r2, #255
 2976 132a 5A62     		str	r2, [r3, #36]
1873:../src/stm32f30x_rtc.c **** }
 2977              		.loc 1 1873 0
 2978 132c 07F11407 		add	r7, r7, #20
 2979 1330 BD46     		mov	sp, r7
 2980 1332 80BC     		pop	{r7}
 2981 1334 7047     		bx	lr
 2982              		.cfi_endproc
 2983              	.LFE143:
 2985 1336 00BF     		.align	2
 2986              		.global	RTC_GetTimeStamp
 2987              		.thumb
 2988              		.thumb_func
 2990              	RTC_GetTimeStamp:
 2991              	.LFB144:
1874:../src/stm32f30x_rtc.c **** 
1875:../src/stm32f30x_rtc.c **** /**
1876:../src/stm32f30x_rtc.c ****   * @brief  Gets the RTC TimeStamp value and masks.
1877:../src/stm32f30x_rtc.c ****   * @param  RTC_Format: specifies the format of the output parameters.
1878:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1879:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BIN: Binary data format 
1880:../src/stm32f30x_rtc.c ****   *     @arg RTC_Format_BCD: BCD data format
1881:../src/stm32f30x_rtc.c ****   * @param RTC_StampTimeStruct: pointer to a RTC_TimeTypeDef structure that will 
1882:../src/stm32f30x_rtc.c ****   *                             contains the TimeStamp time values. 
1883:../src/stm32f30x_rtc.c ****   * @param RTC_StampDateStruct: pointer to a RTC_DateTypeDef structure that will 
1884:../src/stm32f30x_rtc.c ****   *                             contains the TimeStamp date values.     
1885:../src/stm32f30x_rtc.c ****   * @retval None
1886:../src/stm32f30x_rtc.c ****   */
1887:../src/stm32f30x_rtc.c **** void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
1888:../src/stm32f30x_rtc.c ****                                       RTC_DateTypeDef* RTC_StampDateStruct)
1889:../src/stm32f30x_rtc.c **** {
 2992              		.loc 1 1889 0
 2993              		.cfi_startproc
 2994              		@ args = 0, pretend = 0, frame = 24
 2995              		@ frame_needed = 1, uses_anonymous_args = 0
 2996 1338 80B5     		push	{r7, lr}
 2997              	.LCFI96:
 2998              		.cfi_def_cfa_offset 8
 2999              		.cfi_offset 7, -8
 3000              		.cfi_offset 14, -4
 3001 133a 86B0     		sub	sp, sp, #24
 3002              	.LCFI97:
 3003              		.cfi_def_cfa_offset 32
 3004 133c 00AF     		add	r7, sp, #0
 3005              	.LCFI98:
 3006              		.cfi_def_cfa_register 7
 3007 133e F860     		str	r0, [r7, #12]
 3008 1340 B960     		str	r1, [r7, #8]
 3009 1342 7A60     		str	r2, [r7, #4]
1890:../src/stm32f30x_rtc.c ****   uint32_t tmptime = 0, tmpdate = 0;
 3010              		.loc 1 1890 0
 3011 1344 4FF00003 		mov	r3, #0
 3012 1348 7B61     		str	r3, [r7, #20]
 3013 134a 4FF00003 		mov	r3, #0
 3014 134e 3B61     		str	r3, [r7, #16]
1891:../src/stm32f30x_rtc.c **** 
1892:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1893:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_FORMAT(RTC_Format));
1894:../src/stm32f30x_rtc.c **** 
1895:../src/stm32f30x_rtc.c ****   /* Get the TimeStamp time and date registers values */
1896:../src/stm32f30x_rtc.c ****   tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
 3015              		.loc 1 1896 0
 3016 1350 4FF42053 		mov	r3, #10240
 3017 1354 C4F20003 		movt	r3, 16384
 3018 1358 1B6B     		ldr	r3, [r3, #48]
 3019 135a 03F07F33 		and	r3, r3, #2139062143
 3020 135e 23F0FE43 		bic	r3, r3, #2130706432
 3021 1362 7B61     		str	r3, [r7, #20]
1897:../src/stm32f30x_rtc.c ****   tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
 3022              		.loc 1 1897 0
 3023 1364 4FF42053 		mov	r3, #10240
 3024 1368 C4F20003 		movt	r3, 16384
 3025 136c 5B6B     		ldr	r3, [r3, #52]
 3026 136e 23F07F43 		bic	r3, r3, #-16777216
 3027 1372 23F0C003 		bic	r3, r3, #192
 3028 1376 3B61     		str	r3, [r7, #16]
1898:../src/stm32f30x_rtc.c **** 
1899:../src/stm32f30x_rtc.c ****   /* Fill the Time structure fields with the read parameters */
1900:../src/stm32f30x_rtc.c ****   RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 3029              		.loc 1 1900 0
 3030 1378 7B69     		ldr	r3, [r7, #20]
 3031 137a 03F47C13 		and	r3, r3, #4128768
 3032 137e 4FEA1343 		lsr	r3, r3, #16
 3033 1382 DAB2     		uxtb	r2, r3
 3034 1384 BB68     		ldr	r3, [r7, #8]
 3035 1386 1A70     		strb	r2, [r3, #0]
1901:../src/stm32f30x_rtc.c ****   RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
 3036              		.loc 1 1901 0
 3037 1388 7B69     		ldr	r3, [r7, #20]
 3038 138a 03F4FE43 		and	r3, r3, #32512
 3039 138e 4FEA1323 		lsr	r3, r3, #8
 3040 1392 DAB2     		uxtb	r2, r3
 3041 1394 BB68     		ldr	r3, [r7, #8]
 3042 1396 5A70     		strb	r2, [r3, #1]
1902:../src/stm32f30x_rtc.c ****   RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
 3043              		.loc 1 1902 0
 3044 1398 7B69     		ldr	r3, [r7, #20]
 3045 139a DBB2     		uxtb	r3, r3
 3046 139c 03F07F03 		and	r3, r3, #127
 3047 13a0 DAB2     		uxtb	r2, r3
 3048 13a2 BB68     		ldr	r3, [r7, #8]
 3049 13a4 9A70     		strb	r2, [r3, #2]
1903:../src/stm32f30x_rtc.c ****   RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
 3050              		.loc 1 1903 0
 3051 13a6 7B69     		ldr	r3, [r7, #20]
 3052 13a8 03F48003 		and	r3, r3, #4194304
 3053 13ac 4FEA1343 		lsr	r3, r3, #16
 3054 13b0 DAB2     		uxtb	r2, r3
 3055 13b2 BB68     		ldr	r3, [r7, #8]
 3056 13b4 DA70     		strb	r2, [r3, #3]
1904:../src/stm32f30x_rtc.c **** 
1905:../src/stm32f30x_rtc.c ****   /* Fill the Date structure fields with the read parameters */
1906:../src/stm32f30x_rtc.c ****   RTC_StampDateStruct->RTC_Year = 0;
 3057              		.loc 1 1906 0
 3058 13b6 7B68     		ldr	r3, [r7, #4]
 3059 13b8 4FF00002 		mov	r2, #0
 3060 13bc DA70     		strb	r2, [r3, #3]
1907:../src/stm32f30x_rtc.c ****   RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 3061              		.loc 1 1907 0
 3062 13be 3B69     		ldr	r3, [r7, #16]
 3063 13c0 03F4F853 		and	r3, r3, #7936
 3064 13c4 4FEA1323 		lsr	r3, r3, #8
 3065 13c8 DAB2     		uxtb	r2, r3
 3066 13ca 7B68     		ldr	r3, [r7, #4]
 3067 13cc 5A70     		strb	r2, [r3, #1]
1908:../src/stm32f30x_rtc.c ****   RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
 3068              		.loc 1 1908 0
 3069 13ce 3B69     		ldr	r3, [r7, #16]
 3070 13d0 DBB2     		uxtb	r3, r3
 3071 13d2 03F03F03 		and	r3, r3, #63
 3072 13d6 DAB2     		uxtb	r2, r3
 3073 13d8 7B68     		ldr	r3, [r7, #4]
 3074 13da 9A70     		strb	r2, [r3, #2]
1909:../src/stm32f30x_rtc.c ****   RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
 3075              		.loc 1 1909 0
 3076 13dc 3B69     		ldr	r3, [r7, #16]
 3077 13de 03F46043 		and	r3, r3, #57344
 3078 13e2 4FEA5333 		lsr	r3, r3, #13
 3079 13e6 DAB2     		uxtb	r2, r3
 3080 13e8 7B68     		ldr	r3, [r7, #4]
 3081 13ea 1A70     		strb	r2, [r3, #0]
1910:../src/stm32f30x_rtc.c **** 
1911:../src/stm32f30x_rtc.c ****   /* Check the input parameters format */
1912:../src/stm32f30x_rtc.c ****   if (RTC_Format == RTC_Format_BIN)
 3082              		.loc 1 1912 0
 3083 13ec FB68     		ldr	r3, [r7, #12]
 3084 13ee 002B     		cmp	r3, #0
 3085 13f0 35D1     		bne	.L130
1913:../src/stm32f30x_rtc.c ****   {
1914:../src/stm32f30x_rtc.c ****     /* Convert the Time structure parameters to Binary format */
1915:../src/stm32f30x_rtc.c ****     RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
 3086              		.loc 1 1915 0
 3087 13f2 BB68     		ldr	r3, [r7, #8]
 3088 13f4 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3089 13f6 1846     		mov	r0, r3
 3090 13f8 00F04CFB 		bl	RTC_Bcd2ToByte
 3091 13fc 0346     		mov	r3, r0
 3092 13fe 1A46     		mov	r2, r3
 3093 1400 BB68     		ldr	r3, [r7, #8]
 3094 1402 1A70     		strb	r2, [r3, #0]
1916:../src/stm32f30x_rtc.c ****     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
 3095              		.loc 1 1916 0
 3096 1404 BB68     		ldr	r3, [r7, #8]
 3097 1406 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 3098 1408 1846     		mov	r0, r3
 3099 140a 00F043FB 		bl	RTC_Bcd2ToByte
 3100 140e 0346     		mov	r3, r0
 3101 1410 1A46     		mov	r2, r3
 3102 1412 BB68     		ldr	r3, [r7, #8]
 3103 1414 5A70     		strb	r2, [r3, #1]
1917:../src/stm32f30x_rtc.c ****     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
 3104              		.loc 1 1917 0
 3105 1416 BB68     		ldr	r3, [r7, #8]
 3106 1418 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 3107 141a 1846     		mov	r0, r3
 3108 141c 00F03AFB 		bl	RTC_Bcd2ToByte
 3109 1420 0346     		mov	r3, r0
 3110 1422 1A46     		mov	r2, r3
 3111 1424 BB68     		ldr	r3, [r7, #8]
 3112 1426 9A70     		strb	r2, [r3, #2]
1918:../src/stm32f30x_rtc.c **** 
1919:../src/stm32f30x_rtc.c ****     /* Convert the Date structure parameters to Binary format */
1920:../src/stm32f30x_rtc.c ****     RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
 3113              		.loc 1 1920 0
 3114 1428 7B68     		ldr	r3, [r7, #4]
 3115 142a 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 3116 142c 1846     		mov	r0, r3
 3117 142e 00F031FB 		bl	RTC_Bcd2ToByte
 3118 1432 0346     		mov	r3, r0
 3119 1434 1A46     		mov	r2, r3
 3120 1436 7B68     		ldr	r3, [r7, #4]
 3121 1438 5A70     		strb	r2, [r3, #1]
1921:../src/stm32f30x_rtc.c ****     RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
 3122              		.loc 1 1921 0
 3123 143a 7B68     		ldr	r3, [r7, #4]
 3124 143c 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 3125 143e 1846     		mov	r0, r3
 3126 1440 00F028FB 		bl	RTC_Bcd2ToByte
 3127 1444 0346     		mov	r3, r0
 3128 1446 1A46     		mov	r2, r3
 3129 1448 7B68     		ldr	r3, [r7, #4]
 3130 144a 9A70     		strb	r2, [r3, #2]
1922:../src/stm32f30x_rtc.c ****     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
 3131              		.loc 1 1922 0
 3132 144c 7B68     		ldr	r3, [r7, #4]
 3133 144e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3134 1450 1846     		mov	r0, r3
 3135 1452 00F01FFB 		bl	RTC_Bcd2ToByte
 3136 1456 0346     		mov	r3, r0
 3137 1458 1A46     		mov	r2, r3
 3138 145a 7B68     		ldr	r3, [r7, #4]
 3139 145c 1A70     		strb	r2, [r3, #0]
 3140              	.L130:
1923:../src/stm32f30x_rtc.c ****   }
1924:../src/stm32f30x_rtc.c **** }
 3141              		.loc 1 1924 0
 3142 145e 07F11807 		add	r7, r7, #24
 3143 1462 BD46     		mov	sp, r7
 3144 1464 80BD     		pop	{r7, pc}
 3145              		.cfi_endproc
 3146              	.LFE144:
 3148 1466 00BF     		.align	2
 3149              		.global	RTC_GetTimeStampSubSecond
 3150              		.thumb
 3151              		.thumb_func
 3153              	RTC_GetTimeStampSubSecond:
 3154              	.LFB145:
1925:../src/stm32f30x_rtc.c **** 
1926:../src/stm32f30x_rtc.c **** /**
1927:../src/stm32f30x_rtc.c ****   * @brief  Gets the RTC timestamp Subseconds value.
1928:../src/stm32f30x_rtc.c ****   * @param  None
1929:../src/stm32f30x_rtc.c ****   * @retval RTC current timestamp Subseconds value.
1930:../src/stm32f30x_rtc.c ****   */
1931:../src/stm32f30x_rtc.c **** uint32_t RTC_GetTimeStampSubSecond(void)
1932:../src/stm32f30x_rtc.c **** {
 3155              		.loc 1 1932 0
 3156              		.cfi_startproc
 3157              		@ args = 0, pretend = 0, frame = 0
 3158              		@ frame_needed = 1, uses_anonymous_args = 0
 3159              		@ link register save eliminated.
 3160 1468 80B4     		push	{r7}
 3161              	.LCFI99:
 3162              		.cfi_def_cfa_offset 4
 3163              		.cfi_offset 7, -4
 3164 146a 00AF     		add	r7, sp, #0
 3165              	.LCFI100:
 3166              		.cfi_def_cfa_register 7
1933:../src/stm32f30x_rtc.c ****   /* Get timestamp subseconds values from the correspondent registers */
1934:../src/stm32f30x_rtc.c ****   return (uint32_t)(RTC->TSSSR);
 3167              		.loc 1 1934 0
 3168 146c 4FF42053 		mov	r3, #10240
 3169 1470 C4F20003 		movt	r3, 16384
 3170 1474 9B6B     		ldr	r3, [r3, #56]
1935:../src/stm32f30x_rtc.c **** }
 3171              		.loc 1 1935 0
 3172 1476 1846     		mov	r0, r3
 3173 1478 BD46     		mov	sp, r7
 3174 147a 80BC     		pop	{r7}
 3175 147c 7047     		bx	lr
 3176              		.cfi_endproc
 3177              	.LFE145:
 3179 147e 00BF     		.align	2
 3180              		.global	RTC_TamperTriggerConfig
 3181              		.thumb
 3182              		.thumb_func
 3184              	RTC_TamperTriggerConfig:
 3185              	.LFB146:
1936:../src/stm32f30x_rtc.c **** 
1937:../src/stm32f30x_rtc.c **** /**
1938:../src/stm32f30x_rtc.c ****   * @}
1939:../src/stm32f30x_rtc.c ****   */
1940:../src/stm32f30x_rtc.c **** 
1941:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group9 Tampers configuration functions
1942:../src/stm32f30x_rtc.c ****  *  @brief   Tampers configuration functions 
1943:../src/stm32f30x_rtc.c ****  *
1944:../src/stm32f30x_rtc.c **** @verbatim   
1945:../src/stm32f30x_rtc.c ****  ===============================================================================
1946:../src/stm32f30x_rtc.c ****                 ##### Tampers configuration functions #####
1947:../src/stm32f30x_rtc.c ****  ===============================================================================  
1948:../src/stm32f30x_rtc.c **** 
1949:../src/stm32f30x_rtc.c **** @endverbatim
1950:../src/stm32f30x_rtc.c ****   * @{
1951:../src/stm32f30x_rtc.c ****   */
1952:../src/stm32f30x_rtc.c **** 
1953:../src/stm32f30x_rtc.c **** /**
1954:../src/stm32f30x_rtc.c ****   * @brief  Configures the select Tamper pin edge.
1955:../src/stm32f30x_rtc.c ****   * @param  RTC_Tamper: Selected tamper pin.
1956:../src/stm32f30x_rtc.c ****   *   This parameter can be any combination of the following values:
1957:../src/stm32f30x_rtc.c ****   *     @arg RTC_Tamper_1: Select Tamper 1.
1958:../src/stm32f30x_rtc.c ****   *     @arg RTC_Tamper_2: Select Tamper 2.
1959:../src/stm32f30x_rtc.c ****   *     @arg RTC_Tamper_3: Select Tamper 3.
1960:../src/stm32f30x_rtc.c ****   * @param  RTC_TamperTrigger: Specifies the trigger on the tamper pin that 
1961:../src/stm32f30x_rtc.c ****   *                            stimulates tamper event. 
1962:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
1963:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperTrigger_RisingEdge: Rising Edge of the tamper pin causes tamper event.
1964:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperTrigger_FallingEdge: Falling Edge of the tamper pin causes tamper event.
1965:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperTrigger_LowLevel: Low Level of the tamper pin causes tamper event.
1966:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperTrigger_HighLevel: High Level of the tamper pin causes tamper event.
1967:../src/stm32f30x_rtc.c ****   * @retval None
1968:../src/stm32f30x_rtc.c ****   */
1969:../src/stm32f30x_rtc.c **** void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
1970:../src/stm32f30x_rtc.c **** {
 3186              		.loc 1 1970 0
 3187              		.cfi_startproc
 3188              		@ args = 0, pretend = 0, frame = 8
 3189              		@ frame_needed = 1, uses_anonymous_args = 0
 3190              		@ link register save eliminated.
 3191 1480 80B4     		push	{r7}
 3192              	.LCFI101:
 3193              		.cfi_def_cfa_offset 4
 3194              		.cfi_offset 7, -4
 3195 1482 83B0     		sub	sp, sp, #12
 3196              	.LCFI102:
 3197              		.cfi_def_cfa_offset 16
 3198 1484 00AF     		add	r7, sp, #0
 3199              	.LCFI103:
 3200              		.cfi_def_cfa_register 7
 3201 1486 7860     		str	r0, [r7, #4]
 3202 1488 3960     		str	r1, [r7, #0]
1971:../src/stm32f30x_rtc.c ****   /* Check the parameters */
1972:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
1973:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
1974:../src/stm32f30x_rtc.c ****  
1975:../src/stm32f30x_rtc.c ****   /* Check if the  active level for Tamper is rising edge (Low level)*/
1976:../src/stm32f30x_rtc.c ****   if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
 3203              		.loc 1 1976 0
 3204 148a 3B68     		ldr	r3, [r7, #0]
 3205 148c 002B     		cmp	r3, #0
 3206 148e 10D1     		bne	.L135
1977:../src/stm32f30x_rtc.c ****   {  
1978:../src/stm32f30x_rtc.c ****     /* Configure the RTC_TAFCR register */
1979:../src/stm32f30x_rtc.c ****     RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
 3207              		.loc 1 1979 0
 3208 1490 4FF42053 		mov	r3, #10240
 3209 1494 C4F20003 		movt	r3, 16384
 3210 1498 4FF42052 		mov	r2, #10240
 3211 149c C4F20002 		movt	r2, 16384
 3212 14a0 116C     		ldr	r1, [r2, #64]
 3213 14a2 7A68     		ldr	r2, [r7, #4]
 3214 14a4 4FEA4202 		lsl	r2, r2, #1
 3215 14a8 6FEA0202 		mvn	r2, r2
 3216 14ac 0A40     		ands	r2, r2, r1
 3217 14ae 1A64     		str	r2, [r3, #64]
 3218 14b0 0DE0     		b	.L134
 3219              	.L135:
1980:../src/stm32f30x_rtc.c ****   }
1981:../src/stm32f30x_rtc.c ****   else
1982:../src/stm32f30x_rtc.c ****   { 
1983:../src/stm32f30x_rtc.c ****     /* Configure the RTC_TAFCR register */
1984:../src/stm32f30x_rtc.c ****     RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
 3220              		.loc 1 1984 0
 3221 14b2 4FF42053 		mov	r3, #10240
 3222 14b6 C4F20003 		movt	r3, 16384
 3223 14ba 4FF42052 		mov	r2, #10240
 3224 14be C4F20002 		movt	r2, 16384
 3225 14c2 116C     		ldr	r1, [r2, #64]
 3226 14c4 7A68     		ldr	r2, [r7, #4]
 3227 14c6 4FEA4202 		lsl	r2, r2, #1
 3228 14ca 0A43     		orrs	r2, r2, r1
 3229 14cc 1A64     		str	r2, [r3, #64]
 3230              	.L134:
1985:../src/stm32f30x_rtc.c ****   }  
1986:../src/stm32f30x_rtc.c **** }
 3231              		.loc 1 1986 0
 3232 14ce 07F10C07 		add	r7, r7, #12
 3233 14d2 BD46     		mov	sp, r7
 3234 14d4 80BC     		pop	{r7}
 3235 14d6 7047     		bx	lr
 3236              		.cfi_endproc
 3237              	.LFE146:
 3239              		.align	2
 3240              		.global	RTC_TamperCmd
 3241              		.thumb
 3242              		.thumb_func
 3244              	RTC_TamperCmd:
 3245              	.LFB147:
1987:../src/stm32f30x_rtc.c **** 
1988:../src/stm32f30x_rtc.c **** /**
1989:../src/stm32f30x_rtc.c ****   * @brief  Enables or Disables the Tamper detection.
1990:../src/stm32f30x_rtc.c ****   * @param  RTC_Tamper: Selected tamper pin.
1991:../src/stm32f30x_rtc.c ****   *   This parameter can be any combination of the following values:
1992:../src/stm32f30x_rtc.c ****   *     @arg RTC_Tamper_1: Select Tamper 1.
1993:../src/stm32f30x_rtc.c ****   *     @arg RTC_Tamper_2: Select Tamper 2.
1994:../src/stm32f30x_rtc.c ****   *     @arg RTC_Tamper_3: Select Tamper 3.
1995:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the tamper pin.
1996:../src/stm32f30x_rtc.c ****   *         This parameter can be: ENABLE or DISABLE.                   
1997:../src/stm32f30x_rtc.c ****   * @retval None
1998:../src/stm32f30x_rtc.c ****   */
1999:../src/stm32f30x_rtc.c **** void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
2000:../src/stm32f30x_rtc.c **** {
 3246              		.loc 1 2000 0
 3247              		.cfi_startproc
 3248              		@ args = 0, pretend = 0, frame = 8
 3249              		@ frame_needed = 1, uses_anonymous_args = 0
 3250              		@ link register save eliminated.
 3251 14d8 80B4     		push	{r7}
 3252              	.LCFI104:
 3253              		.cfi_def_cfa_offset 4
 3254              		.cfi_offset 7, -4
 3255 14da 83B0     		sub	sp, sp, #12
 3256              	.LCFI105:
 3257              		.cfi_def_cfa_offset 16
 3258 14dc 00AF     		add	r7, sp, #0
 3259              	.LCFI106:
 3260              		.cfi_def_cfa_register 7
 3261 14de 7860     		str	r0, [r7, #4]
 3262 14e0 0B46     		mov	r3, r1
 3263 14e2 FB70     		strb	r3, [r7, #3]
2001:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2002:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_TAMPER(RTC_Tamper));  
2003:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
2004:../src/stm32f30x_rtc.c ****   
2005:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 3264              		.loc 1 2005 0
 3265 14e4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 3266 14e6 002B     		cmp	r3, #0
 3267 14e8 0CD0     		beq	.L138
2006:../src/stm32f30x_rtc.c ****   {
2007:../src/stm32f30x_rtc.c ****     /* Enable the selected Tamper pin */
2008:../src/stm32f30x_rtc.c ****     RTC->TAFCR |= (uint32_t)RTC_Tamper;
 3268              		.loc 1 2008 0
 3269 14ea 4FF42053 		mov	r3, #10240
 3270 14ee C4F20003 		movt	r3, 16384
 3271 14f2 4FF42052 		mov	r2, #10240
 3272 14f6 C4F20002 		movt	r2, 16384
 3273 14fa 116C     		ldr	r1, [r2, #64]
 3274 14fc 7A68     		ldr	r2, [r7, #4]
 3275 14fe 0A43     		orrs	r2, r2, r1
 3276 1500 1A64     		str	r2, [r3, #64]
 3277 1502 0DE0     		b	.L137
 3278              	.L138:
2009:../src/stm32f30x_rtc.c ****   }
2010:../src/stm32f30x_rtc.c ****   else
2011:../src/stm32f30x_rtc.c ****   {
2012:../src/stm32f30x_rtc.c ****     /* Disable the selected Tamper pin */
2013:../src/stm32f30x_rtc.c ****     RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
 3279              		.loc 1 2013 0
 3280 1504 4FF42053 		mov	r3, #10240
 3281 1508 C4F20003 		movt	r3, 16384
 3282 150c 4FF42052 		mov	r2, #10240
 3283 1510 C4F20002 		movt	r2, 16384
 3284 1514 116C     		ldr	r1, [r2, #64]
 3285 1516 7A68     		ldr	r2, [r7, #4]
 3286 1518 6FEA0202 		mvn	r2, r2
 3287 151c 0A40     		ands	r2, r2, r1
 3288 151e 1A64     		str	r2, [r3, #64]
 3289              	.L137:
2014:../src/stm32f30x_rtc.c ****   }  
2015:../src/stm32f30x_rtc.c **** }
 3290              		.loc 1 2015 0
 3291 1520 07F10C07 		add	r7, r7, #12
 3292 1524 BD46     		mov	sp, r7
 3293 1526 80BC     		pop	{r7}
 3294 1528 7047     		bx	lr
 3295              		.cfi_endproc
 3296              	.LFE147:
 3298 152a 00BF     		.align	2
 3299              		.global	RTC_TamperFilterConfig
 3300              		.thumb
 3301              		.thumb_func
 3303              	RTC_TamperFilterConfig:
 3304              	.LFB148:
2016:../src/stm32f30x_rtc.c **** 
2017:../src/stm32f30x_rtc.c **** /**
2018:../src/stm32f30x_rtc.c ****   * @brief  Configures the Tampers Filter.
2019:../src/stm32f30x_rtc.c ****   * @param  RTC_TamperFilter: Specifies the tampers filter.
2020:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
2021:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperFilter_Disable: Tamper filter is disabled.
2022:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperFilter_2Sample: Tamper is activated after 2 consecutive 
2023:../src/stm32f30x_rtc.c ****   *                                    samples at the active level 
2024:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperFilter_4Sample: Tamper is activated after 4 consecutive 
2025:../src/stm32f30x_rtc.c ****   *                                    samples at the active level
2026:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperFilter_8Sample: Tamper is activated after 8 consecutive 
2027:../src/stm32f30x_rtc.c ****   *                                    samples at the active level 
2028:../src/stm32f30x_rtc.c ****   * @retval None
2029:../src/stm32f30x_rtc.c ****   */
2030:../src/stm32f30x_rtc.c **** void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
2031:../src/stm32f30x_rtc.c **** {
 3305              		.loc 1 2031 0
 3306              		.cfi_startproc
 3307              		@ args = 0, pretend = 0, frame = 8
 3308              		@ frame_needed = 1, uses_anonymous_args = 0
 3309              		@ link register save eliminated.
 3310 152c 80B4     		push	{r7}
 3311              	.LCFI107:
 3312              		.cfi_def_cfa_offset 4
 3313              		.cfi_offset 7, -4
 3314 152e 83B0     		sub	sp, sp, #12
 3315              	.LCFI108:
 3316              		.cfi_def_cfa_offset 16
 3317 1530 00AF     		add	r7, sp, #0
 3318              	.LCFI109:
 3319              		.cfi_def_cfa_register 7
 3320 1532 7860     		str	r0, [r7, #4]
2032:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2033:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
2034:../src/stm32f30x_rtc.c ****    
2035:../src/stm32f30x_rtc.c ****   /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
2036:../src/stm32f30x_rtc.c ****   RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
 3321              		.loc 1 2036 0
 3322 1534 4FF42053 		mov	r3, #10240
 3323 1538 C4F20003 		movt	r3, 16384
 3324 153c 4FF42052 		mov	r2, #10240
 3325 1540 C4F20002 		movt	r2, 16384
 3326 1544 126C     		ldr	r2, [r2, #64]
 3327 1546 22F4C052 		bic	r2, r2, #6144
 3328 154a 1A64     		str	r2, [r3, #64]
2037:../src/stm32f30x_rtc.c **** 
2038:../src/stm32f30x_rtc.c ****   /* Configure the RTC_TAFCR register */
2039:../src/stm32f30x_rtc.c ****   RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
 3329              		.loc 1 2039 0
 3330 154c 4FF42053 		mov	r3, #10240
 3331 1550 C4F20003 		movt	r3, 16384
 3332 1554 4FF42052 		mov	r2, #10240
 3333 1558 C4F20002 		movt	r2, 16384
 3334 155c 116C     		ldr	r1, [r2, #64]
 3335 155e 7A68     		ldr	r2, [r7, #4]
 3336 1560 0A43     		orrs	r2, r2, r1
 3337 1562 1A64     		str	r2, [r3, #64]
2040:../src/stm32f30x_rtc.c **** }
 3338              		.loc 1 2040 0
 3339 1564 07F10C07 		add	r7, r7, #12
 3340 1568 BD46     		mov	sp, r7
 3341 156a 80BC     		pop	{r7}
 3342 156c 7047     		bx	lr
 3343              		.cfi_endproc
 3344              	.LFE148:
 3346 156e 00BF     		.align	2
 3347              		.global	RTC_TamperSamplingFreqConfig
 3348              		.thumb
 3349              		.thumb_func
 3351              	RTC_TamperSamplingFreqConfig:
 3352              	.LFB149:
2041:../src/stm32f30x_rtc.c **** 
2042:../src/stm32f30x_rtc.c **** /**
2043:../src/stm32f30x_rtc.c ****   * @brief  Configures the Tampers Sampling Frequency.
2044:../src/stm32f30x_rtc.c ****   * @param  RTC_TamperSamplingFreq: Specifies the tampers Sampling Frequency.
2045:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
2046:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div32768: Each of the tamper inputs are sampled
2047:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 32768
2048:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div16384: Each of the tamper inputs are sampled
2049:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 16384
2050:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div8192: Each of the tamper inputs are sampled
2051:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 8192
2052:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div4096: Each of the tamper inputs are sampled
2053:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 4096
2054:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div2048: Each of the tamper inputs are sampled
2055:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 2048
2056:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div1024: Each of the tamper inputs are sampled
2057:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 1024
2058:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div512: Each of the tamper inputs are sampled
2059:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 512  
2060:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperSamplingFreq_RTCCLK_Div256: Each of the tamper inputs are sampled
2061:../src/stm32f30x_rtc.c ****   *                                           with a frequency =  RTCCLK / 256  
2062:../src/stm32f30x_rtc.c ****   * @retval None
2063:../src/stm32f30x_rtc.c ****   */
2064:../src/stm32f30x_rtc.c **** void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
2065:../src/stm32f30x_rtc.c **** {
 3353              		.loc 1 2065 0
 3354              		.cfi_startproc
 3355              		@ args = 0, pretend = 0, frame = 8
 3356              		@ frame_needed = 1, uses_anonymous_args = 0
 3357              		@ link register save eliminated.
 3358 1570 80B4     		push	{r7}
 3359              	.LCFI110:
 3360              		.cfi_def_cfa_offset 4
 3361              		.cfi_offset 7, -4
 3362 1572 83B0     		sub	sp, sp, #12
 3363              	.LCFI111:
 3364              		.cfi_def_cfa_offset 16
 3365 1574 00AF     		add	r7, sp, #0
 3366              	.LCFI112:
 3367              		.cfi_def_cfa_register 7
 3368 1576 7860     		str	r0, [r7, #4]
2066:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2067:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
2068:../src/stm32f30x_rtc.c ****  
2069:../src/stm32f30x_rtc.c ****   /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
2070:../src/stm32f30x_rtc.c ****   RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
 3369              		.loc 1 2070 0
 3370 1578 4FF42053 		mov	r3, #10240
 3371 157c C4F20003 		movt	r3, 16384
 3372 1580 4FF42052 		mov	r2, #10240
 3373 1584 C4F20002 		movt	r2, 16384
 3374 1588 126C     		ldr	r2, [r2, #64]
 3375 158a 22F4E062 		bic	r2, r2, #1792
 3376 158e 1A64     		str	r2, [r3, #64]
2071:../src/stm32f30x_rtc.c **** 
2072:../src/stm32f30x_rtc.c ****   /* Configure the RTC_TAFCR register */
2073:../src/stm32f30x_rtc.c ****   RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
 3377              		.loc 1 2073 0
 3378 1590 4FF42053 		mov	r3, #10240
 3379 1594 C4F20003 		movt	r3, 16384
 3380 1598 4FF42052 		mov	r2, #10240
 3381 159c C4F20002 		movt	r2, 16384
 3382 15a0 116C     		ldr	r1, [r2, #64]
 3383 15a2 7A68     		ldr	r2, [r7, #4]
 3384 15a4 0A43     		orrs	r2, r2, r1
 3385 15a6 1A64     		str	r2, [r3, #64]
2074:../src/stm32f30x_rtc.c **** }
 3386              		.loc 1 2074 0
 3387 15a8 07F10C07 		add	r7, r7, #12
 3388 15ac BD46     		mov	sp, r7
 3389 15ae 80BC     		pop	{r7}
 3390 15b0 7047     		bx	lr
 3391              		.cfi_endproc
 3392              	.LFE149:
 3394 15b2 00BF     		.align	2
 3395              		.global	RTC_TamperPinsPrechargeDuration
 3396              		.thumb
 3397              		.thumb_func
 3399              	RTC_TamperPinsPrechargeDuration:
 3400              	.LFB150:
2075:../src/stm32f30x_rtc.c **** 
2076:../src/stm32f30x_rtc.c **** /**
2077:../src/stm32f30x_rtc.c ****   * @brief  Configures the Tampers Pins input Precharge Duration.
2078:../src/stm32f30x_rtc.c ****   * @param  RTC_TamperPrechargeDuration: Specifies the Tampers Pins input
2079:../src/stm32f30x_rtc.c ****   *         Precharge Duration.
2080:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
2081:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperPrechargeDuration_1RTCCLK: Tamper pins are pre-charged before sampling durin
2082:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperPrechargeDuration_2RTCCLK: Tamper pins are pre-charged before sampling durin
2083:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperPrechargeDuration_4RTCCLK: Tamper pins are pre-charged before sampling durin
2084:../src/stm32f30x_rtc.c ****   *     @arg RTC_TamperPrechargeDuration_8RTCCLK: Tamper pins are pre-charged before sampling durin
2085:../src/stm32f30x_rtc.c ****   * @retval None
2086:../src/stm32f30x_rtc.c ****   */
2087:../src/stm32f30x_rtc.c **** void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
2088:../src/stm32f30x_rtc.c **** {
 3401              		.loc 1 2088 0
 3402              		.cfi_startproc
 3403              		@ args = 0, pretend = 0, frame = 8
 3404              		@ frame_needed = 1, uses_anonymous_args = 0
 3405              		@ link register save eliminated.
 3406 15b4 80B4     		push	{r7}
 3407              	.LCFI113:
 3408              		.cfi_def_cfa_offset 4
 3409              		.cfi_offset 7, -4
 3410 15b6 83B0     		sub	sp, sp, #12
 3411              	.LCFI114:
 3412              		.cfi_def_cfa_offset 16
 3413 15b8 00AF     		add	r7, sp, #0
 3414              	.LCFI115:
 3415              		.cfi_def_cfa_register 7
 3416 15ba 7860     		str	r0, [r7, #4]
2089:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2090:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
2091:../src/stm32f30x_rtc.c ****    
2092:../src/stm32f30x_rtc.c ****   /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
2093:../src/stm32f30x_rtc.c ****   RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
 3417              		.loc 1 2093 0
 3418 15bc 4FF42053 		mov	r3, #10240
 3419 15c0 C4F20003 		movt	r3, 16384
 3420 15c4 4FF42052 		mov	r2, #10240
 3421 15c8 C4F20002 		movt	r2, 16384
 3422 15cc 126C     		ldr	r2, [r2, #64]
 3423 15ce 22F4C042 		bic	r2, r2, #24576
 3424 15d2 1A64     		str	r2, [r3, #64]
2094:../src/stm32f30x_rtc.c **** 
2095:../src/stm32f30x_rtc.c ****   /* Configure the RTC_TAFCR register */
2096:../src/stm32f30x_rtc.c ****   RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
 3425              		.loc 1 2096 0
 3426 15d4 4FF42053 		mov	r3, #10240
 3427 15d8 C4F20003 		movt	r3, 16384
 3428 15dc 4FF42052 		mov	r2, #10240
 3429 15e0 C4F20002 		movt	r2, 16384
 3430 15e4 116C     		ldr	r1, [r2, #64]
 3431 15e6 7A68     		ldr	r2, [r7, #4]
 3432 15e8 0A43     		orrs	r2, r2, r1
 3433 15ea 1A64     		str	r2, [r3, #64]
2097:../src/stm32f30x_rtc.c **** }
 3434              		.loc 1 2097 0
 3435 15ec 07F10C07 		add	r7, r7, #12
 3436 15f0 BD46     		mov	sp, r7
 3437 15f2 80BC     		pop	{r7}
 3438 15f4 7047     		bx	lr
 3439              		.cfi_endproc
 3440              	.LFE150:
 3442 15f6 00BF     		.align	2
 3443              		.global	RTC_TimeStampOnTamperDetectionCmd
 3444              		.thumb
 3445              		.thumb_func
 3447              	RTC_TimeStampOnTamperDetectionCmd:
 3448              	.LFB151:
2098:../src/stm32f30x_rtc.c **** 
2099:../src/stm32f30x_rtc.c **** /**
2100:../src/stm32f30x_rtc.c ****   * @brief  Enables or Disables the TimeStamp on Tamper Detection Event.
2101:../src/stm32f30x_rtc.c ****   * @note   The timestamp is valid even the TSE bit in tamper control register 
2102:../src/stm32f30x_rtc.c ****   *         is reset.   
2103:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the timestamp on tamper event.
2104:../src/stm32f30x_rtc.c ****   *         This parameter can be: ENABLE or DISABLE.
2105:../src/stm32f30x_rtc.c ****   * @retval None
2106:../src/stm32f30x_rtc.c ****   */
2107:../src/stm32f30x_rtc.c **** void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
2108:../src/stm32f30x_rtc.c **** {
 3449              		.loc 1 2108 0
 3450              		.cfi_startproc
 3451              		@ args = 0, pretend = 0, frame = 8
 3452              		@ frame_needed = 1, uses_anonymous_args = 0
 3453              		@ link register save eliminated.
 3454 15f8 80B4     		push	{r7}
 3455              	.LCFI116:
 3456              		.cfi_def_cfa_offset 4
 3457              		.cfi_offset 7, -4
 3458 15fa 83B0     		sub	sp, sp, #12
 3459              	.LCFI117:
 3460              		.cfi_def_cfa_offset 16
 3461 15fc 00AF     		add	r7, sp, #0
 3462              	.LCFI118:
 3463              		.cfi_def_cfa_register 7
 3464 15fe 0346     		mov	r3, r0
 3465 1600 FB71     		strb	r3, [r7, #7]
2109:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2110:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
2111:../src/stm32f30x_rtc.c ****    
2112:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 3466              		.loc 1 2112 0
 3467 1602 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3468 1604 002B     		cmp	r3, #0
 3469 1606 0CD0     		beq	.L144
2113:../src/stm32f30x_rtc.c ****   {
2114:../src/stm32f30x_rtc.c ****     /* Save timestamp on tamper detection event */
2115:../src/stm32f30x_rtc.c ****     RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
 3470              		.loc 1 2115 0
 3471 1608 4FF42053 		mov	r3, #10240
 3472 160c C4F20003 		movt	r3, 16384
 3473 1610 4FF42052 		mov	r2, #10240
 3474 1614 C4F20002 		movt	r2, 16384
 3475 1618 126C     		ldr	r2, [r2, #64]
 3476 161a 42F08002 		orr	r2, r2, #128
 3477 161e 1A64     		str	r2, [r3, #64]
 3478 1620 0BE0     		b	.L143
 3479              	.L144:
2116:../src/stm32f30x_rtc.c ****   }
2117:../src/stm32f30x_rtc.c ****   else
2118:../src/stm32f30x_rtc.c ****   {
2119:../src/stm32f30x_rtc.c ****     /* Tamper detection does not cause a timestamp to be saved */
2120:../src/stm32f30x_rtc.c ****     RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
 3480              		.loc 1 2120 0
 3481 1622 4FF42053 		mov	r3, #10240
 3482 1626 C4F20003 		movt	r3, 16384
 3483 162a 4FF42052 		mov	r2, #10240
 3484 162e C4F20002 		movt	r2, 16384
 3485 1632 126C     		ldr	r2, [r2, #64]
 3486 1634 22F08002 		bic	r2, r2, #128
 3487 1638 1A64     		str	r2, [r3, #64]
 3488              	.L143:
2121:../src/stm32f30x_rtc.c ****   }
2122:../src/stm32f30x_rtc.c **** }
 3489              		.loc 1 2122 0
 3490 163a 07F10C07 		add	r7, r7, #12
 3491 163e BD46     		mov	sp, r7
 3492 1640 80BC     		pop	{r7}
 3493 1642 7047     		bx	lr
 3494              		.cfi_endproc
 3495              	.LFE151:
 3497              		.align	2
 3498              		.global	RTC_TamperPullUpCmd
 3499              		.thumb
 3500              		.thumb_func
 3502              	RTC_TamperPullUpCmd:
 3503              	.LFB152:
2123:../src/stm32f30x_rtc.c **** 
2124:../src/stm32f30x_rtc.c **** /**
2125:../src/stm32f30x_rtc.c ****   * @brief  Enables or Disables the Precharge of Tamper pin.
2126:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of tamper pull up.
2127:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.                   
2128:../src/stm32f30x_rtc.c ****   * @retval None
2129:../src/stm32f30x_rtc.c ****   */
2130:../src/stm32f30x_rtc.c **** void RTC_TamperPullUpCmd(FunctionalState NewState)
2131:../src/stm32f30x_rtc.c **** {
 3504              		.loc 1 2131 0
 3505              		.cfi_startproc
 3506              		@ args = 0, pretend = 0, frame = 8
 3507              		@ frame_needed = 1, uses_anonymous_args = 0
 3508              		@ link register save eliminated.
 3509 1644 80B4     		push	{r7}
 3510              	.LCFI119:
 3511              		.cfi_def_cfa_offset 4
 3512              		.cfi_offset 7, -4
 3513 1646 83B0     		sub	sp, sp, #12
 3514              	.LCFI120:
 3515              		.cfi_def_cfa_offset 16
 3516 1648 00AF     		add	r7, sp, #0
 3517              	.LCFI121:
 3518              		.cfi_def_cfa_register 7
 3519 164a 0346     		mov	r3, r0
 3520 164c FB71     		strb	r3, [r7, #7]
2132:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2133:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
2134:../src/stm32f30x_rtc.c ****   
2135:../src/stm32f30x_rtc.c ****  if (NewState != DISABLE)
 3521              		.loc 1 2135 0
 3522 164e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 3523 1650 002B     		cmp	r3, #0
 3524 1652 0CD0     		beq	.L147
2136:../src/stm32f30x_rtc.c ****   {
2137:../src/stm32f30x_rtc.c ****     /* Enable precharge of the selected Tamper pin */
2138:../src/stm32f30x_rtc.c ****     RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
 3525              		.loc 1 2138 0
 3526 1654 4FF42053 		mov	r3, #10240
 3527 1658 C4F20003 		movt	r3, 16384
 3528 165c 4FF42052 		mov	r2, #10240
 3529 1660 C4F20002 		movt	r2, 16384
 3530 1664 126C     		ldr	r2, [r2, #64]
 3531 1666 22F40042 		bic	r2, r2, #32768
 3532 166a 1A64     		str	r2, [r3, #64]
 3533 166c 0BE0     		b	.L146
 3534              	.L147:
2139:../src/stm32f30x_rtc.c ****   }
2140:../src/stm32f30x_rtc.c ****   else
2141:../src/stm32f30x_rtc.c ****   {
2142:../src/stm32f30x_rtc.c ****     /* Disable precharge of the selected Tamper pin */
2143:../src/stm32f30x_rtc.c ****     RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
 3535              		.loc 1 2143 0
 3536 166e 4FF42053 		mov	r3, #10240
 3537 1672 C4F20003 		movt	r3, 16384
 3538 1676 4FF42052 		mov	r2, #10240
 3539 167a C4F20002 		movt	r2, 16384
 3540 167e 126C     		ldr	r2, [r2, #64]
 3541 1680 42F40042 		orr	r2, r2, #32768
 3542 1684 1A64     		str	r2, [r3, #64]
 3543              	.L146:
2144:../src/stm32f30x_rtc.c ****   } 
2145:../src/stm32f30x_rtc.c **** }
 3544              		.loc 1 2145 0
 3545 1686 07F10C07 		add	r7, r7, #12
 3546 168a BD46     		mov	sp, r7
 3547 168c 80BC     		pop	{r7}
 3548 168e 7047     		bx	lr
 3549              		.cfi_endproc
 3550              	.LFE152:
 3552              		.align	2
 3553              		.global	RTC_WriteBackupRegister
 3554              		.thumb
 3555              		.thumb_func
 3557              	RTC_WriteBackupRegister:
 3558              	.LFB153:
2146:../src/stm32f30x_rtc.c **** 
2147:../src/stm32f30x_rtc.c **** /**
2148:../src/stm32f30x_rtc.c ****   * @}
2149:../src/stm32f30x_rtc.c ****   */
2150:../src/stm32f30x_rtc.c **** 
2151:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group10 Backup Data Registers configuration functions
2152:../src/stm32f30x_rtc.c ****  *  @brief   Backup Data Registers configuration functions  
2153:../src/stm32f30x_rtc.c ****  *
2154:../src/stm32f30x_rtc.c **** @verbatim   
2155:../src/stm32f30x_rtc.c ****  ===============================================================================
2156:../src/stm32f30x_rtc.c ****           ##### Backup Data Registers configuration functions #####
2157:../src/stm32f30x_rtc.c ****  ===============================================================================  
2158:../src/stm32f30x_rtc.c **** 
2159:../src/stm32f30x_rtc.c **** @endverbatim
2160:../src/stm32f30x_rtc.c ****   * @{
2161:../src/stm32f30x_rtc.c ****   */
2162:../src/stm32f30x_rtc.c **** 
2163:../src/stm32f30x_rtc.c **** /**
2164:../src/stm32f30x_rtc.c ****   * @brief  Writes a data in a specified RTC Backup data register.
2165:../src/stm32f30x_rtc.c ****   * @param  RTC_BKP_DR: RTC Backup data Register number.
2166:../src/stm32f30x_rtc.c ****   *   This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
2167:../src/stm32f30x_rtc.c ****   *                          specify the register.
2168:../src/stm32f30x_rtc.c ****   * @param  Data: Data to be written in the specified RTC Backup data register.                    
2169:../src/stm32f30x_rtc.c ****   * @retval None
2170:../src/stm32f30x_rtc.c ****   */
2171:../src/stm32f30x_rtc.c **** void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
2172:../src/stm32f30x_rtc.c **** {
 3559              		.loc 1 2172 0
 3560              		.cfi_startproc
 3561              		@ args = 0, pretend = 0, frame = 16
 3562              		@ frame_needed = 1, uses_anonymous_args = 0
 3563              		@ link register save eliminated.
 3564 1690 80B4     		push	{r7}
 3565              	.LCFI122:
 3566              		.cfi_def_cfa_offset 4
 3567              		.cfi_offset 7, -4
 3568 1692 85B0     		sub	sp, sp, #20
 3569              	.LCFI123:
 3570              		.cfi_def_cfa_offset 24
 3571 1694 00AF     		add	r7, sp, #0
 3572              	.LCFI124:
 3573              		.cfi_def_cfa_register 7
 3574 1696 7860     		str	r0, [r7, #4]
 3575 1698 3960     		str	r1, [r7, #0]
2173:../src/stm32f30x_rtc.c ****   __IO uint32_t tmp = 0;
 3576              		.loc 1 2173 0
 3577 169a 4FF00003 		mov	r3, #0
 3578 169e FB60     		str	r3, [r7, #12]
2174:../src/stm32f30x_rtc.c ****   
2175:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2176:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_BKP(RTC_BKP_DR));
2177:../src/stm32f30x_rtc.c **** 
2178:../src/stm32f30x_rtc.c ****   tmp = RTC_BASE + 0x50;
 3579              		.loc 1 2178 0
 3580 16a0 42F65003 		movw	r3, #10320
 3581 16a4 C4F20003 		movt	r3, 16384
 3582 16a8 FB60     		str	r3, [r7, #12]
2179:../src/stm32f30x_rtc.c ****   tmp += (RTC_BKP_DR * 4);
 3583              		.loc 1 2179 0
 3584 16aa 7B68     		ldr	r3, [r7, #4]
 3585 16ac 4FEA8302 		lsl	r2, r3, #2
 3586 16b0 FB68     		ldr	r3, [r7, #12]
 3587 16b2 D318     		adds	r3, r2, r3
 3588 16b4 FB60     		str	r3, [r7, #12]
2180:../src/stm32f30x_rtc.c **** 
2181:../src/stm32f30x_rtc.c ****   /* Write the specified register */
2182:../src/stm32f30x_rtc.c ****   *(__IO uint32_t *)tmp = (uint32_t)Data;
 3589              		.loc 1 2182 0
 3590 16b6 FB68     		ldr	r3, [r7, #12]
 3591 16b8 3A68     		ldr	r2, [r7, #0]
 3592 16ba 1A60     		str	r2, [r3, #0]
2183:../src/stm32f30x_rtc.c **** }
 3593              		.loc 1 2183 0
 3594 16bc 07F11407 		add	r7, r7, #20
 3595 16c0 BD46     		mov	sp, r7
 3596 16c2 80BC     		pop	{r7}
 3597 16c4 7047     		bx	lr
 3598              		.cfi_endproc
 3599              	.LFE153:
 3601 16c6 00BF     		.align	2
 3602              		.global	RTC_ReadBackupRegister
 3603              		.thumb
 3604              		.thumb_func
 3606              	RTC_ReadBackupRegister:
 3607              	.LFB154:
2184:../src/stm32f30x_rtc.c **** 
2185:../src/stm32f30x_rtc.c **** /**
2186:../src/stm32f30x_rtc.c ****   * @brief  Reads data from the specified RTC Backup data Register.
2187:../src/stm32f30x_rtc.c ****   * @param  RTC_BKP_DR: RTC Backup data Register number.
2188:../src/stm32f30x_rtc.c ****   *   This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
2189:../src/stm32f30x_rtc.c ****   *                          specify the register.                   
2190:../src/stm32f30x_rtc.c ****   * @retval None
2191:../src/stm32f30x_rtc.c ****   */
2192:../src/stm32f30x_rtc.c **** uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
2193:../src/stm32f30x_rtc.c **** {
 3608              		.loc 1 2193 0
 3609              		.cfi_startproc
 3610              		@ args = 0, pretend = 0, frame = 16
 3611              		@ frame_needed = 1, uses_anonymous_args = 0
 3612              		@ link register save eliminated.
 3613 16c8 80B4     		push	{r7}
 3614              	.LCFI125:
 3615              		.cfi_def_cfa_offset 4
 3616              		.cfi_offset 7, -4
 3617 16ca 85B0     		sub	sp, sp, #20
 3618              	.LCFI126:
 3619              		.cfi_def_cfa_offset 24
 3620 16cc 00AF     		add	r7, sp, #0
 3621              	.LCFI127:
 3622              		.cfi_def_cfa_register 7
 3623 16ce 7860     		str	r0, [r7, #4]
2194:../src/stm32f30x_rtc.c ****   __IO uint32_t tmp = 0;
 3624              		.loc 1 2194 0
 3625 16d0 4FF00003 		mov	r3, #0
 3626 16d4 FB60     		str	r3, [r7, #12]
2195:../src/stm32f30x_rtc.c ****   
2196:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2197:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_BKP(RTC_BKP_DR));
2198:../src/stm32f30x_rtc.c **** 
2199:../src/stm32f30x_rtc.c ****   tmp = RTC_BASE + 0x50;
 3627              		.loc 1 2199 0
 3628 16d6 42F65003 		movw	r3, #10320
 3629 16da C4F20003 		movt	r3, 16384
 3630 16de FB60     		str	r3, [r7, #12]
2200:../src/stm32f30x_rtc.c ****   tmp += (RTC_BKP_DR * 4);
 3631              		.loc 1 2200 0
 3632 16e0 7B68     		ldr	r3, [r7, #4]
 3633 16e2 4FEA8302 		lsl	r2, r3, #2
 3634 16e6 FB68     		ldr	r3, [r7, #12]
 3635 16e8 D318     		adds	r3, r2, r3
 3636 16ea FB60     		str	r3, [r7, #12]
2201:../src/stm32f30x_rtc.c ****   
2202:../src/stm32f30x_rtc.c ****   /* Read the specified register */
2203:../src/stm32f30x_rtc.c ****   return (*(__IO uint32_t *)tmp);
 3637              		.loc 1 2203 0
 3638 16ec FB68     		ldr	r3, [r7, #12]
 3639 16ee 1B68     		ldr	r3, [r3, #0]
2204:../src/stm32f30x_rtc.c **** }
 3640              		.loc 1 2204 0
 3641 16f0 1846     		mov	r0, r3
 3642 16f2 07F11407 		add	r7, r7, #20
 3643 16f6 BD46     		mov	sp, r7
 3644 16f8 80BC     		pop	{r7}
 3645 16fa 7047     		bx	lr
 3646              		.cfi_endproc
 3647              	.LFE154:
 3649              		.align	2
 3650              		.global	RTC_OutputTypeConfig
 3651              		.thumb
 3652              		.thumb_func
 3654              	RTC_OutputTypeConfig:
 3655              	.LFB155:
2205:../src/stm32f30x_rtc.c **** 
2206:../src/stm32f30x_rtc.c **** /**
2207:../src/stm32f30x_rtc.c ****   * @}
2208:../src/stm32f30x_rtc.c ****   */
2209:../src/stm32f30x_rtc.c **** 
2210:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group11 Output Type Config configuration functions
2211:../src/stm32f30x_rtc.c ****  *  @brief   Output Type Config configuration functions  
2212:../src/stm32f30x_rtc.c ****  *
2213:../src/stm32f30x_rtc.c **** @verbatim   
2214:../src/stm32f30x_rtc.c ****  ===============================================================================
2215:../src/stm32f30x_rtc.c ****             ##### Output Type Config configuration functions #####
2216:../src/stm32f30x_rtc.c ****  ===============================================================================  
2217:../src/stm32f30x_rtc.c **** 
2218:../src/stm32f30x_rtc.c **** @endverbatim
2219:../src/stm32f30x_rtc.c ****   * @{
2220:../src/stm32f30x_rtc.c ****   */
2221:../src/stm32f30x_rtc.c **** 
2222:../src/stm32f30x_rtc.c **** /**
2223:../src/stm32f30x_rtc.c ****   * @brief  Configures the RTC Output Pin mode. 
2224:../src/stm32f30x_rtc.c ****   * @param  RTC_OutputType: specifies the RTC Output (PC13) pin mode.
2225:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
2226:../src/stm32f30x_rtc.c ****   *     @arg RTC_OutputType_OpenDrain: RTC Output (PC13) is configured in 
2227:../src/stm32f30x_rtc.c ****   *                                    Open Drain mode.
2228:../src/stm32f30x_rtc.c ****   *     @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
2229:../src/stm32f30x_rtc.c ****   *                                    Push Pull mode.    
2230:../src/stm32f30x_rtc.c ****   * @retval None
2231:../src/stm32f30x_rtc.c ****   */
2232:../src/stm32f30x_rtc.c **** void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
2233:../src/stm32f30x_rtc.c **** {
 3656              		.loc 1 2233 0
 3657              		.cfi_startproc
 3658              		@ args = 0, pretend = 0, frame = 8
 3659              		@ frame_needed = 1, uses_anonymous_args = 0
 3660              		@ link register save eliminated.
 3661 16fc 80B4     		push	{r7}
 3662              	.LCFI128:
 3663              		.cfi_def_cfa_offset 4
 3664              		.cfi_offset 7, -4
 3665 16fe 83B0     		sub	sp, sp, #12
 3666              	.LCFI129:
 3667              		.cfi_def_cfa_offset 16
 3668 1700 00AF     		add	r7, sp, #0
 3669              	.LCFI130:
 3670              		.cfi_def_cfa_register 7
 3671 1702 7860     		str	r0, [r7, #4]
2234:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2235:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
2236:../src/stm32f30x_rtc.c ****   
2237:../src/stm32f30x_rtc.c ****   RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
 3672              		.loc 1 2237 0
 3673 1704 4FF42053 		mov	r3, #10240
 3674 1708 C4F20003 		movt	r3, 16384
 3675 170c 4FF42052 		mov	r2, #10240
 3676 1710 C4F20002 		movt	r2, 16384
 3677 1714 126C     		ldr	r2, [r2, #64]
 3678 1716 22F48022 		bic	r2, r2, #262144
 3679 171a 1A64     		str	r2, [r3, #64]
2238:../src/stm32f30x_rtc.c ****   RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
 3680              		.loc 1 2238 0
 3681 171c 4FF42053 		mov	r3, #10240
 3682 1720 C4F20003 		movt	r3, 16384
 3683 1724 4FF42052 		mov	r2, #10240
 3684 1728 C4F20002 		movt	r2, 16384
 3685 172c 116C     		ldr	r1, [r2, #64]
 3686 172e 7A68     		ldr	r2, [r7, #4]
 3687 1730 0A43     		orrs	r2, r2, r1
 3688 1732 1A64     		str	r2, [r3, #64]
2239:../src/stm32f30x_rtc.c **** }
 3689              		.loc 1 2239 0
 3690 1734 07F10C07 		add	r7, r7, #12
 3691 1738 BD46     		mov	sp, r7
 3692 173a 80BC     		pop	{r7}
 3693 173c 7047     		bx	lr
 3694              		.cfi_endproc
 3695              	.LFE155:
 3697 173e 00BF     		.align	2
 3698              		.global	RTC_SynchroShiftConfig
 3699              		.thumb
 3700              		.thumb_func
 3702              	RTC_SynchroShiftConfig:
 3703              	.LFB156:
2240:../src/stm32f30x_rtc.c **** 
2241:../src/stm32f30x_rtc.c **** /**
2242:../src/stm32f30x_rtc.c ****   * @}
2243:../src/stm32f30x_rtc.c ****   */
2244:../src/stm32f30x_rtc.c **** 
2245:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group12 Shift control synchronisation functions
2246:../src/stm32f30x_rtc.c ****  *  @brief   Shift control synchronisation functions 
2247:../src/stm32f30x_rtc.c ****  *
2248:../src/stm32f30x_rtc.c **** @verbatim   
2249:../src/stm32f30x_rtc.c ****  ===============================================================================
2250:../src/stm32f30x_rtc.c ****               ##### Shift control synchronisation functions #####
2251:../src/stm32f30x_rtc.c ****  ===============================================================================  
2252:../src/stm32f30x_rtc.c **** 
2253:../src/stm32f30x_rtc.c **** @endverbatim
2254:../src/stm32f30x_rtc.c ****   * @{
2255:../src/stm32f30x_rtc.c ****   */
2256:../src/stm32f30x_rtc.c **** 
2257:../src/stm32f30x_rtc.c **** /**
2258:../src/stm32f30x_rtc.c ****   * @brief  Configures the Synchronization Shift Control Settings.
2259:../src/stm32f30x_rtc.c ****   * @note   When REFCKON is set, firmware must not write to Shift control register 
2260:../src/stm32f30x_rtc.c ****   * @param  RTC_ShiftAdd1S : Select to add or not 1 second to the time Calendar.
2261:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values :
2262:../src/stm32f30x_rtc.c ****   *     @arg RTC_ShiftAdd1S_Set  : Add one second to the clock calendar. 
2263:../src/stm32f30x_rtc.c ****   *     @arg RTC_ShiftAdd1S_Reset: No effect.
2264:../src/stm32f30x_rtc.c ****   * @param  RTC_ShiftSubFS: Select the number of Second Fractions to Substitute.
2265:../src/stm32f30x_rtc.c ****   *         This parameter can be one any value from 0 to 0x7FFF.
2266:../src/stm32f30x_rtc.c ****   * @retval An ErrorStatus enumeration value:
2267:../src/stm32f30x_rtc.c ****   *          - SUCCESS: RTC Shift registers are configured
2268:../src/stm32f30x_rtc.c ****   *          - ERROR: RTC Shift registers are not configured
2269:../src/stm32f30x_rtc.c **** */
2270:../src/stm32f30x_rtc.c **** ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
2271:../src/stm32f30x_rtc.c **** {
 3704              		.loc 1 2271 0
 3705              		.cfi_startproc
 3706              		@ args = 0, pretend = 0, frame = 16
 3707              		@ frame_needed = 1, uses_anonymous_args = 0
 3708 1740 80B5     		push	{r7, lr}
 3709              	.LCFI131:
 3710              		.cfi_def_cfa_offset 8
 3711              		.cfi_offset 7, -8
 3712              		.cfi_offset 14, -4
 3713 1742 84B0     		sub	sp, sp, #16
 3714              	.LCFI132:
 3715              		.cfi_def_cfa_offset 24
 3716 1744 00AF     		add	r7, sp, #0
 3717              	.LCFI133:
 3718              		.cfi_def_cfa_register 7
 3719 1746 7860     		str	r0, [r7, #4]
 3720 1748 3960     		str	r1, [r7, #0]
2272:../src/stm32f30x_rtc.c ****   ErrorStatus status = ERROR;
 3721              		.loc 1 2272 0
 3722 174a 4FF00003 		mov	r3, #0
 3723 174e FB73     		strb	r3, [r7, #15]
2273:../src/stm32f30x_rtc.c ****   uint32_t shpfcount = 0;
 3724              		.loc 1 2273 0
 3725 1750 4FF00003 		mov	r3, #0
 3726 1754 BB60     		str	r3, [r7, #8]
2274:../src/stm32f30x_rtc.c **** 
2275:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2276:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
2277:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
2278:../src/stm32f30x_rtc.c **** 
2279:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
2280:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 3727              		.loc 1 2280 0
 3728 1756 4FF42053 		mov	r3, #10240
 3729 175a C4F20003 		movt	r3, 16384
 3730 175e 4FF0CA02 		mov	r2, #202
 3731 1762 5A62     		str	r2, [r3, #36]
2281:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 3732              		.loc 1 2281 0
 3733 1764 4FF42053 		mov	r3, #10240
 3734 1768 C4F20003 		movt	r3, 16384
 3735 176c 4FF05302 		mov	r2, #83
 3736 1770 5A62     		str	r2, [r3, #36]
2282:../src/stm32f30x_rtc.c ****   
2283:../src/stm32f30x_rtc.c ****   /* Check if a Shift is pending*/
2284:../src/stm32f30x_rtc.c ****   if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
 3737              		.loc 1 2284 0
 3738 1772 4FF42053 		mov	r3, #10240
 3739 1776 C4F20003 		movt	r3, 16384
 3740 177a DB68     		ldr	r3, [r3, #12]
 3741 177c 03F00803 		and	r3, r3, #8
 3742 1780 002B     		cmp	r3, #0
 3743 1782 11D0     		beq	.L154
2285:../src/stm32f30x_rtc.c ****   {
2286:../src/stm32f30x_rtc.c ****     /* Wait until the shift is completed*/
2287:../src/stm32f30x_rtc.c ****     while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 3744              		.loc 1 2287 0
 3745 1784 03E0     		b	.L155
 3746              	.L156:
2288:../src/stm32f30x_rtc.c ****     {
2289:../src/stm32f30x_rtc.c ****       shpfcount++;
 3747              		.loc 1 2289 0
 3748 1786 BB68     		ldr	r3, [r7, #8]
 3749 1788 03F10103 		add	r3, r3, #1
 3750 178c BB60     		str	r3, [r7, #8]
 3751              	.L155:
2287:../src/stm32f30x_rtc.c ****     while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 3752              		.loc 1 2287 0 discriminator 1
 3753 178e 4FF42053 		mov	r3, #10240
 3754 1792 C4F20003 		movt	r3, 16384
 3755 1796 DB68     		ldr	r3, [r3, #12]
 3756 1798 03F00803 		and	r3, r3, #8
 3757 179c 002B     		cmp	r3, #0
 3758 179e 03D0     		beq	.L154
2287:../src/stm32f30x_rtc.c ****     while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 3759              		.loc 1 2287 0 is_stmt 0 discriminator 2
 3760 17a0 BB68     		ldr	r3, [r7, #8]
 3761 17a2 B3F5005F 		cmp	r3, #8192
 3762 17a6 EED1     		bne	.L156
 3763              	.L154:
2290:../src/stm32f30x_rtc.c ****     }
2291:../src/stm32f30x_rtc.c ****   }
2292:../src/stm32f30x_rtc.c **** 
2293:../src/stm32f30x_rtc.c ****   /* Check if the Shift pending is completed or if there is no Shift operation at all*/
2294:../src/stm32f30x_rtc.c ****   if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
 3764              		.loc 1 2294 0 is_stmt 1
 3765 17a8 4FF42053 		mov	r3, #10240
 3766 17ac C4F20003 		movt	r3, 16384
 3767 17b0 DB68     		ldr	r3, [r3, #12]
 3768 17b2 03F00803 		and	r3, r3, #8
 3769 17b6 002B     		cmp	r3, #0
 3770 17b8 21D1     		bne	.L157
2295:../src/stm32f30x_rtc.c ****   {
2296:../src/stm32f30x_rtc.c ****     /* check if the reference clock detection is disabled */
2297:../src/stm32f30x_rtc.c ****     if((RTC->CR & RTC_CR_REFCKON) == RESET)
 3771              		.loc 1 2297 0
 3772 17ba 4FF42053 		mov	r3, #10240
 3773 17be C4F20003 		movt	r3, 16384
 3774 17c2 9B68     		ldr	r3, [r3, #8]
 3775 17c4 03F01003 		and	r3, r3, #16
 3776 17c8 002B     		cmp	r3, #0
 3777 17ca 14D1     		bne	.L158
2298:../src/stm32f30x_rtc.c ****     {
2299:../src/stm32f30x_rtc.c ****       /* Configure the Shift settings */
2300:../src/stm32f30x_rtc.c ****       RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
 3778              		.loc 1 2300 0
 3779 17cc 4FF42053 		mov	r3, #10240
 3780 17d0 C4F20003 		movt	r3, 16384
 3781 17d4 3968     		ldr	r1, [r7, #0]
 3782 17d6 7A68     		ldr	r2, [r7, #4]
 3783 17d8 0A43     		orrs	r2, r2, r1
 3784 17da DA62     		str	r2, [r3, #44]
2301:../src/stm32f30x_rtc.c ****     
2302:../src/stm32f30x_rtc.c ****       if(RTC_WaitForSynchro() == ERROR)
 3785              		.loc 1 2302 0
 3786 17dc FFF7FEFF 		bl	RTC_WaitForSynchro
 3787 17e0 0346     		mov	r3, r0
 3788 17e2 002B     		cmp	r3, #0
 3789 17e4 03D1     		bne	.L159
2303:../src/stm32f30x_rtc.c ****       {
2304:../src/stm32f30x_rtc.c ****         status = ERROR;
 3790              		.loc 1 2304 0
 3791 17e6 4FF00003 		mov	r3, #0
 3792 17ea FB73     		strb	r3, [r7, #15]
 3793 17ec 0AE0     		b	.L160
 3794              	.L159:
2305:../src/stm32f30x_rtc.c ****       }
2306:../src/stm32f30x_rtc.c ****       else
2307:../src/stm32f30x_rtc.c ****       {
2308:../src/stm32f30x_rtc.c ****         status = SUCCESS;
 3795              		.loc 1 2308 0
 3796 17ee 4FF00103 		mov	r3, #1
 3797 17f2 FB73     		strb	r3, [r7, #15]
 3798 17f4 06E0     		b	.L160
 3799              	.L158:
2309:../src/stm32f30x_rtc.c ****       }
2310:../src/stm32f30x_rtc.c ****     }
2311:../src/stm32f30x_rtc.c ****     else
2312:../src/stm32f30x_rtc.c ****     {
2313:../src/stm32f30x_rtc.c ****       status = ERROR;
 3800              		.loc 1 2313 0
 3801 17f6 4FF00003 		mov	r3, #0
 3802 17fa FB73     		strb	r3, [r7, #15]
 3803 17fc 02E0     		b	.L160
 3804              	.L157:
2314:../src/stm32f30x_rtc.c ****     }
2315:../src/stm32f30x_rtc.c ****   }
2316:../src/stm32f30x_rtc.c ****   else
2317:../src/stm32f30x_rtc.c ****   {
2318:../src/stm32f30x_rtc.c ****     status = ERROR;
 3805              		.loc 1 2318 0
 3806 17fe 4FF00003 		mov	r3, #0
 3807 1802 FB73     		strb	r3, [r7, #15]
 3808              	.L160:
2319:../src/stm32f30x_rtc.c ****   }
2320:../src/stm32f30x_rtc.c **** 
2321:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
2322:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF;
 3809              		.loc 1 2322 0
 3810 1804 4FF42053 		mov	r3, #10240
 3811 1808 C4F20003 		movt	r3, 16384
 3812 180c 4FF0FF02 		mov	r2, #255
 3813 1810 5A62     		str	r2, [r3, #36]
2323:../src/stm32f30x_rtc.c ****   
2324:../src/stm32f30x_rtc.c ****   return (ErrorStatus)(status);
 3814              		.loc 1 2324 0
 3815 1812 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
2325:../src/stm32f30x_rtc.c **** }
 3816              		.loc 1 2325 0
 3817 1814 1846     		mov	r0, r3
 3818 1816 07F11007 		add	r7, r7, #16
 3819 181a BD46     		mov	sp, r7
 3820 181c 80BD     		pop	{r7, pc}
 3821              		.cfi_endproc
 3822              	.LFE156:
 3824 181e 00BF     		.align	2
 3825              		.global	RTC_ITConfig
 3826              		.thumb
 3827              		.thumb_func
 3829              	RTC_ITConfig:
 3830              	.LFB157:
2326:../src/stm32f30x_rtc.c **** 
2327:../src/stm32f30x_rtc.c **** /**
2328:../src/stm32f30x_rtc.c ****   * @}
2329:../src/stm32f30x_rtc.c ****   */
2330:../src/stm32f30x_rtc.c **** 
2331:../src/stm32f30x_rtc.c **** /** @defgroup RTC_Group13 Interrupts and flags management functions
2332:../src/stm32f30x_rtc.c ****  *  @brief   Interrupts and flags management functions  
2333:../src/stm32f30x_rtc.c ****  *
2334:../src/stm32f30x_rtc.c **** @verbatim   
2335:../src/stm32f30x_rtc.c ****  ===============================================================================
2336:../src/stm32f30x_rtc.c ****                 ##### Interrupts and flags management functions #####
2337:../src/stm32f30x_rtc.c ****  ===============================================================================  
2338:../src/stm32f30x_rtc.c ****     [..] All RTC interrupts are connected to the EXTI controller.
2339:../src/stm32f30x_rtc.c ****          (+) To enable the RTC Alarm interrupt, the following sequence is required:
2340:../src/stm32f30x_rtc.c ****              (++) Configure and enable the EXTI Line 17 in interrupt mode and select 
2341:../src/stm32f30x_rtc.c ****                   the rising edge sensitivity using the EXTI_Init() function.
2342:../src/stm32f30x_rtc.c ****              (++) Configure and enable the RTC_Alarm IRQ channel in the NVIC using 
2343:../src/stm32f30x_rtc.c ****                   the NVIC_Init() function.
2344:../src/stm32f30x_rtc.c ****              (++) Configure the RTC to generate RTC alarms (Alarm A and/or Alarm B)
2345:../src/stm32f30x_rtc.c ****                   using the RTC_SetAlarm() and RTC_AlarmCmd() functions.
2346:../src/stm32f30x_rtc.c ****          (+) To enable the RTC Wakeup interrupt, the following sequence is required:
2347:../src/stm32f30x_rtc.c ****              (++) Configure and enable the EXTI Line 20 in interrupt mode and select 
2348:../src/stm32f30x_rtc.c ****                   the rising edge sensitivity using the EXTI_Init() function.
2349:../src/stm32f30x_rtc.c ****              (++) Configure and enable the RTC_WKUP IRQ channel in the NVIC using
2350:../src/stm32f30x_rtc.c ****                   the NVIC_Init() function.
2351:../src/stm32f30x_rtc.c ****              (++) Configure the RTC to generate the RTC wakeup timer event using the 
2352:../src/stm32f30x_rtc.c ****                   RTC_WakeUpClockConfig(), RTC_SetWakeUpCounter() and RTC_WakeUpCmd() 
2353:../src/stm32f30x_rtc.c ****                   functions.
2354:../src/stm32f30x_rtc.c ****          (+) To enable the RTC Tamper interrupt, the following sequence is required:
2355:../src/stm32f30x_rtc.c ****              (++) Configure and enable the EXTI Line 19 in interrupt mode and select 
2356:../src/stm32f30x_rtc.c ****                   the rising edge sensitivity using the EXTI_Init() function.
2357:../src/stm32f30x_rtc.c ****              (++) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using 
2358:../src/stm32f30x_rtc.c ****                   the NVIC_Init() function.
2359:../src/stm32f30x_rtc.c ****              (++) Configure the RTC to detect the RTC tamper event using the 
2360:../src/stm32f30x_rtc.c ****                   RTC_TamperTriggerConfig() and RTC_TamperCmd() functions.
2361:../src/stm32f30x_rtc.c ****          (+) To enable the RTC TimeStamp interrupt, the following sequence is required:
2362:../src/stm32f30x_rtc.c ****              (++) Configure and enable the EXTI Line 19 in interrupt mode and select
2363:../src/stm32f30x_rtc.c ****                   the rising edge sensitivity using the EXTI_Init() function.
2364:../src/stm32f30x_rtc.c ****              (++) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using 
2365:../src/stm32f30x_rtc.c ****                   the NVIC_Init() function.
2366:../src/stm32f30x_rtc.c ****              (++) Configure the RTC to detect the RTC time-stamp event using the 
2367:../src/stm32f30x_rtc.c ****                   RTC_TimeStampCmd() functions.
2368:../src/stm32f30x_rtc.c **** 
2369:../src/stm32f30x_rtc.c **** @endverbatim
2370:../src/stm32f30x_rtc.c ****   * @{
2371:../src/stm32f30x_rtc.c ****   */
2372:../src/stm32f30x_rtc.c **** 
2373:../src/stm32f30x_rtc.c **** /**
2374:../src/stm32f30x_rtc.c ****   * @brief  Enables or disables the specified RTC interrupts.
2375:../src/stm32f30x_rtc.c ****   * @param  RTC_IT: specifies the RTC interrupt sources to be enabled or disabled. 
2376:../src/stm32f30x_rtc.c ****   *   This parameter can be any combination of the following values:
2377:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TS:  Time Stamp interrupt mask
2378:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_WUT:  WakeUp Timer interrupt mask
2379:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_ALRB:  Alarm B interrupt mask
2380:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_ALRA:  Alarm A interrupt mask
2381:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TAMP: Tamper event interrupt mask
2382:../src/stm32f30x_rtc.c ****   * @param  NewState: new state of the specified RTC interrupts.
2383:../src/stm32f30x_rtc.c ****   *   This parameter can be: ENABLE or DISABLE.
2384:../src/stm32f30x_rtc.c ****   * @retval None
2385:../src/stm32f30x_rtc.c ****   */
2386:../src/stm32f30x_rtc.c **** void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
2387:../src/stm32f30x_rtc.c **** {
 3831              		.loc 1 2387 0
 3832              		.cfi_startproc
 3833              		@ args = 0, pretend = 0, frame = 8
 3834              		@ frame_needed = 1, uses_anonymous_args = 0
 3835              		@ link register save eliminated.
 3836 1820 80B4     		push	{r7}
 3837              	.LCFI134:
 3838              		.cfi_def_cfa_offset 4
 3839              		.cfi_offset 7, -4
 3840 1822 83B0     		sub	sp, sp, #12
 3841              	.LCFI135:
 3842              		.cfi_def_cfa_offset 16
 3843 1824 00AF     		add	r7, sp, #0
 3844              	.LCFI136:
 3845              		.cfi_def_cfa_register 7
 3846 1826 7860     		str	r0, [r7, #4]
 3847 1828 0B46     		mov	r3, r1
 3848 182a FB70     		strb	r3, [r7, #3]
2388:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2389:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_CONFIG_IT(RTC_IT));
2390:../src/stm32f30x_rtc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
2391:../src/stm32f30x_rtc.c **** 
2392:../src/stm32f30x_rtc.c ****   /* Disable the write protection for RTC registers */
2393:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xCA;
 3849              		.loc 1 2393 0
 3850 182c 4FF42053 		mov	r3, #10240
 3851 1830 C4F20003 		movt	r3, 16384
 3852 1834 4FF0CA02 		mov	r2, #202
 3853 1838 5A62     		str	r2, [r3, #36]
2394:../src/stm32f30x_rtc.c ****   RTC->WPR = 0x53;
 3854              		.loc 1 2394 0
 3855 183a 4FF42053 		mov	r3, #10240
 3856 183e C4F20003 		movt	r3, 16384
 3857 1842 4FF05302 		mov	r2, #83
 3858 1846 5A62     		str	r2, [r3, #36]
2395:../src/stm32f30x_rtc.c **** 
2396:../src/stm32f30x_rtc.c ****   if (NewState != DISABLE)
 3859              		.loc 1 2396 0
 3860 1848 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 3861 184a 002B     		cmp	r3, #0
 3862 184c 1CD0     		beq	.L163
2397:../src/stm32f30x_rtc.c ****   {
2398:../src/stm32f30x_rtc.c ****     /* Configure the Interrupts in the RTC_CR register */
2399:../src/stm32f30x_rtc.c ****     RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
 3863              		.loc 1 2399 0
 3864 184e 4FF42053 		mov	r3, #10240
 3865 1852 C4F20003 		movt	r3, 16384
 3866 1856 4FF42052 		mov	r2, #10240
 3867 185a C4F20002 		movt	r2, 16384
 3868 185e 9168     		ldr	r1, [r2, #8]
 3869 1860 7A68     		ldr	r2, [r7, #4]
 3870 1862 22F00402 		bic	r2, r2, #4
 3871 1866 0A43     		orrs	r2, r2, r1
 3872 1868 9A60     		str	r2, [r3, #8]
2400:../src/stm32f30x_rtc.c ****     /* Configure the Tamper Interrupt in the RTC_TAFCR */
2401:../src/stm32f30x_rtc.c ****     RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
 3873              		.loc 1 2401 0
 3874 186a 4FF42053 		mov	r3, #10240
 3875 186e C4F20003 		movt	r3, 16384
 3876 1872 4FF42052 		mov	r2, #10240
 3877 1876 C4F20002 		movt	r2, 16384
 3878 187a 116C     		ldr	r1, [r2, #64]
 3879 187c 7A68     		ldr	r2, [r7, #4]
 3880 187e 02F00402 		and	r2, r2, #4
 3881 1882 0A43     		orrs	r2, r2, r1
 3882 1884 1A64     		str	r2, [r3, #64]
 3883 1886 1FE0     		b	.L164
 3884              	.L163:
2402:../src/stm32f30x_rtc.c ****   }
2403:../src/stm32f30x_rtc.c ****   else
2404:../src/stm32f30x_rtc.c ****   {
2405:../src/stm32f30x_rtc.c ****     /* Configure the Interrupts in the RTC_CR register */
2406:../src/stm32f30x_rtc.c ****     RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
 3885              		.loc 1 2406 0
 3886 1888 4FF42053 		mov	r3, #10240
 3887 188c C4F20003 		movt	r3, 16384
 3888 1890 4FF42052 		mov	r2, #10240
 3889 1894 C4F20002 		movt	r2, 16384
 3890 1898 9168     		ldr	r1, [r2, #8]
 3891 189a 7A68     		ldr	r2, [r7, #4]
 3892 189c 22F00402 		bic	r2, r2, #4
 3893 18a0 6FEA0202 		mvn	r2, r2
 3894 18a4 0A40     		ands	r2, r2, r1
 3895 18a6 9A60     		str	r2, [r3, #8]
2407:../src/stm32f30x_rtc.c ****     /* Configure the Tamper Interrupt in the RTC_TAFCR */
2408:../src/stm32f30x_rtc.c ****     RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
 3896              		.loc 1 2408 0
 3897 18a8 4FF42053 		mov	r3, #10240
 3898 18ac C4F20003 		movt	r3, 16384
 3899 18b0 4FF42052 		mov	r2, #10240
 3900 18b4 C4F20002 		movt	r2, 16384
 3901 18b8 116C     		ldr	r1, [r2, #64]
 3902 18ba 7A68     		ldr	r2, [r7, #4]
 3903 18bc 02F00402 		and	r2, r2, #4
 3904 18c0 6FEA0202 		mvn	r2, r2
 3905 18c4 0A40     		ands	r2, r2, r1
 3906 18c6 1A64     		str	r2, [r3, #64]
 3907              	.L164:
2409:../src/stm32f30x_rtc.c ****   }
2410:../src/stm32f30x_rtc.c ****   /* Enable the write protection for RTC registers */
2411:../src/stm32f30x_rtc.c ****   RTC->WPR = 0xFF; 
 3908              		.loc 1 2411 0
 3909 18c8 4FF42053 		mov	r3, #10240
 3910 18cc C4F20003 		movt	r3, 16384
 3911 18d0 4FF0FF02 		mov	r2, #255
 3912 18d4 5A62     		str	r2, [r3, #36]
2412:../src/stm32f30x_rtc.c **** }
 3913              		.loc 1 2412 0
 3914 18d6 07F10C07 		add	r7, r7, #12
 3915 18da BD46     		mov	sp, r7
 3916 18dc 80BC     		pop	{r7}
 3917 18de 7047     		bx	lr
 3918              		.cfi_endproc
 3919              	.LFE157:
 3921              		.align	2
 3922              		.global	RTC_GetFlagStatus
 3923              		.thumb
 3924              		.thumb_func
 3926              	RTC_GetFlagStatus:
 3927              	.LFB158:
2413:../src/stm32f30x_rtc.c **** 
2414:../src/stm32f30x_rtc.c **** /**
2415:../src/stm32f30x_rtc.c ****   * @brief  Checks whether the specified RTC flag is set or not.
2416:../src/stm32f30x_rtc.c ****   * @param  RTC_FLAG: specifies the flag to check.
2417:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
2418:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_RECALPF: RECALPF event flag
2419:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TAMP3F: Tamper 3 event flag
2420:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TAMP2F: Tamper 2 event flag   
2421:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
2422:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TSOVF: Time Stamp OverFlow flag
2423:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TSF: Time Stamp event flag
2424:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_WUTF: WakeUp Timer flag
2425:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_ALRBF: Alarm B flag
2426:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_ALRAF: Alarm A flag
2427:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_INITF: Initialization mode flag
2428:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_RSF: Registers Synchronized flag
2429:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_INITS: Registers Configured flag
2430:../src/stm32f30x_rtc.c ****   *     @argRTC_FLAG_SHPF  : Shift operation pending flag.  
2431:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_WUTWF: WakeUp Timer Write flag
2432:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_ALRBWF: Alarm B Write flag
2433:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_ALRAWF: Alarm A write flag
2434:../src/stm32f30x_rtc.c ****   * @retval The new state of RTC_FLAG (SET or RESET).
2435:../src/stm32f30x_rtc.c ****   */
2436:../src/stm32f30x_rtc.c **** FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
2437:../src/stm32f30x_rtc.c **** {
 3928              		.loc 1 2437 0
 3929              		.cfi_startproc
 3930              		@ args = 0, pretend = 0, frame = 16
 3931              		@ frame_needed = 1, uses_anonymous_args = 0
 3932              		@ link register save eliminated.
 3933 18e0 80B4     		push	{r7}
 3934              	.LCFI137:
 3935              		.cfi_def_cfa_offset 4
 3936              		.cfi_offset 7, -4
 3937 18e2 85B0     		sub	sp, sp, #20
 3938              	.LCFI138:
 3939              		.cfi_def_cfa_offset 24
 3940 18e4 00AF     		add	r7, sp, #0
 3941              	.LCFI139:
 3942              		.cfi_def_cfa_register 7
 3943 18e6 7860     		str	r0, [r7, #4]
2438:../src/stm32f30x_rtc.c ****   FlagStatus bitstatus = RESET;
 3944              		.loc 1 2438 0
 3945 18e8 4FF00003 		mov	r3, #0
 3946 18ec FB73     		strb	r3, [r7, #15]
2439:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 3947              		.loc 1 2439 0
 3948 18ee 4FF00003 		mov	r3, #0
 3949 18f2 BB60     		str	r3, [r7, #8]
2440:../src/stm32f30x_rtc.c ****   
2441:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2442:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
2443:../src/stm32f30x_rtc.c ****   
2444:../src/stm32f30x_rtc.c ****   /* Get all the flags */
2445:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
 3950              		.loc 1 2445 0
 3951 18f4 4FF42053 		mov	r3, #10240
 3952 18f8 C4F20003 		movt	r3, 16384
 3953 18fc DA68     		ldr	r2, [r3, #12]
 3954 18fe 4FF67F73 		movw	r3, #65407
 3955 1902 C0F20103 		movt	r3, 1
 3956 1906 1340     		ands	r3, r3, r2
 3957 1908 BB60     		str	r3, [r7, #8]
2446:../src/stm32f30x_rtc.c ****   
2447:../src/stm32f30x_rtc.c ****   /* Return the status of the flag */
2448:../src/stm32f30x_rtc.c ****   if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
 3958              		.loc 1 2448 0
 3959 190a BA68     		ldr	r2, [r7, #8]
 3960 190c 7B68     		ldr	r3, [r7, #4]
 3961 190e 1340     		ands	r3, r3, r2
 3962 1910 002B     		cmp	r3, #0
 3963 1912 03D0     		beq	.L166
2449:../src/stm32f30x_rtc.c ****   {
2450:../src/stm32f30x_rtc.c ****     bitstatus = SET;
 3964              		.loc 1 2450 0
 3965 1914 4FF00103 		mov	r3, #1
 3966 1918 FB73     		strb	r3, [r7, #15]
 3967 191a 02E0     		b	.L167
 3968              	.L166:
2451:../src/stm32f30x_rtc.c ****   }
2452:../src/stm32f30x_rtc.c ****   else
2453:../src/stm32f30x_rtc.c ****   {
2454:../src/stm32f30x_rtc.c ****     bitstatus = RESET;
 3969              		.loc 1 2454 0
 3970 191c 4FF00003 		mov	r3, #0
 3971 1920 FB73     		strb	r3, [r7, #15]
 3972              	.L167:
2455:../src/stm32f30x_rtc.c ****   }
2456:../src/stm32f30x_rtc.c ****   return bitstatus;
 3973              		.loc 1 2456 0
 3974 1922 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
2457:../src/stm32f30x_rtc.c **** }
 3975              		.loc 1 2457 0
 3976 1924 1846     		mov	r0, r3
 3977 1926 07F11407 		add	r7, r7, #20
 3978 192a BD46     		mov	sp, r7
 3979 192c 80BC     		pop	{r7}
 3980 192e 7047     		bx	lr
 3981              		.cfi_endproc
 3982              	.LFE158:
 3984              		.align	2
 3985              		.global	RTC_ClearFlag
 3986              		.thumb
 3987              		.thumb_func
 3989              	RTC_ClearFlag:
 3990              	.LFB159:
2458:../src/stm32f30x_rtc.c **** 
2459:../src/stm32f30x_rtc.c **** /**
2460:../src/stm32f30x_rtc.c ****   * @brief  Clears the RTC's pending flags.
2461:../src/stm32f30x_rtc.c ****   * @param  RTC_FLAG: specifies the RTC flag to clear.
2462:../src/stm32f30x_rtc.c ****   *   This parameter can be any combination of the following values:
2463:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TAMP3F: Tamper 3 event flag
2464:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TAMP2F: Tamper 2 event flag
2465:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TAMP1F: Tamper 1 event flag 
2466:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TSOVF: Time Stamp Overflow flag 
2467:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_TSF: Time Stamp event flag
2468:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_WUTF: WakeUp Timer flag
2469:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_ALRBF: Alarm B flag
2470:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_ALRAF: Alarm A flag
2471:../src/stm32f30x_rtc.c ****   *     @arg RTC_FLAG_RSF: Registers Synchronized flag
2472:../src/stm32f30x_rtc.c ****   * @retval None
2473:../src/stm32f30x_rtc.c ****   */
2474:../src/stm32f30x_rtc.c **** void RTC_ClearFlag(uint32_t RTC_FLAG)
2475:../src/stm32f30x_rtc.c **** {
 3991              		.loc 1 2475 0
 3992              		.cfi_startproc
 3993              		@ args = 0, pretend = 0, frame = 8
 3994              		@ frame_needed = 1, uses_anonymous_args = 0
 3995              		@ link register save eliminated.
 3996 1930 80B4     		push	{r7}
 3997              	.LCFI140:
 3998              		.cfi_def_cfa_offset 4
 3999              		.cfi_offset 7, -4
 4000 1932 83B0     		sub	sp, sp, #12
 4001              	.LCFI141:
 4002              		.cfi_def_cfa_offset 16
 4003 1934 00AF     		add	r7, sp, #0
 4004              	.LCFI142:
 4005              		.cfi_def_cfa_register 7
 4006 1936 7860     		str	r0, [r7, #4]
2476:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2477:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
2478:../src/stm32f30x_rtc.c **** 
2479:../src/stm32f30x_rtc.c ****   /* Clear the Flags in the RTC_ISR register */
2480:../src/stm32f30x_rtc.c ****   RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0001FFFF) | (uint32_t)(RTC->ISR &
 4007              		.loc 1 2480 0
 4008 1938 4FF42052 		mov	r2, #10240
 4009 193c C4F20002 		movt	r2, 16384
 4010 1940 7968     		ldr	r1, [r7, #4]
 4011 1942 4FF67F73 		movw	r3, #65407
 4012 1946 C0F20103 		movt	r3, 1
 4013 194a 0B40     		ands	r3, r3, r1
 4014 194c 43F08003 		orr	r3, r3, #128
 4015 1950 6FEA0301 		mvn	r1, r3
 4016 1954 4FF42053 		mov	r3, #10240
 4017 1958 C4F20003 		movt	r3, 16384
 4018 195c DB68     		ldr	r3, [r3, #12]
 4019 195e 03F08003 		and	r3, r3, #128
 4020 1962 0B43     		orrs	r3, r3, r1
 4021 1964 D360     		str	r3, [r2, #12]
2481:../src/stm32f30x_rtc.c **** }
 4022              		.loc 1 2481 0
 4023 1966 07F10C07 		add	r7, r7, #12
 4024 196a BD46     		mov	sp, r7
 4025 196c 80BC     		pop	{r7}
 4026 196e 7047     		bx	lr
 4027              		.cfi_endproc
 4028              	.LFE159:
 4030              		.align	2
 4031              		.global	RTC_GetITStatus
 4032              		.thumb
 4033              		.thumb_func
 4035              	RTC_GetITStatus:
 4036              	.LFB160:
2482:../src/stm32f30x_rtc.c **** 
2483:../src/stm32f30x_rtc.c **** /**
2484:../src/stm32f30x_rtc.c ****   * @brief  Checks whether the specified RTC interrupt has occurred or not.
2485:../src/stm32f30x_rtc.c ****   * @param  RTC_IT: specifies the RTC interrupt source to check.
2486:../src/stm32f30x_rtc.c ****   *   This parameter can be one of the following values:
2487:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TS: Time Stamp interrupt 
2488:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_WUT: WakeUp Timer interrupt 
2489:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_ALRB: Alarm B interrupt 
2490:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_ALRA: Alarm A interrupt 
2491:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TAMP1: Tamper1 event interrupt 
2492:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TAMP2: Tamper2 event interrupt 
2493:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TAMP3: Tamper3 event interrupt
2494:../src/stm32f30x_rtc.c ****   * @retval The new state of RTC_IT (SET or RESET).
2495:../src/stm32f30x_rtc.c ****   */
2496:../src/stm32f30x_rtc.c **** ITStatus RTC_GetITStatus(uint32_t RTC_IT)
2497:../src/stm32f30x_rtc.c **** {
 4037              		.loc 1 2497 0
 4038              		.cfi_startproc
 4039              		@ args = 0, pretend = 0, frame = 24
 4040              		@ frame_needed = 1, uses_anonymous_args = 0
 4041              		@ link register save eliminated.
 4042 1970 80B4     		push	{r7}
 4043              	.LCFI143:
 4044              		.cfi_def_cfa_offset 4
 4045              		.cfi_offset 7, -4
 4046 1972 87B0     		sub	sp, sp, #28
 4047              	.LCFI144:
 4048              		.cfi_def_cfa_offset 32
 4049 1974 00AF     		add	r7, sp, #0
 4050              	.LCFI145:
 4051              		.cfi_def_cfa_register 7
 4052 1976 7860     		str	r0, [r7, #4]
2498:../src/stm32f30x_rtc.c ****   ITStatus bitstatus = RESET;
 4053              		.loc 1 2498 0
 4054 1978 4FF00003 		mov	r3, #0
 4055 197c FB75     		strb	r3, [r7, #23]
2499:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0, enablestatus = 0;
 4056              		.loc 1 2499 0
 4057 197e 4FF00003 		mov	r3, #0
 4058 1982 3B61     		str	r3, [r7, #16]
 4059 1984 4FF00003 		mov	r3, #0
 4060 1988 FB60     		str	r3, [r7, #12]
2500:../src/stm32f30x_rtc.c ****  
2501:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2502:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_GET_IT(RTC_IT));
2503:../src/stm32f30x_rtc.c ****   
2504:../src/stm32f30x_rtc.c ****   /* Get the TAMPER Interrupt enable bit and pending bit */
2505:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
 4061              		.loc 1 2505 0
 4062 198a 4FF42053 		mov	r3, #10240
 4063 198e C4F20003 		movt	r3, 16384
 4064 1992 1B6C     		ldr	r3, [r3, #64]
 4065 1994 03F00403 		and	r3, r3, #4
 4066 1998 3B61     		str	r3, [r7, #16]
2506:../src/stm32f30x_rtc.c ****  
2507:../src/stm32f30x_rtc.c ****   /* Get the Interrupt enable Status */
2508:../src/stm32f30x_rtc.c ****   enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & ((RTC_IT >> (RTC_IT >> 18)) >> 15)));
 4067              		.loc 1 2508 0
 4068 199a 4FF42053 		mov	r3, #10240
 4069 199e C4F20003 		movt	r3, 16384
 4070 19a2 9A68     		ldr	r2, [r3, #8]
 4071 19a4 7B68     		ldr	r3, [r7, #4]
 4072 19a6 1A40     		ands	r2, r2, r3
 4073 19a8 7B68     		ldr	r3, [r7, #4]
 4074 19aa 4FEA9343 		lsr	r3, r3, #18
 4075 19ae 7968     		ldr	r1, [r7, #4]
 4076 19b0 21FA03F3 		lsr	r3, r1, r3
 4077 19b4 4FEAD331 		lsr	r1, r3, #15
 4078 19b8 3B69     		ldr	r3, [r7, #16]
 4079 19ba 0B40     		ands	r3, r3, r1
 4080 19bc 1343     		orrs	r3, r3, r2
 4081 19be FB60     		str	r3, [r7, #12]
2509:../src/stm32f30x_rtc.c ****   
2510:../src/stm32f30x_rtc.c ****   /* Get the Interrupt pending bit */
2511:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
 4082              		.loc 1 2511 0
 4083 19c0 4FF42053 		mov	r3, #10240
 4084 19c4 C4F20003 		movt	r3, 16384
 4085 19c8 DA68     		ldr	r2, [r3, #12]
 4086 19ca 7B68     		ldr	r3, [r7, #4]
 4087 19cc 4FEA1313 		lsr	r3, r3, #4
 4088 19d0 1340     		ands	r3, r3, r2
 4089 19d2 3B61     		str	r3, [r7, #16]
2512:../src/stm32f30x_rtc.c ****   
2513:../src/stm32f30x_rtc.c ****   /* Get the status of the Interrupt */
2514:../src/stm32f30x_rtc.c ****   if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
 4090              		.loc 1 2514 0
 4091 19d4 FB68     		ldr	r3, [r7, #12]
 4092 19d6 002B     		cmp	r3, #0
 4093 19d8 0AD0     		beq	.L171
 4094              		.loc 1 2514 0 is_stmt 0 discriminator 1
 4095 19da 3B69     		ldr	r3, [r7, #16]
 4096 19dc 4FEA0343 		lsl	r3, r3, #16
 4097 19e0 4FEA1343 		lsr	r3, r3, #16
 4098 19e4 002B     		cmp	r3, #0
 4099 19e6 03D0     		beq	.L171
2515:../src/stm32f30x_rtc.c ****   {
2516:../src/stm32f30x_rtc.c ****     bitstatus = SET;
 4100              		.loc 1 2516 0 is_stmt 1
 4101 19e8 4FF00103 		mov	r3, #1
 4102 19ec FB75     		strb	r3, [r7, #23]
 4103 19ee 02E0     		b	.L172
 4104              	.L171:
2517:../src/stm32f30x_rtc.c ****   }
2518:../src/stm32f30x_rtc.c ****   else
2519:../src/stm32f30x_rtc.c ****   {
2520:../src/stm32f30x_rtc.c ****     bitstatus = RESET;
 4105              		.loc 1 2520 0
 4106 19f0 4FF00003 		mov	r3, #0
 4107 19f4 FB75     		strb	r3, [r7, #23]
 4108              	.L172:
2521:../src/stm32f30x_rtc.c ****   }
2522:../src/stm32f30x_rtc.c ****   return bitstatus;
 4109              		.loc 1 2522 0
 4110 19f6 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
2523:../src/stm32f30x_rtc.c **** }
 4111              		.loc 1 2523 0
 4112 19f8 1846     		mov	r0, r3
 4113 19fa 07F11C07 		add	r7, r7, #28
 4114 19fe BD46     		mov	sp, r7
 4115 1a00 80BC     		pop	{r7}
 4116 1a02 7047     		bx	lr
 4117              		.cfi_endproc
 4118              	.LFE160:
 4120              		.align	2
 4121              		.global	RTC_ClearITPendingBit
 4122              		.thumb
 4123              		.thumb_func
 4125              	RTC_ClearITPendingBit:
 4126              	.LFB161:
2524:../src/stm32f30x_rtc.c **** 
2525:../src/stm32f30x_rtc.c **** /**
2526:../src/stm32f30x_rtc.c ****   * @brief  Clears the RTC's interrupt pending bits.
2527:../src/stm32f30x_rtc.c ****   * @param  RTC_IT: specifies the RTC interrupt pending bit to clear.
2528:../src/stm32f30x_rtc.c ****   *   This parameter can be any combination of the following values:
2529:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TS: Time Stamp interrupt 
2530:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_WUT: WakeUp Timer interrupt 
2531:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_ALRB: Alarm B interrupt 
2532:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_ALRA: Alarm A interrupt 
2533:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TAMP1: Tamper1 event interrupt
2534:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TAMP2: Tamper2 event interrupt
2535:../src/stm32f30x_rtc.c ****   *     @arg RTC_IT_TAMP3: Tamper3 event interrupt 
2536:../src/stm32f30x_rtc.c ****   * @retval None
2537:../src/stm32f30x_rtc.c ****   */
2538:../src/stm32f30x_rtc.c **** void RTC_ClearITPendingBit(uint32_t RTC_IT)
2539:../src/stm32f30x_rtc.c **** {
 4127              		.loc 1 2539 0
 4128              		.cfi_startproc
 4129              		@ args = 0, pretend = 0, frame = 16
 4130              		@ frame_needed = 1, uses_anonymous_args = 0
 4131              		@ link register save eliminated.
 4132 1a04 80B4     		push	{r7}
 4133              	.LCFI146:
 4134              		.cfi_def_cfa_offset 4
 4135              		.cfi_offset 7, -4
 4136 1a06 85B0     		sub	sp, sp, #20
 4137              	.LCFI147:
 4138              		.cfi_def_cfa_offset 24
 4139 1a08 00AF     		add	r7, sp, #0
 4140              	.LCFI148:
 4141              		.cfi_def_cfa_register 7
 4142 1a0a 7860     		str	r0, [r7, #4]
2540:../src/stm32f30x_rtc.c ****   uint32_t tmpreg = 0;
 4143              		.loc 1 2540 0
 4144 1a0c 4FF00003 		mov	r3, #0
 4145 1a10 FB60     		str	r3, [r7, #12]
2541:../src/stm32f30x_rtc.c **** 
2542:../src/stm32f30x_rtc.c ****   /* Check the parameters */
2543:../src/stm32f30x_rtc.c ****   assert_param(IS_RTC_CLEAR_IT(RTC_IT));
2544:../src/stm32f30x_rtc.c **** 
2545:../src/stm32f30x_rtc.c ****   /* Get the RTC_ISR Interrupt pending bits mask */
2546:../src/stm32f30x_rtc.c ****   tmpreg = (uint32_t)(RTC_IT >> 4);
 4146              		.loc 1 2546 0
 4147 1a12 7B68     		ldr	r3, [r7, #4]
 4148 1a14 4FEA1313 		lsr	r3, r3, #4
 4149 1a18 FB60     		str	r3, [r7, #12]
2547:../src/stm32f30x_rtc.c **** 
2548:../src/stm32f30x_rtc.c ****   /* Clear the interrupt pending bits in the RTC_ISR register */
2549:../src/stm32f30x_rtc.c ****   RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & R
 4150              		.loc 1 2549 0
 4151 1a1a 4FF42053 		mov	r3, #10240
 4152 1a1e C4F20003 		movt	r3, 16384
 4153 1a22 FA68     		ldr	r2, [r7, #12]
 4154 1a24 4FEA0242 		lsl	r2, r2, #16
 4155 1a28 4FEA1242 		lsr	r2, r2, #16
 4156 1a2c 42F08002 		orr	r2, r2, #128
 4157 1a30 6FEA0201 		mvn	r1, r2
 4158 1a34 4FF42052 		mov	r2, #10240
 4159 1a38 C4F20002 		movt	r2, 16384
 4160 1a3c D268     		ldr	r2, [r2, #12]
 4161 1a3e 02F08002 		and	r2, r2, #128
 4162 1a42 0A43     		orrs	r2, r2, r1
 4163 1a44 DA60     		str	r2, [r3, #12]
2550:../src/stm32f30x_rtc.c **** }
 4164              		.loc 1 2550 0
 4165 1a46 07F11407 		add	r7, r7, #20
 4166 1a4a BD46     		mov	sp, r7
 4167 1a4c 80BC     		pop	{r7}
 4168 1a4e 7047     		bx	lr
 4169              		.cfi_endproc
 4170              	.LFE161:
 4172              		.align	2
 4173              		.thumb
 4174              		.thumb_func
 4176              	RTC_ByteToBcd2:
 4177              	.LFB162:
2551:../src/stm32f30x_rtc.c **** 
2552:../src/stm32f30x_rtc.c **** /**
2553:../src/stm32f30x_rtc.c ****   * @}
2554:../src/stm32f30x_rtc.c ****   */
2555:../src/stm32f30x_rtc.c **** 
2556:../src/stm32f30x_rtc.c **** /**
2557:../src/stm32f30x_rtc.c ****   * @brief  Converts a 2 digit decimal to BCD format.
2558:../src/stm32f30x_rtc.c ****   * @param  Value: Byte to be converted.
2559:../src/stm32f30x_rtc.c ****   * @retval Converted byte
2560:../src/stm32f30x_rtc.c ****   */
2561:../src/stm32f30x_rtc.c **** static uint8_t RTC_ByteToBcd2(uint8_t Value)
2562:../src/stm32f30x_rtc.c **** {
 4178              		.loc 1 2562 0
 4179              		.cfi_startproc
 4180              		@ args = 0, pretend = 0, frame = 16
 4181              		@ frame_needed = 1, uses_anonymous_args = 0
 4182              		@ link register save eliminated.
 4183 1a50 80B4     		push	{r7}
 4184              	.LCFI149:
 4185              		.cfi_def_cfa_offset 4
 4186              		.cfi_offset 7, -4
 4187 1a52 85B0     		sub	sp, sp, #20
 4188              	.LCFI150:
 4189              		.cfi_def_cfa_offset 24
 4190 1a54 00AF     		add	r7, sp, #0
 4191              	.LCFI151:
 4192              		.cfi_def_cfa_register 7
 4193 1a56 0346     		mov	r3, r0
 4194 1a58 FB71     		strb	r3, [r7, #7]
2563:../src/stm32f30x_rtc.c ****   uint8_t bcdhigh = 0;
 4195              		.loc 1 2563 0
 4196 1a5a 4FF00003 		mov	r3, #0
 4197 1a5e FB73     		strb	r3, [r7, #15]
2564:../src/stm32f30x_rtc.c ****   
2565:../src/stm32f30x_rtc.c ****   while (Value >= 10)
 4198              		.loc 1 2565 0
 4199 1a60 07E0     		b	.L176
 4200              	.L177:
2566:../src/stm32f30x_rtc.c ****   {
2567:../src/stm32f30x_rtc.c ****     bcdhigh++;
 4201              		.loc 1 2567 0
 4202 1a62 FB7B     		ldrb	r3, [r7, #15]
 4203 1a64 03F10103 		add	r3, r3, #1
 4204 1a68 FB73     		strb	r3, [r7, #15]
2568:../src/stm32f30x_rtc.c ****     Value -= 10;
 4205              		.loc 1 2568 0
 4206 1a6a FB79     		ldrb	r3, [r7, #7]
 4207 1a6c A3F10A03 		sub	r3, r3, #10
 4208 1a70 FB71     		strb	r3, [r7, #7]
 4209              	.L176:
2565:../src/stm32f30x_rtc.c ****   while (Value >= 10)
 4210              		.loc 1 2565 0 discriminator 1
 4211 1a72 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4212 1a74 092B     		cmp	r3, #9
 4213 1a76 F4D8     		bhi	.L177
2569:../src/stm32f30x_rtc.c ****   }
2570:../src/stm32f30x_rtc.c ****   
2571:../src/stm32f30x_rtc.c ****   return  ((uint8_t)(bcdhigh << 4) | Value);
 4214              		.loc 1 2571 0
 4215 1a78 FB7B     		ldrb	r3, [r7, #15]
 4216 1a7a 4FEA0313 		lsl	r3, r3, #4
 4217 1a7e DAB2     		uxtb	r2, r3
 4218 1a80 FB79     		ldrb	r3, [r7, #7]
 4219 1a82 1343     		orrs	r3, r3, r2
 4220 1a84 DBB2     		uxtb	r3, r3
2572:../src/stm32f30x_rtc.c **** }
 4221              		.loc 1 2572 0
 4222 1a86 1846     		mov	r0, r3
 4223 1a88 07F11407 		add	r7, r7, #20
 4224 1a8c BD46     		mov	sp, r7
 4225 1a8e 80BC     		pop	{r7}
 4226 1a90 7047     		bx	lr
 4227              		.cfi_endproc
 4228              	.LFE162:
 4230 1a92 00BF     		.align	2
 4231              		.thumb
 4232              		.thumb_func
 4234              	RTC_Bcd2ToByte:
 4235              	.LFB163:
2573:../src/stm32f30x_rtc.c **** 
2574:../src/stm32f30x_rtc.c **** /**
2575:../src/stm32f30x_rtc.c ****   * @brief  Convert from 2 digit BCD to Binary.
2576:../src/stm32f30x_rtc.c ****   * @param  Value: BCD value to be converted.
2577:../src/stm32f30x_rtc.c ****   * @retval Converted word
2578:../src/stm32f30x_rtc.c ****   */
2579:../src/stm32f30x_rtc.c **** static uint8_t RTC_Bcd2ToByte(uint8_t Value)
2580:../src/stm32f30x_rtc.c **** {
 4236              		.loc 1 2580 0
 4237              		.cfi_startproc
 4238              		@ args = 0, pretend = 0, frame = 16
 4239              		@ frame_needed = 1, uses_anonymous_args = 0
 4240              		@ link register save eliminated.
 4241 1a94 80B4     		push	{r7}
 4242              	.LCFI152:
 4243              		.cfi_def_cfa_offset 4
 4244              		.cfi_offset 7, -4
 4245 1a96 85B0     		sub	sp, sp, #20
 4246              	.LCFI153:
 4247              		.cfi_def_cfa_offset 24
 4248 1a98 00AF     		add	r7, sp, #0
 4249              	.LCFI154:
 4250              		.cfi_def_cfa_register 7
 4251 1a9a 0346     		mov	r3, r0
 4252 1a9c FB71     		strb	r3, [r7, #7]
2581:../src/stm32f30x_rtc.c ****   uint8_t tmp = 0;
 4253              		.loc 1 2581 0
 4254 1a9e 4FF00003 		mov	r3, #0
 4255 1aa2 FB73     		strb	r3, [r7, #15]
2582:../src/stm32f30x_rtc.c ****   tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 4256              		.loc 1 2582 0
 4257 1aa4 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4258 1aa6 4FEA1313 		lsr	r3, r3, #4
 4259 1aaa DBB2     		uxtb	r3, r3
 4260 1aac 1A46     		mov	r2, r3
 4261 1aae 4FEA8202 		lsl	r2, r2, #2
 4262 1ab2 D318     		adds	r3, r2, r3
 4263 1ab4 4FEA4303 		lsl	r3, r3, #1
 4264 1ab8 FB73     		strb	r3, [r7, #15]
2583:../src/stm32f30x_rtc.c ****   return (tmp + (Value & (uint8_t)0x0F));
 4265              		.loc 1 2583 0
 4266 1aba FB79     		ldrb	r3, [r7, #7]
 4267 1abc 03F00F03 		and	r3, r3, #15
 4268 1ac0 DAB2     		uxtb	r2, r3
 4269 1ac2 FB7B     		ldrb	r3, [r7, #15]
 4270 1ac4 D318     		adds	r3, r2, r3
 4271 1ac6 DBB2     		uxtb	r3, r3
2584:../src/stm32f30x_rtc.c **** }
 4272              		.loc 1 2584 0
 4273 1ac8 1846     		mov	r0, r3
 4274 1aca 07F11407 		add	r7, r7, #20
 4275 1ace BD46     		mov	sp, r7
 4276 1ad0 80BC     		pop	{r7}
 4277 1ad2 7047     		bx	lr
 4278              		.cfi_endproc
 4279              	.LFE163:
 4281              	.Letext0:
 4282              		.file 2 "/home/aghosh01/gcc-arm-none-eabi-4_7-2012q4/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../.
 4283              		.file 3 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x.h"
 4284              		.file 4 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/stm32f30x_rtc.h"
 4285              		.file 5 "/home/aghosh01/git/Trinity2013/STM32F3x/inc/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f30x_rtc.c
     /tmp/ccXN4yX4.s:19     .text:00000000 $t
     /tmp/ccXN4yX4.s:24     .text:00000000 RTC_DeInit
     /tmp/ccXN4yX4.s:412    .text:000002c8 RTC_EnterInitMode
     /tmp/ccXN4yX4.s:540    .text:00000380 RTC_WaitForSynchro
     /tmp/ccXN4yX4.s:213    .text:00000194 RTC_Init
     /tmp/ccXN4yX4.s:506    .text:0000035c RTC_ExitInitMode
     /tmp/ccXN4yX4.s:315    .text:00000254 RTC_StructInit
     /tmp/ccXN4yX4.s:358    .text:00000280 RTC_WriteProtectionCmd
     /tmp/ccXN4yX4.s:653    .text:00000448 RTC_RefClockCmd
     /tmp/ccXN4yX4.s:744    .text:000004e4 RTC_BypassShadowCmd
     /tmp/ccXN4yX4.s:814    .text:0000055c RTC_SetTime
     /tmp/ccXN4yX4.s:4234   .text:00001a94 RTC_Bcd2ToByte
     /tmp/ccXN4yX4.s:4176   .text:00001a50 RTC_ByteToBcd2
     /tmp/ccXN4yX4.s:1013   .text:000006bc RTC_TimeStructInit
     /tmp/ccXN4yX4.s:1060   .text:000006f0 RTC_GetTime
     /tmp/ccXN4yX4.s:1161   .text:00000798 RTC_GetSubSecond
     /tmp/ccXN4yX4.s:1206   .text:000007c8 RTC_SetDate
     /tmp/ccXN4yX4.s:1406   .text:00000924 RTC_DateStructInit
     /tmp/ccXN4yX4.s:1453   .text:00000958 RTC_GetDate
     /tmp/ccXN4yX4.s:1559   .text:00000a08 RTC_SetAlarm
     /tmp/ccXN4yX4.s:1782   .text:00000b84 RTC_AlarmStructInit
     /tmp/ccXN4yX4.s:1841   .text:00000bd0 RTC_GetAlarm
     /tmp/ccXN4yX4.s:1979   .text:00000cbc RTC_AlarmCmd
     /tmp/ccXN4yX4.s:2106   .text:00000da4 RTC_AlarmSubSecondConfig
     /tmp/ccXN4yX4.s:2179   .text:00000e14 RTC_GetAlarmSubSecond
     /tmp/ccXN4yX4.s:2237   .text:00000e64 RTC_WakeUpClockConfig
     /tmp/ccXN4yX4.s:2300   .text:00000ed0 RTC_SetWakeUpCounter
     /tmp/ccXN4yX4.s:2351   .text:00000f18 RTC_GetWakeUpCounter
     /tmp/ccXN4yX4.s:2384   .text:00000f38 RTC_WakeUpCmd
     /tmp/ccXN4yX4.s:2503   .text:00001010 RTC_DayLightSavingConfig
     /tmp/ccXN4yX4.s:2569   .text:00001084 RTC_GetStoreOperation
     /tmp/ccXN4yX4.s:2601   .text:000010a0 RTC_OutputConfig
     /tmp/ccXN4yX4.s:2667   .text:00001114 RTC_CalibOutputCmd
     /tmp/ccXN4yX4.s:2737   .text:0000118c RTC_CalibOutputConfig
     /tmp/ccXN4yX4.s:2800   .text:000011f8 RTC_SmoothCalibConfig
     /tmp/ccXN4yX4.s:2909   .text:000012b4 RTC_TimeStampCmd
     /tmp/ccXN4yX4.s:2990   .text:00001338 RTC_GetTimeStamp
     /tmp/ccXN4yX4.s:3153   .text:00001468 RTC_GetTimeStampSubSecond
     /tmp/ccXN4yX4.s:3184   .text:00001480 RTC_TamperTriggerConfig
     /tmp/ccXN4yX4.s:3244   .text:000014d8 RTC_TamperCmd
     /tmp/ccXN4yX4.s:3303   .text:0000152c RTC_TamperFilterConfig
     /tmp/ccXN4yX4.s:3351   .text:00001570 RTC_TamperSamplingFreqConfig
     /tmp/ccXN4yX4.s:3399   .text:000015b4 RTC_TamperPinsPrechargeDuration
     /tmp/ccXN4yX4.s:3447   .text:000015f8 RTC_TimeStampOnTamperDetectionCmd
     /tmp/ccXN4yX4.s:3502   .text:00001644 RTC_TamperPullUpCmd
     /tmp/ccXN4yX4.s:3557   .text:00001690 RTC_WriteBackupRegister
     /tmp/ccXN4yX4.s:3606   .text:000016c8 RTC_ReadBackupRegister
     /tmp/ccXN4yX4.s:3654   .text:000016fc RTC_OutputTypeConfig
     /tmp/ccXN4yX4.s:3702   .text:00001740 RTC_SynchroShiftConfig
     /tmp/ccXN4yX4.s:3829   .text:00001820 RTC_ITConfig
     /tmp/ccXN4yX4.s:3926   .text:000018e0 RTC_GetFlagStatus
     /tmp/ccXN4yX4.s:3989   .text:00001930 RTC_ClearFlag
     /tmp/ccXN4yX4.s:4035   .text:00001970 RTC_GetITStatus
     /tmp/ccXN4yX4.s:4125   .text:00001a04 RTC_ClearITPendingBit
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.323dce8664331a0daf4a2675e107c70c
                           .group:00000000 wm4.stm32f30x.h.56.6f19c65e98e3319a61449cb2b2455af5
                           .group:00000000 wm4.core_cm4.h.32.1434cd257ff5806b1b03cd32ab0641e9
                           .group:00000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:00000000 wm4.core_cmInstr.h.25.d8165482ef3061013a2fc83e2d85f3d9
                           .group:00000000 wm4.core_cm4_simd.h.29.013e5bcf58dba2d27c60184174208e07
                           .group:00000000 wm4.core_cm4.h.155.cf7c793e178943e1bbf613f1b21cd51a
                           .group:00000000 wm4.stm32f30x.h.294.d8a54360eca16e4157694b52a095202d
                           .group:00000000 wm4.stm32f30x_adc.h.130.cbebad91f78fb87381fe0860eea6104e
                           .group:00000000 wm4.stm32f30x_can.h.50.8b8f5d301152c422a6e50622b33ef620
                           .group:00000000 wm4.stm32f30x_crc.h.54.66d4c5e565e18566aebd9abfd4bcd4b0
                           .group:00000000 wm4.stm32f30x_comp.h.91.06ae44150aaaa82c077b71df8db3541a
                           .group:00000000 wm4.stm32f30x_dac.h.49.b1b5b26e4ca241dbe67fa16dc86a615f
                           .group:00000000 wm4.stm32f30x_dbgmcu.h.53.b238a263ce6a2cc83f610cc35302a38b
                           .group:00000000 wm4.stm32f30x_dma.h.96.d7a2ddd10023e12781aa8ff5ac15d212
                           .group:00000000 wm4.stm32f30x_exti.h.60.8ca0809491a21dec6fc69cf7471e2bab
                           .group:00000000 wm4.stm32f30x_flash.h.70.32613455dfe7328932f786a224daac23
                           .group:00000000 wm4.stm32f30x_gpio.h.50.408e1f6250246e4cc28221970909d34c
                           .group:00000000 wm4.stm32f30x_syscfg.h.58.4cadeb4ec8e47d36b972bbb6b96b7161
                           .group:00000000 wm4.stm32f30x_i2c.h.86.3d51d4edc0e3b9ee9aae045ccbb7739a
                           .group:00000000 wm4.stm32f30x_iwdg.h.59.467d704fb073a015941f19b50fa6470a
                           .group:00000000 wm4.stm32f30x_opamp.h.75.704e2e5e2aab039de307aaa2dcc99fa5
                           .group:00000000 wm4.stm32f30x_pwr.h.59.5c85acff2a3e3c5085b2140c06025cfc
                           .group:00000000 wm4.stm32f30x_rcc.h.79.5ba7cac1e74879861a72556c25322aa4
                           .group:00000000 wm4.stm32f30x_spi.h.119.4d21ec94ec14f3553a127e61c0a9874f
                           .group:00000000 wm4.stm32f30x_tim.h.175.d4a93cff2e7924577147254e501271b6
                           .group:00000000 wm4.stm32f30x_usart.h.110.c89016273702821ff4f9fe43881f70b5
                           .group:00000000 wm4.stm32f30x_wwdg.h.58.4688eee61a2709866472b4b4c07d9275
                           .group:00000000 wm4.stm32f30x_misc.h.113.6a52e4fe7c3825a3ab05990f30dddf92
                           .group:00000000 wm4.stm32f30x_rtc.h.133.d184e08ff40bda44db4bed94f9633384

NO UNDEFINED SYMBOLS
